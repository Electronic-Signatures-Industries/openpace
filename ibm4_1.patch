diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aes_ccm.c openssl-1.0.0-beta4/crypto/aes/aes_ccm.c
--- openssl-1.0.0-beta4.orig/crypto/aes/aes_ccm.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aes_ccm.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,510 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+//---------------------------------------------------------------------------*/
+
+
+/* Note !
+   AES-CCM is defined as a one-shot encrypt/mac operation
+   hence there's no AES_CCM_CTX, no Init/Update/Final
+   It'll also eat a LOT of RAM for long messages.
+*/
+#ifndef AES_DEBUG
+# ifndef NDEBUG
+#  define NDEBUG
+# endif
+#endif
+#include <assert.h>
+
+#include "openssl/evp.h"
+#include "openssl/aes.h"
+#include "aes_locl.h"
+
+
+/*
+\debug Define: Uncomment to enable debugging of the AES-CCM code
+#define AES_CCM_DEBUG 1
+*/
+
+#if defined(AES_CCM_DEBUG)
+
+
+/*! @brief print a tagged binary buffer
+    @param tag the tag
+    @param buf the buffer to convert to hex and print
+    @param blen the length of the buffer
+    \debug Code: printbin: controlled by AES_CCM_DEBUG
+*/
+static void printbin(char *tag,unsigned char *buf, int blen)
+{
+  int i;
+  printf("\t%-12s: ",tag);
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+    if( (i % 4) == 3) printf(" ");
+    
+  }
+  printf("\n");
+}
+/*! @brief print a tagged binary buffer with an incrementing counter on the tag
+    @param tag the tag
+    @param ctr a pointer to the counter
+    @param buf the buffer to convert to hex and print
+    @param blen the length of the buffer
+    \debug Code: printbinCTR: controlled by AES_CCM_DEBUG
+*/
+static void printbinCTR(char *tag,int *ctr,unsigned char *buf, int blen)
+{
+
+  char buffer[21];
+  sprintf(buffer,"%s%1d",tag,*ctr);
+  (*ctr)++;
+  printbin(buffer,buf,blen);
+}
+#else
+#define printbin(x,y,z)
+#define printbinCTR(x,y,z,q)
+#endif
+
+
+/*! @brief
+  Increment the CCM CTR, which is variable length, big endian
+  @param counter the counter to increment
+  @param q the number of bytes in the counter
+*/
+static void AES_CCM_inc(unsigned char *counter,unsigned q) {
+  int i;
+  for(i = 15; q > 0 ; i--,q--) {
+    counter[i]++;
+    if(0 != counter[i] ) break;
+  }            
+}
+
+
+/** @brief xor two buffers into a destination. 
+    (Which may be one of the source buffers )
+    @param dest the destination buffer
+    @param s1 first source buffer
+    @param s2 second source buffer
+    @param blen buffer length
+*/
+
+static void xor(unsigned char *dest, unsigned char *s1, unsigned char *s2, unsigned blen)
+{
+    unsigned int i;
+    for(i = 0; i < blen; i++) {
+	dest[i] = s1[i] ^ s2[i];
+    }
+}
+/** @brief perform the CCM incremental hash function 
+    @param pcb An ICC library context 
+    @param B The retained hash buffer 
+    @param A the new data to hash in
+    @param ctx and initialzied Cipher CTX   
+*/
+static void CCM_HASH(unsigned char *B,unsigned char *A,EVP_CIPHER_CTX *ctx) 
+{
+  int outl = 0;
+  /* XOR the encrypted last block (now in B) 
+     with the newly prepared block 
+  */
+  xor(A,B,A,AES_BLOCK_SIZE);
+  /* Encrypt the result, and save it as the "last block" */
+  /* AES_encrypt(A,B,akey); */
+  EVP_EncryptUpdate(ctx,B,&outl,A,AES_BLOCK_SIZE);  
+}
+
+/** @brief Initialize the CCM counter
+    @param CTR a pointer to the counter buffer
+    @param iv the nonce
+    @param ivlen the length of the nonce
+    @param q the size of the counter fields
+*/
+static void CCM_FORMAT_CTR(unsigned char *CTR,
+			   unsigned char *iv,
+			   unsigned long ivlen,
+			   unsigned int q) 
+{
+  unsigned int i;
+  /* Format the CTR */
+  memset(CTR,0,AES_BLOCK_SIZE);
+  /* Copy in the IV fields */
+  for(i = 1; i <= ivlen; i ++) {
+    CTR[i] = iv[i-1];
+  }
+  CTR[0] |= ((q-1) & 7);
+}
+
+/** @brief
+    Perform the code common to AES_CCM encrypt and decrypt 
+    provide the iv (Nonce),aad, data and key, output buffer and taglength
+    @param pcb an ICC library context
+    @param iv the Nonce, can be 32-128 bits long, < 64 is not recommended
+    @param ivlen the length of the IV
+    @param key an aes
+    @param keylen the length of the AES key in bytes
+    @param aad Additional Authentication data, hashed, but not encrypted
+    @param aadlen the length of the aad
+    @param data the data buffer to encrypt
+    @param datalen the length of the data buffer
+    @param out the output buffer
+    @param outlen a place to store the returned output length
+    - which WILL be rounded up to a 16 byte boundary +16 bytes
+    @param taglen the desired length of the auth tag
+    @param enc 0 = decrypt, else encrypt
+    @return 1 if O.K., 0 otherwise
+*/ 
+static int AES_CCM_Common(unsigned char *iv,unsigned int ivlen,
+			  unsigned char *key,unsigned int keylen,
+			  unsigned char *aad, unsigned long aadlen,
+			  unsigned char *data,unsigned long datalen,
+			  unsigned char *out, unsigned long *outlen,
+			  unsigned int taglen,int enc
+			  )
+{
+    int rv = 1;
+    EVP_CIPHER_CTX *ctx = NULL;
+    const EVP_CIPHER *cipher = NULL;
+    unsigned char A0[AES_BLOCK_SIZE];
+    unsigned char B0[AES_BLOCK_SIZE];
+    unsigned char CTR[AES_BLOCK_SIZE];
+    unsigned char S0[AES_BLOCK_SIZE];
+    unsigned t = 0;
+    unsigned q = 0;
+    unsigned long p = 0;
+    unsigned char *oldout = out;
+    unsigned int aadbytes = 0;
+    unsigned int offset = 0;
+    int outl = 0;
+    unsigned int i,j;
+#if defined(AES_CCM_DEBUG)
+    int b = 0; /* Index counters to aid formatting during debug */
+    int s = 0;
+    int c = 0;
+#endif
+    /* Check for a valid aad length */
+    if(aadlen > 0xFFFFFFFFL) {
+      rv = 0;
+    }
+    /* Check for a valid nonce length 7-13 */
+    if( (ivlen < 7) || (ivlen > 13) ) {
+      rv = 0;
+    } else {
+      /* Calculate q, the bytes required to hold the possible representation 
+	 of the LENGTH of the plaintext from the nonce 
+      */
+      q = 15 - ivlen;
+
+    }
+    t = (taglen-2)/2;
+    /* check for a valid tag length 4,6,8,10,12,14,16 */
+    
+    if( (0 != (taglen & 1)) || (taglen < 4) || (taglen > 16)) {
+      rv = 0;      
+    }
+    if(NULL == outlen) {
+      rv = 0;
+    }
+    switch(keylen) {
+    case 16:
+      cipher = EVP_get_cipherbyname("AES-128-ECB");
+      break;
+    case 24:
+      cipher = EVP_get_cipherbyname("AES-192-ECB");
+      break;
+    case 32:
+      cipher = EVP_get_cipherbyname("AES-256-ECB");
+      break;
+    default:
+      rv = 0;
+      break;
+    }
+    ctx = EVP_CIPHER_CTX_new();
+    if( 1 == rv ) {
+      *outlen = 0; /* Clear the output data length */
+      /* Now - to prevent the user from knowing why we failed 
+	 always flush the output buffers 
+      */
+      if(enc) {
+	/* In encrypt mode, clear the output buffer */
+	memset(out,0,(((datalen+15)/16)*16)+taglen);
+      } else {
+	/* Same in decrypt mode */
+	memset(out,0,datalen-taglen);
+      }
+      EVP_CIPHER_CTX_set_padding(ctx,0);
+      EVP_EncryptInit(ctx,cipher,key,NULL);      
+    } 
+    if (1 == rv ) {
+      /* If we are decrypting, we don't decrypt the tag ... */
+      if( ! enc ) {
+	datalen -= taglen;
+      }
+
+      /* Format the first block */
+      memset(B0,0,AES_BLOCK_SIZE);
+      /* Do we have adata ? */
+      if(aad != NULL && aadlen > 0) {
+	B0[0] |= 0x40;
+      }
+      B0[0] |= (((taglen-2)/2) & 7) << 3;
+      B0[0] |= (q - 1) & 7;
+      /* Copy in the IV fields */
+      for(i = 1; i <= ivlen; i ++) {
+	B0[i] = iv[i-1];
+      }
+
+      /* 
+	 Encode the number of bytes of plaintext 
+	 in the remaining space 
+      */
+      p = datalen;;
+      for( j = 15 ; j > i ; j--) {
+	B0[j] = (p & 0xff);
+	p >>= 8;
+      }
+      
+      printbinCTR("B",&b,B0,16);
+      memset(A0,0,AES_BLOCK_SIZE); /* Start with original data == 0 */
+      CCM_HASH(B0,A0,ctx);
+
+      CCM_FORMAT_CTR(CTR,iv,ivlen,q);
+
+      /*
+	 now any aadata 
+      */
+    
+      memset(A0,0,AES_BLOCK_SIZE);
+      
+      if(aad != NULL && aadlen > 0) {
+	if(aadlen < (0x10000L - 0x100L)) {
+	  aadbytes = 2;	    
+	} else if(aadlen <= 0xFFFFFFFF) {
+	  aadbytes = 6;
+	} else {
+	  aadbytes = 10;
+	}
+	j = aadlen;
+	for(i = aadbytes-1; i > 0; i--) {
+	  A0[i] = j & 0xff;
+	  j >>= 8;
+	}
+	/* Now roll through the aad ? */
+      }
+      /* Free space in A0.16 - (1 byte flags + aadbytes) */
+      offset = aadbytes;
+      j = 16 - offset; 
+      /* j is the number of bytes to copy,
+	 offset is the offset into the buffer to start 
+	 the copy
+      */
+
+      for( ;aadlen > 0 ; aadlen -= j,j = AES_BLOCK_SIZE) {
+
+	/* If the remaining free space is less than the aadlength
+	   copy only the aadlength 
+	*/
+	if( j > aadlen) {
+	  j = aadlen;
+	}
+	
+	/* start at buffer + flags + stored length
+	   copy the requistite ammount of aad
+	*/
+	memcpy(A0+offset,aad,j);
+	if(offset+j < 16) {
+	  memset(A0+offset+j,0,(16-(offset+j)));
+	}
+
+	printbinCTR("B",&b,A0,16);
+	CCM_HASH(B0,A0,ctx);
+ 	aad += j;
+	/* Now encrypt the result, and store it in B0 */
+
+	offset = 0; /* offset can only be zero the first time through */
+	if(aadlen <= j) break; /* aadlen is unsigned, this ensures we exit */
+      }
+
+
+      /* Process the first counter block */
+      printbinCTR("CTR",&c,CTR,AES_BLOCK_SIZE);
+      /* AES_encrypt(CTR,A0,akey); */
+      EVP_EncryptUpdate(ctx,A0,&outl,CTR,AES_BLOCK_SIZE);
+      printbinCTR("S",&s,A0,AES_BLOCK_SIZE);
+      AES_CCM_inc(CTR,q); 
+      memcpy(S0,A0,AES_BLOCK_SIZE);
+
+
+      /* Now do the encrypt/decrypt phase, note that we are still adding data to the
+	 hash function at this phase as well.
+      */
+
+      for( ; datalen > 0; datalen -= AES_BLOCK_SIZE) {
+	int l = AES_BLOCK_SIZE;
+
+	if(datalen < AES_BLOCK_SIZE) {
+	  l = datalen;
+	  /* In this case we need to zero A0 */
+	  memset(A0,0,AES_BLOCK_SIZE);
+	}
+
+	if(enc) {
+	  memcpy(A0,data,l);
+	  printbinCTR("B",&b,A0,AES_BLOCK_SIZE);
+	  CCM_HASH(B0,A0,ctx);
+	} 
+	/* Prep the counter - encrypt the current value
+	   
+	 */
+	printbinCTR("CTR",&c,CTR,AES_BLOCK_SIZE);
+	/* AES_encrypt(CTR,A0,akey); */
+	EVP_EncryptUpdate(ctx,A0,&outl,CTR,AES_BLOCK_SIZE);
+	printbinCTR("S",&s,A0,AES_BLOCK_SIZE);
+	/* Increment the ounter */
+	AES_CCM_inc(CTR,q);
+
+	/* XOR the encrypted counter with the incoming data */
+	xor(A0,data,A0,l);
+
+	/* Copy this to the output */
+	memcpy(out,A0,l);
+	printbin("C",A0,l);
+
+	/* In decrypt mode, that gave us plaintext which
+	   we hash 
+	*/
+	if( !enc ) {
+	  if(l != AES_BLOCK_SIZE) {
+            memset(A0+l,0,AES_BLOCK_SIZE-l);
+          }
+	  printbinCTR("B",&b,A0,AES_BLOCK_SIZE);
+	  CCM_HASH(B0,A0,ctx);
+	}
+	data += l;
+	out += l;
+	*outlen += l;
+	if(datalen < AES_BLOCK_SIZE) {
+	  break;
+	}
+      }
+    }
+    if(1 == rv ) {
+      /* last encrypted hash block is our tag */
+      printbin("T",B0,taglen);
+      /* XOR this with the saved first counter block */
+      xor(B0,S0,B0,taglen);
+      /* append this to the encrypted data in encrypt mode */
+      if( enc ) {
+	memcpy(out,B0,taglen);
+	*outlen += taglen;
+      } else {	
+	/* If it's decrypt mode, we compare it with the end of the data */
+	if(memcmp(B0,data,taglen) != 0 ) {
+	  rv = 0;
+	  memset(oldout,0,*outlen);
+	}
+      }
+    }
+    if(NULL != ctx) {
+      EVP_CIPHER_CTX_cleanup(ctx);
+      EVP_CIPHER_CTX_free(ctx);
+   }
+    return rv;
+}
+
+/** @brief
+    Perform an AES CCM Encrypt operation, 
+    provide the iv (Nonce),aad, data and key, output buffer and taglength
+    @param pcb an ICC library context
+    @param iv The Nonce, can be 32-128 bits long, < 64 is not recommended
+    @param ivlen the length of the IV
+    @param key an aes key
+    @param keylen the length of the AES key in bytes
+    @param aad Additional Authentication data, hashed, but not encrypted
+    @param aadlen the length of the aad
+    @param data the data buffer to encrypt
+    @param datalen the length of the data buffer
+    @param out the output buffer
+    @param outlen a place to store the returned output length
+    - which WILL be rounded up to a 16 byte boundary +16 bytes
+    @param taglen the desired length of the auth tag
+    @return 1 if O.K., 0 otherwise
+*/ 
+int AES_CCM_Encrypt(unsigned char *iv,unsigned int ivlen,
+		    unsigned char *key,unsigned int keylen,
+		    unsigned char *aad, unsigned long aadlen,
+		    unsigned char *data,unsigned long datalen,
+		    unsigned char *out, unsigned long *outlen,
+		    unsigned int taglen
+		    )
+{
+  int rv = 1;
+  rv = AES_CCM_Common(iv,ivlen,
+		      key,keylen,
+		      aad,aadlen,
+		      data,datalen,
+		      out,outlen,
+		      taglen,1);
+
+ 
+    return rv;
+}
+
+
+/** @brief
+    Perform an AES CCM Decrypt operation, 
+    provide the iv (Nonce),aad, data and key, output buffer and taglength
+    @param pcb an ICC library context
+    @param iv The Nonce, can be 32-128 bits long, < 64 is not recommended
+    @param ivlen the length of the IV
+    @param key an aes key
+    @param keylen the length of the AES key
+    @param aad Additional Authentication data, hashed, but not encrypted
+    @param aadlen the length of the aad
+    @param data the data buffer to encrypt
+    @param datalen the length of the data buffer
+    @param out the output buffer
+    @param outlen a place to store the returned output length
+    @param taglen the length of the auth tag
+    @return 1 if O.K., 0 otherwise
+    @note This (by spec) returns no data on failure. However as
+    we'd have to allocate an internal buffer, which would still be
+    accessable to the caller within the same process, we simple
+    erase any partial data in the output buffer on failure instead.
+    - So , be aware that the output buffer WILL be overwritten,
+    no matter what.
+    @note the fact that this isn't allowed to return any data if the
+    tag match fails is the reason why there can't be the usual 
+    Init/Update/Update/Final API.
+*/ 
+int AES_CCM_Decrypt(unsigned char *iv,unsigned int ivlen,
+		    unsigned char *key,unsigned int keylen,
+		    unsigned char *aad, unsigned long aadlen,
+		    unsigned char *data,unsigned long datalen,
+		    unsigned char *out, unsigned long *outlen,
+		    unsigned int taglen
+		    )
+{
+  int rv = 1;
+  rv = AES_CCM_Common(iv,ivlen,
+		      key,keylen,
+		      aad,aadlen,
+		      data,datalen,
+		      out,outlen,
+		      taglen,0);
+  
+ 
+  if(0 == rv) { /* If anything failed, kill the output buffer */
+    memset(out,0,*outlen);
+    *outlen = 0;    
+  }
+
+  return rv;
+}
+
+
+
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aes_ccm.h openssl-1.0.0-beta4/crypto/aes/aes_ccm.h
--- openssl-1.0.0-beta4.orig/crypto/aes/aes_ccm.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aes_ccm.h	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,10 @@
+/* crypto/aes/aes_ccm.h */
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+//---------------------------------------------------------------------------*/
+
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/AES_CCMVS.c openssl-1.0.0-beta4/crypto/aes/AES_CCMVS.c
--- openssl-1.0.0-beta4.orig/crypto/aes/AES_CCMVS.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/AES_CCMVS.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,532 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+//--------------------------------------------------------------------------*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+/* #include "VSparser.h" */
+#include "explode.h"
+#include "hex_utils.h"
+#include "openssl/evp.h"
+#include "openssl/err.h"
+#include "openssl/aes.h"
+
+/* Ugly, but thats the way the test build system works */
+
+#include "hex_utils.c"
+#include "explode.c"
+#include "VSparser.c"
+
+/* Types of CCM validation tests 
+   our processing needs to vary a little based on the
+   file type, so we need this info
+*/
+typedef enum {
+  CCM_NONE = 0,
+  DVPT,
+  VADT,
+  VNT,
+  VPT,
+  VTT
+} CCM_T;
+
+static int verbose = 0;
+
+/* AES tests */
+/* verification with possibly corrupt data ? */
+VS vsAES_CCM_DVPT[] = {
+  {"[*]",NULL,VS_NONE},
+  {"Key",NULL,VS_NONE},
+  {"Count",NULL,VS_NONE},
+  {"Nonce",NULL,VS_NONE},
+  {"Adata",NULL,VS_NONE},
+  {"CT",NULL,VS_NONE},
+  {"Result",NULL,VS_EXIT},
+  {NULL,NULL,VS_NONE},
+};
+/* Generate ciphertext with changing AAD */
+VS vsAES_CCM_VADT[] = {
+
+  {"Plen",NULL,VS_NONE},
+  {"Nlen",NULL,VS_NONE},
+  {"Tlen",NULL,VS_NONE},
+  {"[Alen",NULL,VS_NONE},
+  {"Key",NULL,VS_NONE},
+  {"Nonce",NULL,VS_NONE},
+  {"Count",NULL,VS_NONE},
+  {"Adata",NULL,VS_NONE},
+  {"Payload",NULL,VS_NONE},
+  {"CT",NULL,VS_EXIT},
+  {NULL,NULL,VS_NONE},
+};
+/* Generate ciphertext with changing nonce */
+VS vsAES_CCM_VNT[] = {
+
+  {"Alen",NULL,VS_NONE},
+  {"Plen",NULL,VS_NONE},
+  {"Nlen",NULL,VS_NONE},
+  {"Tlen",NULL,VS_NONE},
+  {"[Nlen",NULL,VS_NONE},
+  {"Key",NULL,VS_NONE},
+  {"Nonce",NULL,VS_NONE},
+  {"Count",NULL,VS_NONE},
+  {"Adata",NULL,VS_NONE},
+  {"Payload",NULL,VS_NONE},
+  {"CT",NULL,VS_EXIT},
+  {NULL,NULL,VS_NONE},
+};
+/* Generate ciphertext with changing plaintext ? */
+
+VS vsAES_CCM_VPT[] = {
+  {"Alen",NULL,VS_NONE},
+  {"Nlen",NULL,VS_NONE},
+  {"Tlen",NULL,VS_NONE},
+  {"[Plen",NULL,VS_NONE},
+  {"Key",NULL,VS_NONE},
+  {"Nonce",NULL,VS_NONE},
+  {"Count",NULL,VS_NONE},
+  {"Adata",NULL,VS_NONE},
+  {"Payload",NULL,VS_NONE},
+  {"CT",NULL,VS_EXIT},
+  {NULL,NULL,VS_NONE},
+};
+
+/* Generate ciphertext with varying tag length ? */
+
+VS vsAES_CCM_VTT[] = {
+  {"Alen",NULL,VS_NONE},
+  {"Plen",NULL,VS_NONE},
+  {"Nlen",NULL,VS_NONE},
+  {"[Tlen",NULL,VS_NONE},
+  {"Key",NULL,VS_NONE},
+  {"Nonce",NULL,VS_NONE},
+  {"Count",NULL,VS_NONE},
+  {"Adata",NULL,VS_NONE},
+  {"Payload",NULL,VS_NONE},
+  {"CT",NULL,VS_EXIT},
+  {NULL,NULL,VS_NONE},
+};
+
+
+
+static void printbin(char *tag,unsigned char *buf, int blen)
+{
+  char *bh = NULL;
+  Bin2HexBuffer((char *)buf,blen,&bh);
+  if(verbose) {
+    printf("%s = %s\n",tag,bh);
+  }
+  free(bh);
+}
+static void printi(char *tag,int i)
+{
+  if(verbose) {
+    printf("%s = %d\n",tag,i);
+  }
+}
+
+/* Compare a binary buffer with it's expected value in hex
+   the size of the binary buffer is calculated from the hex "known answer"
+*/
+   
+static int cmp(char *tag,char *ref,unsigned char *bin)
+{
+  int rv = 0;
+  char *tmp = NULL;
+  Bin2HexBuffer((char *)bin,strlen(ref)/2,&tmp);
+  rv = strcmp(ref,tmp);
+  if(0 != rv) {
+    printf("%-10s = %s\ngot          %s\n",tag,ref,tmp);
+  }
+  free(tmp);
+  return rv;
+}
+/*
+  free a pointer if not NULL
+*/
+static void freeme(unsigned char **ptr)
+{
+  if(*ptr) {
+    free(*ptr);
+    *ptr = NULL;
+  }
+}
+/*
+  Track a possible change in an unsigned long var 
+  if it changed, print with tag
+*/
+void pcondul(char *tag,long *last,unsigned long current)
+{
+  if( *last != current) {
+    if(verbose) {
+      if( *tag == '[' ) printf("%s = %ld]\n",tag,current);
+      else printf("%s = %ld\n",tag,current);
+    }
+    *last = current;
+  }
+}
+/*
+  Track a possible change in a pointer (to a string)
+  if it changed, print with tag
+  this one is a bit dodgy, but the VSParser strings 
+  are "mostly" persistant
+*/
+void pcondptr(char *tag,char **last,char * current,int nl)
+{
+  if( (NULL == *last) || (0 != strcmp(*last,current))) {
+    if(verbose) {
+      printf("%s = %s\n",tag,current);
+      if(nl) printf("\n");
+    }
+    if(NULL != *last) {
+      free(*last);
+      *last = strdup(current);
+    }
+  }
+}
+
+/* 
+   Get the value part of a tag/value pair, convert to binary and
+   return the length
+*/
+int GetX(VS *vs,char *tag,unsigned char **buf) 
+{
+  int rv = 0;
+  if(NULL != VSgetData(vs,tag)) {
+    rv = strlen(VSgetData(vs,tag));
+    /*    printf("%-20s = %s\n",tag,VSgetData(vs,tag)); */
+    Hex2BinBuffer(VSgetData(vs,tag),rv,(char **)buf);
+  }
+  return rv/2;
+}
+int AES_CCM_test(FILE *fin, VS vs[],unsigned int keylen, CCM_T ccm_test)
+{
+  int rv = 0;
+
+  unsigned long Plen = 0; /* Length of plaintext */
+  unsigned long Alen = 0; /* length of AAD */
+  unsigned long Nlen = 0; /* Length of Nonce */
+  unsigned long Tlen = 0; /* Length of tag */
+  unsigned int Count = 0; /* bookkeeping, test number */
+  unsigned char *key    =  NULL; /* binary key */
+  unsigned char *nonce  =  NULL; /* binary nonce */
+  unsigned char *aadata =  NULL; /* binary additional auth data */
+  unsigned char *payload = NULL; /* binary payload/plaintext */
+  unsigned char *ct     =  NULL; /* binary ciphertext */
+  unsigned long ctlen   =  0;
+  unsigned char *out    = NULL;
+  unsigned long outlen = 0;
+  char *tmp = NULL;
+  char **expld = NULL;
+  int Result = 0;
+  int X;
+  /* This group of vars is used to track changes in the NIST
+     input and trigger printing
+  */
+  char *lastkey = NULL;
+  char *lastNonce = NULL;
+  long lastPlen = -1;
+  long lastNlen = -1;
+  long lastTlen = -1;
+  long lastAlen = -1;
+
+
+
+  while(VSparse(fin,vs) != 0) {
+    GetX(vs,"Nonce",&nonce);
+    GetX(vs,"Adata",&aadata);
+    GetX(vs,"Payload",&payload);
+    ctlen = GetX(vs,"CT",&ct);
+    GetX(vs,"Key",&key);
+
+    switch(ccm_test) {
+    case CCM_NONE:
+    exit(1);
+    break;
+    case DVPT: 
+      /* need to split the [*] field out, the input looks like this:
+	 [Alen = 0, Plen = 10, Nlen = 7, Tlen = 4]
+      */
+      tmp = VSgetData(vs,"[*]");
+
+      expld = explode((char *)tmp,",");      
+      Alen = atoi(expld[0]+strlen("[Alen ="));
+      Plen = atoi(expld[1]+strlen(" Plen = "));
+      Nlen = atoi(expld[2]+strlen(" Nlen = "));
+      Tlen = atoi(expld[3]+strlen(" Tlen = "));
+    
+      if((lastAlen != Alen) || (lastPlen != Plen) || 
+	 (lastNlen != Nlen) || (lastTlen != Tlen) ) {
+	if(verbose) {
+	  printf("[Alen = %ld, Plen = %ld, Nlen = %ld, Tlen = %ld]\n\n",Alen,Plen,Nlen,Tlen);
+	}
+	lastAlen = Alen;
+	lastPlen = Plen;
+	lastNlen = Nlen;
+	lastTlen = Tlen;
+      }
+      pcondptr("Key",&lastkey,VSgetData(vs,"Key"),1);
+      explodefree(expld);
+      tmp = NULL;
+      break;
+    case VADT:
+      Alen = atoi(VSgetData(vs,"[Alen"));
+      Plen = atoi(VSgetData(vs,"Plen"));
+      Tlen = atoi(VSgetData(vs,"Tlen"));
+      Nlen = atoi(VSgetData(vs,"Nlen"));
+      pcondul("Plen",&lastPlen,Plen);
+      pcondul("Nlen",&lastNlen,Nlen);
+      pcondul("Tlen",&lastTlen,Tlen);
+      pcondul("[Alen",&lastAlen,Alen);
+      pcondptr("Key",&lastkey,VSgetData(vs,"Key"),0);
+      pcondptr("Nonce",&lastNonce,VSgetData(vs,"Nonce"),1);
+      break;
+    case VNT:
+      Alen = atoi(VSgetData(vs,"Alen"));
+      Plen = atoi(VSgetData(vs,"Plen"));
+      Tlen = atoi(VSgetData(vs,"Tlen"));
+      Nlen = atoi(VSgetData(vs,"[Nlen"));
+      pcondul("Alen",&lastAlen,Alen);
+      pcondul("Plen",&lastPlen,Plen);
+      pcondul("Tlen",&lastTlen,Tlen);
+      pcondul("[Nlen",&lastNlen,Nlen);
+      pcondptr("Key",&lastkey,VSgetData(vs,"Key"),0);
+      break;
+    case VPT:
+      Alen = atoi(VSgetData(vs,"Alen"));
+      Plen = atoi(VSgetData(vs,"[Plen"));
+      Tlen = atoi(VSgetData(vs,"Tlen"));
+      Nlen = atoi(VSgetData(vs,"Nlen"));
+      pcondul("Alen",&lastAlen,Alen);
+      pcondul("Nlen",&lastNlen,Nlen);
+      pcondul("Tlen",&lastTlen,Tlen);
+      pcondul("[Plen",&lastPlen,Plen);
+      pcondptr("Key",&lastkey,VSgetData(vs,"Key"),0);
+      pcondptr("Nonce",&lastNonce,VSgetData(vs,"Nonce"),1);
+      break;
+    case VTT:
+      Alen = atoi(VSgetData(vs,"Alen"));
+      Plen = atoi(VSgetData(vs,"Plen"));
+      Tlen = atoi(VSgetData(vs,"[Tlen"));
+      Nlen = atoi(VSgetData(vs,"Nlen"));
+      pcondul("Alen",&lastAlen,Alen);
+      pcondul("Plen",&lastPlen,Plen);
+      pcondul("Nlen",&lastNlen,Nlen);
+      pcondul("[Tlen",&lastTlen,Tlen);
+      pcondptr("Key",&lastkey,VSgetData(vs,"Key"),0);
+      pcondptr("Nonce",&lastNonce,VSgetData(vs,"Nonce"),1);
+      break;
+    }
+
+
+    if(ctlen > Plen) out = malloc(ctlen+64);
+    else out = malloc(Plen +64);
+    switch(ccm_test) {
+    case CCM_NONE:
+      exit(1);
+      break;
+    case DVPT:
+      printi("Count",Count);
+      printbin("Nonce",nonce,Nlen);
+      printbin("Adata",aadata,Alen);
+      printbin("CT",ct,ctlen);
+      
+      Result = AES_CCM_Decrypt(nonce,Nlen,
+				   key,keylen,
+				   aadata,Alen,
+				   ct,ctlen,
+				   out, &outlen,
+				   Tlen);
+      if(verbose) {
+	printf("Result = %s\n",Result ? "Pass" : "Fail");
+      }
+      if ( 0 != Result) {
+	printbin("Payload",out,outlen);
+      }
+      tmp = VSgetData(vs,"Result");
+      X = 0; /* Fail */
+      if(strstr((char *)tmp,"(0)")) { /* Pass (0) */
+ 	X = 1;
+      }
+      /* And set our return code to fail if we didn't get the 
+	 expected result... 
+      */
+      if(Result != X) {
+	rv++;
+      }
+      break;
+    case VADT:
+      printi("Count",Count);
+      printbin("Adata",aadata,Alen);
+      printbin("Payload",payload,Plen);
+      AES_CCM_Encrypt(nonce,Nlen,
+			  key,keylen,
+			  aadata,Alen,
+			  payload,Plen,
+			  out, &outlen,
+			  Tlen);
+      printbin("CT",out,outlen);
+      if(0 != cmp("CT",VSgetData(vs,"CT"),out) ) {
+	rv ++;
+      }
+      break;
+    case VNT:
+      printi("Count",Count);
+      pcondptr("Nonce",&lastNonce,VSgetData(vs,"Nonce"),1);
+      printbin("Adata",aadata,Alen);
+      printbin("Payload",payload,Plen);
+      AES_CCM_Encrypt(nonce,Nlen,
+			  key,keylen,
+			  aadata,Alen,
+			  payload,Plen,
+			  out, &outlen,
+			  Tlen);
+      printbin("CT",out,outlen);
+      if(0 != cmp("CT",VSgetData(vs,"CT"),out) ) {
+	rv ++;
+      }
+      break;
+    case VPT:
+      printi("Count",Count);
+      printbin("Adata",aadata,Alen);
+      printbin("Payload",payload,Plen);
+      AES_CCM_Encrypt(nonce,Nlen,
+			  key,keylen,
+			  aadata,Alen,
+			  payload,Plen,
+			  out, &outlen,
+			  Tlen);
+      printbin("CT",out,outlen);
+      if(0 != cmp("CT",VSgetData(vs,"CT"),out) ) {
+	rv ++;
+      }
+      break;
+    case VTT:
+      printi("Count",Count);
+      printbin("Adata",aadata,Alen);
+      printbin("Payload",payload,Plen);
+      AES_CCM_Encrypt(nonce,Nlen,
+			  key,keylen,
+			  aadata,Alen,
+			  payload,Plen,
+			  out, &outlen,
+			  Tlen);
+      printbin("CT",out,outlen);
+      if(0 != cmp("CT",VSgetData(vs,"CT"),out) ) {
+	rv ++;
+      }
+      break;
+
+    }
+    if(verbose) printf("\n");
+
+    Plen = Alen = ctlen = Nlen = Tlen = outlen = 0;
+    freeme(&key);
+    freeme(&nonce);
+    freeme(&payload);
+    freeme(&aadata);
+    freeme(&out);
+    freeme(&ct);
+    Count ++;
+  }
+  freeme((unsigned char **)&lastkey);
+  freeme((unsigned char **)&lastNonce);
+  VSclean(vs);
+  return rv;
+}
+
+int main(int argc, char *argv[])
+{
+  int rv = 1;
+
+  char **exploded = NULL;
+  int nelem;
+  FILE *fin = NULL;
+  char *fname = NULL;
+  VS *vs = NULL;
+  CCM_T ccm_test = CCM_NONE;
+  unsigned int keylen = 0;
+
+
+  if(argc < 2) {
+    printf("%s: %s\n",argv[0],"Too few arguments");
+    exit(1);
+  }
+
+
+  OPENSSL_add_all_algorithms_noconf();
+
+ 
+  if(argc > 2) {
+    if(NULL != strstr(argv[2],"-v")) {
+      verbose = 1;
+    }
+  }
+
+
+    /* Parse out the filename */
+    exploded = explode(argv[1],"\\/");
+    nelem = explodesize(exploded);
+    if(nelem) {
+      fname = exploded[nelem-1];
+      if(NULL != fname) {
+	/* Fish out the keylength */
+	if(NULL != strstr(fname,"128")) {
+	  keylen = 16;
+	} else if(NULL != strstr(fname,"192")) {
+	  keylen = 24;
+	} else if(NULL != strstr(fname,"256")) {
+	  keylen = 32;
+	}
+	if(NULL != strstr(fname,"DVPT")) {
+	  vs = vsAES_CCM_DVPT;
+	  ccm_test = DVPT;
+	} else if(NULL != strstr(fname,"VADT")) {
+	  vs = vsAES_CCM_VADT;
+	  ccm_test = VADT;
+	} else if(NULL != strstr(fname,"VNT")) {
+	  vs = vsAES_CCM_VNT;
+	  ccm_test = VNT;
+	} else if( NULL != strstr(fname,"VPT")) {
+	  vs = vsAES_CCM_VPT;
+	  ccm_test = VPT;
+	} else if ( NULL != strstr(fname,"VTT")) {
+	  vs = vsAES_CCM_VTT;
+	  ccm_test = VTT;
+	}
+      }
+      if( (NULL == fname) || (NULL == vs) || 0 == keylen) {
+	printf("%s: %s (%s)\n",argv[0],"Can't parse filename",argv[1]);
+	rv = 1;
+	goto exit;
+      }
+    }
+
+  fin = fopen(argv[1],"r");
+  if(NULL == fin) {
+    printf("%s: %s (%s)\n",argv[0],"Can't open file",argv[1]);
+    exit(1);
+  }
+  rv = AES_CCM_test(fin,vs,keylen,ccm_test);
+
+ exit:
+
+  if(fin) fclose(fin);
+  if(exploded) explodefree(exploded);
+  EVP_cleanup();
+  CRYPTO_cleanup_all_ex_data();
+  ERR_remove_state(0);
+  ERR_free_strings();
+  CRYPTO_mem_leaks_fp(stderr);
+
+  return(rv);
+}
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aes_gcm.c openssl-1.0.0-beta4/crypto/aes/aes_gcm.c
--- openssl-1.0.0-beta4.orig/crypto/aes/aes_gcm.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aes_gcm.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,1437 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007,2009
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+// Table driven GCM acceleration add by Aaron Cristensen November 2007.
+// Fix bug reported by Paul Suhler
+//---------------------------------------------------------------------------*/
+
+
+#ifndef AES_DEBUG
+# ifndef NDEBUG
+#  define NDEBUG
+# endif
+#endif
+
+#include <string.h>
+
+#include "openssl/evp.h"
+#include "openssl/aes.h"
+#include "openssl/rand.h"
+
+#if !defined(AES_BLOCK_SIZE)
+#define AES_BLOCK_SIZE 16
+#endif
+
+#include "aes_gcm.h"
+
+
+/*
+\debug Define: Uncomment to enable debugging of the AES-GCM code
+#define AES_GCM_DEBUG
+*/
+
+#if defined(AES_GCM_DEBUG)
+/* Used for printing tags in debug mode */
+static int Xc = 0;
+static int Yc = 0;
+static int Nc = 0;
+
+/*! @brief print a tagged binary buffer
+    @param tag the tag
+    @param buf the buffer to convert to hex and print
+    @param blen the length of the buffer
+    \debug Code: printbin: controlled by AES_GCM_DEBUG
+*/
+
+static void printbin(char *tag,unsigned char *buf, int blen)
+{
+  int i;
+  printf("%-20s: ",tag);
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+  }
+  printf("\n");
+}
+static void printY(unsigned char *buf, int blen)
+{
+  int i;
+  printf("Y_%1d%17s: ",Yc,"");
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+  }
+  printf("\n");
+}
+static void printX(unsigned char *buf, int blen)
+{
+  int i;
+  printf("X_%1d%17s: ",Xc++,"");
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+  }
+  printf("\n");
+}
+static void printN(unsigned char *buf, int blen)
+{
+  int i;
+  printf("N_%1d%17s: ",Nc++,"");
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+  }
+  printf("\n");
+}
+static void printEY(unsigned char *buf, int blen)
+{
+  int i;
+  printf("E(K,Y_%1d)%12s: ",Yc++,"");
+  for(i = 0; i < blen; i++) {
+    printf("%02x",(unsigned)buf[i]);
+  }
+  printf("\n");
+}
+
+
+
+#else
+#define printbin(x,y,z) 
+#define printX(x,y)
+#define printY(x,y)
+#define printN(x,y)
+#define printEY(x,y)
+#endif
+
+static const unsigned char zero[AES_BLOCK_SIZE];
+
+/** @brief convert the length fields to big endian byte streams 
+    @param l the incoming unsigned long, assumed to be 8 byte 
+    FIX THIS!
+    @param b (8 byte) output buffer
+*/
+static void ULongToChar(unsigned long l, unsigned char *b)
+{
+    int i;
+
+    for(i = 7; i >= 0; i--) {
+    	b[i] = l & 0xff;
+    	l >>= 8;
+    }
+}
+
+
+/*! @brief increment a big endian counter
+  @param counter pointer to the base of the counter block
+  @param n number of bytes in the counter
+  @note: the IV/counter CTR mode is big-endian.  The rest of the AES code
+  is endian-neutral.
+  increment counter (32 bit unsigned int
+  rightmost 32 bits of a 128 bit block ) by 1 
+*/
+static void AES_gcm_inc(unsigned char *counter, int n) {
+  int i;
+  int cy = 0;
+  for(i = (n - 1); i >= 0; i--) {
+    if(0xff == counter[i]) {
+      cy = 1;
+    }
+    counter[i]++;
+    if(!cy) break;
+  }
+
+}
+
+/** @brief xor two buffers into a destination.
+    (Which may be one of the source buffers )
+    @param dest the destination buffer
+    @param s1 first source buffer
+    @param s2 second source buffer
+    @param blen buffer length
+*/
+
+static void xor(unsigned char *dest, unsigned char *s1, unsigned char *s2, unsigned blen)
+{
+    unsigned int i;
+    for(i = 0; i < blen; i++) {
+	dest[i] = s1[i] ^ s2[i];
+    }
+}
+
+/** @brief right shift a buffer (assumed to be a big endian byte stream)
+    @param buf  source buffer
+    @param blen buffer length
+*/
+static void shr(unsigned char *buf,unsigned blen)
+{
+    unsigned cry;
+    unsigned crynxt;
+    unsigned i;
+
+    if(blen != 0) {
+      for(i = cry = 0; i < blen ; i++) {
+	crynxt = 0;
+	if(buf[i] & 1) {
+	  crynxt = 0x80;
+	}
+	buf[i] = ((buf[i] >> 1) & 0x7f) | cry;
+	cry = crynxt;
+      }
+    }
+}
+#if 0
+/** @brief left shift a buffer (assumed to be a big endian byte stream)
+    @param buf  source buffer
+    @param blen buffer length
+*/
+static void shl(unsigned char *buf,unsigned blen)
+{
+    unsigned cry;
+    unsigned crynxt;
+    int i;
+
+    for(i = blen-1,cry = 0; blen >0 && i >=0 ; i--) {
+      crynxt = 0;
+      if(buf[i] & 0x80) {
+	crynxt = 0x01;
+      }
+      buf[i] = (buf[i] << 1)  | cry;
+      cry = crynxt;
+    }
+}
+#endif
+
+static unsigned char rem_table_8bit[256][2] = {
+    {0x00,0x00}, {0x01,0xC2}, {0x03,0x84}, {0x02,0x46}, {0x07,0x08}, {0x06,0xCA},
+    {0x04,0x8C}, {0x05,0x4E}, {0x0E,0x10}, {0x0F,0xD2}, {0x0D,0x94}, {0x0C,0x56},
+    {0x09,0x18}, {0x08,0xDA}, {0x0A,0x9C}, {0x0B,0x5E}, {0x1C,0x20}, {0x1D,0xE2},
+    {0x1F,0xA4}, {0x1E,0x66}, {0x1B,0x28}, {0x1A,0xEA}, {0x18,0xAC}, {0x19,0x6E},
+    {0x12,0x30}, {0x13,0xF2}, {0x11,0xB4}, {0x10,0x76}, {0x15,0x38}, {0x14,0xFA},
+    {0x16,0xBC}, {0x17,0x7E}, {0x38,0x40}, {0x39,0x82}, {0x3B,0xC4}, {0x3A,0x06},
+    {0x3F,0x48}, {0x3E,0x8A}, {0x3C,0xCC}, {0x3D,0x0E}, {0x36,0x50}, {0x37,0x92},
+    {0x35,0xD4}, {0x34,0x16}, {0x31,0x58}, {0x30,0x9A}, {0x32,0xDC}, {0x33,0x1E},
+    {0x24,0x60}, {0x25,0xA2}, {0x27,0xE4}, {0x26,0x26}, {0x23,0x68}, {0x22,0xAA},
+    {0x20,0xEC}, {0x21,0x2E}, {0x2A,0x70}, {0x2B,0xB2}, {0x29,0xF4}, {0x28,0x36},
+    {0x2D,0x78}, {0x2C,0xBA}, {0x2E,0xFC}, {0x2F,0x3E}, {0x70,0x80}, {0x71,0x42},
+    {0x73,0x04}, {0x72,0xC6}, {0x77,0x88}, {0x76,0x4A}, {0x74,0x0C}, {0x75,0xCE},
+    {0x7E,0x90}, {0x7F,0x52}, {0x7D,0x14}, {0x7C,0xD6}, {0x79,0x98}, {0x78,0x5A},
+    {0x7A,0x1C}, {0x7B,0xDE}, {0x6C,0xA0}, {0x6D,0x62}, {0x6F,0x24}, {0x6E,0xE6},
+    {0x6B,0xA8}, {0x6A,0x6A}, {0x68,0x2C}, {0x69,0xEE}, {0x62,0xB0}, {0x63,0x72},
+    {0x61,0x34}, {0x60,0xF6}, {0x65,0xB8}, {0x64,0x7A}, {0x66,0x3C}, {0x67,0xFE},
+    {0x48,0xC0}, {0x49,0x02}, {0x4B,0x44}, {0x4A,0x86}, {0x4F,0xC8}, {0x4E,0x0A},
+    {0x4C,0x4C}, {0x4D,0x8E}, {0x46,0xD0}, {0x47,0x12}, {0x45,0x54}, {0x44,0x96},
+    {0x41,0xD8}, {0x40,0x1A}, {0x42,0x5C}, {0x43,0x9E}, {0x54,0xE0}, {0x55,0x22},
+    {0x57,0x64}, {0x56,0xA6}, {0x53,0xE8}, {0x52,0x2A}, {0x50,0x6C}, {0x51,0xAE},
+    {0x5A,0xF0}, {0x5B,0x32}, {0x59,0x74}, {0x58,0xB6}, {0x5D,0xF8}, {0x5C,0x3A},
+    {0x5E,0x7C}, {0x5F,0xBE}, {0xE1,0x00}, {0xE0,0xC2}, {0xE2,0x84}, {0xE3,0x46},
+    {0xE6,0x08}, {0xE7,0xCA}, {0xE5,0x8C}, {0xE4,0x4E}, {0xEF,0x10}, {0xEE,0xD2},
+    {0xEC,0x94}, {0xED,0x56}, {0xE8,0x18}, {0xE9,0xDA}, {0xEB,0x9C}, {0xEA,0x5E},
+    {0xFD,0x20}, {0xFC,0xE2}, {0xFE,0xA4}, {0xFF,0x66}, {0xFA,0x28}, {0xFB,0xEA},
+    {0xF9,0xAC}, {0xF8,0x6E}, {0xF3,0x30}, {0xF2,0xF2}, {0xF0,0xB4}, {0xF1,0x76},
+    {0xF4,0x38}, {0xF5,0xFA}, {0xF7,0xBC}, {0xF6,0x7E}, {0xD9,0x40}, {0xD8,0x82},
+    {0xDA,0xC4}, {0xDB,0x06}, {0xDE,0x48}, {0xDF,0x8A}, {0xDD,0xCC}, {0xDC,0x0E},
+    {0xD7,0x50}, {0xD6,0x92}, {0xD4,0xD4}, {0xD5,0x16}, {0xD0,0x58}, {0xD1,0x9A},
+    {0xD3,0xDC}, {0xD2,0x1E}, {0xC5,0x60}, {0xC4,0xA2}, {0xC6,0xE4}, {0xC7,0x26},
+    {0xC2,0x68}, {0xC3,0xAA}, {0xC1,0xEC}, {0xC0,0x2E}, {0xCB,0x70}, {0xCA,0xB2},
+    {0xC8,0xF4}, {0xC9,0x36}, {0xCC,0x78}, {0xCD,0xBA}, {0xCF,0xFC}, {0xCE,0x3E},
+    {0x91,0x80}, {0x90,0x42}, {0x92,0x04}, {0x93,0xC6}, {0x96,0x88}, {0x97,0x4A},
+    {0x95,0x0C}, {0x94,0xCE}, {0x9F,0x90}, {0x9E,0x52}, {0x9C,0x14}, {0x9D,0xD6},
+    {0x98,0x98}, {0x99,0x5A}, {0x9B,0x1C}, {0x9A,0xDE}, {0x8D,0xA0}, {0x8C,0x62},
+    {0x8E,0x24}, {0x8F,0xE6}, {0x8A,0xA8}, {0x8B,0x6A}, {0x89,0x2C}, {0x88,0xEE},
+    {0x83,0xB0}, {0x82,0x72}, {0x80,0x34}, {0x81,0xF6}, {0x84,0xB8}, {0x85,0x7A},
+    {0x87,0x3C}, {0x86,0xFE}, {0xA9,0xC0}, {0xA8,0x02}, {0xAA,0x44}, {0xAB,0x86},
+    {0xAE,0xC8}, {0xAF,0x0A}, {0xAD,0x4C}, {0xAC,0x8E}, {0xA7,0xD0}, {0xA6,0x12},
+    {0xA4,0x54}, {0xA5,0x96}, {0xA0,0xD8}, {0xA1,0x1A}, {0xA3,0x5C}, {0xA2,0x9E},
+    {0xB5,0xE0}, {0xB4,0x22}, {0xB6,0x64}, {0xB7,0xA6}, {0xB2,0xE8}, {0xB3,0x2A},
+    {0xB1,0x6C}, {0xB0,0xAE}, {0xBB,0xF0}, {0xBA,0x32}, {0xB8,0x74}, {0xB9,0xB6},
+    {0xBC,0xF8}, {0xBD,0x3A}, {0xBF,0x7C}, {0xBE,0xBE}
+};
+
+static unsigned char rem_table_4bit[16][2] = {
+    {0x00,0x00}, {0x1C,0x20}, {0x38,0x40}, {0x24,0x60}, {0x70,0x80}, {0x6C,0xA0},
+    {0x48,0xC0}, {0x54,0xE0}, {0xE1,0x00}, {0xFD,0x20}, {0xD9,0x40}, {0xC5,0x60},
+    {0x91,0x80}, {0x8D,0xA0}, {0xA9,0xC0}, {0xB5,0xE0}
+};
+
+
+/*! @brief generates table n for each possible byte multipled by hkey.
+    @param n which table to generate (the nth table)
+    @param hkey the authentication key
+    @param t the table will be generated in this variable
+*/
+static void GCM_TAB_gen_8bit_table_n(
+				     int n,
+				     unsigned char hkey[16],
+				     unsigned char t[256][16])
+{
+  int i;
+  int j;
+  int overflow;
+  int remi;
+
+  /* Set t[128] = hkey since t[128] is the same as f(x) = 1.  That is,
+     t[128] = f(x) * hkey = hkey.  Then, depending on which table this is,
+     shift over by 8 bytes in the GF(2^128) field.  So, each time this loop
+     iterates we have t[128] = t[128] * x^8 in GF(2^128). */
+  i = n;
+  memcpy(t[128], hkey, 16);
+  while (i > 0) {
+    remi = t[128][15];
+
+    for (j = 15; j >= 1; j--) {
+      t[128][j] = t[128][j - 1];
+    }
+    t[128][0] = rem_table_8bit[remi][0];
+    t[128][1] ^= rem_table_8bit[remi][1];
+
+    i--;
+  }
+
+  /* Then start figuring out the other indices.  If t[128] is 1, then
+     t[64] is x, t[32] is x^2, t[16] is x^3, etc.  So, to find those
+     indices we simply shift t[128] over by 1, 2, 3 bits. */
+  i = 64;
+  while (i > 0) {
+    memcpy(t[i], t[i << 1], 16);
+    overflow = t[i][15] & 0x01;
+    shr(t[i], 16);
+    if (overflow) {
+      t[i][0] ^= 0xE1;
+    }
+
+    i >>= 1;
+  }
+
+  /* After figuring out all the powers of two up to t[128], we can simply add
+     all these together to get the remaining indices. */
+  i = 2;
+  while (i < 256) {
+    for (j = 1; j < i; j++) {
+      xor(t[i + j], t[i], t[j], 16);
+    }
+    i <<= 1;
+  }
+
+  memset(t[0], 0x00, 16);
+}
+
+/*! @brief generates table n for each possible nibble multipled by hkey.
+  @param n which table to generate (the nth table)
+  @param hkey the authentication key
+  @param t the table will be generated in this variable
+*/
+static void GCM_TAB_gen_4bit_table_n(
+				     int n,
+				     unsigned char hkey[16],
+				     unsigned char t[16][16])
+{
+  int i;
+  int j;
+  int overflow;
+  int remi;
+
+  /* For the 4 bit tables, we're basically doing the same thing as the
+     8 bit tables except at a 4 bit scale.  So, instead of t[128] being
+     f(x) = 1, t[8] is f(x) = 1.  Everything else proceeds the same from
+     there. */
+  i = n;
+  memcpy(t[8], hkey, 16);
+  while (i > 0) {
+    remi = t[8][15] & 0x0F;
+    for (j = 31; j >= 1; j--) {
+      if (j & 0x01) {
+        t[8][j >> 1] = (t[8][j >> 1] >> 4) & 0x0F;
+      } else {
+        t[8][j >> 1] = t[8][j >> 1] | ((t[8][(j >> 1) - 1] << 4) & 0xF0);
+      }
+    }
+    t[8][0] &= 0x0F;
+
+    t[8][0] ^= rem_table_4bit[remi][0];
+    t[8][1] ^= rem_table_4bit[remi][1];
+
+    i--;
+  }
+
+  i = 4;
+  while (i > 0) {
+    memcpy(t[i], t[i << 1], 16);
+    overflow = t[i][15] & 0x01;
+    shr(t[i], 16);
+    if (overflow) {
+      t[i][0] ^= 0xE1;
+    }
+
+    i >>= 1;
+  }
+
+  i = 2;
+  while (i < 16) {
+    for (j = 1; j < i; j++) {
+      xor(t[i + j], t[i], t[j], 16);
+    }
+    i <<= 1;
+  }
+
+  memset(t[0], 0x00, 16);
+}
+
+/*! @brief initialize the table for level 1 acceleration.
+  This acceleration level maintains a table for all 16 possible values
+  of the first nibble of the 8KB table.  That is, it only holds:
+  x^0 + x^1 + x^2 + x^3 multipled by the hash key for all possible
+  values (0x0-0xF).
+  @param hkey the authentication key
+  @param t the table that will be initialized
+  @retval 0 if table initializaiton fails
+  @retval 1 if table initialization succeeds
+*/
+static void GCM_TAB_init_256b(
+			      unsigned char hkey[16],
+			      unsigned char t[16][16])
+{
+  GCM_TAB_gen_4bit_table_n(0, hkey, t);
+}
+
+/*! @brief initialize the table for level 1 acceleration.
+  This acceleration level maintains a table for all 256 possible values
+  of the first byte of the 64KB table.  That is, it only holds:
+  x^0 + x^1 + ... + x^7 multiplied by the hash key for all possible
+  values (0x00-0xFF).
+  @param hkey the authentication key
+  @param t the table that will be initialized
+  @retval 0 if table initializaiton fails
+  @retval 1 if table initialization succeeds
+*/
+static void GCM_TAB_init_4kb(
+			     unsigned char hkey[16],
+			     unsigned char t[256][16])
+{
+  GCM_TAB_gen_8bit_table_n(0, hkey, t);
+}
+
+/*! @brief initialize the table for level 3 acceleration.
+  This acceleration level maintains a table for all 16 possible values
+  of a nibble (4 bits) for each of the 32 nibbles in an AES block (which
+  is 16 bytes long).  That is, any given table t[i=0..32] represents:
+  x^(i+0) + x^(i+1) + ... + x^(i+3) multipled by the hash key for all
+  possible values (0x0-0xF).
+  @param hkey the authentication key
+  @param t the table that will be initialized
+  @retval 0 if table initializaiton fails
+  @retval 1 if table initialization succeeds
+*/
+static void GCM_TAB_init_8kb(
+			     unsigned char hkey[16],
+			     unsigned char t[32][16][16])
+{
+  int i;
+  for (i = 0; i < 32; i++) {
+    GCM_TAB_gen_4bit_table_n(i, hkey, t[i]);
+  }
+}
+
+/*! @brief initialize the table for level 4 acceleration.
+  This acceleration level maintains a table for all 256 possible values
+  of a byte (8 bits) for each of the 16 bytes in an AES block (which is
+  16 bytes long).  That is, any given table t[i=0..15] represents:
+  x^(i+0) + x^(i+1) + ... + x^(i+7) multiplied by the hash key for
+  all possible values (0x00-0xFF).
+  @param hkey the authentication key
+  @param t the table that will be initialized
+  @retval 0 if table initializaiton fails
+  @retval 1 if table initialization succeeds
+*/
+static void GCM_TAB_init_64kb(
+			      unsigned char hkey[16],
+			      unsigned char t[16][256][16])
+{
+  int i;
+  for (i = 0; i < 16; i++) {
+    GCM_TAB_gen_8bit_table_n(i, hkey, t[i]);
+  }
+}
+
+static size_t GCM_table_size(GCM_ACCEL accel)
+{
+  size_t table_size = 0;
+  switch (accel) {
+  default:
+  case GCM_ACCEL_noaccel:
+    break;
+  case GCM_ACCEL_level1:    
+    /* 16 x 16 = 256 bytes */
+    table_size = 256;
+    break;
+  case GCM_ACCEL_level2:   
+    /* 256 x 16 = 4096 bytes */
+    table_size = 4096;
+    break;
+  case GCM_ACCEL_level3:  
+    /* 32 x 16 x 16 = 8192 bytes */
+    table_size = 8192;
+    break;
+  case GCM_ACCEL_level4:
+    /* 16 x 256 x 16 = 65536 bytes */
+    table_size = 65536;
+    break;
+  }
+  return table_size;
+}
+/*! @brief Allocate a new GCM acceleration table
+  with enough space to support the requested level of acceleration
+  @param accel the acceleration level to use
+*/
+static void * GCM_TAB_new(GCM_ACCEL accel)
+{
+  size_t table_size = 0;
+  table_size = GCM_table_size(accel);
+  return CRYPTO_malloc(table_size, __FILE__, __LINE__);
+}
+
+/*! @brief given a pointer to some memory call the appropriate
+  table initialization routine.
+  @param t the pointer to memory that will hold table
+  @param accel the acceleration level for the table
+  @retval 0 if table initialization fails
+  @retval 1 if table initialization succeeds
+*/
+static int GCM_TAB_init(GCM_ACCEL accel, void *t, unsigned char hkey[16])
+{
+  int ret = 1;
+
+  if (NULL != t && (accel == GCM_ACCEL_level1 || accel == GCM_ACCEL_level2
+		    || accel == GCM_ACCEL_level3 || accel == GCM_ACCEL_level4)) {
+    switch (accel) {
+    case GCM_ACCEL_noaccel:
+      break;
+    case GCM_ACCEL_level1:
+      GCM_TAB_init_256b(hkey, (unsigned char (*)[16]) t); /*[16][16]*/
+      break;
+    case GCM_ACCEL_level2:
+      GCM_TAB_init_4kb(hkey, (unsigned char (*)[16]) t); /*[256][16]*/
+      break;
+    case GCM_ACCEL_level3:
+      GCM_TAB_init_8kb(hkey, (unsigned char (*)[16][16]) t); /*[32][16][16]*/
+      break;
+    case GCM_ACCEL_level4:
+      GCM_TAB_init_64kb(hkey, (unsigned char (*)[256][16]) t); /*[16][256][16]*/
+      break;
+    default:
+      ret = 0;
+      break;
+    }
+  }
+  return ret;
+}
+
+/*! @brief clear/free a GCM acceleration table
+  @param t a pointer to the table to clean/free
+*/
+static void GCM_TAB_free(GCM_ACCEL accel, void *t) {
+  size_t table_size = 0;
+  table_size = GCM_table_size(accel);
+  if(NULL != t) {
+    memset(t, 0x00, table_size);      
+    CRYPTO_free(t);
+  }
+}
+
+/** 
+    @brief IV generator for AES_GCM IV's
+    @param gcm_ctx An AES_GCM context
+    @param out an 8 byte buffer which should contain reasonably non-repeating data 
+    ideally at least 2^32 between repeats, and not predictable.
+    @return 1 if O.K. 0 if the RNG found two adjacent repeated values
+    @note
+    - There are probably a lot of ways to do this, but the simplest to ensure: 
+    - a) non-repitition over 2^32 calls
+    - b) unpredictability of the data stream
+    seems to be to encrypt a counter with (any) cipher with an 8 byte block size and
+    a randomly generated key. 
+    - To guarantee no repeats within our 8 byte output
+    we need a cipher with an 8 byte blocksize so AES isn't usable.
+    The 8 byte cipher blocksize guarantees a unqiue 1:1 transform
+    between our input (counter) and the output and no repeats for the block size.
+    - To avoid attacks, we generate a new random key every 2^32 iterations.
+    - The choice of cipher itself shouldn't matter as we are only relying on this one 
+    property (key specific 1:1 mapping of input to output over 64 bits),
+    not it's strength, and over one block, all ciphers will be equally strong or weak
+    WRT this. We chose to use blowfish because of it's speed.
+    DES, 3DES or CAST could also be used, but offer no functional advantages
+    The weak keys in DES cause problems they require reducing the key space  
+    - We believe blowfish is usable here, even in FIPS approved code, because we 
+    are NOT using it as an encryption function, simply as a way to guarantee 
+    the unique 1:1 input/output mapping.
+*/
+   
+int AES_GCM_GenerateIV(AES_GCM_CTX *gcm_ctx,unsigned char out[8]) 
+{
+  int rv = 1;
+  AES_GCM_CTX_t *ctx = NULL;
+  static const EVP_CIPHER *cipher = NULL; 
+  unsigned char IVkeybuf[16];  /*!< Transient encrypt key */
+  int outl = 0;
+
+  ctx = (AES_GCM_CTX_t *)gcm_ctx;
+  
+  /* Obtain the block cipher */
+  if(NULL == cipher) {
+    cipher = EVP_get_cipherbyname("blowfish");
+  }
+  /* Have we used this for IV generation before ? */
+  if(NULL == ctx->IVctx) {
+    /* Create an encryption context for this IV generator */
+    ctx->IVctx = EVP_CIPHER_CTX_new();
+  }
+  /* Initialize from scratch the first time, 
+     and every 2^32'th time round the block 
+  */
+  if(0 == ctx->count) {
+    /* Initialize the counter to some random starting value */
+    
+    RAND_bytes(ctx->IVcounter,8);
+    /* get a new seed from the TRNG for the transform key*/
+    RAND_bytes(IVkeybuf,16);
+    EVP_CIPHER_CTX_cleanup(ctx->IVctx);
+    EVP_CIPHER_CTX_set_padding(ctx->IVctx,0);
+    EVP_EncryptInit(ctx->IVctx,cipher,IVkeybuf,ctx->IVcounter);
+  }
+  /* Here we go, encrypt our randomly initialized counter with a random key */
+  EVP_EncryptUpdate(ctx->IVctx,out,&outl,ctx->IVcounter,8);
+  /* Increment the counter, 8 bytes of it in this case */
+  AES_gcm_inc(ctx->IVcounter,8);
+  /* Increment the number of cycles, and ensure we'll restart again at 2^32 */
+  ctx->count = (ctx->count +1) & 0xffffffff;  
+  return rv;
+}
+/*
+ *
+ * This algorithm assumes that the counter is in the x lower bits
+ * of the IV (ivec), and that the application has full control over
+ * overflow and the rest of the IV.  This implementation takes NO
+ * responsibility for checking that the counter doesn't overflow
+ * into the rest of the IV when incremented.
+ */
+
+/*! @brief allocate a new AES_GCM context
+  @return a newly allocated AES_GCM context or NULL
+*/
+AES_GCM_CTX * AES_GCM_CTX_new()
+{
+
+  AES_GCM_CTX_t *ctx;
+  ctx = (AES_GCM_CTX_t *)CRYPTO_malloc(sizeof(AES_GCM_CTX_t),__FILE__,__LINE__);
+
+  if(NULL != ctx) {
+    memset(ctx,0,sizeof(AES_GCM_CTX_t));
+  }
+  return ((AES_GCM_CTX *)ctx);
+}
+
+/*! @brief clear/free a previously allocated AES_GCM context/IV context
+  @param ain the AES_GCM context to clear/free
+*/
+void AES_GCM_CTX_free(AES_GCM_CTX *ain)
+{
+  AES_GCM_CTX_t *a = (AES_GCM_CTX_t *)ain;
+  if((a->tab.accel != GCM_ACCEL_noaccel) && (a->tab.tabdata != NULL)) {
+    GCM_TAB_free(a->tab.accel, a->tab.tabdata);
+    a->tab.tabdata = NULL;
+  }
+  /* If the IV part of the context was in use, clean that up */
+  if(NULL != a->IVctx) {
+    EVP_CIPHER_CTX_cleanup(a->IVctx);
+    EVP_CIPHER_CTX_free(a->IVctx);      
+  }
+  if(NULL != a->ctx) {
+    EVP_CIPHER_CTX_cleanup(a->ctx);
+    EVP_CIPHER_CTX_free(a->ctx);      
+  }
+  /* Clear everything */
+  memset(a,0,sizeof(AES_GCM_CTX_t));
+  CRYPTO_free(a);
+}
+/*! @brief Multiply X by Y in GF(2^128) into Z using no optimization.
+  @param Z The output for the multiplication
+  @param X X is multiplied by Y
+  @param Y X is multiplied by Y
+  @return 0 on success
+*/
+static int GCM_mult_noaccel(
+			    unsigned char *Z,
+			    unsigned char *X,
+			    unsigned char *Y)
+{
+  /* Note our endianess of the field polynomial's decription in the spec
+     i.e. a + x1a + x2a^2 + x3a^3 is little endian
+     form and the operations are defined as though
+     the input vectors are also little endian
+     (confusing)
+  */
+  /*                           bit 0   ,1   ,2   ,3   ,4   ,5   ,6   ,7 */
+  static unsigned char mask[8] = { 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
+  int rv = 0;
+  int i = 0;
+  /* In the implementation of this, X or Y is the same as Z
+     so we want to make sure we aren't rewriting our input as we go
+  */
+  unsigned char T[AES_BLOCK_SIZE];
+  unsigned char V[AES_BLOCK_SIZE];
+  /*
+    printbin("   GCM X",X,16);
+    printbin("   GCM Y",Y,16);
+  */
+  memset(T,0,AES_BLOCK_SIZE);
+  memcpy(V,X,AES_BLOCK_SIZE);
+  for( i = 0; i < 128 ; i++) {
+
+    /* if Yi == 0, then adding this term is a NOP */
+    /* if Yi != 0, the XOR is the addition operation as all terms are independent */
+    if( 0 != (Y[i>>3] & mask[i&7]) ) {
+      xor(T,T,V,AES_BLOCK_SIZE);
+    }
+    /* If the MSBit of the shifted X vector is 0, then there's no need to 
+       divide by the field polynomial, as we can't possibly overflow 
+    */
+    if ( 0 == ((V[15] & 0x01)) ) {
+      shr(V,AES_BLOCK_SIZE);
+    } else { 
+      /* In a Galois field no one can hear you scream ...
+	 We are after the 128bit remainder ...
+      */
+      shr(V,AES_BLOCK_SIZE);
+      V[0] = V[0] ^ 0xe1;
+    }
+  } 
+  memcpy(Z,T,AES_BLOCK_SIZE);
+  /*printbin("   GCM Z",Z,16);*/
+  return rv;
+}
+/*! @brief Multiply X by some value that has had some precalculation done
+  into t.  Place result in Z
+  @param Z The result of the muliplication
+  @param X The value to be multiplied by the value precalculated in t
+  @param t Precalculated values for some value Y times possible values of X
+  @return 0 on success
+*/
+static int GCM_mult_level1(
+			   unsigned char *Z,
+			   unsigned char *X,
+			   unsigned char t[16][16])
+{
+  int i;
+  int j;
+  int tabi;
+  int remi;
+  unsigned char tmp[16];
+
+  /* The table at this level only has those value in the first table
+     for level3 acceleration, which means we need to shift everything
+     over as we index the table (multiply).  We start at the high
+     degrees and move down so that the values at the high degree
+     get multiplied over (shifted right) as we go.  Remember, we're
+     doing everything in 4 bit increments so be careful to use the
+     correct nibble of each byte processed */
+  memcpy(tmp, X, 16);
+  memset(Z, 0x00, 16);
+  for (i = 31; i > 0; i--) {
+    tabi = (i & 0x01) ? tmp[i >> 1] & 0x0F : (tmp[i >> 1] >> 4) & 0x0F;
+    xor(Z, Z, t[tabi], 16);
+
+    remi = Z[15] & 0x0F;
+    for (j = 31; j > 0; j--) {
+      Z[j >> 1] = (j & 0x01)
+	? (Z[j >> 1] >> 4) & 0x0F
+	: ((Z[(j >> 1) - 1] << 4) & 0xF0) | Z[j >> 1];
+    }
+    Z[0] &= 0x0F;
+    Z[0] ^= rem_table_4bit[remi][0];
+    Z[1] ^= rem_table_4bit[remi][1];
+  }
+
+  tabi = (tmp[0] >> 4) & 0x0F;
+  xor(Z, Z, t[tabi], 16);
+
+  return 0;
+}
+/*! @brief Multiply X by some value that has been precalculated into t and
+  place the result into Z.
+  @param Z The result of the multiplication
+  @param X The value to be multiplied by the precalculated value in t
+  @param t Precalculated value for some value Y times possible values of X
+  @return 0 on success
+*/
+static int GCM_mult_level2(
+			   unsigned char *Z,
+			   unsigned char *X,
+			   unsigned char t[256][16])
+{
+  int i;
+  int j;
+  int remi;
+  unsigned char tmp[16];
+
+  /* The table, at this level, has only those value in the first table for
+     level 4 acceleration.  That is, the hash key times all possible 2^8
+     values, for 1 + x + x^2 + ... + x^7.  So, we need to multiply everything
+     by x^8 however many times to get them in the appropriate location.  To
+     do this, we start with the high degree value, find their index and shift
+     them over by  only bytes.  We continue to do this until the last
+     iteration of this loop when the higher degrees will have been shifted
+     the correct number of times.  The last byte (lowest 8 degree terms) are
+     simply added into the result since they don't need to be shifted. */
+  memcpy(tmp, X, 16);
+  memset(Z, 0x00, 16);
+  for (i = 15; i > 0; i--) {
+    xor(Z, Z, t[tmp[i]], 16);
+
+    remi = Z[15];
+    for (j = 15; j > 0; j--) {
+      Z[j] = Z[j - 1];
+    }
+    Z[0] = rem_table_8bit[remi][0];
+    Z[1] ^= rem_table_8bit[remi][1];
+  }
+  xor(Z, Z, t[tmp[0]], 16);
+  return 0;
+}
+/*! @brief Multiply X by some value that has been precalculated into t and
+  place the result into Z.
+  @param Z The result of the multiplication
+  @param X The value to be multiplied by the precalculated value in t
+  @param t Precalculated value for some value Y times possible values of X
+  @return 0 on success
+*/
+static int GCM_mult_level3(
+			   unsigned char *Z,
+			   unsigned char *X,
+			   unsigned char t[32][16][16])
+{
+  int i;
+  int tabi;
+  unsigned char tmp[16];
+
+  /* Everything has been precalculated, so just loop through each 4 bit
+     chunk and the corrresponding table and add the value at that point
+     of the table into the result. */
+  memcpy(tmp, X, 16);
+  memset(Z, 0x00, 16);
+  for (i = 0; i < 32; i++)  {
+    tabi = (i & 0x01) ? tmp[i >> 1] & 0x0F : (tmp[i >> 1] >> 4) & 0x0F;
+    xor(Z, Z, t[i][tabi], 16);
+  }
+  return 0;
+}
+/*! @brief Multiply X by some value that has been precalculated into t and
+  place the result into Z.
+  @param Z The result of the multiplication
+  @param X The value to be multiplied by the precalculated value in t
+  @param t Precalculated value for some vaule Y times possible values of X
+  @return 0 on success
+*/
+static int GCM_mult_level4(
+			   unsigned char *Z,
+			   unsigned char *X,
+			   unsigned char t[16][256][16])
+{
+  int i;
+  unsigned char tmp[16];
+
+  /* Everything has been precalculated, so just loop through each byte and
+     the corresponding table and add the value at that point in the table
+     onto the result in Z. */
+  memcpy(tmp, X, 16);
+  memset(Z, 0x00, 16);
+  for (i = 0; i < 16; i++) {
+    xor(Z, Z, t[i][tmp[i]], 16);
+  }
+  return 0;
+}
+/*!
+  @brief Multiply two bit strings in a Galois field
+  @param tab a "short cut" table for algorithm acceleration
+  There are multiple space/time tradeoffs possible,
+  so I expect this to encapsulate multiple possible methods
+  up to and including tab == NULL, i.e. we don't need no
+  steenkin accleration, in which case I brute force
+  the algorithm
+  @param tab a pointer to the GCM acceleration table
+  @param Z  result vector
+  @param X  input vector1
+  @param Y  input vector2.  If tab->accel != GCM_ACCEL_noaccel than this
+  parameter is ignored and tab is used, instead.
+  @return 0 == O.K. 1 = invalid parameter
+  @note This is really screwed up
+  The GCM operation is defined on a little endian field but all the
+  data is kept in it's natural form (big endian)
+  That makes this really really ugly.
+*/
+static int GCM_mult(GCM_TAB *tab,
+		    unsigned char *Z,
+		    unsigned char *X,
+		    unsigned char *Y)
+{
+  int ret = 0;
+  switch (tab->accel) {
+  case GCM_ACCEL_noaccel:
+    ret = GCM_mult_noaccel(Z, X, Y);
+    break;
+  case GCM_ACCEL_level1:
+    ret = GCM_mult_level1(Z, X, (unsigned char (*)[16]) tab->tabdata);
+    break;
+  case GCM_ACCEL_level2:
+    ret = GCM_mult_level2(Z, X, (unsigned char (*)[16]) tab->tabdata);
+    break;
+  case GCM_ACCEL_level3:
+    ret = GCM_mult_level3(Z, X, (unsigned char (*)[16][16]) tab->tabdata);
+    break;
+  case GCM_ACCEL_level4:
+    ret = GCM_mult_level4(Z, X, (unsigned char (*)[256][16]) tab->tabdata);
+    break;
+  default:
+    ret = 1;
+    break;
+  }
+  return ret;
+}
+/*! 
+  @brief Public (test) entry point for the Galois multiplier
+  Multiply two 16 byte vectors (X & Y) in a 128 bit Galois field
+  @param gcm_ctx an ICC AES_GCM context
+  @param Z the result
+  @param X the X input vector
+  @param Y the Y input vector
+  @return always 0
+  @note This routine was provided ONLY to allow us to debug and performance tune
+  the AES-GCM code 
+  @note if supported, any acceleration set up the the AES_GCM context should 
+  work for this routine
+  @note the field chosen is 1 + a +a^2 + a^7 + a^128
+*/
+int GCM128(AES_GCM_CTX *gcm_ctx,unsigned char *Z, unsigned char *X, unsigned char *Y)
+{   
+  return GCM_mult(&(((AES_GCM_CTX_t *)gcm_ctx)->tab),Z,X,Y);
+}
+/** @brief
+    Setup AES-GCM acceleration tables
+    @param a an AES_GCM_CTX template
+    @param accel the speed/space tradeoff preferred
+    @return The acceleration state
+*/
+static int aes_gcm_accel(AES_GCM_CTX_t *a, int accel)
+{
+  int ret = 0;
+  void *tab = NULL;
+    
+  /* if the current acceleration is the same as the
+     requested, then simply return success. */
+  if (a->tab.accel == accel) {
+    ret = 1;
+  } else {
+    tab = GCM_TAB_new(accel);
+    ret = GCM_TAB_init(accel, tab, a->H);
+    if (ret == 0) {
+      GCM_TAB_free(accel, tab);
+    } else {
+      GCM_TAB_free(a->tab.accel, a->tab.tabdata);
+      a->tab.accel = accel;
+      a->tab.tabdata = tab;
+    }
+  }
+  return ret;
+}
+/** @brief the ctrl interface for AES GCM.
+    @param a an AES_GCM_CTX context
+    @param type the type of ctrl to run
+    @param val the value corresponding to type
+    @param ptr a pointer to data corresponding to type
+    @retval 1 on success
+    @retval 0 on failure
+*/
+
+int AES_GCM_CTX_ctrl(AES_GCM_CTX *ain, int type, int val, void *ptr)
+{
+  AES_GCM_CTX_t *a = (AES_GCM_CTX_t *)ain;
+  int ret = 0;
+
+  switch (type) {
+  case AES_GCM_CTRL_SET_ACCEL:
+    ret = aes_gcm_accel((AES_GCM_CTX_t *) a, val);
+    break;
+  case AES_GCM_CTRL_GET_ACCEL:
+    *(int *)ptr = a->tab.accel;
+    ret = 1;
+    break;
+  default:
+    ret = 0;
+    break;
+  }
+
+  return ret;
+}
+
+/** @brief Calculate the GHASH of an arbitrary data stream 
+    @param tab the GSM speedup table. (if one exists)
+    @param H the hash key
+    @param Y is the output, (AES_BLOCK_SIZE long)
+    @param X the input data
+    @param xlen is the length of the input data 0 <= X <= 2^64 BITS
+    @return 1 if O.K. 0 on error (X is too long)
+    @note The last block of X will be 0 padded - so no partial blocks
+    unless you want this.
+    @note Y should be initialized to 0 if this is the first pass
+    otherwise, Y is the output from the previous invocation and
+    the GHASH can be chained.   
+*/
+
+static void GHASH_i(GCM_TAB *tab,unsigned char *H,unsigned char *Y, unsigned char *X,unsigned long xlen) 
+{  
+  unsigned char tmp[AES_BLOCK_SIZE];
+     
+  for( ; xlen >= AES_BLOCK_SIZE; xlen -= AES_BLOCK_SIZE) {
+    xor(Y,X,Y,AES_BLOCK_SIZE);
+    GCM_mult(tab,Y,Y,H);
+    printN(Y,AES_BLOCK_SIZE);
+    X += AES_BLOCK_SIZE;
+  }
+  /* Last block */
+  if( xlen > 0 ) {
+    memset(tmp,0,AES_BLOCK_SIZE);
+    memcpy(tmp,X,xlen);
+    xor(Y,tmp,Y,AES_BLOCK_SIZE);
+    GCM_mult(tab,Y,Y,H);
+  }
+}
+/** @brief Calculate the GHASH of an arbitrary data stream
+    @param a an AES GSM context
+    @param H the hash key
+    @param Hash is the input/output, (AES_BLOCK_SIZE long)
+    @param X the input data
+    @param xlen is the length of the input data 0 <= X <= 2^64 BITS
+    @return 1 if O.K. 0 on error (X is too long)
+    @note The last block of X will be 0 padded - so no partial blocks
+    unless you want this.
+    @note Y should be initialized to 0 if this is the first pass
+    otherwise, Y is the output from the previous invocation and
+    the GHASH can be chained.   
+*/
+void GHASH(AES_GCM_CTX *gcm_ctx,unsigned char *H, unsigned char *Hash, unsigned char *X,unsigned long Xlen)
+{
+  GHASH_i(&(((AES_GCM_CTX_t *)gcm_ctx)->tab),H,Hash,X,Xlen);  
+}
+
+
+/** @brief
+    Initialize an AES GCM operation, provide the initialization data and
+    key
+    @param ain an AES_GCM_CTX context
+    @param iv The IV, can be 1-2^56 bytes long, 12 bytes is best
+    @param ivlen the length of the IV
+    @param key an aes key 16,24 or 32 bytes long
+    @param klen the length of the aes key
+
+    At present unimplemented. 
+    @return 1 if O.K., 0 otherwise
+*/ 
+int AES_GCM_Init(AES_GCM_CTX *ain,
+		 unsigned char *iv,unsigned long ivlen,
+		 unsigned char *key, unsigned int klen
+
+		 )
+{
+  AES_GCM_CTX_t *a = (AES_GCM_CTX_t *)ain;
+  int rv = 1;
+  int outl = 0;
+  const EVP_CIPHER *cipher = NULL;
+#if defined(AES_GCM_DEBUG)
+  Xc = 1;
+  Yc = 0;
+  Nc = 1;
+#endif
+  /* 
+     If a key was already setup ...
+     It's possible to call Init without specifying a key
+     in which case a previous key/GCM tables will be reused
+  */
+  if(NULL != key) {
+    /* check for a valid AES key */
+    switch(klen) {
+    case 16:
+      cipher = EVP_get_cipherbyname("AES-128-ECB");
+      break;
+    case 24:
+      cipher = EVP_get_cipherbyname("AES-192-ECB");
+      break;
+    case 32:
+      cipher = EVP_get_cipherbyname("AES-256-ECB");
+      break;
+    default:
+      rv = 0;
+      break;
+    }
+  }
+  if(NULL == cipher) {
+    rv = 0;
+  }
+  /* However the context and iv must be present */
+  if(NULL == a || NULL == iv) {
+    rv = 0;
+  }
+  if( 1 == rv) {
+    /* Clean stuff that needs to be cleared ... */
+    memset(a->Y,0,AES_BLOCK_SIZE);
+    memset(a->R,0,AES_BLOCK_SIZE);
+    a->state = 0;
+    a->LenA = 0;
+    a->LenC = 0;
+    /* Create a key if we need one */
+    if(NULL == a->ctx) {
+      void *tab = NULL;
+      a->ctx = EVP_CIPHER_CTX_new();
+      EVP_CIPHER_CTX_set_padding(a->ctx,0);
+      EVP_EncryptInit(a->ctx,cipher,key,NULL);
+
+      /* generate the hash key, which is 0 encrypted with the AES key */
+      EVP_EncryptUpdate(a->ctx,a->H,&outl,&zero[0],AES_BLOCK_SIZE);
+      /* AES_encrypt(zero,a->H,&(a->key)); */
+      /* set up acceleration for the key.  We can free it if it is not
+         NULL, but it's probably best to assume we need a new allocation. 
+      */
+      tab = GCM_TAB_new(a->tab.accel);
+      if (1 == (rv = GCM_TAB_init(a->tab.accel, tab, a->H))) {
+	GCM_TAB_free(a->tab.accel, a->tab.tabdata);
+	a->tab.tabdata = tab;
+      } else {
+	GCM_TAB_free(a->tab.accel, tab);
+      }
+    } /* Otherwise we assume this was already set up */
+  }
+
+  if( 1 == rv ) {
+      
+    /* now eat the IV */
+    if(ivlen == 12) {
+      memcpy(a->ecount_buf,iv,12);
+      memset(a->ecount_buf+12,0,4); /* Zero the count buffer */
+      a->ecount_buf[15] = 1; /* Counter starts at 1 ??? */  
+    } else {
+      /* NIST appear to have screwed up here, 
+	 I can't find this documented 
+      */
+      memset(a->ecount_buf,0,AES_BLOCK_SIZE);
+      GHASH_i(&(a->tab),a->H,a->ecount_buf,iv,ivlen);
+      /* and add in the BIT length of the IV  64 bits */
+      ULongToChar(ivlen*8,a->R+8);
+      printbin("0^{64}||len(IV)",a->R,AES_BLOCK_SIZE);
+      GHASH_i(&(a->tab),a->H,a->ecount_buf,a->R,AES_BLOCK_SIZE);
+      memset(a->R,0,AES_BLOCK_SIZE);
+    }
+    printY(a->ecount_buf,AES_BLOCK_SIZE);
+    EVP_EncryptUpdate(a->ctx,a->eZero,&outl,a->ecount_buf,AES_BLOCK_SIZE);
+    /* AES_encrypt(a->ecount_buf,a->eZero,&(a->key)); */
+    printEY(a->eZero,AES_BLOCK_SIZE);
+  }
+
+  return rv;
+}
+
+/** @brief
+    Merge in any pending aad data to the ciphertext 
+    @param a an AES_GCM_CTX context
+*/
+static void GCM_merge_aad(AES_GCM_CTX_t *a) {
+  if( 1 == a->state ) { /* We've had aad presented and possibly unprocessed */
+    if( a->Rlen > 0 ) { /* There's some aad unprocessed */
+      /* Generate the GMAC of the last of the aad */
+      GHASH_i(&(a->tab),a->H,a->Y,a->R,a->Rlen);
+      /* Update the length of the aad */
+      a->LenA += a->Rlen * 8;
+      printX(a->Y,AES_BLOCK_SIZE);
+
+    }
+    /* Clear our partial hash and retained unhashed data buffers */
+    a->Rlen = 0;
+    memset(a->R,0,AES_BLOCK_SIZE);
+  }
+  a->state = 2;
+}
+/**
+   @brief Common code, does the encrypt/hash core code
+
+   @param a an AES_GCM_CTX context
+   @param out the output buffer 
+   @param outlen a place to store the amount of data copied to the output buffer
+   @param encrypt 1 = encrypt, 0 = decrypt
+   @note Uses a->R/a->Rlen to hold/describe the amount of data
+   waiting the be encrypted/decrypted
+*/
+static void ED_block(AES_GCM_CTX_t *a,unsigned char **out,unsigned long *outlen,int encrypt) 
+{
+  int outl = 0;
+  if(a->Rlen) {
+    AES_gcm_inc(a->ecount_buf+12,4);
+    printY(a->ecount_buf,AES_BLOCK_SIZE);
+    /* AES encrypt the IV + counter with the AES key */
+    EVP_EncryptUpdate(a->ctx,a->S,&outl,a->ecount_buf,AES_BLOCK_SIZE);
+    /* AES_encrypt(a->ecount_buf,a->S,&(a->key)); */
+    printEY(a->S,AES_BLOCK_SIZE);
+    /* XOR with the input data , which may be a partial block */
+    memset((a->R+a->Rlen),0,AES_BLOCK_SIZE - a->Rlen);
+    memset((a->S+a->Rlen),0,AES_BLOCK_SIZE - a->Rlen);
+    xor(a->S,a->S,a->R,a->Rlen);
+    /* That's either generated plaintext, or in reverse, cipher text 
+       either way - that gets copied to the output buffer
+    */
+    memcpy(*out,a->S,a->Rlen);
+    *out += a->Rlen;
+    /* Update the counters */
+    if(NULL != outlen) *outlen += a->Rlen;
+    a->LenC += (a->Rlen * 8);
+    if(a->state == 2) { /* We had aad data to mix in, that was in a->Y (last hash) */	 		
+      a->state = 3;
+    }  
+    if(encrypt) { /* Encrypt: We mix the result of the "last" hash - which may be aad with ciphertext (a->S) */
+      /* printbin("Enc CT",a->S,a->Rlen); */
+      xor(a->Y,a->S,a->Y,AES_BLOCK_SIZE);
+      
+      /* printbin("Enc Xor CT",a->Y,16); */
+    } else {      /* Decrypt: We mix the result of the "last" hash - which may be aad with incoming ciphertext (a->R) */    
+      /* printbin("Dec CT",a->R,a->Rlen); */
+      xor(a->Y,a->R,a->Y,AES_BLOCK_SIZE); 
+      /* printbin("Dec Xor CT",a->Y,16); */ 
+    }
+    /* The residual buffer is now 'empty' */
+    a->Rlen = 0;
+    /* generate the next hash block */
+    /* printbin("H",a->H,16); */
+    /* printbin("CT^Last",a->Y,16); */
+    GCM_mult(&(a->tab),a->Y,a->Y,a->H); 
+    printX(a->Y,AES_BLOCK_SIZE);
+    
+    /* printbin("GCM128(CT^Last)",a->Y,16); */ 
+  }
+}
+
+/** @brief Perform an AES_GCM_CTX "update" operation
+
+@param a the (opaque) AES_GCM_CTX context
+@param aad additional authentication data (hashed, not encrypted)
+@param aadlen the length of the aad 0-2^56 bytes long
+@param data data to encrypt
+@param datalen the length of the encrypted data
+@param out the output buffer, should be at least "data" long
+@param outlen a place to store the length of the output data
+@param encrypt 1 if encrypting, 0 if decrypting
+@return 1 if O.K., 0 otherwise
+@note aad may only be specified up to the point where input data is being supplied
+we do support streaming aad up until that point.
+- i.e. we allow multiple chunks of aad to be specified provided data is NULL until
+the last aad chunk
+- multiple chunks of data, but aad must be NULL after the first chunk
+- There's very little difference between encrypt and decrypt in AES_GCM
+so we've rolled the code into one routine with a wrapper to simplify
+maintenance.
+*/
+static int AES_GCM_Update(AES_GCM_CTX_t *a,
+			  unsigned char *aad,unsigned long aadlen,
+			  unsigned char *data,unsigned long datalen,
+			  unsigned char *out, unsigned long *outlen,
+			  int encrypt
+			  )
+{
+  int rv = 1;
+  int i;
+  if(NULL !=outlen) {
+    *outlen = 0;
+  }
+  if((aadlen != 0) && (NULL != aad)) {
+    if(a->state > 1) { /* We've started processing data blocks ... */
+      rv = 0; /* bad, all the aad must be fed in BEFORE we process data */
+    } else {
+      a->state = 1; /* Flag that we've been supplied at least some aad */ 
+      if( (aadlen + a->Rlen) >= AES_BLOCK_SIZE) { 
+	/* At least one full block */
+	for( i = aadlen +a->Rlen ; i >= AES_BLOCK_SIZE; i -= AES_BLOCK_SIZE) {
+	  /* Top up the retain buffer from incoming */
+	  memcpy(a->R + a->Rlen,aad,AES_BLOCK_SIZE - a->Rlen);
+	  /* We stole this many bytes of aad */
+	  aad += AES_BLOCK_SIZE - a->Rlen;
+	  aadlen -= (AES_BLOCK_SIZE - a->Rlen);
+	  a->Rlen = 0;
+	  /* Generate the GMAC of the aad */
+	  GHASH_i(&(a->tab),a->H,a->Y,a->R,AES_BLOCK_SIZE);
+	  printX(a->Y,AES_BLOCK_SIZE);
+	  /* count the number of bits */
+	  a->LenA = AES_BLOCK_SIZE * 8;
+	}		
+      } 
+      if( aadlen ) { 
+	memcpy(a->R + a->Rlen,aad,aadlen);
+	a->Rlen += aadlen;
+      }	    
+    }
+  }
+  if( (1 == rv) && (datalen != 0) && (NULL != data) ) {
+    /* Check to see if we have any partial aad left to process ? */
+    GCM_merge_aad(a); 
+    a->state = 2;
+    if( (datalen + a->Rlen) >= AES_BLOCK_SIZE) { /* Do we have a complete data block ? */
+      for( i = datalen + a->Rlen ; i >= AES_BLOCK_SIZE; i -= AES_BLOCK_SIZE) {
+	/* Top up the retain buffer from incoming */
+	memcpy(a->R + a->Rlen,data,AES_BLOCK_SIZE-a->Rlen);
+	/* we stole this many bytes of input */
+	data += AES_BLOCK_SIZE-a->Rlen;
+	datalen -= ( AES_BLOCK_SIZE-a->Rlen);
+	a->Rlen = AES_BLOCK_SIZE;
+	ED_block(a,&out,outlen,encrypt);
+      }
+    } 
+    if(datalen) { /* Not a complete block yet ... */
+      memcpy(a->R + a->Rlen,data,datalen);
+      a->Rlen += datalen;
+    }
+  } /* NULL != data */
+
+  return rv;
+}
+/** @brief Perform an AES_GCM_CTX "updateEncrypt" operation
+
+@param a the (opaque) AES_GCM_CTX context
+@param aad additional authentication data (hashed, not encrypted)
+@param aadlen the length of the aad 0-2^56 bytes long
+@param data data to encrypt
+@param datalen the length of the encrypted data
+@param out the output buffer, should be at least "data" long
+@param outlen a place to store the length of the output data
+@return 1 if O.K., 0 otherwise
+@note aad may only be specified up to the point where input data is being supplied
+we do support streaming aad up until that point.
+- i.e. we allow multiple chunks of aad to be specified provided data is NULL until
+the last aad chunk
+- multiple chunks of data, but aad must be NULL after the first chunk
+- There's very little difference between encrypt and decrypt in AES_GCM
+so we've rolled the code into one routine with a wrapper to simplify
+maintenance.
+*/
+int AES_GCM_EncryptUpdate(AES_GCM_CTX *a,
+			  unsigned char *aad,unsigned long aadlen,
+			  unsigned char *data,unsigned long datalen,
+			  unsigned char *out, unsigned long *outlen)
+{
+
+  return AES_GCM_Update((AES_GCM_CTX_t *)a,aad,aadlen,data,datalen,out,outlen,1);
+}
+
+/** @brief Perform an AES_GCM_CTX "updateDecrypt" operation
+
+@param a the (opaque) AES_GCM_CTX context
+@param aad additional authentication data (hashed, not encrypted)
+@param aadlen the length of the aad 0-2^56 bytes long
+@param data data to encrypt
+@param datalen the length of the encrypted data
+@param out the output buffer, should be at least "data" long
+@param outlen a place to store the length of the output data
+@return 1 if O.K., 0 otherwise
+@note aad may only be specified up to the point where input data is being supplied
+we do support streaming aad up until that point.
+- i.e. we allow multiple chunks of aad to be specified provided data is NULL until
+the last aad chunk
+- multiple chunks of data, but aad must be NULL after the first chunk
+- There's very little difference between encrypt and decrypt in AES_GCM
+so we've rolled the code into one routine with a wrapper to simplify
+maintenance.
+*/
+int AES_GCM_DecryptUpdate(AES_GCM_CTX *a,
+			  unsigned char *aad,unsigned long aadlen,
+			  unsigned char *data,unsigned long datalen,
+			  unsigned char *out, unsigned long *outlen)
+{
+
+  return AES_GCM_Update((AES_GCM_CTX_t *)a,aad,aadlen,data,datalen,out,outlen,0);
+}
+
+/** @brief
+    The final phase of an AES GCM operation
+
+    @param ain an AES_GCM_CTX pointer
+    @param out the buffer to hold any residual encrypted data 
+    @param outlen a place to hold the length of any residual data
+    @param hash a place to store AES_BLOCK_SIZE bytes of the 
+    authentication tag
+    @param encrypt 1 if encrypting, 0 if decrypting
+    @return 1 if O.K., 0 otherwise
+*/
+static int AES_GCM_Final(AES_GCM_CTX *ain,
+			 unsigned char *out, unsigned long *outlen,
+			 unsigned char *hash,int encrypt)
+{
+  AES_GCM_CTX_t *a = (AES_GCM_CTX_t *)ain;
+  int rv = 1;
+  *outlen = 0;
+  if( a->Rlen ) { /* Do we have residual data ? */
+    if(a->state == 1) {
+      GCM_merge_aad(a); 
+    } else if(a->state >= 2) {
+      ED_block(a,&out,outlen,encrypt);
+    }
+  }
+  ULongToChar(a->LenA,a->S);
+  ULongToChar(a->LenC,a->S+8);
+  printbin("LenALenC",a->S,16);
+  /*
+    xor(a->Y,a->Y,a->S,AES_BLOCK_SIZE);
+
+    printbin("Xor'd",a->Y,16);
+  */
+  GHASH_i(&(a->tab),a->H,a->Y,a->S,AES_BLOCK_SIZE);
+  xor(a->Y,a->eZero,a->Y,AES_BLOCK_SIZE);
+  memcpy(hash,a->Y,AES_BLOCK_SIZE);
+  return rv;
+}
+/** @brief
+    The final phase of an AES GCM operation
+
+    @param ain an AES_GCM_CTX pointer
+    @param out the buffer to hold any residual encrypted data 
+    @param outlen a place to hold the length of any residual data
+    @param hash a place to store AES_BLOCK_SIZE bytes of the 
+    authentication tag
+    @return 1 if O.K., 0 otherwise
+*/
+int AES_GCM_EncryptFinal(AES_GCM_CTX *ain,
+			 unsigned char *out, unsigned long *outlen,
+			 unsigned char *hash)
+{
+  return AES_GCM_Final(ain,out,outlen,hash,1);
+}
+
+/** @brief
+    The final phase of an AES GCM decrypt operation
+
+    @param ain an AES_GCM_CTX pointer
+    @param out the buffer to hold any residual encrypted data 
+    @param outlen a place to hold the length of any residual data
+    @param hash a place to store AES_BLOCK_SIZE bytes of the 
+    authentication tag
+    @return 1 if the operation completed with the correct hash, 0 otherwise
+*/
+int AES_GCM_DecryptFinal(AES_GCM_CTX *ain,
+			 unsigned char *out, unsigned long *outlen,
+			 unsigned char *hash,unsigned int hlen)
+{
+  int rv = 0;
+  unsigned char ihash[AES_BLOCK_SIZE];
+  rv = AES_GCM_Final(ain,out,outlen,ihash,0);
+  if(1 == rv ) {
+    if((hlen == 0) || 
+       (hlen > AES_BLOCK_SIZE) || 
+       (memcmp(ihash,hash,hlen) != 0)) {
+      rv = 0;
+    }
+  }    
+  return rv;
+}
+
+
+
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aes_gcm.h openssl-1.0.0-beta4/crypto/aes/aes_gcm.h
--- openssl-1.0.0-beta4.orig/crypto/aes/aes_gcm.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aes_gcm.h	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,63 @@
+/* crypto/aes/aes_gcm.h */
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+// GCM table driven acceleration: Aaron Cristensen November 2007.
+//---------------------------------------------------------------------------*/
+
+#if !defined(AES_GCM_H)
+#define AES_GCM_H
+
+#define FAILURE 0
+#define OK 1
+
+#define AES_GCM_CTRL_SET_ACCEL 0
+#define AES_GCM_CTRL_GET_ACCEL 1
+
+/*! @enum GCM_ACCEL
+    @brief The level of acceleration to use; a space-time trade-off
+ */
+typedef enum GCM_ACCEL {
+  GCM_ACCEL_noaccel,    /*!< No acceleration and no additional space used */
+  GCM_ACCEL_level1,     /*!< Uses a 256 byte table to speed up GHASH computation */
+  GCM_ACCEL_level2,     /*!< Uses a 4 Kbyte table to speed up GHASH computation */
+  GCM_ACCEL_level3,     /*!< Uses a 8 Kbyte table to speed up GHASH computation */
+  GCM_ACCEL_level4      /*!< Uses a 64 Kbyte table to speed up GHASH computation */
+} GCM_ACCEL;
+
+/*! @brief A table holding lookup tables for accelerating Galois multiply operations */
+typedef struct GCM_TAB {
+  GCM_ACCEL accel;        /*!< Type of acceleration table */
+  void *tabdata; /*!< How long tabdata is depends on the type of table used */
+} GCM_TAB;
+
+/*! @brief The structure of the AES_GCM context */
+typedef struct AES_GCM_struct {
+  GCM_TAB tab;                              /*!< GCM acceleration table */
+  EVP_CIPHER_CTX *ctx;                      /*!< Cipher context used by GCM */
+  unsigned char ecount_buf[AES_BLOCK_SIZE]; /*!< Counter buffer */
+  unsigned char eZero[AES_BLOCK_SIZE];      /*!< Counter buffer '0' encrypted with the key */
+  unsigned char Y[AES_BLOCK_SIZE];          /*!< Retained data buffer (aad and data) */
+  unsigned char H[AES_BLOCK_SIZE];          /*!< "magic" hash key */
+  unsigned char R[AES_BLOCK_SIZE];          /*!< retained data from last partial block */
+  unsigned char S[AES_BLOCK_SIZE];          /*!< Temporary buffer. Useful for debug. This only has "local to one function" scope */
+  unsigned int  state;                      /*!< 0 no data, 1 have aad, 2 processed aad but not mixed in, 3 aad mixed in handling data */
+  unsigned int  Rlen;                       /*!< length of last partial aad or data block */ 
+  unsigned int  n;                          /*!< Block count */
+  unsigned long LenA;                       /*!< Length of the AAD */
+  unsigned long LenC;                       /*!< Length of the ciphertext */
+  EVP_CIPHER_CTX *IVctx;                    /*!< 64 bit encryptor context */
+  unsigned char IVcounter[8];               /*!< IV generator state buffer */
+  unsigned long count;                      /*!< The number of times we've called the IV routine */
+} AES_GCM_CTX_t;
+
+
+
+
+
+                                                                           
+#endif
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aesgcmtest.c openssl-1.0.0-beta4/crypto/aes/aesgcmtest.c
--- openssl-1.0.0-beta4.orig/crypto/aes/aesgcmtest.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aesgcmtest.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,1125 @@
+#include <stdio.h>
+#include <string.h>
+#include "openssl/aes.h"
+#include "openssl/evp.h" /* This is only needed b/c the aes_gcm header pulls in
+                          * the EVP_CIPHER_CTX struct but doesn't pull in evp.h
+                          * So, right now, whenever aes_gcm is used evp.h must
+                          * be included before aes_gcm.h */
+#include "openssl/aes_gcm.h"
+#include "openssl/err.h"
+
+static unsigned int success = 0;
+static unsigned int fail = 0;
+
+typedef struct GCM_TEST_CASE_t {
+  const char *name;
+
+  /* Inputs to the test case */
+  unsigned int keylen;
+  const unsigned char *key;
+  unsigned int ivlen;
+  const unsigned char *iv;
+  unsigned int ptlen;
+  const unsigned char *pt;
+  unsigned int adlen;
+  const unsigned char *ad;
+
+  /* Output from the test case */
+  unsigned int ctlen;
+  const unsigned char *ct;
+  unsigned int taglen;
+  const unsigned char *tag;
+} GCM_TEST_CASE;
+
+/* These are the test cases from the original paper from McGrew & Viega */
+/***** Test Case 1 *****/
+static const unsigned char test_case_1_key[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+static const unsigned char test_case_1_iv[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+static const unsigned char test_case_1_tag[] = {
+  0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61,
+  0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a
+};
+static const GCM_TEST_CASE test_case_1 = {
+  "Spec Test Case 1",
+  sizeof (test_case_1_key),
+  test_case_1_key,
+  sizeof (test_case_1_iv),
+  test_case_1_iv,
+  0,
+  NULL,
+  0,
+  NULL,
+  0,
+  NULL,
+  sizeof (test_case_1_tag),
+  test_case_1_tag
+};
+
+/***** Test Case 2 *****/
+static const unsigned char test_case_2_key[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+static const unsigned char test_case_2_iv[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+static const unsigned char test_case_2_pt[] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+static const unsigned char test_case_2_ct[] = {
+  0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92,
+  0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78
+};
+static const unsigned char test_case_2_tag[] = {
+  0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd,
+  0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf
+};
+static const GCM_TEST_CASE test_case_2 = {
+  "Spec Test Case 2",
+  sizeof (test_case_2_key),
+  test_case_2_key,
+  sizeof (test_case_2_iv),
+  test_case_2_iv,
+  sizeof (test_case_2_pt),
+  test_case_2_pt,
+  0,
+  NULL,
+  sizeof (test_case_2_ct),
+  test_case_2_ct,
+  sizeof (test_case_2_tag),
+  test_case_2_tag
+};
+
+/***** Test Case 3 *****/
+static const unsigned char test_case_3_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_3_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_3_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
+  0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55
+};
+static const unsigned char test_case_3_ct[] = {
+  0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
+  0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
+  0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
+  0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
+  0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
+  0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
+  0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
+  0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85
+};
+static const unsigned char test_case_3_tag[] = {
+  0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6,
+  0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4
+};
+static const GCM_TEST_CASE test_case_3 = {
+  "Spec Test Case 3",
+  sizeof (test_case_3_key),
+  test_case_3_key,
+  sizeof (test_case_3_iv),
+  test_case_3_iv,
+  sizeof (test_case_3_pt),
+  test_case_3_pt,
+  0,
+  NULL,
+  sizeof (test_case_3_ct),
+  test_case_3_ct,
+  sizeof (test_case_3_tag),
+  test_case_3_tag
+};
+
+/***** Test Case 4 *****/
+static const unsigned char test_case_4_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_4_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_4_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_4_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_4_ct[] = {
+  0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
+  0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
+  0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
+  0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
+  0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
+  0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
+  0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
+  0x3d, 0x58, 0xe0, 0x91
+};
+static const unsigned char test_case_4_tag[] = {
+  0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,
+  0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47
+};
+static const GCM_TEST_CASE test_case_4 = {
+  "Spec Test Case 4",
+  sizeof (test_case_4_key),
+  test_case_4_key,
+  sizeof (test_case_4_iv),
+  test_case_4_iv,
+  sizeof (test_case_4_pt),
+  test_case_4_pt,
+  sizeof (test_case_4_ad),
+  test_case_4_ad,
+  sizeof (test_case_4_ct),
+  test_case_4_ct,
+  sizeof (test_case_4_tag),
+  test_case_4_tag
+};
+
+/***** Test Case 5 *****/
+static const unsigned char test_case_5_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_5_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad
+};
+static const unsigned char test_case_5_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_5_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_5_ct[] = {
+  0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a, 
+  0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55, 
+  0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8, 
+  0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23, 
+  0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2, 
+  0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42, 
+  0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07, 
+  0xc2, 0x3f, 0x45, 0x98
+};
+static const unsigned char test_case_5_tag[] = {
+  0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85, 
+  0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb
+};
+static const GCM_TEST_CASE test_case_5 = {
+  "Spec Test Case 5",
+  sizeof (test_case_5_key),
+  test_case_5_key,
+  sizeof (test_case_5_iv),
+  test_case_5_iv,
+  sizeof (test_case_5_pt),
+  test_case_5_pt,
+  sizeof (test_case_5_ad),
+  test_case_5_ad,
+  sizeof (test_case_5_ct),
+  test_case_5_ct,
+  sizeof (test_case_5_tag),
+  test_case_5_tag
+};
+
+/***** Test Case 6 *****/
+static const unsigned char test_case_6_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_6_iv[] = {
+  0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 
+  0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa, 
+  0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 
+  0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28, 
+  0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 
+  0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54, 
+  0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 
+  0xa6, 0x37, 0xb3, 0x9b
+};
+static const unsigned char test_case_6_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_6_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_6_ct[] = {
+  0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6, 
+  0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94, 
+  0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8, 
+  0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7, 
+  0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90, 
+  0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f, 
+  0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03, 
+  0x4c, 0x34, 0xae, 0xe5
+};
+static const unsigned char test_case_6_tag[] = {
+  0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa, 
+  0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50
+};
+static const GCM_TEST_CASE test_case_6 = {
+  "Spec Test Case 6",
+  sizeof (test_case_6_key),
+  test_case_6_key,
+  sizeof (test_case_6_iv),
+  test_case_6_iv,
+  sizeof (test_case_6_pt),
+  test_case_6_pt,
+  sizeof (test_case_6_ad),
+  test_case_6_ad,
+  sizeof (test_case_6_ct),
+  test_case_6_ct,
+  sizeof (test_case_6_tag),
+  test_case_6_tag
+};
+
+/***** Test Case 7 *****/
+static const unsigned char test_case_7_key[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_7_iv[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_7_tag[] = {
+  0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b, 
+  0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35
+};
+static const GCM_TEST_CASE test_case_7 = {
+  "Spec Test Case 7",
+  sizeof (test_case_7_key),
+  test_case_7_key,
+  sizeof (test_case_7_iv),
+  test_case_7_iv,
+  0,
+  NULL,
+  0,
+  NULL,
+  0,
+  NULL,
+  sizeof (test_case_7_tag),
+  test_case_7_tag
+};
+
+/***** Test Case 8 *****/
+static const unsigned char test_case_8_key[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_8_iv[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_8_pt[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_8_ct[] = {
+  0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41, 
+  0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00
+};
+static const unsigned char test_case_8_tag[] = {
+  0x2f, 0xf5, 0x8d, 0x80, 0x03, 0x39, 0x27, 0xab, 
+  0x8e, 0xf4, 0xd4, 0x58, 0x75, 0x14, 0xf0, 0xfb
+};
+static const GCM_TEST_CASE test_case_8 = {
+  "Spec Test Case 8",
+  sizeof (test_case_8_key),
+  test_case_8_key,
+  sizeof (test_case_8_iv),
+  test_case_8_iv,
+  sizeof (test_case_8_pt),
+  test_case_8_pt,
+  0,
+  NULL,
+  sizeof (test_case_8_ct),
+  test_case_8_ct,
+  sizeof (test_case_8_tag),
+  test_case_8_tag
+};
+
+/***** Test Case 9 *****/
+static const unsigned char test_case_9_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c
+};
+static const unsigned char test_case_9_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_9_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55
+};
+static const unsigned char test_case_9_ct[] = {
+  0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 
+  0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57, 
+  0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 
+  0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 
+  0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25, 
+  0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 
+  0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9, 
+  0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56
+};
+static const unsigned char test_case_9_tag[] = {
+  0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf, 
+  0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14
+};
+static const GCM_TEST_CASE test_case_9 = {
+  "Spec Test Case 9",
+  sizeof (test_case_9_key),
+  test_case_9_key,
+  sizeof (test_case_9_iv),
+  test_case_9_iv,
+  sizeof (test_case_9_pt),
+  test_case_9_pt,
+  0,
+  NULL,
+  sizeof (test_case_9_ct),
+  test_case_9_ct,
+  sizeof (test_case_9_tag),
+  test_case_9_tag
+};
+
+/***** Test Case 10 *****/
+static const unsigned char test_case_10_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c
+};
+static const unsigned char test_case_10_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_10_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_10_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_10_ct[] = {
+  0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41, 
+  0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57, 
+  0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84, 
+  0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c, 
+  0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25, 
+  0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47, 
+  0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9, 
+  0xcc, 0xda, 0x27, 0x10
+};
+static const unsigned char test_case_10_tag[] = {
+  0x25, 0x19, 0x49, 0x8e, 0x80, 0xf1, 0x47, 0x8f, 
+  0x37, 0xba, 0x55, 0xbd, 0x6d, 0x27, 0x61, 0x8c
+};
+static const GCM_TEST_CASE test_case_10 = {
+  "Spec Test Case 10",
+  sizeof (test_case_10_key),
+  test_case_10_key,
+  sizeof (test_case_10_iv),
+  test_case_10_iv,
+  sizeof (test_case_10_pt),
+  test_case_10_pt,
+  sizeof (test_case_10_ad),
+  test_case_10_ad,
+  sizeof (test_case_10_ct),
+  test_case_10_ct,
+  sizeof (test_case_10_tag),
+  test_case_10_tag
+};
+
+/***** Test Case 11 *****/
+static const unsigned char test_case_11_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c
+};
+static const unsigned char test_case_11_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad
+};
+static const unsigned char test_case_11_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_11_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_11_ct[] = {
+  0x0f, 0x10, 0xf5, 0x99, 0xae, 0x14, 0xa1, 0x54, 
+  0xed, 0x24, 0xb3, 0x6e, 0x25, 0x32, 0x4d, 0xb8, 
+  0xc5, 0x66, 0x63, 0x2e, 0xf2, 0xbb, 0xb3, 0x4f, 
+  0x83, 0x47, 0x28, 0x0f, 0xc4, 0x50, 0x70, 0x57, 
+  0xfd, 0xdc, 0x29, 0xdf, 0x9a, 0x47, 0x1f, 0x75, 
+  0xc6, 0x65, 0x41, 0xd4, 0xd4, 0xda, 0xd1, 0xc9, 
+  0xe9, 0x3a, 0x19, 0xa5, 0x8e, 0x8b, 0x47, 0x3f, 
+  0xa0, 0xf0, 0x62, 0xf7
+};
+static const unsigned char test_case_11_tag[] = {
+  0x65, 0xdc, 0xc5, 0x7f, 0xcf, 0x62, 0x3a, 0x24, 
+  0x09, 0x4f, 0xcc, 0xa4, 0x0d, 0x35, 0x33, 0xf8
+};
+static const GCM_TEST_CASE test_case_11 = {
+  "Spec Test Case 11",
+  sizeof (test_case_11_key),
+  test_case_11_key,
+  sizeof (test_case_11_iv),
+  test_case_11_iv,
+  sizeof (test_case_11_pt),
+  test_case_11_pt,
+  sizeof (test_case_11_ad),
+  test_case_11_ad,
+  sizeof (test_case_11_ct),
+  test_case_11_ct,
+  sizeof (test_case_11_tag),
+  test_case_11_tag
+};
+
+/***** Test Case 12 *****/
+static const unsigned char test_case_12_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c
+};
+static const unsigned char test_case_12_iv[] = {
+  0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 
+  0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa, 
+  0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 
+  0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28, 
+  0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 
+  0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54, 
+  0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 
+  0xa6, 0x37, 0xb3, 0x9b
+};
+static const unsigned char test_case_12_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_12_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_12_ct[] = {
+  0xd2, 0x7e, 0x88, 0x68, 0x1c, 0xe3, 0x24, 0x3c, 
+  0x48, 0x30, 0x16, 0x5a, 0x8f, 0xdc, 0xf9, 0xff, 
+  0x1d, 0xe9, 0xa1, 0xd8, 0xe6, 0xb4, 0x47, 0xef, 
+  0x6e, 0xf7, 0xb7, 0x98, 0x28, 0x66, 0x6e, 0x45, 
+  0x81, 0xe7, 0x90, 0x12, 0xaf, 0x34, 0xdd, 0xd9, 
+  0xe2, 0xf0, 0x37, 0x58, 0x9b, 0x29, 0x2d, 0xb3, 
+  0xe6, 0x7c, 0x03, 0x67, 0x45, 0xfa, 0x22, 0xe7, 
+  0xe9, 0xb7, 0x37, 0x3b
+};
+static const unsigned char test_case_12_tag[] = {
+  0xdc, 0xf5, 0x66, 0xff, 0x29, 0x1c, 0x25, 0xbb, 
+  0xb8, 0x56, 0x8f, 0xc3, 0xd3, 0x76, 0xa6, 0xd9
+};
+static const GCM_TEST_CASE test_case_12 = {
+  "Spec Test Case 12",
+  sizeof (test_case_12_key),
+  test_case_12_key,
+  sizeof (test_case_12_iv),
+  test_case_12_iv,
+  sizeof (test_case_12_pt),
+  test_case_12_pt,
+  sizeof (test_case_12_ad),
+  test_case_12_ad,
+  sizeof (test_case_12_ct),
+  test_case_12_ct,
+  sizeof (test_case_12_tag),
+  test_case_12_tag
+};
+
+/***** Test Case 13 *****/
+static const unsigned char test_case_13_key[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_13_iv[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_13_tag[] = {
+  0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9, 
+  0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b
+};
+static const GCM_TEST_CASE test_case_13 = {
+  "Spec Test Case 13",
+  sizeof (test_case_13_key),
+  test_case_13_key,
+  sizeof (test_case_13_iv),
+  test_case_13_iv,
+  0,
+  NULL,
+  0,
+  NULL,
+  0,
+  NULL,
+  sizeof (test_case_13_tag),
+  test_case_13_tag
+};
+
+/***** Test Case 14 *****/
+static const unsigned char test_case_14_key[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_14_iv[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_14_pt[] = {
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static const unsigned char test_case_14_ct[] = {
+  0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e, 
+  0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18
+};
+static const unsigned char test_case_14_tag[] = {
+  0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0, 
+  0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19
+};
+static const GCM_TEST_CASE test_case_14 = {
+  "Spec Test Case 14",
+  sizeof (test_case_14_key),
+  test_case_14_key,
+  sizeof (test_case_14_iv),
+  test_case_14_iv,
+  sizeof (test_case_14_pt),
+  test_case_14_pt,
+  0,
+  NULL,
+  sizeof (test_case_14_ct),
+  test_case_14_ct,
+  sizeof (test_case_14_tag),
+  test_case_14_tag
+};
+
+/***** Test Case 15 ******/
+static const unsigned char test_case_15_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_15_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_15_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55
+};
+static const unsigned char test_case_15_ct[] = {
+  0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 
+  0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 
+  0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 
+  0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 
+  0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 
+  0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 
+  0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 
+  0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad
+};
+static const unsigned char test_case_15_tag[] = {
+  0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd, 
+  0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c
+};
+static const GCM_TEST_CASE test_case_15 = {
+  "Spec Test Case 15",
+  sizeof (test_case_15_key),
+  test_case_15_key,
+  sizeof (test_case_15_iv),
+  test_case_15_iv,
+  sizeof (test_case_15_pt),
+  test_case_15_pt,
+  0,
+  NULL,
+  sizeof (test_case_15_ct),
+  test_case_15_ct,
+  sizeof (test_case_15_tag),
+  test_case_15_tag
+};
+
+/***** Test Case 16 *****/
+static const unsigned char test_case_16_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_16_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 
+  0xde, 0xca, 0xf8, 0x88
+};
+static const unsigned char test_case_16_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_16_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_16_ct[] = {
+  0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 
+  0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 
+  0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9, 
+  0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 
+  0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 
+  0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 
+  0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 
+  0xbc, 0xc9, 0xf6, 0x62
+};
+static const unsigned char test_case_16_tag[] = {
+  0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68, 
+  0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b
+};
+static const GCM_TEST_CASE test_case_16 = {
+  "Spec Test Case 16",
+  sizeof (test_case_16_key),
+  test_case_16_key,
+  sizeof (test_case_16_iv),
+  test_case_16_iv,
+  sizeof (test_case_16_pt),
+  test_case_16_pt,
+  sizeof (test_case_16_ad),
+  test_case_16_ad,
+  sizeof (test_case_16_ct),
+  test_case_16_ct,
+  sizeof (test_case_16_tag),
+  test_case_16_tag
+};
+
+/***** Test Case 17 *****/
+static const unsigned char test_case_17_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_17_iv[] = {
+  0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad
+};
+static const unsigned char test_case_17_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_17_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_17_ct[] = {
+  0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32, 
+  0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb, 
+  0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa, 
+  0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0, 
+  0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0, 
+  0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78, 
+  0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99, 
+  0xf4, 0x7c, 0x9b, 0x1f
+};
+static const unsigned char test_case_17_tag[] = {
+  0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4, 
+  0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2
+};
+static const GCM_TEST_CASE test_case_17 = {
+  "Spec Test Case 17",
+  sizeof (test_case_17_key),
+  test_case_17_key,
+  sizeof (test_case_17_iv),
+  test_case_17_iv,
+  sizeof (test_case_17_pt),
+  test_case_17_pt,
+  sizeof (test_case_17_ad),
+  test_case_17_ad,
+  sizeof (test_case_17_ct),
+  test_case_17_ct,
+  sizeof (test_case_17_tag),
+  test_case_17_tag
+};
+
+/***** Test Case 18 *****/
+static const unsigned char test_case_18_key[] = {
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08, 
+  0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
+  0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
+};
+static const unsigned char test_case_18_iv[] = {
+  0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5, 
+  0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa, 
+  0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1, 
+  0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28, 
+  0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39, 
+  0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54, 
+  0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57, 
+  0xa6, 0x37, 0xb3, 0x9b
+};
+static const unsigned char test_case_18_pt[] = {
+  0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
+  0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 
+  0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
+  0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 
+  0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
+  0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 
+  0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
+  0xba, 0x63, 0x7b, 0x39
+};
+static const unsigned char test_case_18_ad[] = {
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 
+  0xab, 0xad, 0xda, 0xd2
+};
+static const unsigned char test_case_18_ct[] = {
+  0x5a, 0x8d, 0xef, 0x2f, 0x0c, 0x9e, 0x53, 0xf1, 
+  0xf7, 0x5d, 0x78, 0x53, 0x65, 0x9e, 0x2a, 0x20, 
+  0xee, 0xb2, 0xb2, 0x2a, 0xaf, 0xde, 0x64, 0x19, 
+  0xa0, 0x58, 0xab, 0x4f, 0x6f, 0x74, 0x6b, 0xf4, 
+  0x0f, 0xc0, 0xc3, 0xb7, 0x80, 0xf2, 0x44, 0x45, 
+  0x2d, 0xa3, 0xeb, 0xf1, 0xc5, 0xd8, 0x2c, 0xde, 
+  0xa2, 0x41, 0x89, 0x97, 0x20, 0x0e, 0xf8, 0x2e, 
+  0x44, 0xae, 0x7e, 0x3f
+};
+static const unsigned char test_case_18_tag[] = {
+  0xa4, 0x4a, 0x82, 0x66, 0xee, 0x1c, 0x8e, 0xb0, 
+  0xc8, 0xb5, 0xd4, 0xcf, 0x5a, 0xe9, 0xf1, 0x9a
+};
+static const GCM_TEST_CASE test_case_18 = {
+  "Spec Test Case 18",
+  sizeof (test_case_18_key),
+  test_case_18_key,
+  sizeof (test_case_18_iv),
+  test_case_18_iv,
+  sizeof (test_case_18_pt),
+  test_case_18_pt,
+  sizeof (test_case_18_ad),
+  test_case_18_ad,
+  sizeof (test_case_18_ct),
+  test_case_18_ct,
+  sizeof (test_case_18_tag),
+  test_case_18_tag
+};
+
+/* Set of test cases from the GCM specification */
+static const GCM_TEST_CASE *spec_test_cases[] = {
+  &test_case_1,
+  &test_case_2,
+  &test_case_3,
+  &test_case_4,
+  &test_case_5,
+  &test_case_6,
+  &test_case_7,
+  &test_case_8,
+  &test_case_9,
+  &test_case_10,
+  &test_case_11,
+  &test_case_12,
+  &test_case_13,
+  &test_case_14,
+  &test_case_15,
+  &test_case_16,
+  &test_case_17,
+  &test_case_18
+};
+
+    
+static void run_test_case_mode(const GCM_TEST_CASE *tc, GCM_ACCEL accel) {
+  AES_GCM_CTX *ctx = NULL;
+  unsigned char *out = NULL;
+  unsigned long outlen = 0;
+  unsigned long total_out = 0;
+  unsigned char tag[AES_BLOCK_SIZE];
+
+  fail++;
+
+  if (tc->ctlen != 0) {
+    out = (unsigned char *) OPENSSL_malloc(tc->ctlen + tc->ptlen + 16);
+    if (out == NULL) {
+      fprintf(stdout, "    malloc failed\n");
+      goto exit;
+    }
+  }
+  memset(out, 0x00, tc->ctlen);
+
+  ctx = AES_GCM_CTX_new();
+  if (ctx == NULL) {
+    fprintf(stdout, "    malloc of AES_GCM_CTX failed\n");
+    goto exit;
+  }
+
+  /* 1. Init aes gcm with the key and iv.  Set the acceleration level */
+  if (!AES_GCM_Init(ctx,(unsigned char *)tc->iv, tc->ivlen,
+		    (unsigned char *)tc->key, tc->keylen)) {
+    fprintf(stdout, "    AES_GCM_Init failed, keylen %d\n",tc->keylen);
+    goto exit;
+  }
+  AES_GCM_CTX_ctrl(ctx, AES_GCM_CTRL_SET_ACCEL, accel, NULL);
+
+  /* 2. Update with any associated data */
+  if (tc->adlen != 0) {
+    if (!AES_GCM_EncryptUpdate(ctx, (unsigned char *)tc->ad, tc->adlen, NULL, 0, NULL, NULL)) {
+      fprintf(stdout, "    AES_GCM_EncryptUpdate failed for associated data\n");
+      goto exit;
+    }
+  }
+
+  /* 3. Update with any plain text */
+  if (tc->ptlen != 0) {
+    if (!AES_GCM_EncryptUpdate(
+          ctx,
+          NULL,
+          0,
+          (unsigned char *)tc->pt,
+          tc->ptlen,
+          out,
+          &outlen)) {
+
+      if (tc->ctlen != 0) {
+        fprintf(stdout, "    AES_GCM_EncryptUpdate failed for plain text\n");
+        goto exit;
+      }
+    }
+    total_out += outlen;
+  }
+
+  /* 4. Finalize and get the tag */
+  if (!AES_GCM_EncryptFinal(ctx, out + total_out, &outlen, tag)) {
+    fprintf(stdout, "    AES_GCM_EncryptFinal failed\n");
+    goto exit;
+  }
+  total_out += outlen;
+
+  /* 5. Compare the ciphertext if any */
+  if (tc->ctlen != 0) {
+    if (tc->ctlen != total_out) {
+      fprintf(stdout, "    AES_GCM failed.  Cipher text length incorrect: "
+                      "%ld (expected: %d)\n", outlen, tc->ctlen);
+      goto exit;
+    }
+    if (memcmp(tc->ct, out, tc->ctlen)) {
+      fprintf(stdout, "    AES_GCM failed.  Unexpected cipher text\n");
+      goto exit;
+    }
+  }
+
+  /* 6. Compare the tag */
+  if (memcmp(tc->tag, tag, tc->taglen)) {
+    fprintf(stdout, "    AES_GCM failed.  Unexpected tag output\n");
+    goto exit;
+  }
+
+  /* 7. Init the decrypt and set the key, iv.  set the acceleration */
+  AES_GCM_CTX_free(ctx);
+  ctx = (AES_GCM_CTX *) AES_GCM_CTX_new();
+  memset(out, 0x00, tc->ptlen);
+  total_out = 0;
+  if (ctx == NULL) {
+    fprintf (stdout, "    malloc of AES_GCM_CTX for decrypt failed\n");
+  }
+  if (!AES_GCM_Init(ctx, (unsigned char *)tc->iv, tc->ivlen, 
+		    (unsigned char *)tc->key, tc->keylen)) {
+    fprintf(stdout, "    AES_GCM_Init for decrypt failed\n");
+    goto exit;
+  }
+  AES_GCM_CTX_ctrl(ctx, AES_GCM_CTRL_SET_ACCEL, accel, NULL);
+
+  /* 8. Update with any associated data */
+  if (tc->adlen != 0) {
+    if (!AES_GCM_DecryptUpdate(ctx, (unsigned char *)tc->ad, tc->adlen, 
+			       NULL, 0, NULL, NULL)) {
+      fprintf(stdout, "    AES_GCM_DecryptUpdate failed for associated data\n");
+      goto exit;
+    }
+  }
+
+  /* 9. Update with any cipher text */
+  if (tc->ctlen != 0) {
+    if (!AES_GCM_DecryptUpdate(
+          ctx,
+          NULL,
+          0,
+          (unsigned char *)tc->ct,
+          tc->ctlen,
+          out,
+          &outlen)) {
+
+      if (tc->ptlen != 0) {
+        fprintf(stdout, "    AES_GCM_DecryptUpdate failed for cipher text\n");
+        goto exit;
+      }
+    }
+    total_out += outlen;
+  }
+
+  /* 10. Finalize and pass the tag */
+  if (!AES_GCM_DecryptFinal(ctx, out + total_out, &outlen,
+			    (unsigned char *) tc->tag,16)) {
+    fprintf(stdout, "    AES_GCM_DecryptFinal failed\n");
+    goto exit;
+  }
+  total_out += outlen;
+
+  /* 11. Compare the plain text, if any */
+  if (tc->ptlen != 0) {
+    if (tc->ptlen != total_out) {
+      fprintf(stdout, "    AES_GCM failed.  Cipher text length incorrect: "
+                      "%ld (expected: %d)\n", outlen, tc->ptlen);
+      goto exit;
+    }
+    if (memcmp(tc->pt, out, tc->ptlen)) {
+      fprintf(stdout, "    AES_GCM failed.  Unexpected plain text\n");
+      goto exit;
+    }
+  }
+
+  /* 12. Print the result and clean up */
+  fprintf(stdout, "    AES_GCM succeeded\n");
+  
+exit:
+  if(NULL != out) {
+    OPENSSL_free(out);
+    out = NULL;
+  }
+  if(NULL != ctx) {
+    AES_GCM_CTX_free(ctx);
+    ctx = NULL;
+  }  
+  success++;
+  fail--;
+}
+
+static void run_test_case(const GCM_TEST_CASE *tc) {
+  fprintf(stdout, "Executing Test: %s\n", tc->name);
+  
+  fprintf(stdout, "    No acceleration\n");
+  run_test_case_mode(tc, GCM_ACCEL_noaccel);
+  fprintf(stdout, "\n");
+
+  fprintf(stdout, "    Level 1 acceleration\n");
+  run_test_case_mode(tc, GCM_ACCEL_level1);
+  fprintf(stdout, "\n");
+
+  fprintf(stdout, "    Level 2 accelertion\n");
+  run_test_case_mode(tc, GCM_ACCEL_level2);
+  fprintf(stdout, "\n");
+
+  fprintf(stdout, "    Level 3 acceleration\n");
+  run_test_case_mode(tc, GCM_ACCEL_level3);
+  fprintf(stdout, "\n");
+
+  fprintf(stdout, "    Level 4 acceleration\n");
+  run_test_case_mode(tc, GCM_ACCEL_level4);
+  fprintf(stdout, "\n");
+}
+
+int main(int argc, char **argv) {
+  int i = 0;
+  int test_case_len = (sizeof(spec_test_cases)) / (sizeof(GCM_TEST_CASE *));
+
+  OPENSSL_add_all_algorithms_noconf();
+  fprintf(stdout, "Beginning AES GCM test cases\n\n");
+
+  for (i = 0; i < test_case_len; i++) {
+    run_test_case(spec_test_cases[i]);
+  }
+
+  fprintf(stdout, "Tests run: %d, Successes: %d, Failures: %d\n", success + fail, success, fail);
+  EVP_cleanup();
+  CRYPTO_cleanup_all_ex_data();
+  ERR_remove_state(0);
+  ERR_free_strings();
+  CRYPTO_mem_leaks_fp(stderr);
+  return 0;
+}
+
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/aes.h openssl-1.0.0-beta4/crypto/aes/aes.h
--- openssl-1.0.0-beta4.orig/crypto/aes/aes.h	2008-12-23 16:15:43.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/aes.h	2009-12-05 15:15:23.877754212 +0100
@@ -135,6 +135,51 @@
 		const unsigned char *in, unsigned int inlen);
 
 
+typedef struct AES_GCM_CTX_t AES_GCM_CTX;
+
+int AES_GCM_GenerateIV(AES_GCM_CTX *gcm_ctx,unsigned char out[8]);
+
+AES_GCM_CTX * AES_GCM_CTX_new(void);
+void AES_GCM_CTX_free(AES_GCM_CTX *ain);
+int GCM128(AES_GCM_CTX *gcm_ctx,unsigned char *Z, unsigned char *X, unsigned char *Y);
+int AES_GCM_CTX_ctrl(AES_GCM_CTX *a,int mode,int accel,void *ptr);
+
+void GHASH(AES_GCM_CTX *gcm_ctx,unsigned char *H, unsigned char *Hash, unsigned char *X,unsigned long Xlen);
+int AES_GCM_Init(AES_GCM_CTX *ain,
+                 unsigned char *iv,unsigned long ivlen,
+                 unsigned char *key, unsigned int klen
+                 );
+int AES_GCM_EncryptUpdate(AES_GCM_CTX *a,
+                          unsigned char *aad,unsigned long aadlen,
+                          unsigned char *data,unsigned long datalen,
+                          unsigned char *out, unsigned long *outlen);
+int AES_GCM_DecryptUpdate(AES_GCM_CTX *a,
+                          unsigned char *aad,unsigned long aadlen,
+                          unsigned char *data,unsigned long datalen,
+                          unsigned char *out, unsigned long *outlen);
+int AES_GCM_EncryptFinal(AES_GCM_CTX *ain,
+                         unsigned char *out, unsigned long *outlen,
+                         unsigned char *hash);
+int AES_GCM_DecryptFinal(AES_GCM_CTX *ain,
+                         unsigned char *out, unsigned long *outlen,
+                         unsigned char *hash,unsigned int hlen);
+
+
+int AES_CCM_Encrypt(unsigned char *iv,unsigned int ivlen,
+		    unsigned char *key,unsigned int keylen,
+		    unsigned char *aad, unsigned long aadlen,
+		    unsigned char *data,unsigned long datalen,
+		    unsigned char *out, unsigned long *outlen,
+		    unsigned int taglen
+		    );
+int AES_CCM_Decrypt(unsigned char *iv,unsigned int ivlen,
+		    unsigned char *key,unsigned int keylen,
+		    unsigned char *aad, unsigned long aadlen,
+		    unsigned char *data,unsigned long datalen,
+		    unsigned char *out, unsigned long *outlen,
+		    unsigned int taglen
+		    );
+
 #ifdef  __cplusplus
 }
 #endif
diff -urN openssl-1.0.0-beta4.orig/crypto/aes/Makefile openssl-1.0.0-beta4/crypto/aes/Makefile
--- openssl-1.0.0-beta4.orig/crypto/aes/Makefile	2008-12-23 12:33:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/aes/Makefile	2009-12-05 15:15:23.877754212 +0100
@@ -19,18 +19,19 @@
 
 GENERAL=Makefile
 #TEST=aestest.c
-TEST=
+TEST= aesgcmtest.c
 APPS=
 
 LIB=$(TOP)/libcrypto.a
 LIBSRC=aes_core.c aes_misc.c aes_ecb.c aes_cbc.c aes_cfb.c aes_ofb.c \
-       aes_ctr.c aes_ige.c aes_wrap.c
-LIBOBJ=aes_misc.o aes_ecb.o aes_cfb.o aes_ofb.o aes_ctr.o aes_ige.o aes_wrap.o \
+       aes_ctr.c aes_ige.c aes_ccm.c aes_gcm.c aes_wrap.c 
+LIBOBJ=aes_misc.o aes_ecb.o aes_cfb.o aes_ofb.o aes_ctr.o aes_ige.o \
+        aes_ccm.o aes_gcm.o aes_wrap.o \
        $(AES_ENC)
 
 SRC= $(LIBSRC)
 
-EXHEADER= aes.h
+EXHEADER= aes.h aes_gcm.h
 HEADER= aes_locl.h $(EXHEADER)
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
diff -urN openssl-1.0.0-beta4.orig/crypto/cmac/cmac.c openssl-1.0.0-beta4/crypto/cmac/cmac.c
--- openssl-1.0.0-beta4.orig/crypto/cmac/cmac.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/cmac/cmac.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,528 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007,2009
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+// 
+-----------------------------------------------------------------------------*/
+
+#include <string.h>
+#include "openssl/evp.h"
+#include "cmac.h"
+
+/* 
+\debug Define: Uncomment this to debug the CMAC code
+#define DEBUG_CMAC 
+*/
+
+
+/* 
+   We reuse one buffer, which gets set to zero on the first
+   CMAC_Update() operation. This is used as a flag to say the next
+   update will be the first. It's possible to perform a CMAC
+   with no data passed in.
+*/
+#define STUPID_VALUE 0xdeadbeef
+/*
+  These are what the constants should be, but we always XOR them, so just
+  xoring the final value is enough.
+static const unsigned char R128[16] = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0x87};
+static const unsigned char R64[8] =   {0,0,0,0, 0,0,0,0x1b};
+*/
+#define R128 0x87
+#define R64 0x1b
+
+static const char iv[16]; /*!< zero filled buffer NIST CMAC always uses a 0 IV and it's reused for the 0 data block input to generate subkeys */
+
+/* DES odd parity */
+static const unsigned char parity[256]={
+    1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
+   16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
+   32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
+   49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
+   64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
+   81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
+   97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
+  112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
+  128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
+  145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
+  161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
+  176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
+  193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
+  208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
+  224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
+  241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254
+};
+
+/*!
+  #brief fix up the key parity.
+  This does duplicate function inside the DES code
+  the DES_CBLOCK data structure is really ugly - this
+  is simpler
+  @param key a des/3des key
+  @param leylen the length in bytes of the key
+*/
+static void fix_des(unsigned char *key, int keylen)
+{
+  int i;
+  for(i = 0; i < keylen; i++) {
+    key[i] = parity[key[i]];
+  }
+}
+
+
+
+
+#if defined(DEBUG_CMAC)
+/*! @brief print a binary buffer
+    @param s the buffer to print
+    @param l the length of the buffer
+    \debug Code printbin: controlled by DEBUG_CMAC
+*/
+static void printbin( char *s,int l)
+{
+  int i;
+  printf("len = %d :",l);
+  for(i = 0; i < l ; i++) {
+	printf("%02x",((unsigned)s[i] & 0xff));
+  }
+  printf("\n");
+}
+#endif
+
+
+/** @brief xor two buffers into a destination. 
+    (Which may be one of the source buffers )
+    @param dest the destination buffer
+    @param s1 first source buffer
+    @param s2 second source buffer
+    @param blen buffer length
+*/
+
+static void xor(unsigned char *dest, unsigned char *s1, unsigned char *s2, unsigned blen)
+{
+  unsigned int i;
+  for(i = 0; i < blen; i++) {
+    dest[i] = s1[i] ^ s2[i];
+  }
+}
+
+/** @brief left shift a buffer (assumed to be a big endian byte stream)
+    @param buf  source buffer
+    @param blen buffer length
+*/
+static void shl(unsigned char *buf,unsigned blen)
+{
+  unsigned cry = 0;
+  unsigned crynxt = 0;
+  if(blen != 0) {
+    do {
+      blen --;
+      if(buf[blen] & 0x80) {
+	crynxt = 1;
+      }
+      buf[blen] = (buf[blen] << 1) | cry;
+      cry = crynxt;
+      crynxt = 0;
+    } while(blen != 0);
+  }
+}
+/**
+   @brief Call EVP_EncryptInit() for the CMAC context
+          this is used in more than one place, and the logic is a bit messy
+	  with the need to handle variable length keys	  
+    @param cmac_ctx a pointer to an CMAC_CTX_t
+    @return 1 if O.K. 0 otherwise
+*/
+static int CMAC_EVP_Init(CMAC_CTX_t *cmac_ctx)
+{
+  int rv = 1;
+  unsigned int keybytes = 0;
+  int nid = -1;
+
+  nid =  EVP_CIPHER_type(cmac_ctx->cip);
+  EVP_CIPHER_CTX_cleanup(cmac_ctx->cctx);
+  if(cmac_ctx->keylen == 0) { /* Fixed length keys, AES, DES etc */
+    /* Check for DES keys here as we need to fixup the key parity */
+    switch(nid) {
+    case NID_des_cbc:
+      fix_des(cmac_ctx->key,8);
+      break;
+    case NID_des_ede_cbc:
+    case NID_des_ede3_cbc:
+      fix_des(cmac_ctx->key,24);
+      break;
+    default:
+      break;
+    }    
+    rv = EVP_EncryptInit(cmac_ctx->cctx,cmac_ctx->cip,cmac_ctx->key,(unsigned char *)iv);
+    EVP_CIPHER_CTX_set_padding(cmac_ctx->cctx,0);
+  } else { /* Alg's with variable length keys, RC2, RC4 etc */
+    keybytes = (cmac_ctx->keylen + 7)/8;
+    EVP_EncryptInit_ex(cmac_ctx->cctx,cmac_ctx->cip,NULL,NULL,NULL);
+    EVP_CIPHER_CTX_set_key_length(cmac_ctx->cctx,keybytes);
+    /* RC2 non-byte length keys */
+    if(NID_rc2_cbc == nid ) {
+      EVP_CIPHER_CTX_ctrl(cmac_ctx->cctx,EVP_CTRL_SET_RC2_KEY_BITS,cmac_ctx->keylen,NULL);
+    }
+    EVP_CIPHER_CTX_set_padding(cmac_ctx->cctx,0);
+    rv = EVP_EncryptInit_ex(cmac_ctx->cctx,NULL,NULL,cmac_ctx->key,(unsigned char *)iv);
+  }
+  return rv;
+}
+
+/** @brief generate the CMAC subkeys
+    @param pcb a pointer to an ICC library context
+    @param cmac_ctx a pointer to an CMAC_CTX_t 
+    @return 1 if O.K., 0 on failure (unsupported cipher block size etc).    
+*/
+    
+static int SubKeys(CMAC_CTX_t *cmac_ctx)
+{
+  int rv = 1;
+  int olen = 0;
+  unsigned char R;
+  switch(cmac_ctx->bs) {
+  case 8:
+    R = R64;
+    break;
+  case 16:
+    R = R128;
+    break;
+  default:
+    rv = 0;
+    break;
+  }
+  if(1 == rv) {
+    rv = CMAC_EVP_Init(cmac_ctx);
+    if( 1 == rv) {
+      /* We need to encrypt with a block of 0's here */
+      EVP_EncryptUpdate(cmac_ctx->cctx,
+			     cmac_ctx->k1,&olen,(unsigned char *)iv, cmac_ctx->bs);
+      
+      /* k1 now contains one block of 0 encrypted with our key */
+      
+      /* We only need this for testing, save a copy of the encrypted key 
+	 so we can verify it against NIST known answers.
+	 This buffer is reused as a scratch area during CMAC_Update
+      */
+      memcpy(cmac_ctx->cip_k,cmac_ctx->k1, cmac_ctx->bs);
+      
+      if(0 == (cmac_ctx->k1[0] & 0x80)) { /* MSBit of K1 is zero */
+	shl(cmac_ctx->k1, cmac_ctx->bs);
+      } else {
+	shl(cmac_ctx->k1, cmac_ctx->bs);
+	cmac_ctx->k1[cmac_ctx->bs-1] ^= R;
+	/* xor(cmac_ctx->k1,cmac_ctx->k1,R,cmac_ctx->bs); */
+      }
+      memcpy(cmac_ctx->k2,cmac_ctx->k1, cmac_ctx->bs);
+      if(0 == (cmac_ctx->k2[0] & 0x80)) { /* MSBit of K2 is zero */
+	shl(cmac_ctx->k2, cmac_ctx->bs);
+      } else {
+	shl(cmac_ctx->k2, cmac_ctx->bs);      
+	cmac_ctx->k2[cmac_ctx->bs-1] ^= R;
+	/* xor(cmac_ctx->k2,cmac_ctx->k2,R,cmac_ctx->bs);*/
+      }
+    }
+  }
+  if(rv != 1) printf("CMAC_EVP_Init() fails %d\n",rv);
+  return rv;
+}
+/** @brief Allocate a new CMAC_CTX (CMAC context)
+    @param pcb a pointer to an ICC library context
+    @return NULL on failure, or a pointer to an uninitialized CMAC_CTX
+*/
+CMAC_CTX * CMAC_CTX_new()
+{
+  CMAC_CTX *ctx;
+  ctx = (CMAC_CTX *)CRYPTO_malloc(sizeof(CMAC_CTX),__FILE__,__LINE__);
+  if(NULL != ctx) memset(ctx,0,sizeof(CMAC_CTX));
+  return (ctx);
+}
+/** @brief Clean up an CMAC_CTX_t (erase sensitive data)
+    @param pcb a pointer to an ICC library context
+    @param cmac_ctx a pointer to a CMAC_CTX_t
+*/
+static void CMAC_CTX_cleanup(CMAC_CTX_t *cmac_ctx)
+{
+  int clen = 0;
+  memset(cmac_ctx->k1,0,cmac_ctx->bs);
+  memset(cmac_ctx->k2,0,cmac_ctx->bs);
+  memset(cmac_ctx->buf,0,cmac_ctx->bs);
+  memset(cmac_ctx->cip_k,0,cmac_ctx->bs);
+  if(cmac_ctx->keylen) {
+    clen = (cmac_ctx->keylen + 7)/8;
+  } else {
+    clen = EVP_CIPHER_key_length(cmac_ctx->cip);
+  }
+  memset(cmac_ctx->key,0,clen);
+}
+/** @brief free an CMAC_CTX_t 
+    @param pcb a pointer to an ICC library context 
+    @param cmac a pointer to the CMAC_CTX to free
+*/
+void CMAC_CTX_free(CMAC_CTX *cmac) 
+{
+  CMAC_CTX_t *cmac_ctx = (CMAC_CTX_t *)cmac;
+
+  if(NULL != cmac_ctx) {
+    CMAC_CTX_cleanup(cmac_ctx);
+    if(NULL != cmac_ctx->k1) CRYPTO_free(cmac_ctx->k1);
+    if(NULL != cmac_ctx->k2) CRYPTO_free(cmac_ctx->k2);
+    if(NULL != cmac_ctx->buf) CRYPTO_free(cmac_ctx->buf);
+    if(NULL != cmac_ctx->cip_k) CRYPTO_free(cmac_ctx->cip_k);
+    if(NULL != cmac_ctx->cctx) {
+        EVP_CIPHER_CTX_cleanup(cmac_ctx->cctx);
+        EVP_CIPHER_CTX_free(cmac_ctx->cctx);
+    }
+    if(NULL != cmac_ctx->key) CRYPTO_free(cmac_ctx->key);
+    CRYPTO_free(cmac_ctx);
+  }
+}
+/** @brief Initialize a CMAC operation
+    @param pcb a pointer to an ICC library context 
+    @param cmac a pointer to an CMAC_CTX
+    @param cip a pointer to a cipher structure
+    @param key a key buffer, the size must match that
+           needed by the CMAC cipher
+    @param keylen the length of the key in bits for variable key length algs,
+           Set this to zero for fixed length key algs
+    @return 1 on success, 0 otherwise
+*/
+    
+int CMAC_Init(CMAC_CTX *cmac,
+	      const EVP_CIPHER *cip,
+	      unsigned char *key,
+	      unsigned int keylen) 
+{
+  
+  CMAC_CTX_t *cmac_ctx = (CMAC_CTX_t *)cmac;
+  int rv = 1;
+  unsigned int nid = 0;
+
+  cmac_ctx->bs = EVP_CIPHER_block_size(cip);
+  if( 8 == cmac_ctx->bs || 16 == cmac_ctx->bs) {
+
+    cmac_ctx->cip = cip;
+    if(NULL == cmac_ctx->k1) {
+      cmac_ctx->k1 = (unsigned char *)CRYPTO_malloc(cmac_ctx->bs,__FILE__,__LINE__);
+    }
+    memset(cmac_ctx->k1,0,cmac_ctx->bs);
+
+    if(NULL == cmac_ctx->k2) {
+      cmac_ctx->k2 = (unsigned char *)CRYPTO_malloc(cmac_ctx->bs,__FILE__,__LINE__);
+    }
+    memset(cmac_ctx->k2,0,cmac_ctx->bs);
+ 
+    if(NULL == cmac_ctx->buf ) {
+      cmac_ctx->buf = (unsigned char *)CRYPTO_malloc(cmac_ctx->bs,__FILE__,__LINE__);
+    } 
+    memset(cmac_ctx->buf,0,cmac_ctx->bs);
+    if( 0 == keylen) {
+      keylen = EVP_CIPHER_key_length(cip)*8;
+    }
+    if(NULL == cmac_ctx->key) {
+      /* Allows for RC2 keys */
+      cmac_ctx->key = (unsigned char *)CRYPTO_malloc(keylen+7/8,__FILE__,__LINE__);
+    }
+    memcpy(cmac_ctx->key,key,EVP_CIPHER_key_length(cip));
+ 
+    
+    /* Used in Init() to hold the encrypted key,
+       after that it's used as scratch storage for Update()
+    */
+    if(NULL == cmac_ctx->cip_k) {
+      cmac_ctx->cip_k = (unsigned char *)CRYPTO_malloc(cmac_ctx->bs,__FILE__,__LINE__);
+    }
+    memset(cmac_ctx->cip_k,0,cmac_ctx->bs);
+
+    if(NULL == cmac_ctx->cctx) {
+      cmac_ctx->cctx = EVP_CIPHER_CTX_new();
+    } else {
+      EVP_CIPHER_CTX_cleanup(cmac_ctx->cctx);
+    }
+    cmac_ctx->pbs = STUPID_VALUE;
+    nid =  EVP_CIPHER_type(cip);
+    switch(nid) { /* This is just in case the caller messes up ! */
+    case NID_aes_128_cbc:
+    case NID_aes_192_cbc:
+    case NID_aes_256_cbc:
+    case NID_camellia_128_cbc:
+    case NID_camellia_192_cbc:
+    case NID_camellia_256_cbc:
+    case NID_des_cbc:
+    case NID_des_ede3_cbc:
+    case NID_cast5_cbc:
+      cmac_ctx->keylen = 0; 
+      break;
+    default: /* RC2, RC4 */
+      cmac_ctx->keylen = keylen;
+      break;
+    }
+    
+    if( 1 != SubKeys(cmac_ctx) ) {
+      rv = 0;
+    }
+  } else {
+    rv = 0;
+  }
+  return rv;
+}
+/* 
+   This needs to be just a bit clever to cope with partial blocks
+   and the special handling of the final block
+   Basically CMAC_Final needs either a partial or a full block 
+   left over. 
+   Since we'll be kind and allow partial blocks to be input here
+   we need to be sure we'll have at least a partial block left,
+   and possibly a full one.
+
+   Note that this code does assume certain behaviour from OpenSSL's
+   EncryptUpdate - i.e. that with padding off, and complete blocks being fed
+   in, complete blocks are output immediately. That's not unreasonable,
+   but I'm not sure it's guaranteed.
+
+*/
+/** @brief Update phase of a CMAC operation
+    @param pcb a pointer to an ICC library context
+    @param cmac a pointer to a CMAC_CTX
+    @param in a pointer to data to MAC
+    @param inlen the length of the input data
+    @note blocked/aligned data will be more efficient, but this will
+    survive incorrectly blocked/misaligned data
+*/
+int CMAC_Update(CMAC_CTX *cmac,
+		unsigned char *in, 
+		unsigned int inlen)
+{
+  int rv = 1;
+  unsigned int i = 0;
+  unsigned int outl = 0;
+  CMAC_CTX_t *cmac_ctx = (CMAC_CTX_t *)cmac;
+
+  /* We need to erase this buffer anyway - and we avoid allocating
+     one extra buffer this way - is it worth it ? - Probably since
+     we needed somewhere to save cip_k to pass the known answer tests 
+     and it still needs to be set to zero for the first block.
+  */
+  if(STUPID_VALUE == cmac_ctx->pbs) {
+    memset(cmac_ctx->cip_k,0,cmac_ctx->bs);
+    cmac_ctx->pbs = 0;
+  } 
+  /* This is a bit ugly, redundant memcpy's in what's hopefully 
+     the common case, but the cost of memcpy is minor
+     compared with the encrypt and we have to deal with the possibility
+     of misaligned input data at any time
+  */
+  if(inlen > 0) {
+    if( (inlen + cmac_ctx->pbs) > cmac_ctx->bs) {
+      for( i = inlen+cmac_ctx->pbs; i > cmac_ctx->bs; i -= ((cmac_ctx->bs > i) ? i : cmac_ctx->bs) ) {
+	/* Top up the retained buffer with incoming data */
+	memcpy(cmac_ctx->buf + cmac_ctx->pbs,in,(cmac_ctx->bs - cmac_ctx->pbs));
+	/* We stole this many bytes of input */
+	in += (cmac_ctx->bs - cmac_ctx->pbs);
+	/* And there's no partial buffer for next time */
+	cmac_ctx->pbs = 0;
+	/* Ci-1 ^ Mi */
+	xor(cmac_ctx->buf,cmac_ctx->cip_k,cmac_ctx->buf,cmac_ctx->bs);
+	/* Ci = CIPH(Ci-1 ^ Mi) */
+	
+	rv = CMAC_EVP_Init(cmac_ctx);
+	if( 1 == rv) {
+#if defined(DEBUG_CMAC)
+	  printf("UPD:");
+	  printbin(cmac_ctx->buf,cmac_ctx->bs);
+#endif
+	  rv = EVP_EncryptUpdate(cmac_ctx->cctx,
+				      cmac_ctx->cip_k,
+				      &outl,cmac_ctx->buf,cmac_ctx->bs);      
+	}
+      }
+      if(i > 0) {
+	/* We have at most one block left over, 
+	   copy that to our retain buffer and set the length of the left over segment       
+	*/
+	memcpy(cmac_ctx->buf,in,i);
+	cmac_ctx->pbs = i;
+      }
+    } else { 
+      /* O.K. someone is being a bit silly, we don't have enough data to do an update yet,
+	 maybe doing the CMAC 3 bytes at a time perhaps ...
+	 Just top up the retain buffer ... *sigh*
+      */
+      memcpy(cmac_ctx->buf + cmac_ctx->pbs,in,inlen);
+      cmac_ctx->pbs += inlen;
+    }
+  }
+  return rv;
+}
+/** @brief Finish a CMAC operation and return the CMAC value
+    @param pcb a pointer to an ICC library context
+    @param cmac a pointer to an CMAC_CTX
+    @param md a pointer to a buffer in which to store the CMAC,
+           must be at least maclen bytes longs
+    @param maclen the length of the desired mac value in bytes. (<= block length)
+    @return 1 on success, 0 on failure
+    @note a request for an overly long CMAC return will result in an error and
+          no data being produced
+
+*/
+int CMAC_Final(CMAC_CTX *cmac,
+	       unsigned char *md, 
+	       unsigned int maclen)
+{
+  int rv = 1;
+  int outl = 0;
+  CMAC_CTX_t *cmac_ctx = (CMAC_CTX_t *)cmac;
+  if(maclen <= cmac_ctx->bs) {
+    /* A CMAC is valid with no input data, so depending on the user CMAC
+       logic we COULD hit this case. i.e. 
+       CMAC_Init()
+       for(i = 0; i < len ; i+= blocksize) {
+          CMAC_Update()
+       }
+       CMAC_Final()
+    */
+    if(STUPID_VALUE == cmac_ctx->pbs) {
+      memset(cmac_ctx->cip_k,0,cmac_ctx->bs);
+      cmac_ctx->pbs = 0;
+    } 
+
+    if(cmac_ctx->pbs == cmac_ctx->bs) { /* Complete block */
+      /* Mn = K1 ^ Mn* */
+      xor(cmac_ctx->buf,cmac_ctx->k1,cmac_ctx->buf,cmac_ctx->bs);
+    } else { /* Partial block */
+      /* Mn' = (Mn* || 10... ) - we are byte blocked so ... */
+      memset(cmac_ctx->buf + cmac_ctx->pbs,0,(cmac_ctx->bs-cmac_ctx->pbs));
+      /* MSBit of the unused section set to 1 */
+      cmac_ctx->buf[cmac_ctx->pbs] = 0x80;
+      /* XOR with k2 => Mn = (K2 ^ (Mn* || 10....) */
+      xor(cmac_ctx->buf,cmac_ctx->k2,cmac_ctx->buf,cmac_ctx->bs);
+    }
+    /* Now Xor with the retained data (cip_k)*/
+    xor(cmac_ctx->buf,cmac_ctx->cip_k,cmac_ctx->buf,cmac_ctx->bs);
+    /* Now do the final run through the encryption */
+#if defined(DEBUG_CMAC)
+    printbin(cmac_ctx->buf,cmac_ctx->bs);
+    printf("FIN:");
+#endif
+    CMAC_EVP_Init(cmac_ctx);
+
+    rv = EVP_EncryptUpdate(cmac_ctx->cctx,
+				cmac_ctx->cip_k,
+				&outl,
+				cmac_ctx->buf,cmac_ctx->bs);
+    /* Return the requested amount of mac */
+    memcpy(md,cmac_ctx->cip_k,maclen);    
+  } else {
+    rv = 0; /* Invalid mac length */
+  }
+  /* Scrub the CMAC ctx */
+  CMAC_CTX_cleanup(cmac_ctx);
+  EVP_CIPHER_CTX_cleanup(cmac_ctx->cctx);
+  return rv;
+}
+
+
diff -urN openssl-1.0.0-beta4.orig/crypto/cmac/cmac.h openssl-1.0.0-beta4/crypto/cmac/cmac.h
--- openssl-1.0.0-beta4.orig/crypto/cmac/cmac.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/cmac/cmac.h	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,52 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+// 
+-----------------------------------------------------------------------------*/
+
+#if !defined(CMAC_H)
+#define CMAC_H
+
+/*! @brief The CMAC_CTX data structure */
+typedef struct {
+  unsigned char *cip_k;  /*!< Scratch buffer, the encrypted key is here until the first Update() is done */
+  unsigned char *k1;     /*!< subkey 1 */
+  unsigned char *k2;     /*!< subkey 2 */
+  unsigned bs;           /*!< Cipher block size */
+  unsigned pbs;          /*!< Size of the partial block left in the buffer */
+  const EVP_CIPHER *cip; /*!< Cipher used for this CMAC */
+  EVP_CIPHER_CTX *cctx;  /*!< Cipher context in flight for this CMAC */
+  unsigned char *buf;    /*!< Transient MAC buffer */
+  unsigned char *key;    /*!< Retained copy of the key */
+  unsigned int keylen;   /*!< Retained copy of the keylength of variable length keys - in bits */
+} CMAC_CTX_t;
+
+typedef CMAC_CTX_t CMAC_CTX;
+
+int CMAC_Init(CMAC_CTX *cmac,
+              const EVP_CIPHER *cip,
+              unsigned char *key,
+              unsigned int keylen);
+              
+int CMAC_Update(CMAC_CTX *cmac,
+                unsigned char *in, 
+                unsigned int inlen);
+                
+int CMAC_Final(CMAC_CTX *cmac,
+               unsigned char *md, 
+               unsigned int maclen);
+               
+CMAC_CTX * CMAC_CTX_new(void);
+               
+void CMAC_CTX_free(CMAC_CTX *cmac);
+
+               
+                                              
+                                              
+                                          
+
+#endif
diff -urN openssl-1.0.0-beta4.orig/crypto/cmac/cmac_test.c openssl-1.0.0-beta4/crypto/cmac/cmac_test.c
--- openssl-1.0.0-beta4.orig/crypto/cmac/cmac_test.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/cmac/cmac_test.c	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,362 @@
+/*----------------------------------------------------------------------------
+// Licensed materials - Property of IBM                                      
+//
+// (C) Copyright IBM Corp.  2007
+// This code was donated to the OpenSSL project under the terms of the 
+// OpenSSL license.
+//
+//--------------------------------------------------------------------------*/
+
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include "openssl/err.h"
+#include "openssl/evp.h"
+#include "openssl/cmac.h"
+
+/* #define DES_WORKS */
+static int x2bin(unsigned char c) {
+  int i = 0;
+  c = tolower(c);
+  if( c >= 'a' && c <= 'f') {
+    i = c - 'a' + 10;
+  } else if (c >= '0' && c <= '9' ) {
+    i = c - '0';
+  }
+  return i;
+}
+
+static unsigned char bin2xn(unsigned char in)
+{
+  if ( in <= 9 ) in += '0';
+  else in += ('a' - 10);
+  return in;
+}
+static void bin2x(unsigned char in,unsigned char out[2]) {
+  unsigned char hi,lo;
+  hi = (in >> 4) & 0x0f;
+  lo = in & 0x0f;
+  out[0] = bin2xn(hi);
+  out[1] = bin2xn(lo);
+}
+/* Convert a stream of bytes to hex 
+   We do 0 terminate the buffer
+   return value is length of string (not including the 0 terminator)
+*/
+static int Bin2HexBuffer(char *in,int inlen,char **out)
+{
+  int i = 0;
+  unsigned char *ptr;
+  if(out != NULL && *out == NULL) {
+    *out = (char *)malloc(inlen*2 +1);
+  }
+  if( out != NULL && *out != NULL) {
+    ptr = (unsigned char *)*out;
+    for(i = 0; i < inlen; i ++,ptr += 2) {
+      bin2x(in[i],ptr);
+    }   
+    *ptr = '\0';
+  }
+  return i*2;   
+}
+/* Convert a stream of hex data to binary 
+   We '\0' terminate the returned buffer IFF we allocate it
+   return value is number of bytes returned
+*/
+static int Hex2BinBuffer(char *in,int inlen,char **out)
+{
+  int i =0,j = 0;
+  int alloc = 0;
+  unsigned char c,hh = 0;
+  char *ptr;
+  if(out != NULL && *out == NULL) {
+    *out = (char *)malloc(inlen/2+1);
+    alloc = 1;
+  }
+  if( out != NULL && *out != NULL) {
+    ptr = *out;
+    for(i = j = 0; i < inlen; i ++) {
+      c = in[i];
+      if ( !isxdigit(c) ) break;
+      if( !(i&1) ) { /* Even numbered == high nybble */
+	hh = (unsigned char)x2bin(c);
+      } else {
+	ptr[j] = hh << 4 | (unsigned char)x2bin(c);
+	j++;
+      }           
+    }
+    if(alloc) ptr[j] = '\0';    
+  }
+  return j;
+}
+/* debug routine */
+static void printbin(unsigned char *buf, int blen)
+{
+  char *bh = NULL;
+  Bin2HexBuffer((char *)buf,blen,&bh);
+  printf("%s",bh);
+  free(bh);
+}
+
+
+typedef struct tv_t {
+  char *mess;
+  char *cmac;
+} TV;
+
+typedef struct ka_t {
+  char *cname;
+  char *key;
+  char *cip_k;
+  char *k1;
+  char *k2;
+  TV tv[4];
+} KA;
+/* Data from NIST SP800-38B.pdf */
+#if defined(DES_WORKS)
+#define NTESTS 5
+#else
+#define NTESTS 3
+#endif
+
+KA ka[NTESTS] = {
+#if defined(DES_WORKS)
+  {"DES3", /* 3 Key TDEA */
+   "8aa83bf8cbda10620bc1bf19fbb6cd58bc313d4a371ca8b5",
+   "c8cc74e98a7329a2",
+   "9198e9d314e6535f",
+   "2331d3a629cca6a5",
+   {
+    {"","b7a688e122ffaf95"},
+    {"6bc1bee22e409f96","b7a688e122ffaf95"},
+    {"6bc1bee22e409f96e93d7e117393172aae2d8a57","d32bcebe43d23d80"},
+    {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51","33e6b1092400eae5"},
+   },
+  },
+  {"DES3", /* 2 Key TDEA */
+   "4cf15134a2850dd58a3d10ba80570d384cf15134a2850dd5",
+   "c7679b9f6b8d7d7a",
+   "8ecf373ed71afaef",
+   "1d9e6e7dae35f5c5",
+   {
+     {"","bd2ebf9a3ba00361"},
+     {"6bc1bee22e409f96","bd2ebf9a3ba00361"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a57","8ea92435b52660e0"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51","31b1e431dabc4eb8"},
+   },
+  },
+#endif  
+  {"AES-128-CBC",
+   "2b7e151628aed2a6abf7158809cf4f3c",
+   "7df76b0c1ab899b33e42f047b91b546f",
+   "fbeed618357133667c85e08f7236a8de",
+   "f7ddac306ae266ccf90bc11ee46d513b",
+   {
+     {"","bb1d6929e95937287fa37d129b756746"},
+     {"6bc1bee22e409f96e93d7e117393172a","070a16b46b4d4144f79bdd9dd04a287c"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411","dfa66747de9ae63030ca32611497c827"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710","51f0bebf7e3b9d92fc49741779363cfe"},
+   },
+  },
+  {"AES-192-CBC",
+   "8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b",
+   "22452d8e49a8a5939f7321ceea6d514b",
+   "448a5b1c93514b273ee6439dd4daa296",
+   "8914b63926a2964e7dcc873ba9b5452c", 
+   {
+     {"","d17ddf46adaacde531cac483de7a9367"},
+     {"6bc1bee22e409f96e93d7e117393172a","9e99a7bf31e710900662f65e617c5184"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411",
+      "8a1de5be2eb31aad089a82e6ee908b0e"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710","a1d5df0eed790f794d77589659f39a11"},
+   },
+  },
+  {"AES-256-CBC",
+   "603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4",
+   "e568f68194cf76d6174d4cc04310a854",
+   "cad1ed03299eedac2e9a99808621502f",
+   "95a3da06533ddb585d3533010c42a0d9",
+   {
+     {"","028962f61b7bf89efc6b551f4667d983"},
+     {"6bc1bee22e409f96e93d7e117393172a","28a7023f452e8f82bd4bf28d8c37c35c"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411","aaf3d8f1de5640c232f5b169b9c911e6"},
+     {"6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e5130c81c46a35ce411e5fbc1191a0a52eff69f2445df4f9b17ad2b417be66c3710","e1992190549f6ed5696a2c056c315410"},
+   },
+  },
+};
+/** @brief controls whether we've printed the algorithm header info yet or not */
+
+static int prthdr = 0;
+
+/** @brief regurgitate the input test data 
+*/
+static void dump_TestData(void)
+{ 
+  int i,j;
+
+  for(i = 0; i < NTESTS; i++) {
+    printf("ALG   %s\nKey   %s\ncip_k %s\nk1    %s\nk2    %s\n",ka[i].cname,ka[i].key,ka[i].cip_k,ka[i].k1,ka[i].k2);
+    for(j = 0; j < 4; j++) {
+      printf("\tMSG %s, MAC %s\n",ka[i].tv[j].mess,ka[i].tv[j].cmac);
+    }
+    printf("\n");
+  }
+}
+static void cmac_hdr(CMAC_CTX_t *cmac_ctx,int i,int j) 
+{
+  char *cip_k = NULL;
+  char *k1 = NULL;
+  char *k2 = NULL;
+
+
+  if( (1 == prthdr) ) {
+    prthdr = 0;
+    
+    Bin2HexBuffer((char *)cmac_ctx->cip_k,cmac_ctx->bs,&cip_k);
+    Bin2HexBuffer((char *)cmac_ctx->k1,cmac_ctx->bs,&k1);
+    Bin2HexBuffer((char *)cmac_ctx->k2,cmac_ctx->bs,&k2);
+    
+    if( (strcmp(ka[i].cip_k,cip_k) != 0 ) ||
+	(strcmp(ka[i].k1,k1) != 0 ) ||
+	(strcmp(ka[i].k2,k2) != 0 )
+	) {
+      printf("CMAC error\nAlg %s, key %s, blocksize %u\n",ka[i].cname,ka[j].key,cmac_ctx->bs);
+      printf("\nmesg = %4d:(%s)\ncmac = %4d:(%s)\n\n",
+	     (int)strlen(ka[i].tv[j].mess)/2,ka[i].tv[j].mess,
+	     (int)strlen(ka[i].tv[j].cmac)/2,ka[i].tv[j].cmac);
+      printf("cip_k %s ?= %s\n",cip_k,ka[i].cip_k);
+      printf("   k1 %s ?= %s\n",k1,ka[i].k1);
+      printf("   k2 %s ?= %s\n",k2,ka[i].k2);
+    }
+    free(cip_k);
+    cip_k = NULL;
+    free(k1);
+    k1 = NULL;
+    free(k2);
+    k2 = NULL;	
+  }
+}
+
+void do_CMAC_test(CMAC_CTX *cmac_ctx,int i,int j, int stride) 
+{
+  int allocd = 0;
+  int mlen,keylen;
+  char *key = NULL;
+  char *data = NULL;
+  unsigned char mac[16];
+  char *machex = NULL; 
+  const EVP_CIPHER *cip = NULL;
+  int bs = 0;
+  int k = 0;
+  static CMAC_CTX_t tmp;
+
+  cip = EVP_get_cipherbyname(ka[i].cname);
+  if(NULL == cip) {
+    printf("getcipherbyname failed [%s]\n",ka[i].cname);
+    
+  } else {
+
+    
+    if(cmac_ctx == NULL) { /* One shot test, allocate our own */
+      cmac_ctx = CMAC_CTX_new();
+      allocd = 1;
+    }
+    /* Now torture our code a little - this is to make sure our buffer
+       handling code is 100% O.K.	 
+    */
+    bs = EVP_CIPHER_block_size(cip);
+    keylen = strlen(ka[i].key)/2;
+    Hex2BinBuffer(ka[i].key,keylen*2,&key);
+
+    mlen = strlen(ka[i].tv[j].mess)/2;
+    Hex2BinBuffer(ka[i].tv[j].mess,mlen*2,&data);
+    
+    
+
+    CMAC_Init(cmac_ctx,cip,(unsigned char *)key,keylen*8);
+    /* Now keep a copy of the CMAC data NOW because some fields may
+       be overwritten by the time we fail 
+    */
+    memcpy(&tmp,cmac_ctx,sizeof(CMAC_CTX_t));
+    if(0 == stride) { /* Special case, do the first pass in one hit */
+      CMAC_Update(cmac_ctx,(unsigned char *)(data),mlen);
+    } else {
+      for(k = 0; k+stride < mlen; k+= stride) {
+	CMAC_Update(cmac_ctx,(unsigned char *)(data+k),stride);
+      }
+      if(k < mlen) { /* Any little bit left over ... */
+	CMAC_Update(cmac_ctx,(unsigned char *)(data+k),mlen-k);
+      }
+    }
+      
+    CMAC_Final(cmac_ctx,mac,bs);
+    Bin2HexBuffer((char *)mac,bs,&machex);
+    
+    if( 0 != strcmp(machex,ka[i].tv[j].cmac) ) {
+      prthdr = 1;
+      cmac_hdr(&tmp,i,j);
+      printf("Error expected %s, got %s - test %d.%d stride %d\n",
+	     ka[i].tv[j].cmac,machex,i,j,stride);
+    }
+    free(data);
+    data = NULL;
+    free(machex);
+    machex = NULL;
+    free(key);
+    key = NULL;
+    if(allocd) {
+      CMAC_CTX_free(cmac_ctx);
+    }   
+  }
+}
+
+
+
+int main(int argc,char *argv[])
+{
+
+  CMAC_CTX *cmac_ctx = NULL;
+
+  int i = 0,j = 0 ,stride = 0;
+  int mlen = 0;
+
+  OPENSSL_add_all_algorithms_noconf();
+#if defined(DEBUG_CMAC)
+    dump_TestData();
+#endif
+    
+  /* Specific way to drive a particular case */
+  if(argc > 3) { /* Expect i,j,stride */
+    i = atoi(argv[1]);
+    j = atoi(argv[2]);
+    stride = atoi(argv[3]);
+    cmac_ctx = CMAC_CTX_new();
+    do_CMAC_test(cmac_ctx,i,j,stride);
+    CMAC_CTX_free(cmac_ctx);
+  } else {
+    /* Loop through the cipher modes NIST support */
+    for(i = 0 ; i < NTESTS; i++) {
+      cmac_ctx = CMAC_CTX_new();
+      /* Loop through the test cases from the NIST CMAC pdf for each cipher mode */
+      prthdr = 1;
+      for(j = 0; j < 4; j++ ) {
+	mlen = strlen(ka[i].tv[j].mess)/2;
+	for(stride = 0  ; stride == 0 || stride < mlen; stride++ ) {
+	  do_CMAC_test(cmac_ctx,i,j,stride);
+	}
+      }
+      CMAC_CTX_free(cmac_ctx);
+      cmac_ctx = NULL;;  
+    }
+  }
+
+  EVP_cleanup();
+  CRYPTO_cleanup_all_ex_data();
+  ERR_remove_state(0);
+  ERR_free_strings();
+  CRYPTO_mem_leaks_fp(stderr);
+  return 0;
+}
+
+
diff -urN openssl-1.0.0-beta4.orig/crypto/cmac/Makefile openssl-1.0.0-beta4/crypto/cmac/Makefile
--- openssl-1.0.0-beta4.orig/crypto/cmac/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.0-beta4/crypto/cmac/Makefile	2009-12-05 15:15:23.000000000 +0100
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/cmac/Makefile
+#
+
+DIR=	cmac
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= cmac_test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=cmac.c
+LIBOBJ=cmac.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= cmac.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -urN openssl-1.0.0-beta4.orig/Makefile.org openssl-1.0.0-beta4/Makefile.org
--- openssl-1.0.0-beta4.orig/Makefile.org	2009-10-16 01:44:11.000000000 +0200
+++ openssl-1.0.0-beta4/Makefile.org	2009-12-05 15:15:23.877754212 +0100
@@ -119,6 +119,7 @@
 	md2 md4 md5 sha mdc2 hmac ripemd whrlpool \
 	des aes rc2 rc4 rc5 idea bf cast camellia seed modes \
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
+	cmac \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
 	cms pqueue ts jpake store
diff -urN openssl-1.0.0-beta4.orig/test/Makefile openssl-1.0.0-beta4/test/Makefile
--- openssl-1.0.0-beta4.orig/test/Makefile	2009-10-18 16:44:50.000000000 +0200
+++ openssl-1.0.0-beta4/test/Makefile	2009-12-05 15:17:00.016504442 +0100
@@ -60,8 +60,11 @@
 ENGINETEST=	enginetest
 EVPTEST=	evp_test
 IGETEST=	igetest
+GCMTESTA=  aesgcmtest
+CMACTESTA= cmac_test
 JPAKETEST=	jpaketest
 
+
 TESTS=		alltests
 
 EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
@@ -71,7 +74,8 @@
 	$(MDC2TEST)$(EXE_EXT) $(RMDTEST)$(EXE_EXT) \
 	$(RANDTEST)$(EXE_EXT) $(DHTEST)$(EXE_EXT) $(ENGINETEST)$(EXE_EXT) \
 	$(BFTEST)$(EXE_EXT) $(CASTTEST)$(EXE_EXT) $(SSLTEST)$(EXE_EXT) $(EXPTEST)$(EXE_EXT) $(DSATEST)$(EXE_EXT) $(RSATEST)$(EXE_EXT) \
-	$(EVPTEST)$(EXE_EXT) $(IGETEST)$(EXE_EXT) $(JPAKETEST)$(EXE_EXT)
+	$(EVPTEST)$(EXE_EXT) $(IGETEST)$(EXE_EXT) $(JPAKETEST)$(EXE_EXT) \
+	$(GCMTESTA)$(EXE_EXT) $(CMACTESTA)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -83,7 +87,8 @@
 	$(MDC2TEST).o $(RMDTEST).o \
 	$(RANDTEST).o $(DHTEST).o $(ENGINETEST).o $(CASTTEST).o \
 	$(BFTEST).o  $(SSLTEST).o  $(DSATEST).o  $(EXPTEST).o $(RSATEST).o \
-	$(EVPTEST).o $(IGETEST).o $(JPAKETEST).o
+	$(EVPTEST).o $(IGETEST).o $(JPAKETEST).o \
+	$(GCMTESTA).o $(CMACTESTA).o
 SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
 	$(HMACTEST).c $(WPTEST).c \
@@ -91,7 +96,8 @@
 	$(DESTEST).c $(SHATEST).c $(SHA1TEST).c $(MDC2TEST).c $(RMDTEST).c \
 	$(RANDTEST).c $(DHTEST).c $(ENGINETEST).c $(CASTTEST).c \
 	$(BFTEST).c  $(SSLTEST).c $(DSATEST).c   $(EXPTEST).c $(RSATEST).c \
-	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c
+	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c \
+	$(GCMTESTA).c $(CMACTESTA).c
 
 EXHEADER= 
 HEADER=	$(EXHEADER)
@@ -101,7 +107,7 @@
 top:
 	(cd ..; $(MAKE) DIRS=$(DIR) TESTS=$(TESTS) all)
 
-all:	exe
+all:	$(OBJ) exe
 
 exe:	$(EXE) dummytest$(EXE_EXT)
 
@@ -134,7 +140,7 @@
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_ssl test_tsa test_ige \
-	test_jpake test_cms
+	test_jpake test_cms test_aes_gcm test_cmac
 
 test_evp:
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
@@ -308,6 +314,14 @@
 	@echo "CMS consistency test"
 	$(PERL) cms-test.pl
 
+test_aes_gcm:  $(GCMTESTA)$(EXE_EXT)
+	@echo "Test AES GCM modes"
+	../util/shlib_wrap.sh ./aesgcmtest$(EXE_EXT)
+
+test_cmac: $(CMACTESTA)$(EXE_EXT)
+	@echo "Test CMAC modes"
+	../util/shlib_wrap.sh  ./$(CMACTESTA)$(EXE_EXT)
+
 lint:
 	lint -DLINT $(INCLUDES) $(SRC)>fluff
 
@@ -441,6 +455,15 @@
 $(JPAKETEST)$(EXE_EXT): $(JPAKETEST).o $(DLIBCRYPTO)
 	@target=$(JPAKETEST); $(BUILD_CMD)
 
+$(GCMTESTA)$(EXE_EXT): $(GCMTESTA).o  $(DLIBCRYPTO)
+	@target=$(GCMTESTA); $(BUILD_CMD)
+
+$(CMACTESTA)$(EXE_EXT): $(CMACTESTA).o  $(DLIBCRYPTO)
+	@target=$(CMACTESTA); $(BUILD_CMD)
+
+
+
+
 #$(AESTEST).o: $(AESTEST).c
 #	$(CC) -c $(CFLAGS) -DINTERMEDIATE_VALUE_KAT -DTRACE_KAT_MCT $(AESTEST).c
 
diff -urN openssl-1.0.0-beta4.orig/util/libeay.num openssl-1.0.0-beta4/util/libeay.num
--- openssl-1.0.0-beta4.orig/util/libeay.num	2009-11-04 14:29:58.000000000 +0100
+++ openssl-1.0.0-beta4/util/libeay.num	2009-12-05 15:18:49.416503991 +0100
@@ -4169,3 +4169,22 @@
 X509_STORE_CTX_get0_current_crl         4544	EXIST::FUNCTION:
 X509_STORE_CTX_get0_parent_ctx          4545	EXIST::FUNCTION:
 X509_STORE_CTX_get0_current_issuer      4546	EXIST::FUNCTION:
+AES_CCM_Decrypt                         4539 EXIST::FUNCTION:AES
+AES_CCM_Encrypt                         4540 EXIST::FUNCTION:AES
+GCM128                                  4541 EXIST::FUNCTION:
+AES_GCM_CTX_new                         4542 EXIST::FUNCTION:AES
+AES_GCM_CTX_free                        4543 EXIST::FUNCTION:AES
+AES_GCM_CTX_ctrl                        4544 EXIST::FUNCTION:AES
+AES_GCM_Init                            4545 EXIST::FUNCTION:AES
+AES_GCM_EncryptUpdate                   4546 EXIST::FUNCTION:AES
+AES_GCM_EncryptFinal                    4547 EXIST::FUNCTION:AES
+AES_GCM_DecryptUpdate                   4548 EXIST::FUNCTION:AES
+AES_GCM_DecryptFinal                    4549 EXIST::FUNCTION:AES
+AES_GCM_GenerateIV                      4550 EXIST::FUNCTION:AES
+GHASH                                   4551 EXIST::FUNCTION:
+CMAC_Update                             4552 EXIST::FUNCTION:
+CMAC_Final                              4553 EXIST::FUNCTION:
+CMAC_CTX_new                            4554 EXIST::FUNCTION:
+CMAC_Init                               4555 EXIST::FUNCTION:
+CMAC_CTX_free                           4556 EXIST::FUNCTION:
+
diff -urN openssl-1.0.0-beta4.orig/util/mkdef.pl openssl-1.0.0-beta4/util/mkdef.pl
--- openssl-1.0.0-beta4.orig/util/mkdef.pl	2009-05-15 18:01:42.000000000 +0200
+++ openssl-1.0.0-beta4/util/mkdef.pl	2009-12-05 15:15:23.897754329 +0100
@@ -86,6 +86,7 @@
 			 "SHA256", "SHA512", "RIPEMD",
 			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA",
 			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
+			 "CMAC","GHASH","GCM128",
 			 # Envelope "algorithms"
 			 "EVP", "X509", "ASN1_TYPEDEFS",
 			 # Helper "algorithms"
@@ -283,6 +284,7 @@
 $crypto.=" crypto/ecdsa/ecdsa.h" ; # unless $no_ecdsa;
 $crypto.=" crypto/ecdh/ecdh.h" ; # unless $no_ecdh;
 $crypto.=" crypto/hmac/hmac.h" ; # unless $no_hmac;
+$crypto.=" crypto/cmac/cmac.h";
 
 $crypto.=" crypto/engine/engine.h"; # unless $no_engine;
 $crypto.=" crypto/stack/stack.h" ; # unless $no_stack;
@@ -317,6 +319,8 @@
 $crypto.=" crypto/cms/cms.h";
 $crypto.=" crypto/jpake/jpake.h";
 
+
+
 my $symhacks="crypto/symhacks.h";
 
 my @ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
diff -urN openssl-1.0.0-beta4.orig/util/mkfiles.pl openssl-1.0.0-beta4/util/mkfiles.pl
--- openssl-1.0.0-beta4.orig/util/mkfiles.pl	2008-12-23 16:15:44.000000000 +0100
+++ openssl-1.0.0-beta4/util/mkfiles.pl	2009-12-05 15:15:23.897754329 +0100
@@ -15,6 +15,7 @@
 "crypto/sha",
 "crypto/mdc2",
 "crypto/hmac",
+"crypto/cmac",
 "crypto/ripemd",
 "crypto/des",
 "crypto/rc2",
