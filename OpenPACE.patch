Index: openssl/Configure
===================================================================
--- openssl.orig/Configure	2010-10-14 13:47:08.000000000 +0200
+++ openssl/Configure	2010-10-14 13:47:08.000000000 +0200
@@ -667,6 +667,7 @@
 		 "gmp"		  => "default",
                  "jpake"          => "experimental",
                  "md2"            => "default",
+                 "pace"           => "experimental",
                  "rc5"            => "default",
 		 "rfc3779"	  => "default",
                  "shared"         => "default",
Index: openssl/Makefile.org
===================================================================
--- openssl.orig/Makefile.org	2010-10-14 13:47:08.000000000 +0200
+++ openssl/Makefile.org	2010-10-14 13:47:08.000000000 +0200
@@ -122,7 +122,7 @@
 	cmac \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts jpake store
+	cms pqueue ts jpake store pace cv_cert
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
Index: openssl/crypto/bn/bn.h
===================================================================
--- openssl.orig/crypto/bn/bn.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/bn/bn.h	2010-10-14 13:47:08.000000000 +0200
@@ -126,6 +126,7 @@
 #define HEADER_BN_H
 
 #include <openssl/e_os2.h>
+#include <openssl/buffer.h>
 #ifndef OPENSSL_NO_FP_API
 #include <stdio.h> /* FILE */
 #endif
@@ -429,6 +430,15 @@
 int	BN_bn2bin(const BIGNUM *a, unsigned char *to);
 BIGNUM *BN_mpi2bn(const unsigned char *s,int len,BIGNUM *ret);
 int	BN_bn2mpi(const BIGNUM *a, unsigned char *to);
+/**
+ * @brief converts an BIGNUM object to a BUF_MEM object
+ *
+ * @param bn bignumber to convert
+ *
+ * @return converted bignumber or NULL if an error occurred
+ */
+BUF_MEM *
+BN_bn2buf(const BIGNUM *bn);
 int	BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int	BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int	BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
Index: openssl/crypto/bn/bn_lib.c
===================================================================
--- openssl.orig/crypto/bn/bn_lib.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/bn/bn_lib.c	2010-10-14 13:47:08.000000000 +0200
@@ -66,6 +66,7 @@
 #include <stdio.h>
 #include "cryptlib.h"
 #include "bn_lcl.h"
+#include <openssl/buffer.h>
 
 const char BN_version[]="Big Number" OPENSSL_VERSION_PTEXT;
 
@@ -653,6 +654,23 @@
 	return(n);
 	}
 
+BUF_MEM *
+BN_bn2buf(const BIGNUM *bn)
+{
+    BUF_MEM * out;
+
+    if (!bn)
+        return NULL;
+
+    out = BUF_MEM_create(BN_num_bytes(bn));
+    if (!out)
+        return NULL;
+
+    out->length = BN_bn2bin(bn, (unsigned char *) out->data);
+
+    return out;
+}
+
 int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
 	{
 	int i;
Index: openssl/crypto/buffer/buffer.c
===================================================================
--- openssl.orig/crypto/buffer/buffer.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/buffer/buffer.c	2010-10-14 13:47:08.000000000 +0200
@@ -242,3 +242,59 @@
 			}
 		}
 	}
+
+BUF_MEM *
+BUF_MEM_create(size_t len)
+{
+    BUF_MEM *out = BUF_MEM_new();
+    if (!out)
+        return NULL;
+
+    if (!BUF_MEM_grow(out, len)) {
+        BUF_MEM_free(out);
+        return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len)
+{
+    BUF_MEM *out;
+
+    if (!buf)
+        return NULL;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    memcpy(out->data, buf, len);
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+
+    if (!in)
+        return NULL;
+
+    out = BUF_MEM_create(in->length);
+    if (!out)
+        goto err;
+
+    memcpy(out->data, in->data, in->length);
+    out->max = in->max;
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
Index: openssl/crypto/buffer/buffer.h
===================================================================
--- openssl.orig/crypto/buffer/buffer.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/buffer/buffer.h	2010-10-14 13:47:08.000000000 +0200
@@ -89,6 +89,34 @@
 char *	BUF_strndup(const char *str, size_t siz);
 void *	BUF_memdup(const void *data, size_t siz);
 void	BUF_reverse(unsigned char *out, unsigned char *in, size_t siz);
+/**
+ * @brief Creates a BUF_MEM object
+ *
+ * @param len required length of the buffer
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create(size_t len);
+/**
+ * @brief Creates and initializes a BUF_MEM object
+ *
+ * @param buf Initial data
+ * @param len Length of buf
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len);
+/**
+ * @brief duplicates a BUF_MEM structure
+ *
+ * @param in BUF_MEM to duplicate
+ *
+ * @return pointer to the new BUF_MEM or NULL in case of error
+ */
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in);
 
 /* safe string functions */
 size_t BUF_strlcpy(char *dst,const char *src,size_t siz);
Index: openssl/crypto/cv_cert/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/cv_cert/Makefile	2010-10-14 13:47:06.000000000 +0200
@@ -0,0 +1,59 @@
+DIR=cv_cert
+TOP=../..
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+LIB=$(TOP)/libcrypto.a
+LIBOBJ=cv_cert.o
+LIBSRC=cv_cert.c
+
+EXHEADER=cv_cert.h
+#TEST=pacetest.c
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+#	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj des lib tags core .pure .nfs* *.old *.bak fluff
+
+#pacetest: top pace.h pacetest.c $(LIB)
+#	$(CC) $(CFLAGS) -Wall -Werror -g -o pacetest pacetest.c $(LIB)
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+cv_cert.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cv_cert.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+cv_cert.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+cv_cert.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+cv_cert.o: ../../include/openssl/ec.h ../../include/openssl/obj_mac.h
+cv_cert.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+cv_cert.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+cv_cert.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+cv_cert.o: ../../include/openssl/symhacks.h cv_cert.c cv_cert.h
Index: openssl/crypto/cv_cert/cv_cert.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/cv_cert/cv_cert.c	2010-10-26 11:18:00.000000000 +0200
@@ -0,0 +1,605 @@
+/**
+ * @file
+ * @brief Library for card verifiable certificates
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "cv_cert.h"
+//#include "pace_asn1.h"
+//#include "pace_util.h"
+#include <openssl/ec.h>
+#include <openssl/objects.h>
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/pace.h> /*for ec_key_from_asn1 */
+#include <string.h>
+
+/** Check wether or not  a specific bit is set */
+#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
+
+/** Human readable names of the individual bits of the CHAT of an
+    authentication terminal*/
+static const char *at_chat_strings[] = {
+        "Age Verification",
+        "Community ID Verification",
+        "Restrictied Identification",
+        "Privileged Terminal",
+        "CAN allowed",
+        "PIN Managment",
+        "Install Certificate",
+        "Install Qualified Certificate",
+        "Read DG 1",
+        "Read DG 2",
+        "Read DG 3",
+        "Read DG 4",
+        "Read DG 5",
+        "Read DG 6",
+        "Read DG 7",
+        "Read DG 8",
+        "Read DG 9",
+        "Read DG 10",
+        "Read DG 11",
+        "Read DG 12",
+        "Read DG 13",
+        "Read DG 14",
+        "Read DG 15",
+        "Read DG 16",
+        "Read DG 17",
+        "Read DG 18",
+        "Read DG 19",
+        "Read DG 20",
+        "Read DG 21",
+        "RFU",
+        "RFU",
+        "RFU",
+        "RFU",
+        "Write DG 21",
+        "Write DG 20",
+        "Write DG 19",
+        "Write DG 18",
+        "Write DG 17"
+};
+
+/** Human readable names of the individual bits of the CHAT of an
+    inspection system */
+static const char *is_chat_strings[] = {
+        "Read fingerprint",
+        "Read iris",
+        "RFU",
+        "RFU",
+        "RFU",
+        "Read eID application"
+};
+
+/** Human readable names of the individual bits of the CHAT of a
+    signature terminal */
+static const char *st_chat_strings[] = {
+        "Generate electronic signature",
+        "Generate qualified electronic signature",
+        "RFU",
+        "RFU",
+        "RFU",
+        "RFU"
+};
+
+/** Human readable names of the individual members of a certificate description */
+static const char *cert_desc_field_strings[] = {
+    "issuerName",
+    "issuerURL",
+    "subjectName",
+    "subjectURL",
+    "redirectURL",
+    "termsOfUsage",
+};
+
+/**
+ * @defgroup CVC_CERT_ASN1     ASN1 structures for Card Verifiable Certificates
+ * @{ ************************************************************************/
+
+ASN1_SEQUENCE(CVC_CHAT_SEQ) = {
+        ASN1_SIMPLE(CVC_CHAT_SEQ, terminal_type, ASN1_OBJECT),
+        /* tag: 0x53*/
+        ASN1_APP_IMP(CVC_CHAT_SEQ, relative_authorization, ASN1_OCTET_STRING, 0x13) /* discretionary data */
+} ASN1_SEQUENCE_END(CVC_CHAT_SEQ)
+/* Change the tag of the CV Cert to 0x7f4c */
+ASN1_ITEM_TEMPLATE(CVC_CHAT) =
+        ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, 0x4c, CVC_CHAT, CVC_CHAT_SEQ)
+ASN1_ITEM_TEMPLATE_END(CVC_CHAT)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CHAT)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CHAT)
+
+ASN1_SEQUENCE(CVC_PUBKEY) = {
+    ASN1_SIMPLE(CVC_PUBKEY, oid, ASN1_OBJECT),
+    /* tag: 0x81 */
+    ASN1_IMP_OPT(CVC_PUBKEY, modulus, ASN1_OCTET_STRING, 0x1),
+    /* tag: 0x82 */
+    ASN1_IMP_OPT(CVC_PUBKEY, a, ASN1_OCTET_STRING, 0x2),
+    /* tag: 0x83 */
+    ASN1_IMP_OPT(CVC_PUBKEY, b, ASN1_OCTET_STRING, 0x3),
+    /* tag: 0x84 */
+    ASN1_IMP_OPT(CVC_PUBKEY, base, ASN1_OCTET_STRING, 0x4),
+    /* tag: 0x85 */
+    ASN1_IMP_OPT(CVC_PUBKEY, base_order, ASN1_OCTET_STRING, 0x5),
+    /* tag: 0x86 */
+    ASN1_IMP_OPT(CVC_PUBKEY, public_point, ASN1_OCTET_STRING, 0x6),
+    /* tag: 0x87 */
+    ASN1_IMP_OPT(CVC_PUBKEY, cofactor, ASN1_OCTET_STRING, 0x7)
+} ASN1_SEQUENCE_END(CVC_PUBKEY)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_PUBKEY)
+
+ASN1_SEQUENCE(CVC_CERT_EXTENSION) = {
+    ASN1_SIMPLE(CVC_CERT_EXTENSION, type, ASN1_OBJECT),
+    /* tag: 0x80 */
+    ASN1_IMP(CVC_CERT_EXTENSION, hash1, ASN1_OCTET_STRING, 0),
+    /* tag: 0x81 */
+    ASN1_IMP_OPT(CVC_CERT_EXTENSION, hash2, ASN1_OCTET_STRING, 1),
+} ASN1_SEQUENCE_END(CVC_CERT_EXTENSION)
+
+ASN1_SEQUENCE(CVC_CERT_EXTENSIONS) = {
+    ASN1_APP_IMP_OPT(CVC_CERT_EXTENSIONS, certificateDescription, CVC_CERT_EXTENSION, 0x13),
+    ASN1_APP_IMP_OPT(CVC_CERT_EXTENSIONS, terminalSectors, CVC_CERT_EXTENSION, 0x13),
+} ASN1_SEQUENCE_END(CVC_CERT_EXTENSIONS)
+
+ASN1_SEQUENCE(CVC_CERT_BODY) = {
+        /* tag: 0x5f29 */
+        ASN1_APP_IMP(CVC_CERT_BODY, certificate_profile_identifier, ASN1_INTEGER, 0x29),
+        /* tag: 0x42 */
+        ASN1_APP_IMP(CVC_CERT_BODY, certificate_authority_reference, ASN1_OCTET_STRING, 0x2),
+        /* public key: tag:0x7f49 */
+        ASN1_APP_IMP(CVC_CERT_BODY, public_key, CVC_PUBKEY, 0x49),
+        /* tag: 0x5f20 */
+        ASN1_APP_IMP(CVC_CERT_BODY, certificate_holder_reference, ASN1_OCTET_STRING, 0x20),
+        /* tag: 0x7f4c */
+        ASN1_SIMPLE(CVC_CERT_BODY, chat, CVC_CHAT),
+        /* tag: 0x5f25 */
+        ASN1_APP_IMP(CVC_CERT_BODY, certificate_effective_date, ASN1_OCTET_STRING, 0x25),
+        /* tag: 0x5f24 */
+        ASN1_APP_IMP(CVC_CERT_BODY, certificate_expiration_date, ASN1_OCTET_STRING, 0x24),
+        /* tag: 0x65 */
+        ASN1_APP_IMP_OPT(CVC_CERT_BODY, certificate_extensions, CVC_CERT_EXTENSIONS, 0x5)
+} ASN1_SEQUENCE_END(CVC_CERT_BODY)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERT_BODY)
+
+ASN1_SEQUENCE(CVC_CERT_SEQ) = {
+        /* tag: 0x7F4E */
+        ASN1_APP_IMP(CVC_CERT_SEQ, body, CVC_CERT_BODY, 0x4e),
+        /* tag: 0x5F37 */
+        ASN1_APP_IMP(CVC_CERT_SEQ, signature, ASN1_OCTET_STRING, 0x37),
+} ASN1_SEQUENCE_END(CVC_CERT_SEQ)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERT_SEQ)
+
+/* Change the tag of the CV Cert to 0x7f21 */
+ASN1_ITEM_TEMPLATE(CVC_CERT) =
+        ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, 0x21, CVC_CERT, CVC_CERT_SEQ)
+ASN1_ITEM_TEMPLATE_END(CVC_CERT)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERT)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CERT)
+
+ASN1_ADB_TEMPLATE(cert_def) = ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.other, ASN1_ANY, 0x05);
+
+ASN1_ADB(CVC_CERTIFICATE_DESCRIPTION) = {
+        ADB_ENTRY(NID_id_plainFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.plainTerms, ASN1_UTF8STRING, 0x05)),
+        ADB_ENTRY(NID_id_htmlFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.htmlTerms, ASN1_IA5STRING, 0x05)),
+        ADB_ENTRY(NID_id_pdfFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.pdfTerms, ASN1_OCTET_STRING, 0x05))
+} ASN1_ADB_END(CVC_CERTIFICATE_DESCRIPTION, 0, descriptionType, 0, &cert_def_tt, NULL);
+
+ASN1_SEQUENCE(CVC_CERTIFICATE_DESCRIPTION) = {
+        ASN1_SIMPLE(CVC_CERTIFICATE_DESCRIPTION, descriptionType, ASN1_OBJECT),
+        ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, issuerName, ASN1_UTF8STRING, 0x01),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, issuerURL, ASN1_PRINTABLESTRING, 0x02),
+        ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, subjectName, ASN1_UTF8STRING, 0x03),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, subjectURL, ASN1_PRINTABLESTRING, 0x04),
+        ASN1_ADB_OBJECT(CVC_CERTIFICATE_DESCRIPTION),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, redirectURL, ASN1_PRINTABLESTRING, 0x06),
+} ASN1_SEQUENCE_END(CVC_CERTIFICATE_DESCRIPTION)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERTIFICATE_DESCRIPTION)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CERTIFICATE_DESCRIPTION)
+/** @} ***********************************************************************/
+
+/** Convert the CAR or CHR to a human readable string */
+static char *cvc_get_reference_string(ASN1_OCTET_STRING *ref);
+/** Convert the profile identifier to an integer*/
+static short cvc_get_profile_identifier(ASN1_INTEGER *id);
+#if 0
+static EC_KEY *cvc_get_ec_key(CVC_EC_PUBKEY *key_asn1);
+#endif
+
+CVC_CERT *CVC_d2i_CVC_CERT(CVC_CERT **cert, const unsigned char **in, long len) {
+	CVC_CERT *ret = NULL;
+
+	ret = d2i_CVC_CERT(cert, in, len);
+	if (!ret)
+		goto err;
+
+	/* Check whether or not all the necessary parameters for the given type of
+	 * public key are provided */
+	switch(OBJ_obj2nid(ret->body->public_key->oid)) {
+		case NID_id_TA_ECDSA_SHA_1:
+		case NID_id_TA_ECDSA_SHA_224:
+		case NID_id_TA_ECDSA_SHA_256:
+		case NID_id_TA_ECDSA_SHA_384:
+		case NID_id_TA_ECDSA_SHA_512:
+			if (!ret->body->public_key->public_point)
+				goto err;
+			break;
+		case NID_id_TA_RSA_v1_5_SHA_1:
+		case NID_id_TA_RSA_v1_5_SHA_256:
+		case NID_id_TA_RSA_v1_5_SHA_512:
+		case NID_id_TA_RSA_PSS_SHA_1:
+		case NID_id_TA_RSA_PSS_SHA_256:
+		case NID_id_TA_RSA_PSS_SHA_512:
+			if (!ret->body->public_key->modulus || !ret->body->public_key->a)
+				goto err;
+			break;
+		default:
+			goto err;
+	}
+
+	return ret;
+
+err:
+	if(ret) {
+		CVC_CERT_free(ret);
+		ret = NULL;
+	}
+
+	return ret;
+}
+
+int cvc_print(BIO *bio, CVC_CERT *cv, const char *prefix)
+{
+    int r = 0;
+    char *effective_date = NULL, *expiration_date = NULL, *car = NULL, *chr = NULL;
+    BUF_MEM *buf = NULL;
+
+    if (!bio || !cv || !cv->body || !cv->body->public_key || !prefix)
+        goto err;
+
+    buf = BUF_MEM_create(strlen(prefix) + 2);
+    buf->data[buf->length - 2] = '\t';
+    buf->data[buf->length - 1] = '\0';
+
+    effective_date = cvc_get_date_string(cv->body->certificate_effective_date);
+    expiration_date = cvc_get_date_string(cv->body->certificate_expiration_date);
+    car = cvc_get_reference_string(cv->body->certificate_authority_reference);
+    chr = cvc_get_reference_string(cv->body->certificate_holder_reference);
+
+    if (!effective_date || !expiration_date || !car || !chr)
+        goto err;
+
+    BIO_printf(bio, "%sProfile identifier: %d\n", prefix, cvc_get_profile_identifier(cv->body->certificate_profile_identifier));
+    BIO_printf(bio, "%sCAR: %s\n", prefix, car);
+    BIO_printf(bio, "%sPublic key type: %s\n", prefix, OBJ_nid2ln(OBJ_obj2nid(cv->body->public_key->oid)));
+    BIO_printf(bio, "%sCHR: %s\n", prefix, chr);
+    BIO_printf(bio, "%sCHAT:\n", prefix);
+    cvc_chat_print(bio, cvc_get_chat(cv), buf->data);
+    BIO_printf(bio, "%sEffective Date: %s\n", prefix, effective_date);
+    BIO_printf(bio, "%sExpiration Date: %s\n", prefix, expiration_date);
+    if (cv->body->certificate_extensions) {
+        BIO_printf(bio, "%sExtensions:\n", prefix);
+        BIO_printf(bio, "%s\tDescription type: %s\n", prefix, OBJ_nid2ln(OBJ_obj2nid(cv->body->certificate_extensions->certificateDescription->type)));
+        BIO_printf(bio, "%s\tTerminal sector: %s\n", prefix, OBJ_nid2ln(OBJ_obj2nid(cv->body->certificate_extensions->terminalSectors->type)));
+    }
+
+    r = 1;
+
+err:
+    if (effective_date)
+        OPENSSL_free(effective_date);
+    if (expiration_date)
+        OPENSSL_free(expiration_date);
+    if (car)
+        OPENSSL_free(car);
+    if (chr)
+        OPENSSL_free(chr);
+    if (buf)
+        BUF_MEM_free(buf);
+
+    return r;
+}
+
+int cvc_chat_print(BIO *bio, CVC_CHAT *chat, char prefix[]) {
+
+    int ok = 0, nid = 0, rel_auth_len = 0, rel_auth_num_bytes = 0, i, j = 1;
+    const const char **strings;
+
+    if (!bio || !chat || !chat->relative_authorization
+            || !chat->relative_authorization->data)
+        goto err;
+
+    /* Figure out what kind of CHAT we have */
+    nid = OBJ_obj2nid(chat->terminal_type);
+    switch(nid) {
+        case NID_id_AT:
+            BIO_printf(bio, "%sAuthentication terminal\n", prefix);
+            strings = at_chat_strings;
+            rel_auth_len = 38;
+            rel_auth_num_bytes = 5;
+            break;
+        case NID_id_IS:
+            BIO_printf(bio, "%sInspection system\n", prefix);
+            strings = is_chat_strings;
+            rel_auth_len = 6;
+            rel_auth_num_bytes = 1;
+            break;
+        case NID_id_ST:
+            BIO_printf(bio, "%sSignature terminal\n", prefix);
+            strings = st_chat_strings;
+            rel_auth_len = 6;
+            rel_auth_num_bytes = 1;
+            break;
+        default:
+            BIO_printf(bio, "%sInvalid terminal type\n", prefix);
+            goto err;
+    }
+
+    /* Sanity check: Does the received CHAT have the correct length? */
+    if(chat->relative_authorization->length != rel_auth_num_bytes)
+        goto err;
+
+    /* Dump the relative authorization bitstring in human readable form.
+     * Each set Bit means one authorization */
+    for (i = 0; i <= rel_auth_len; i++) {
+        if (i % 8 == 0 && i != 0)
+            j++;
+        if (CHECK_BIT(chat->relative_authorization->data[rel_auth_num_bytes - j],
+                i % 8))
+            BIO_printf(bio, "%s\t%s\n", prefix, strings[i]);
+    }
+
+    /* The most significant two bits contain the role of the terminal */
+    switch(chat->relative_authorization->data[rel_auth_num_bytes - 1] & (3 << 6)) {
+        case 3:
+            BIO_printf(bio, "%s\tCVCA certificate\n", prefix);
+            break;
+        case 2:
+        case 1:
+            BIO_printf(bio, "%s\tDV certificate\n", prefix);
+            break;
+        case 0:
+            BIO_printf(bio, "%s\tTerminal certificate\n", prefix);
+            break;
+    }
+
+    ok = 1;
+
+err:
+    return ok;
+}
+
+#if 0
+/* Extract the public key from a CV certificate */
+EC_KEY *
+cvc_get_ec_key(CVC_EC_PUBKEY *key_asn1)
+{
+    EC_KEY *key = NULL;
+
+    if (!key_asn1)
+        goto err;
+
+    /* XXX: Check OID? */
+    if (ec_key_from_asn1(&key, key_asn1->modulus, key_asn1->a, key_asn1->b,
+            key_asn1->base, key_asn1->base_order, key_asn1->public_point,
+            key_asn1->cofactor))
+        printf("Copied public key\n");
+    else
+        printf("Failed to copy public key\n");
+
+err:
+    return key;
+
+}
+#endif
+
+short
+cvc_get_profile_identifier(ASN1_INTEGER *id)
+{
+    long l;
+    if (!id || !id->data)
+        return -1;
+    l = ASN1_INTEGER_get(id);
+    return (l == 0) ? 0 : -1; /* The only specified version number is 0 right now */
+}
+
+char *
+cvc_get_reference_string(ASN1_OCTET_STRING *ref)
+{
+    /* Used to check CAR and CHR */
+    /* Max length is 16 byte: 2 Byte country code (ASCII), max. 9 Byte Holder
+     *      Mnemonic, 5 Byte Sequence Number (ASCII A-Z, 0-9)
+     */
+
+    int i;
+    char *ret = NULL;
+    char c;
+
+    if (!ref || !ref->data || ref->length > 16)
+        return NULL;
+
+    ret = (char *) OPENSSL_malloc(ref->length + 1);
+    if (!ret)
+        return NULL;
+
+    for (i = 0; i < ref->length; i++) {
+        c = ref->data[i];
+        /*XXX: For now we accept Alphanumeric characters only */
+        if (((c >= 0x30) && (c <= 0x39)) || ((c >= 0x41) && (c <= 0x5A)))
+            ret[i] = c;
+        else {
+            OPENSSL_free(ret);
+            return NULL;
+        }
+
+    }
+
+    ret[ref->length] = 0;
+    return ret;
+}
+
+char *
+cvc_get_date_string(ASN1_OCTET_STRING *date)
+{
+    int i;
+    char *ret = (char *) OPENSSL_malloc(7);
+
+    if (!ret || !date || !date->data || date->length != 6)
+        return NULL;
+
+    for(i = 0; i < date->length; i++) {
+        if (date->data[i] <= 9)
+            /* Convert to ASCII digit */
+            ret[i] = date->data[i] + 0x30;
+        else { /* Invalid character */
+            OPENSSL_free(ret);
+            return NULL;
+        }
+
+    }
+
+    ret[6] = 0; /* Null-terminate string */
+    return ret;
+}
+
+int
+certificate_description_print(BIO *bio, const unsigned char *cert_desc_in,
+        unsigned int len, const char *prefix)
+{
+    CVC_CERTIFICATE_DESCRIPTION *cert_desc = NULL;
+    int ret = -1, nid;
+
+    cert_desc = d2i_CVC_CERTIFICATE_DESCRIPTION(NULL, &cert_desc_in, len);
+    if (cert_desc == NULL) {
+        goto err;
+    }
+
+    BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[0],
+            cert_desc->issuerName->data);
+    if (cert_desc->issuerURL)
+        BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[1],
+                cert_desc->issuerURL->data);
+    BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[2],
+            cert_desc->subjectName->data);
+    if (cert_desc->subjectURL)
+        BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[3],
+                cert_desc->subjectURL->data);
+    if (cert_desc->redirectURL)
+        BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[4],
+                cert_desc->redirectURL->data);
+
+    nid = OBJ_obj2nid(cert_desc->descriptionType);
+    switch (nid) {
+        case NID_id_plainFormat:
+            BIO_printf(bio, "%s%s\t%s\n", prefix, cert_desc_field_strings[5],
+                    cert_desc->termsOfUsage.plainTerms->data);
+            break;
+            ret = 0;
+        case NID_id_htmlFormat:
+            ret = 1;
+            break;
+        case NID_id_pdfFormat:
+            ret = 2;
+            break;
+        default:
+            /* Unknown format for terms of usage */
+            break;
+    }
+
+    CVC_CERTIFICATE_DESCRIPTION_free(cert_desc);
+
+err:
+    return ret;
+
+}
+
+CVC_CHAT*
+cvc_get_chat(CVC_CERT *cvc) {
+
+    if (!cvc || !cvc->body)
+        return NULL;
+
+    return cvc->body->chat;
+}
+
+int
+CVC_check_cert(CVC_CERT *cv, const unsigned char *cert_desc_in,
+        const unsigned int cert_desc_in_len)
+{
+
+    BUF_MEM *desc_hash = NULL;
+    EVP_MD *md = NULL;
+    EVP_MD_CTX *md_ctx = NULL;
+
+    unsigned int ret = 0, tmp_len;
+
+    if (!cv || !cv->body || !cv->body->public_key)
+        goto err;
+
+    md_ctx = EVP_MD_CTX_create();
+
+    /* Chose the correct hash function */
+    switch(OBJ_obj2nid(cv->body->public_key->oid)) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_1:
+            md = EVP_sha1();
+            break;
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_256:
+            md = EVP_sha256();
+            break;
+        case NID_id_TA_ECDSA_SHA_512:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            md = EVP_sha512();
+            break;
+/*        case NID_id_TA_ECDSA_SHA_224:
+            md = EVP_sha224();
+        case NID_id_TA_ECDSA_SHA_384:
+            md = EVP_sha384();*/
+        default:
+            goto err;
+    }
+    desc_hash = BUF_MEM_create(EVP_MD_size(md));
+
+    if (!md_ctx || !desc_hash)
+        goto err;
+
+    if (cv->body->certificate_extensions &&
+            cv->body->certificate_extensions->certificateDescription &&
+            cv->body->certificate_extensions->certificateDescription->hash1) {
+
+        /* Check whether or not the hash in the certificate has the correct size */
+        if (cv->body->certificate_extensions->certificateDescription->hash1->length
+                != EVP_MD_size(md)) {
+            ret = -1;
+            goto err;
+        }
+
+        /* Hash the certificate description */
+        tmp_len = EVP_MD_size(md);
+        if (!EVP_DigestInit_ex(md_ctx, md, NULL) ||
+                !EVP_DigestUpdate(md_ctx, cert_desc_in, cert_desc_in_len) ||
+                !EVP_DigestFinal_ex(md_ctx, (unsigned char *) desc_hash->data,
+                        &tmp_len)) {
+            ret = -1;
+            goto err;
+        }
+        desc_hash->length = tmp_len;
+
+        /* Compare it with the hash in the cert */
+        if (memcmp(desc_hash->data,
+                cv->body->certificate_extensions->certificateDescription->hash1,
+                desc_hash->length))
+            ret = 1;
+    }
+
+err:
+    if (md_ctx)
+        EVP_MD_CTX_destroy(md_ctx);
+    if (desc_hash)
+        BUF_MEM_free(desc_hash);
+    return ret;
+}
Index: openssl/crypto/cv_cert/cv_cert.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/cv_cert/cv_cert.h	2010-10-26 11:18:00.000000000 +0200
@@ -0,0 +1,314 @@
+/**
+ * @file
+ * @brief Interface to library for card verifiable certificates
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef CVC_CERT_H_
+#define CVC_CERT_H_
+
+#include <openssl/asn1t.h>
+#include <openssl/asn1.h>
+#include <openssl/bio.h>
+
+/** Application specific, IMPLICIT tagged ASN1 type */
+#define ASN1_APP_IMP(stname, field, type, tag) ASN1_EX_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, tag, stname, field, type)
+/** Application specific, IMPLICIT tagged, optional ASN1 type */
+#define ASN1_APP_IMP_OPT(stname, field, type, tag) ASN1_EX_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION|ASN1_TFLG_OPTIONAL, tag, stname, field, type)
+
+/**
+ * @defgroup cvctypes      Data types for card verifiable certificates
+ * @{ ************************************************************************/
+
+/** Certificate Holder Authentication template*/
+typedef struct cvc_chat_seq_st {
+    /** What kind of terminals does this certificate belong to (Inspection System,
+     *  Authentication Terminal or Signature terminal) */
+    ASN1_OBJECT *terminal_type;
+    /** What datagroups or special functions may the terminal access */
+    ASN1_OCTET_STRING *relative_authorization;
+} CVC_CHAT_SEQ;
+/** Short name for CVC_CHAT_SEQ */
+typedef CVC_CHAT_SEQ CVC_CHAT;
+
+/** Elliptic curve public key. May contain domain parameters*/
+typedef struct cvc_pubkey_st {
+    ASN1_OBJECT *oid;
+    ASN1_OCTET_STRING *modulus;
+    ASN1_OCTET_STRING *a;
+    ASN1_OCTET_STRING *b;
+    ASN1_OCTET_STRING *base;
+    ASN1_OCTET_STRING *base_order;
+    ASN1_OCTET_STRING *public_point;
+    ASN1_OCTET_STRING *cofactor;
+} CVC_PUBKEY;
+
+/** Discretionary data template, used to encode certificate extensions. Consists
+ *  of an OID and up to two hash values */
+typedef struct cvc_cert_extension_st {
+    ASN1_OBJECT *type;
+    ASN1_OCTET_STRING *hash1;
+    ASN1_OCTET_STRING *hash2;
+} CVC_CERT_EXTENSION;
+
+//XXX: This should actually not be a SEQUENCE
+/** Two kinds of certificate extensions are specified */
+typedef struct cvc_cert_extensions_st {
+    /** Contains the hash of the certificate description associated with this
+     *  certifcate */
+    CVC_CERT_EXTENSION *certificateDescription;
+    /** Contains up to two hashes of public keys for restricted identification */
+    CVC_CERT_EXTENSION *terminalSectors;
+} CVC_CERT_EXTENSIONS;
+
+/** The body of the certificate */
+typedef struct cvc_cert_body_st {
+    /** Certificate Profile of this certificate. Only version number 0 is
+     *  specified */
+    ASN1_INTEGER *certificate_profile_identifier;
+    /** Certificate authority that issued this certificate */
+    ASN1_UTF8STRING *certificate_authority_reference; /* Actually Latin1 */
+    /** Public key associated with this certificate */
+    CVC_PUBKEY *public_key;
+    /** Holder of the certificate */
+    ASN1_UTF8STRING *certificate_holder_reference; /* Actually Latin1 */
+    /** Certificate Holder Authorisation Template */
+    CVC_CHAT *chat;
+    /** Date the certificate was issued. Format: YYMMDD, BCD encoded */
+    ASN1_OCTET_STRING *certificate_effective_date;
+    /** Date until which the certicate is valid. Format: YYMMDD, BCD encoded  */
+    ASN1_OCTET_STRING *certificate_expiration_date;
+    /** Optional extensions */
+    CVC_CERT_EXTENSIONS *certificate_extensions;
+} CVC_CERT_BODY;
+
+/** The actual certifcate, consisting of the body and a signature */
+typedef struct cvc_cert_seq_st {
+    /** Body of the certificate */
+    CVC_CERT_BODY *body;
+    /** Signature calculated over the hash of the certificate body */
+    ASN1_OCTET_STRING *signature;
+} CVC_CERT_SEQ;
+/** Short name for CVC_CERT_SEQ */
+typedef CVC_CERT_SEQ CVC_CERT;
+
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup certificatedescriptiontypes  Data Types for the Certificate
+ *                  Description structure
+ * @{ ************************************************************************/
+
+/** This structure holds further information about a card verifiable certificate
+ *  in human readable form. It should be displayed to the user along with the
+ *  access rights encoded in the CHAT of the certificate. A hash of this description
+ *  may be contained in the certificate. */
+ typedef struct cvc_certificate_description_st {
+    /** Format of the description (Plain Text, PDF or HTML) */
+    ASN1_OBJECT *descriptionType;
+    /** Human readable name of the issuer of this certificate */
+    ASN1_UTF8STRING *issuerName;
+    /** Optional URL that points to informations about the issuer of this
+     *  certificate */
+    ASN1_PRINTABLESTRING *issuerURL;
+    /** Human readable name of the holder of this certificate */
+    ASN1_UTF8STRING *subjectName;
+    /** Optional URL that points to informations about the holder of this
+     *  certificate */
+    ASN1_PRINTABLESTRING *subjectURL;
+    union {
+        /** Plaintext Terms of Usage */
+        ASN1_UTF8STRING *plainTerms;
+        /** HTML formatted Terms of Usage */
+        ASN1_IA5STRING *htmlTerms;
+        /** PDF formatted Terms of Usage */
+        ASN1_OCTET_STRING *pdfTerms;
+        /** Otherwise formatted Terms of Usage (not specified) */
+        ASN1_TYPE *other;
+    } termsOfUsage;
+    ASN1_PRINTABLESTRING *redirectURL;
+} CVC_CERTIFICATE_DESCRIPTION;
+
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup mgmtfunctions  Functions for memory managment and data conversion
+ * @{ ************************************************************************/
+
+/**
+ * @brief Convert an ASN1 formatted CV certificate to the internal structure
+ * @param cert A pointer to the internal structure.
+ * @param in The ASN1 formatted data
+ * @param len The length of the data
+ *
+ * @return the CVC_CERT structure or NULL in case of an error
+ * */
+CVC_CERT *CVC_d2i_CVC_CERT(CVC_CERT **cert, const unsigned char **in, long len);
+
+/**
+ * @brief Convert a certificate description to an ASN1 representation
+ *
+ * @param[in] a the certificate description
+ * @param[out] out where to write the ASN1 data
+ *
+ * @return the number of bytes successfully encoded or a negative value if an
+ * error occured.
+ */
+int i2d_CVC_CERT(CVC_CERT *a, unsigned char **out);
+
+/**
+ * @brief Allocate memory for a CV certificate structure
+ * */
+CVC_CERT *CVC_CERT_new(void);
+/**
+ * @brief Free a CV certificate structure
+ * @param a Pointer to the structure to be freed
+ * */
+void CVC_CERT_free(CVC_CERT *a);
+
+//void CVC_CERT_print_ctx(BIO *bio, CVC_CERT *cert, int indent, const ASN1_PCTX *pctx);
+DECLARE_ASN1_PRINT_FUNCTION(CVC_CERT)
+
+DECLARE_ASN1_FUNCTIONS(CVC_CERTIFICATE_DESCRIPTION)
+DECLARE_ASN1_PRINT_FUNCTION(CVC_CERTIFICATE_DESCRIPTION)
+
+DECLARE_ASN1_FUNCTIONS(CVC_CHAT);
+
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup convenience        Convenience functions
+ * @{ ************************************************************************/
+
+/**
+ * @brief Print the certificate description in a human readable form
+ *
+ * @param[in] bio
+ * @param[in] cert_desc_in
+ * @param[in] len
+ * @param[in] prefix prepend @a prefix to each line (for indentation)
+ *
+ * @return 1 on success and 0 if an error occurred
+ */
+int certificate_description_print(BIO *bio, const unsigned char *cert_desc_in,
+        unsigned int len, const char *prefix);
+
+/**
+ * @brief Print card holder authorization template (CHAT) in a human readable form
+ *
+ * @param[in] bio
+ * @param[in] chat The CHAT that shell be dumped
+ * @param[in] prefix prepend @a prefix to each line (for indentation)
+ *
+ * @return 1 on success and 0 if an error occurred
+ * */
+int
+cvc_chat_print(BIO *bio, CVC_CHAT *chat, char prefix[]);
+
+/**
+ * @brief Print card verifiable certificate in a human readable form
+ *
+ * @param[in] bio
+ * @param[in] cv
+ * @param[in] prefix prepend @a prefix to each line (for indentation)
+ *
+ * @return 1 on success and 0 if an error occurred
+ * */
+int
+cvc_print(BIO *bio, CVC_CERT *cv, const char *prefix);
+
+/**
+ *  @brief Returns a pointer to the CHAT contained in a CV certifcate.
+ *  @param[in] cvc The card verifiable certifcate
+
+ *  @return Pointer to the CHAT or NULL in case of an error
+ */
+CVC_CHAT*
+cvc_get_chat(CVC_CERT *cvc);
+
+/**
+ *  @brief Helper function to convert the effective date and expiration date,
+ *         of a certificate to a string
+ *  @param[in] date Octet string that holds the date
+ *  @return Null terminated string representation of the date
+ */
+char*
+cvc_get_date_string(ASN1_OCTET_STRING *date);
+
+/** @} ***********************************************************************/
+
+/**
+ *  @brief Check wether or not the certificate contains the correct hash
+ *         of the certificate description
+ *  @param[in] cv The card verifiable certificate
+ *  @param[in] cert_desc_in ASN1 representation of the certificate description
+ *  @param[in] cert_desc_in_len Length of cvc_desc_in
+ *
+ *  @return 1 if the certificate contains the correct hash, 0 if not and -1 in case of
+ *      an error.
+ */
+int
+CVC_check_cert(CVC_CERT *cv, const unsigned char *cert_desc_in,
+        const unsigned int cert_desc_in_len);
+
+/**
+ * @defgroup ec_asn1        ASN1 structures for EC parameters and keys
+ * @{ ************************************************************************/
+
+/* I stole these from ec_asn1.c */
+
+typedef struct x9_62_pentanomial_st {
+    long k1;
+    long k2;
+    long k3;
+    } PACE_X9_62_PENTANOMIAL;
+
+typedef struct pace_x9_62_characteristic_two_st {
+    long m;
+    ASN1_OBJECT  *type;
+    union   {
+        char *ptr;
+        /* NID_X9_62_onBasis */
+        ASN1_NULL    *onBasis;
+        /* NID_X9_62_tpBasis */
+        ASN1_INTEGER *tpBasis;
+        /* NID_X9_62_ppBasis */
+        PACE_X9_62_PENTANOMIAL *ppBasis;
+        /* anything else */
+        ASN1_TYPE *other;
+        } p;
+    } PACE_X9_62_CHARACTERISTIC_TWO;
+
+typedef struct pace_x9_62_fieldid_st {
+        ASN1_OBJECT *fieldType;
+    union   {
+        char *ptr;
+        /* NID_X9_62_prime_field */
+        ASN1_INTEGER *prime;
+        /* NID_X9_62_characteristic_two_field */
+        PACE_X9_62_CHARACTERISTIC_TWO *char_two;
+        /* anything else */
+        ASN1_TYPE *other;
+        } p;
+    } PACE_X9_62_FIELDID;
+
+typedef struct pace_x9_62_curve_st {
+        ASN1_OCTET_STRING *a;
+        ASN1_OCTET_STRING *b;
+        ASN1_BIT_STRING   *seed;
+        } PACE_X9_62_CURVE;
+
+typedef struct pace_ec_parameters_st {
+    ASN1_INTEGER           *version;
+    PACE_X9_62_FIELDID     *fieldID;
+    PACE_X9_62_CURVE       *curve;
+    ASN1_OCTET_STRING *base;
+    ASN1_INTEGER      *order;
+    ASN1_INTEGER      *cofactor;
+    } PACE_ECPARAMETERS;
+
+/** @} ***********************************************************************/
+
+#endif /* CVC_CERT_H_ */
Index: openssl/crypto/ec/ec.h
===================================================================
--- openssl.orig/crypto/ec/ec.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/ec/ec.h	2010-10-14 13:47:08.000000000 +0200
@@ -1094,6 +1094,19 @@
 #define EC_R_UNSUPPORTED_FIELD				 131
 #define EC_R_WRONG_ORDER				 130
 
+#include <openssl/buffer.h>
+/**
+ * @brief converts an EC_POINT object to a BUF_MEM object
+ *
+ * @param ecdh EC_KEY object
+ * @param bn_ctx object (optional)
+ * @param ecp elliptic curve point to convert
+ *
+ * @return converted elliptic curve point or NULL if an error occurred
+ */
+BUF_MEM *
+EC_POINT_point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp);
+
 #ifdef  __cplusplus
 }
 #endif
Index: openssl/crypto/ec/ec_print.c
===================================================================
--- openssl.orig/crypto/ec/ec_print.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/ec/ec_print.c	2010-10-14 13:47:08.000000000 +0200
@@ -54,6 +54,7 @@
  */
 
 #include <openssl/crypto.h>
+#include <openssl/buffer.h>
 #include "ec_lcl.h"
 
 BIGNUM *EC_POINT_point2bn(const EC_GROUP *group, 
@@ -193,3 +194,25 @@
 
 	return ret;
 	}
+
+BUF_MEM *
+EC_POINT_point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp)
+{
+    size_t len;
+    BUF_MEM * out;
+
+    len = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), NULL, 0, bn_ctx);
+    if (len == 0)
+        return NULL;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    out->length = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), (unsigned char *) out->data, out->max,
+            bn_ctx);
+
+    return out;
+}
Index: openssl/crypto/ecdh/ecdh.h
===================================================================
--- openssl.orig/crypto/ecdh/ecdh.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/ecdh/ecdh.h	2010-10-14 13:47:08.000000000 +0200
@@ -86,6 +86,7 @@
 #endif
 
 const ECDH_METHOD *ECDH_OpenSSL(void);
+const ECDH_METHOD *ECDH_OpenSSL_Point(void);
 
 void	  ECDH_set_default_method(const ECDH_METHOD *);
 const ECDH_METHOD *ECDH_get_default_method(void);
Index: openssl/crypto/ecdh/ech_ossl.c
===================================================================
--- openssl.orig/crypto/ecdh/ech_ossl.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/ecdh/ech_ossl.c	2010-10-14 13:47:08.000000000 +0200
@@ -211,3 +211,113 @@
 	if (buf) OPENSSL_free(buf);
 	return(ret);
 	}
+
+static int ecdh_compute_key_point(void *out, size_t len, const EC_POINT *pub_key,
+	EC_KEY *ecdh,
+	void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen));
+
+static ECDH_METHOD openssl_ecdh_meth_point = {
+	"OpenSSL ECDH method with Point",
+	ecdh_compute_key_point,
+#if 0
+	NULL, /* init     */
+	NULL, /* finish   */
+#endif
+	0,    /* flags    */
+	NULL  /* app_data */
+};
+
+const ECDH_METHOD *ECDH_OpenSSL_Point(void)
+	{
+	return &openssl_ecdh_meth_point;
+	}
+/* This implementation calculates the point as in ecdh_compute_key.
+ * Finally an optional KDF is applied to the point rather than to the x-coordinate as done in ecdh_compute_key.
+ */
+int ecdh_compute_key_point(void *out, size_t outlen, const EC_POINT *pub_key,
+	EC_KEY *ecdh,
+	void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))
+	{
+	BN_CTX *ctx;
+	EC_POINT *tmp=NULL;
+	const BIGNUM *priv_key;
+	const EC_GROUP* group;
+	int ret= -1;
+	size_t buflen;
+	unsigned char *buf=NULL;
+
+	if (outlen > INT_MAX)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE); /* sort of, anyway */
+		return -1;
+		}
+
+	if ((ctx = BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+
+	priv_key = EC_KEY_get0_private_key(ecdh);
+	if (priv_key == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_NO_PRIVATE_VALUE);
+		goto err;
+		}
+
+	group = EC_KEY_get0_group(ecdh);
+	if ((tmp=EC_POINT_new(group)) == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if (!EC_POINT_mul(group, tmp, NULL, pub_key, priv_key, ctx))
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_POINT_ARITHMETIC_FAILURE);
+		goto err;
+		}
+
+
+        buflen = EC_POINT_point2oct(group, tmp,
+                EC_KEY_get_conv_form(ecdh), NULL, 0, ctx);
+        if (buflen < 0)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_BN_LIB);
+		goto err;
+		}
+	if ((buf = OPENSSL_malloc(buflen)) == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+        if (buflen != EC_POINT_point2oct(group, tmp,
+                    EC_KEY_get_conv_form(ecdh), buf, buflen, ctx))
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_BN_LIB);
+		goto err;
+		}
+
+	if (KDF != 0)
+		{
+		if (KDF(buf, buflen, out, &outlen) == NULL)
+			{
+			ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_KDF_FAILED);
+			goto err;
+			}
+		ret = outlen;
+		}
+	else
+		{
+		/* no KDF, just copy as much as we can */
+		if (outlen > buflen)
+			outlen = buflen;
+		memcpy(out, buf, outlen);
+		ret = outlen;
+		}
+
+err:
+	if (tmp) EC_POINT_free(tmp);
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+	if (buf) OPENSSL_free(buf);
+	return(ret);
+	}
Index: openssl/crypto/err/err.c
===================================================================
--- openssl.orig/crypto/err/err.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/err/err.c	2010-10-14 13:47:08.000000000 +0200
@@ -156,6 +156,7 @@
 {ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
 {ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
 {ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
+{ERR_PACK(ERR_LIB_PACE,0,0)             ,"PACE routines"},
 {0,NULL},
 	};
 
Index: openssl/crypto/err/err.h
===================================================================
--- openssl.orig/crypto/err/err.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/err/err.h	2010-10-14 13:47:08.000000000 +0200
@@ -198,6 +198,7 @@
 #define ERR_LIB_TS		47
 #define ERR_LIB_HMAC		48
 #define ERR_LIB_JPAKE		49
+#define ERR_LIB_PACE		50
 
 #define ERR_LIB_USER		128
 
@@ -234,6 +235,7 @@
 #define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)
 #define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)
 #define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)
+#define PACEerr(f,r) ERR_PUT_error(ERR_LIB_PACE,(f),(r),__FILE__,__LINE__)
 
 /* Borland C seems too stupid to be able to shift and do longs in
  * the pre-processor :-( */
Index: openssl/crypto/err/err_all.c
===================================================================
--- openssl.orig/crypto/err/err_all.c	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/err/err_all.c	2010-10-14 13:47:08.000000000 +0200
@@ -102,6 +102,9 @@
 #ifndef OPENSSL_NO_JPAKE
 #include <openssl/jpake.h>
 #endif
+#ifndef OPENSSL_NO_PACE
+#include <openssl/pace.h>
+#endif
 #include <openssl/comp.h>
 
 void ERR_load_crypto_strings(void)
@@ -155,6 +158,9 @@
 #ifndef OPENSSL_NO_JPAKE
 	ERR_load_JPAKE_strings();
 #endif
+#ifndef OPENSSL_NO_PACE
+	ERR_load_PACE_strings();
+#endif
 	ERR_load_COMP_strings();
 #endif
 	}
Index: openssl/crypto/err/openssl.ec
===================================================================
--- openssl.orig/crypto/err/openssl.ec	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/err/openssl.ec	2010-10-14 13:47:08.000000000 +0200
@@ -35,6 +35,7 @@
 L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
 L CMS		crypto/cms/cms.h		crypto/cms/cms_err.c
 L JPAKE		crypto/jpake/jpake.h		crypto/jpake/jpake_err.c
+L PACE		crypto/pace/pace.h		crypto/pace/pace_err.c
 
 # additional header files to be scanned for function names
 L NONE		crypto/x509/x509_vfy.h		NONE
Index: openssl/crypto/objects/obj_mac.h
===================================================================
--- openssl.orig/crypto/objects/obj_mac.h	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/objects/obj_mac.h	2010-10-26 11:18:00.000000000 +0200
@@ -122,7 +122,7 @@
 
 #define SN_wap_wsg		"wap-wsg"
 #define NID_wap_wsg		679
-#define OBJ_wap_wsg		OBJ_wap,1L
+#define OBJ_wap_wsg		OBJ_wap,13L
 
 #define SN_selected_attribute_types		"selected-attribute-types"
 #define LN_selected_attribute_types		"Selected Attribute Types"
@@ -3968,3 +3968,211 @@
 #define NID_brainpoolP512t1		906
 #define OBJ_brainpoolP512t1		1L,3L,36L,3L,3L,2L,8L,1L,1L,14L
 
+#define OBJ_bsi_de		0L,4L,0L,127L,0L,7L
+
+#define OBJ_id_PACE		OBJ_bsi_de,2L,2L,4L
+
+#define SN_id_PACE_DH_GM		"id-PACE-DH-GM"
+#define NID_id_PACE_DH_GM		907
+#define OBJ_id_PACE_DH_GM		OBJ_id_PACE,1L
+
+#define SN_id_PACE_DH_GM_3DES_CBC_CBC		"id-PACE-DH-GM-3DES-CBC-CBC"
+#define NID_id_PACE_DH_GM_3DES_CBC_CBC		908
+#define OBJ_id_PACE_DH_GM_3DES_CBC_CBC		OBJ_id_PACE_DH_GM,1L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_128		"id-PACE-DH-GM-AES-CBC-CMAC-128"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_128		909
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_128		OBJ_id_PACE_DH_GM,2L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_192		"id-PACE-DH-GM-AES-CBC-CMAC-192"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_192		910
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_192		OBJ_id_PACE_DH_GM,3L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_256		"id-PACE-DH-GM-AES-CBC-CMAC-256"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_256		911
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_256		OBJ_id_PACE_DH_GM,4L
+
+#define SN_id_PACE_ECDH_GM		"id-PACE-ECDH-GM"
+#define NID_id_PACE_ECDH_GM		912
+#define OBJ_id_PACE_ECDH_GM		OBJ_id_PACE,2L
+
+#define SN_id_PACE_ECDH_GM_3DES_CBC_CBC		"id-PACE-ECDH-GM-3DES-CBC-CBC"
+#define NID_id_PACE_ECDH_GM_3DES_CBC_CBC		913
+#define OBJ_id_PACE_ECDH_GM_3DES_CBC_CBC		OBJ_id_PACE_ECDH_GM,1L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_128		"id-PACE-ECDH-GM-AES-CBC-CMAC-128"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128		914
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_128		OBJ_id_PACE_ECDH_GM,2L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_192		"id-PACE-ECDH-GM-AES-CBC-CMAC-192"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192		915
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_192		OBJ_id_PACE_ECDH_GM,3L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_256		"id-PACE-ECDH-GM-AES-CBC-CMAC-256"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256		916
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_256		OBJ_id_PACE_ECDH_GM,4L
+
+#define SN_id_PACE_DH_IM		"id-PACE-DH-IM"
+#define NID_id_PACE_DH_IM		917
+#define OBJ_id_PACE_DH_IM		OBJ_id_PACE,3L
+
+#define SN_id_PACE_DH_IM_3DES_CBC_CBC		"id-PACE-DH-IM-3DES-CBC-CBC"
+#define NID_id_PACE_DH_IM_3DES_CBC_CBC		918
+#define OBJ_id_PACE_DH_IM_3DES_CBC_CBC		OBJ_id_PACE_DH_IM,1L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_128		"id-PACE-DH-IM-AES-CBC-CMAC-128"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_128		919
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_128		OBJ_id_PACE_DH_IM,2L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_192		"id-PACE-DH-IM-AES-CBC-CMAC-192"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_192		920
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_192		OBJ_id_PACE_DH_IM,3L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_256		"id-PACE-DH-IM-AES-CBC-CMAC-256"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_256		921
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_256		OBJ_id_PACE_DH_IM,4L
+
+#define SN_id_PACE_ECDH_IM		"id-PACE-ECDH-IM"
+#define NID_id_PACE_ECDH_IM		922
+#define OBJ_id_PACE_ECDH_IM		OBJ_id_PACE,4L
+
+#define SN_id_PACE_ECDH_IM_3DES_CBC_CBC		"id-PACE-ECDH-IM-3DES-CBC-CBC"
+#define NID_id_PACE_ECDH_IM_3DES_CBC_CBC		923
+#define OBJ_id_PACE_ECDH_IM_3DES_CBC_CBC		OBJ_id_PACE_ECDH_IM,1L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_128		"id-PACE-ECDH-IM-AES-CBC-CMAC-128"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128		924
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_128		OBJ_id_PACE_ECDH_IM,2L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_192		"id-PACE-ECDH-IM-AES-CBC-CMAC-192"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192		925
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_192		OBJ_id_PACE_ECDH_IM,3L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_256		"id-PACE-ECDH-IM-AES-CBC-CMAC-256"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256		926
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_256		OBJ_id_PACE_ECDH_IM,4L
+
+#define SN_ansi_x942		"ansi-x942"
+#define NID_ansi_x942		927
+#define OBJ_ansi_x942		OBJ_ISO_US,10046L
+
+#define OBJ_x942_number_type		OBJ_ansi_x942,2L
+
+#define SN_dhpublicnumber		"dhpublicnumber"
+#define NID_dhpublicnumber		928
+#define OBJ_dhpublicnumber		OBJ_x942_number_type,1L
+
+#define OBJ_id_ecc		OBJ_bsi_de,1L,1L
+
+#define OBJ_ecka_dh		OBJ_id_ecc,5L,2L
+
+#define SN_ecka_dh_SessionKDF		"ecka-dh-SessionKDF"
+#define NID_ecka_dh_SessionKDF		929
+#define OBJ_ecka_dh_SessionKDF		OBJ_ecka_dh,2L
+
+#define SN_ecka_dh_SessionKDF_DES3		"ecka-dh-SessionKDF-DES3"
+#define NID_ecka_dh_SessionKDF_DES3		930
+#define OBJ_ecka_dh_SessionKDF_DES3		OBJ_ecka_dh,2L,1L
+
+#define SN_ecka_dh_SessionKDF_AES128		"ecka-dh-SessionKDF-AES128"
+#define NID_ecka_dh_SessionKDF_AES128		931
+#define OBJ_ecka_dh_SessionKDF_AES128		OBJ_ecka_dh,2L,2L
+
+#define SN_ecka_dh_SessionKDF_AES192		"ecka-dh-SessionKDF-AES192"
+#define NID_ecka_dh_SessionKDF_AES192		932
+#define OBJ_ecka_dh_SessionKDF_AES192		OBJ_ecka_dh,2L,3L
+
+#define SN_ecka_dh_SessionKDF_AES256		"ecka-dh-SessionKDF-AES256"
+#define NID_ecka_dh_SessionKDF_AES256		933
+#define OBJ_ecka_dh_SessionKDF_AES256		OBJ_ecka_dh,2L,4L
+
+#define OBJ_id_TA		OBJ_bsi_de,2L,2L,2L
+
+#define SN_id_TA_RSA		"id-TA-RSA"
+#define NID_id_TA_RSA		934
+#define OBJ_id_TA_RSA		OBJ_id_TA,1L
+
+#define SN_id_TA_RSA_v1_5_SHA_1		"id-TA-RSA-v1-5-SHA-1"
+#define NID_id_TA_RSA_v1_5_SHA_1		935
+#define OBJ_id_TA_RSA_v1_5_SHA_1		OBJ_id_TA_RSA,1L
+
+#define SN_id_TA_RSA_v1_5_SHA_256		"id-TA-RSA-v1-5-SHA-256"
+#define NID_id_TA_RSA_v1_5_SHA_256		936
+#define OBJ_id_TA_RSA_v1_5_SHA_256		OBJ_id_TA_RSA,2L
+
+#define SN_id_TA_RSA_PSS_SHA_1		"id-TA-RSA-PSS-SHA-1"
+#define NID_id_TA_RSA_PSS_SHA_1		937
+#define OBJ_id_TA_RSA_PSS_SHA_1		OBJ_id_TA_RSA,3L
+
+#define SN_id_TA_RSA_PSS_SHA_256		"id-TA-RSA-PSS-SHA-256"
+#define NID_id_TA_RSA_PSS_SHA_256		938
+#define OBJ_id_TA_RSA_PSS_SHA_256		OBJ_id_TA_RSA,4L
+
+#define SN_id_TA_RSA_v1_5_SHA_512		"id-TA-RSA-v1-5-SHA-512"
+#define NID_id_TA_RSA_v1_5_SHA_512		955
+#define OBJ_id_TA_RSA_v1_5_SHA_512		OBJ_id_TA_RSA,5L
+
+#define SN_id_TA_RSA_PSS_SHA_512		"id-TA-RSA-PSS-SHA-512"
+#define NID_id_TA_RSA_PSS_SHA_512		940
+#define OBJ_id_TA_RSA_PSS_SHA_512		OBJ_id_TA_RSA,6L
+
+#define SN_id_TA_ECDSA		"id-TA-ECDSA"
+#define NID_id_TA_ECDSA		941
+#define OBJ_id_TA_ECDSA		OBJ_id_TA,2L
+
+#define SN_id_TA_ECDSA_SHA_1		"id-TA-ECDSA-SHA-1"
+#define NID_id_TA_ECDSA_SHA_1		942
+#define OBJ_id_TA_ECDSA_SHA_1		OBJ_id_TA_ECDSA,1L
+
+#define SN_id_TA_ECDSA_SHA_224		"id-TA-ECDSA-SHA-224"
+#define NID_id_TA_ECDSA_SHA_224		943
+#define OBJ_id_TA_ECDSA_SHA_224		OBJ_id_TA_ECDSA,2L
+
+#define SN_id_TA_ECDSA_SHA_256		"id-TA-ECDSA-SHA-256"
+#define NID_id_TA_ECDSA_SHA_256		944
+#define OBJ_id_TA_ECDSA_SHA_256		OBJ_id_TA_ECDSA,3L
+
+#define SN_id_TA_ECDSA_SHA_384		"id-TA-ECDSA-SHA-384"
+#define NID_id_TA_ECDSA_SHA_384		945
+#define OBJ_id_TA_ECDSA_SHA_384		OBJ_id_TA_ECDSA,4L
+
+#define SN_id_TA_ECDSA_SHA_512		"id-TA-ECDSA-SHA-512"
+#define NID_id_TA_ECDSA_SHA_512		946
+#define OBJ_id_TA_ECDSA_SHA_512		OBJ_id_TA_ECDSA,5L
+
+#define OBJ_id_roles		OBJ_bsi_de,3L,1L,2L
+
+#define SN_id_IS		"id-IS"
+#define NID_id_IS		947
+#define OBJ_id_IS		OBJ_id_roles,1L
+
+#define SN_id_AT		"id-AT"
+#define NID_id_AT		948
+#define OBJ_id_AT		OBJ_id_roles,2L
+
+#define SN_id_ST		"id-ST"
+#define NID_id_ST		949
+#define OBJ_id_ST		OBJ_id_roles,3L
+
+#define OBJ_id_extensions		OBJ_bsi_de,3L,1L,3L
+
+#define SN_id_description		"id-description"
+#define NID_id_description		950
+#define OBJ_id_description		OBJ_id_extensions,1L
+
+#define SN_id_plainFormat		"id-plainFormat"
+#define NID_id_plainFormat		951
+#define OBJ_id_plainFormat		OBJ_id_description,1L
+
+#define SN_id_htmlFormat		"id-htmlFormat"
+#define NID_id_htmlFormat		952
+#define OBJ_id_htmlFormat		OBJ_id_description,2L
+
+#define SN_id_pdfFormat		"id-pdfFormat"
+#define NID_id_pdfFormat		953
+#define OBJ_id_pdfFormat		OBJ_id_description,3L
+
+#define SN_id_sector		"id-sector"
+#define NID_id_sector		954
+#define OBJ_id_sector		OBJ_id_extensions,2L
+
Index: openssl/crypto/objects/obj_mac.num
===================================================================
--- openssl.orig/crypto/objects/obj_mac.num	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/objects/obj_mac.num	2010-10-26 11:18:00.000000000 +0200
@@ -904,3 +904,52 @@
 brainpoolP384t1		904
 brainpoolP512r1		905
 brainpoolP512t1		906
+id_PACE_DH_GM		907
+id_PACE_DH_GM_3DES_CBC_CBC		908
+id_PACE_DH_GM_AES_CBC_CMAC_128		909
+id_PACE_DH_GM_AES_CBC_CMAC_192		910
+id_PACE_DH_GM_AES_CBC_CMAC_256		911
+id_PACE_ECDH_GM		912
+id_PACE_ECDH_GM_3DES_CBC_CBC		913
+id_PACE_ECDH_GM_AES_CBC_CMAC_128		914
+id_PACE_ECDH_GM_AES_CBC_CMAC_192		915
+id_PACE_ECDH_GM_AES_CBC_CMAC_256		916
+id_PACE_DH_IM		917
+id_PACE_DH_IM_3DES_CBC_CBC		918
+id_PACE_DH_IM_AES_CBC_CMAC_128		919
+id_PACE_DH_IM_AES_CBC_CMAC_192		920
+id_PACE_DH_IM_AES_CBC_CMAC_256		921
+id_PACE_ECDH_IM		922
+id_PACE_ECDH_IM_3DES_CBC_CBC		923
+id_PACE_ECDH_IM_AES_CBC_CMAC_128		924
+id_PACE_ECDH_IM_AES_CBC_CMAC_192		925
+id_PACE_ECDH_IM_AES_CBC_CMAC_256		926
+ansi_x942		927
+dhpublicnumber		928
+ecka_dh_SessionKDF		929
+ecka_dh_SessionKDF_DES3		930
+ecka_dh_SessionKDF_AES128		931
+ecka_dh_SessionKDF_AES192		932
+ecka_dh_SessionKDF_AES256		933
+id_TA_RSA		934
+id_TA_RSA_v1_5_SHA_1		935
+id_TA_RSA_v1_5_SHA_256		936
+id_TA_RSA_PSS_SHA_1		937
+id_TA_RSA_PSS_SHA_256		938
+id_TA_RSA_v1_SHA_512		939
+id_TA_RSA_PSS_SHA_512		940
+id_TA_ECDSA		941
+id_TA_ECDSA_SHA_1		942
+id_TA_ECDSA_SHA_224		943
+id_TA_ECDSA_SHA_256		944
+id_TA_ECDSA_SHA_384		945
+id_TA_ECDSA_SHA_512		946
+id_IS		947
+id_AT		948
+id_ST		949
+id_description		950
+id_plainFormat		951
+id_htmlFormat		952
+id_pdfFormat		953
+id_sector		954
+id_TA_RSA_v1_5_SHA_512		955
Index: openssl/crypto/objects/objects.txt
===================================================================
--- openssl.orig/crypto/objects/objects.txt	2010-10-14 13:47:08.000000000 +0200
+++ openssl/crypto/objects/objects.txt	2010-10-26 11:18:00.000000000 +0200
@@ -1276,3 +1276,70 @@
 1 3 36 3 3 2 8 1 1 12 : brainpoolP384t1
 1 3 36 3 3 2 8 1 1 13 : brainpoolP512r1
 1 3 36 3 3 2 8 1 1 14 : brainpoolP512t1
+
+# BSI Extensions TR 3110 Version 2.01
+!Alias bsi-de           0 4 0 127 0 7
+!Alias id-PACE          bsi-de  2 2 4
+id-PACE 1 :             id-PACE-DH-GM
+id-PACE-DH-GM 1 :       id-PACE-DH-GM-3DES-CBC-CBC
+id-PACE-DH-GM 2 :       id-PACE-DH-GM-AES-CBC-CMAC-128
+id-PACE-DH-GM 3 :       id-PACE-DH-GM-AES-CBC-CMAC-192
+id-PACE-DH-GM 4 :       id-PACE-DH-GM-AES-CBC-CMAC-256
+id-PACE 2 :             id-PACE-ECDH-GM
+id-PACE-ECDH-GM 1 :     id-PACE-ECDH-GM-3DES-CBC-CBC
+id-PACE-ECDH-GM 2 :     id-PACE-ECDH-GM-AES-CBC-CMAC-128
+id-PACE-ECDH-GM 3 :     id-PACE-ECDH-GM-AES-CBC-CMAC-192
+id-PACE-ECDH-GM 4 :     id-PACE-ECDH-GM-AES-CBC-CMAC-256
+id-PACE 3 :             id-PACE-DH-IM
+id-PACE-DH-IM 1 :       id-PACE-DH-IM-3DES-CBC-CBC
+id-PACE-DH-IM 2 :       id-PACE-DH-IM-AES-CBC-CMAC-128
+id-PACE-DH-IM 3 :       id-PACE-DH-IM-AES-CBC-CMAC-192
+id-PACE-DH-IM 4 :       id-PACE-DH-IM-AES-CBC-CMAC-256
+id-PACE 4 :             id-PACE-ECDH-IM
+id-PACE-ECDH-IM 1 :     id-PACE-ECDH-IM-3DES-CBC-CBC
+id-PACE-ECDH-IM 2 :     id-PACE-ECDH-IM-AES-CBC-CMAC-128
+id-PACE-ECDH-IM 3 :     id-PACE-ECDH-IM-AES-CBC-CMAC-192
+id-PACE-ECDH-IM 4 :     id-PACE-ECDH-IM-AES-CBC-CMAC-256
+
+ISO-US 10046 :          ansi-x942
+!Alias x942_number-type ansi-x942 2
+x942_number-type 1:     dhpublicnumber
+
+# BSI extensions TR-03111
+!Alias id-ecc   bsi-de 1 1
+!Alias ecka-dh  id-ecc 5 2
+ecka-dh 2 :          ecka-dh-SessionKDF
+ecka-dh 2 1 :        ecka-dh-SessionKDF-DES3
+ecka-dh 2 2 :        ecka-dh-SessionKDF-AES128
+ecka-dh 2 3 :        ecka-dh-SessionKDF-AES192
+ecka-dh 2 4 :        ecka-dh-SessionKDF-AES256
+
+# Terminal authentication OIDs from TR-03110
+!Alias id-TA    bsi-de 2 2 2
+id-TA 1 :       id-TA-RSA
+id-TA-RSA 1 :   id-TA-RSA-v1-5-SHA-1
+id-TA-RSA 2 :   id-TA-RSA-v1-5-SHA-256
+id-TA-RSA 3 :   id-TA-RSA-PSS-SHA-1
+id-TA-RSA 4 :   id-TA-RSA-PSS-SHA-256
+id-TA-RSA 5 :   id-TA-RSA-v1-5-SHA-512
+id-TA-RSA 6 :   id-TA-RSA-PSS-SHA-512
+id-TA 2 :       id-TA-ECDSA
+id-TA-ECDSA 1 : id-TA-ECDSA-SHA-1
+id-TA-ECDSA 2 : id-TA-ECDSA-SHA-224
+id-TA-ECDSA 3 : id-TA-ECDSA-SHA-256
+id-TA-ECDSA 4 : id-TA-ECDSA-SHA-384
+id-TA-ECDSA 5 : id-TA-ECDSA-SHA-512
+
+# Role OIDs for CV certificates according to 03110
+!Alias id-roles bsi-de 3 1 2
+id-roles 1 :    id-IS
+id-roles 2 :    id-AT
+id-roles 3 :    id-ST
+
+# Description and extesnsion OIDs from TR-03110
+!Alias id-extensions bsi-de 3 1 3
+id-extensions 1 :   id-description
+id-description 1 :  id-plainFormat
+id-description 2 :  id-htmlFormat
+id-description 3 :  id-pdfFormat
+id-extensions 2 :   id-sector
Index: openssl/crypto/pace/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/Makefile	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,156 @@
+DIR=pace
+TOP=../..
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+LIB=$(TOP)/libcrypto.a
+LIBOBJ=pace_err.o pace_lib.o pace_util.o pace.o pace_dh.o pace_kdf.o pace_ecdh.o pace_mappings.o pace_asn1.o #pace_ka.o
+LIBSRC=pace_err.c pace_lib.c pace_util.c pace.c pace_dh.c pace_kdf.c pace_ecdh.c pace_mappings.c pace_asn1.c #pace_ka.c
+
+EXHEADER=pace.h
+TEST=pacetest.c
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj des lib tags core .pure .nfs* *.old *.bak fluff
+
+pacetest: top pace.h pacetest.c $(LIB)
+	$(CC) $(CFLAGS) -Wall -Werror -g -o pacetest pacetest.c $(LIB)
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+pace.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h pace.c
+pace.o: pace_dh.h pace_ecdh.h pace_kdf.h pace_mappings.h pace_util.h
+pace_asn1.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+pace_asn1.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+pace_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_asn1.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_asn1.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_asn1.o: ../../include/openssl/ecdh.h ../../include/openssl/obj_mac.h
+pace_asn1.o: ../../include/openssl/objects.h
+pace_asn1.o: ../../include/openssl/opensslconf.h
+pace_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_asn1.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_asn1.o: pace_asn1.c pace_asn1.h
+pace_dh.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_dh.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_dh.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_dh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_dh.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_dh.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+pace_dh.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+pace_dh.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+pace_dh.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+pace_dh.o: ../../include/openssl/symhacks.h pace_dh.c pace_dh.h
+pace_ecdh.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_ecdh.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_ecdh.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_ecdh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_ecdh.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_ecdh.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_ecdh.o: ../../include/openssl/opensslconf.h
+pace_ecdh.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_ecdh.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_ecdh.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_ecdh.o: pace_ecdh.c pace_ecdh.h
+pace_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_err.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_err.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_err.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_err.o: ../../include/openssl/ecdh.h ../../include/openssl/err.h
+pace_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+pace_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_err.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_err.o: pace_err.c
+pace_kdf.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_kdf.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_kdf.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_kdf.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_kdf.o: ../../include/openssl/ecdh.h ../../include/openssl/evp.h
+pace_kdf.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_kdf.o: ../../include/openssl/opensslconf.h
+pace_kdf.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_kdf.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_kdf.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_kdf.o: pace_kdf.c pace_kdf.h pace_util.h
+pace_lib.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_lib.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_lib.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_lib.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_lib.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_lib.o: ../../include/openssl/evp.h ../../include/openssl/obj_mac.h
+pace_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_lib.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_lib.o: pace_dh.h pace_ecdh.h pace_lib.c pace_mappings.h
+pace_mappings.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_mappings.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_mappings.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_mappings.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_mappings.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_mappings.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace_mappings.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace_mappings.o: ../../include/openssl/objects.h
+pace_mappings.o: ../../include/openssl/opensslconf.h
+pace_mappings.o: ../../include/openssl/opensslv.h
+pace_mappings.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+pace_mappings.o: ../../include/openssl/safestack.h
+pace_mappings.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_mappings.o: pace_dh.h pace_ecdh.h pace_mappings.c pace_mappings.h
+pace_mappings.o: pace_util.h
+pace_util.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_util.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_util.o: ../../include/openssl/cmac.h ../../include/openssl/conf.h
+pace_util.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_util.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_util.o: ../../include/openssl/ecdh.h ../../include/openssl/err.h
+pace_util.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+pace_util.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_util.o: ../../include/openssl/opensslconf.h
+pace_util.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_util.o: ../../include/openssl/pace.h ../../include/openssl/rand.h
+pace_util.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+pace_util.o: ../../include/openssl/symhacks.h pace.h pace_dh.h pace_util.c
+pace_util.o: pace_util.h
Index: openssl/crypto/pace/pace.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace.c	2010-10-18 12:09:39.000000000 +0200
@@ -0,0 +1,644 @@
+/**
+ * @file
+ * @brief OpenPACE implementation
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include <openssl/bn.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include "pace_util.h"
+#include "pace_dh.h"
+#include "pace_ecdh.h"
+#include "pace_kdf.h"
+#include "pace_mappings.h"
+
+int
+PACE_init(PACE_CTX * ctx, PACEDomainParameterInfo * dp, PACEInfo * info,
+        int nid, void *ka_obj)
+{
+    if (!ctx || !dp || !info)
+        goto err;
+
+    /* Always use the first (and only) set of domain parameters */
+    info->parameterId = 1;
+    dp->parameterId = 1;
+
+    info->protocol = nid;
+
+    /* Always clear domain parameters to remove the old DH/EC_KEY object */
+    AlgorithmIdentifier_clear_free(dp->domainParameter);
+    dp->domainParameter = AlgorithmIdentifier_new();
+    if (!dp->domainParameter)
+        goto err;
+    /* Note: This is equivalent to
+     * dp->domainParameter->parameters.ecdh = ka_obj; */
+    dp->domainParameter->parameters.dh = ka_obj;
+
+    switch (nid) {
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_DH_GM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_DH_IM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_ECDH_GM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_DH_GM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_DH_IM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_DH_GM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_DH_IM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_DH_GM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_DH_IM;
+            dp->domainParameter->algorithm = NID_dhpublicnumber;
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_ECDH_GM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_ECDH_GM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            info->version = 1;
+            dp->protocol = NID_id_PACE_ECDH_GM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_ECDH_IM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_ECDH_IM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_ECDH_IM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            info->version = 2;
+            dp->protocol = NID_id_PACE_ECDH_IM;
+            dp->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            break;
+
+        default:
+            goto err;
+    }
+
+    if (!PACE_CTX_init(ctx, info))
+        goto err;
+
+    return 1;
+
+err:
+    return 0;
+}
+
+int
+PACE_STEP1_enc_nonce(const PACE_SEC * pi, PACE_CTX * ctx,
+        BUF_MEM ** nonce, BUF_MEM ** enc_nonce)
+{
+    BUF_MEM * key = NULL;
+
+    if (!ctx || !nonce || !enc_nonce)
+        goto err;
+
+    key = kdf_pi(pi, NULL, ctx->md, NULL, NULL, ctx->cipher->key_len);
+    if (!key)
+        goto err;
+
+    *nonce = randb(EVP_CIPHER_block_size(ctx->cipher));
+    if (!*nonce)
+        goto err;
+
+    *enc_nonce = cipher_no_pad(ctx, key, *nonce, 1);
+    if (!*enc_nonce)
+        goto err;
+
+    OPENSSL_cleanse(key->data, key->max);
+    BUF_MEM_free(key);
+
+    return 1;
+
+err:
+    if (key) {
+        OPENSSL_cleanse(key->data, key->max);
+        BUF_MEM_free(key);
+    }
+    if (*nonce) {
+        BUF_MEM *p = *nonce;
+        OPENSSL_cleanse(p->data, p->max);
+        BUF_MEM_free(*nonce);
+    }
+    if (*enc_nonce)
+        BUF_MEM_free(*enc_nonce);
+
+    return 0;
+}
+
+BUF_MEM *
+PACE_STEP2_dec_nonce(const PACE_SEC * pi, const BUF_MEM * enc_nonce,
+        PACE_CTX * ctx)
+{
+    BUF_MEM * nonce = NULL, * key = NULL;
+
+    if (!ctx)
+        goto err;
+
+    key = kdf_pi(pi, NULL, ctx->md, NULL, NULL, ctx->cipher->key_len);
+    if (!key)
+        goto err;
+
+    nonce = cipher_no_pad(ctx, key, enc_nonce, 0);
+
+err:
+    if (key) {
+        OPENSSL_cleanse(key->data, key->max);
+        BUF_MEM_free(key);
+    }
+
+    return nonce;
+}
+
+BUF_MEM *
+PACE_STEP3A_generate_mapping_data(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx)
+{
+    if (!ctx)
+        return NULL;
+
+    return ctx->map_generate_key(dp, ctx);
+}
+
+PACEDomainParameterInfo *
+PACE_STEP3A_map_dp(const PACEDomainParameterInfo * dp_in,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out;
+
+    if (!ctx)
+        return NULL;
+
+    out = ctx->map_compute_key(dp_in, ctx, s, in);
+
+    return out;
+}
+
+BUF_MEM *
+PACE_STEP3B_generate_ephemeral_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx)
+{
+    if (!dp || !dp->domainParameter || !ctx)
+        return NULL;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            return dh_generate_key(dp, ctx);
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards derive from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            return ecdh_generate_key(dp, ctx);
+        default:
+            return NULL;
+    }
+}
+
+BUF_MEM *
+PACE_STEP3B_compute_ephemeral_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx, const BUF_MEM * in)
+{
+    BUF_MEM *out = NULL;
+    const ECDH_METHOD * default_method;
+
+    if (!dp || !dp->domainParameter || !ctx || !in)
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            out = dh_compute_key(dp, ctx, in);
+            break;
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards derive from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            default_method = ECDH_get_default_method();
+            ECDH_set_default_method(ECDH_OpenSSL());
+            out = ecdh_compute_key(dp, ctx, in);
+            ECDH_set_default_method(default_method);
+            break;
+        default:
+            goto err;
+    }
+    if (!out)
+        goto err;
+
+    /* XXX should we check this also in TR-03110 v2.01? */
+    if (ctx->tr_version != PACE_TR_VERSION_2_01) {
+        /* Check if the new public key is different from the other party's
+         * public key */
+        if ((in->length == out->length)
+                && (memcmp(in->data, out->data, out->length) == 0)) {
+            PACEerr(PACE_F_PACE_STEP3B_PROCESS, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+            goto err;
+        }
+    }
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+int
+PACE_STEP3C_derive_keys(const BUF_MEM *key, PACE_CTX *ctx, PACEInfo *info,
+        BUF_MEM **k_mac, BUF_MEM **k_enc)
+{
+    BUF_MEM *key_mac = NULL;
+    BUF_MEM *key_enc = NULL;
+    int mac_keylen = 0, enc_keylen = 0;
+
+    if (!ctx)
+        goto err;
+    enc_keylen = ctx->cipher->key_len;
+
+    switch (info->protocol) {
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            mac_keylen = 16;
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            mac_keylen = 16;
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            mac_keylen = 24;
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            mac_keylen = 32;
+            break;
+        default:
+            goto err;
+    }
+
+    key_mac = kdf_mac(key, NULL, ctx->md, ctx->md_ctx, ctx->md_engine, mac_keylen);
+    key_enc = kdf_enc(key, NULL, ctx->md, ctx->md_ctx, ctx->md_engine, enc_keylen);
+    if (!key_mac || !key_enc)
+        goto err;
+
+    *k_mac = key_mac;
+    *k_enc = key_enc;
+
+    return 1;
+
+err:
+    if (key_mac) {
+        OPENSSL_cleanse(key_mac->data, key_mac->max);
+        BUF_MEM_free(key_mac);
+    }
+    if (key_enc) {
+        OPENSSL_cleanse(key_enc->data, key_enc->max);
+        BUF_MEM_free(key_enc);
+    }
+
+    return 0;
+}
+
+BUF_MEM *
+PACE_STEP3D_compute_authentication_token(PACE_CTX *ctx,
+        PACEDomainParameterInfo *dp, const PACEInfo *info, BUF_MEM *pub,
+        BUF_MEM *k_mac)
+{
+    BUF_MEM *out = NULL;
+    EC_POINT *ecp = NULL;
+    PACEDomainParameterInfo *dp_opp = PACEDomainParameterInfo_dup(dp);
+
+    if (!dp || !dp->domainParameter || !pub || !dp_opp)
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            if (!dp->domainParameter->parameters.dh)
+                goto err;
+
+            dp_opp->domainParameter->parameters.dh->pub_key = BN_bin2bn(
+                    (unsigned char *) pub->data, pub->length,
+                    dp_opp->domainParameter->parameters.dh->pub_key);
+            break;
+
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards derive from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            if (!dp->domainParameter->parameters.ecdh)
+                goto err;
+
+            ecp = EC_POINT_new(EC_KEY_get0_group(
+                    dp_opp->domainParameter->parameters.ecdh));
+            if (!ecp || !EC_POINT_oct2point(EC_KEY_get0_group(
+                    dp_opp->domainParameter->parameters.ecdh), ecp,
+                    (unsigned char *) pub->data, pub->length, ctx->bn_ctx)
+                    || !EC_KEY_set_public_key(
+                            dp_opp->domainParameter->parameters.ecdh, ecp))
+                goto err;
+            break;
+
+        default:
+            goto err;
+    }
+    out = compute_authentication_token(ctx, dp_opp, info, k_mac);
+
+err:
+    if (ecp)
+        EC_POINT_free(ecp);
+    PACEDomainParameterInfo_clear_free(dp_opp);
+
+    return out;
+}
+
+int
+PACE_STEP3D_verify_authentication_token(PACE_CTX *ctx,
+        PACEDomainParameterInfo *dp, const PACEInfo *info, BUF_MEM *key,
+        BUF_MEM *token)
+{
+    BUF_MEM *token_verify = NULL;
+    int rv;
+
+    if (!token)
+        return -1;
+
+    token_verify = compute_authentication_token(ctx, dp, info, key);
+    if (!token_verify)
+        return -1;
+
+    if (token_verify->length != token->length ||
+            memcmp(token_verify->data, token->data, token->length) != 0)
+        rv = 0;
+    else
+        rv = 1;
+
+    BUF_MEM_free(token_verify);
+
+    return rv;
+}
+
+BUF_MEM *
+PACE_add_iso_pad(const BUF_MEM * m, int block_size)
+{
+    BUF_MEM * out = NULL;
+    int p_len;
+
+    if (!m)
+        goto err;
+
+    /* calculate length of padded message */
+    p_len = (m->length / block_size) * block_size + block_size;
+
+    out = BUF_MEM_create(p_len);
+    if (!out)
+        goto err;
+
+    /* Flawfinder: ignore */
+    memcpy(out->data, m->data, m->length);
+
+    /* now add iso padding */
+    memset(out->data + m->length, 0x80, 1);
+    memset(out->data + m->length + 1, 0, p_len - m->length - 1);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+PACE_encrypt(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc,
+        const BUF_MEM *data)
+{
+    if (!update_iv(ctx, ssc, key_enc))
+        return NULL;
+
+    return cipher_no_pad(ctx, key_enc, data, 1);
+}
+
+BUF_MEM *
+PACE_decrypt(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc,
+        const BUF_MEM *data)
+{
+    if (!update_iv(ctx, ssc, key_enc))
+        return NULL;
+
+    return cipher_no_pad(ctx, key_enc, data, 0);
+}
+
+BUF_MEM *
+PACE_authenticate(const PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *k_mac,
+        const unsigned char *data, size_t datalen)
+{
+    int r;
+    BUF_MEM *out = NULL, *databuf = NULL;
+    unsigned char *ssc_buf = NULL;
+
+    r = encode_ssc(ssc, ctx, &ssc_buf);
+    if (r < 0) {
+        goto err;
+    }
+
+    databuf = BUF_MEM_create(r + datalen);
+    if (!databuf) {
+        goto err;
+    }
+    /* Flawfinder: ignore */
+    memcpy(databuf->data, ssc_buf, r);
+    /* Flawfinder: ignore */
+    memcpy(databuf->data + r, data, datalen);
+    databuf->length = r + datalen;
+
+    out = authenticate(ctx, k_mac, databuf);
+
+err:
+    if (ssc_buf)
+        free(ssc_buf);
+    if (databuf)
+        BUF_MEM_free(databuf);
+
+    return out;
+}
+
+BUF_MEM *
+PACE_Comp(const PACEDomainParameterInfo *dp, PACE_CTX *ctx, const BUF_MEM *pub)
+{
+    BUF_MEM *out = NULL;
+    const EC_GROUP *group;
+    EC_POINT *ecp = NULL;
+    BIGNUM *x = NULL, *y = NULL;
+
+    if (!dp || !dp->domainParameter || !ctx)
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            out = hash(EVP_sha1(), NULL, NULL, pub);
+            break;
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards derive from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            group = EC_KEY_get0_group(
+                    dp->domainParameter->parameters.ecdh);
+            ecp = EC_POINT_new(group);
+            x = BN_CTX_get(ctx->bn_ctx);
+            y = BN_CTX_get(ctx->bn_ctx);
+
+            if(!ecp || !x || !y
+                    || !EC_POINT_oct2point(group, ecp,
+                        (unsigned char *) pub->data, pub->length, ctx->bn_ctx)
+                    || !EC_POINT_get_affine_coordinates_GF2m(group, ecp, x, y, ctx->bn_ctx))
+                goto err;
+
+            out = BUF_MEM_create(BN_num_bytes(x));
+            if(!out
+                    || !BN_bn2bin(x, (unsigned char *) out->data))
+                goto err;
+            break;
+        default:
+            goto err;
+    }
+
+err:
+    if (ecp)
+        EC_POINT_free(ecp);
+    if (x)
+        BN_free(x);
+    if (y)
+        BN_free(y);
+
+    return out;
+}
+
+BUF_MEM *
+PACE_hash_certificate_description(const unsigned char *cert_desc,
+        size_t cert_desc_len)
+{
+    BUF_MEM *cd = BUF_MEM_create_init(cert_desc, cert_desc_len);
+    BUF_MEM *out = hash(EVP_sha256(), NULL, NULL, cd);
+    BUF_MEM_free(cd);
+    return out;
+}
Index: openssl/crypto/pace/pace.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace.h	2010-10-26 11:17:30.000000000 +0200
@@ -0,0 +1,581 @@
+/**
+ * @mainpage OpenPACE
+ * Implements the Password Authenticated Connection Establishment
+ * (PACE) protocol, as specified in BSI TR-03110 version 2.0.
+ *
+ * PACE is a protocol used to establish strong session keys based
+ * on a weak shared secret (password). The result of a PACE run
+ * are two symmetric keys, one for MAC computation and one for
+ * encryption. It was specfied for Extended Access Control (EAC)
+ * in Machine Readable Travel Documents (MRTD), but can also be
+ * used for securing any other communication channel.
+ *
+ * PACE can be used with different suites of algorithms and is not
+ * subject to any patents.
+ *
+ * @date 2010-09-28
+ * @version 0.4
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+/**
+ * @file
+ * @brief Interface to OpenPACE
+ *
+ * Provide all usefull functions (API) for establishing and communicating
+ * through a PACE channel
+ */
+
+#ifndef PACE_H_
+#define PACE_H_
+
+#include <openssl/dh.h>
+#include <openssl/ecdh.h>
+#include <openssl/cmac.h>
+#include <openssl/buffer.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup types                 Data Types
+ *
+ * @{ ************************************************************************/
+
+/**
+ * Enum for the type of the secret used.
+ */
+enum s_type {
+    /** MRZ is the Machine Readable Zone, printed on the card, encoding
+     * the personal information of the user */
+    PACE_MRZ = 1,
+    /** CAN is the Card access number printed on the card */
+    PACE_CAN,
+    /** PIN is the Personal Identification Number, a secret known only
+     * to the user and not printed on the card */
+    PACE_PIN,
+    /** PUK is the Personal Unblocking key. This type of secret is used
+     * when the card is suspended due to too many incorrect PACE runs */
+    PACE_PUK,
+    /** This type of secret is not defined in BSI TR-03110. We use it as
+     * a generic type, so we can use PACE independent from a ID card */
+    PACE_RAW,
+    /** Undefined type, if nothing else matches */
+    PACE_SEC_UNDEF,
+};
+/**
+ * Shared secret
+ */
+typedef struct pace_sec {
+    /** The type of the secret */
+    enum s_type type;
+    /** The secret itself */
+    BUF_MEM * mem;
+} PACE_SEC;
+
+/** Specifies which algorithm to use for key exchange and contains the necessary
+ * parameters
+ */
+typedef struct algorithmidentifier {
+    /** NID to identify the algorithms to be used */
+    int algorithm;
+    /** Depending on algorithm either a \c DH object or a \c EC_KEY object. */
+    union {
+        /** Classic Diffie-Hellman parameters */
+        DH * dh;
+        /** Elliptic curve Diffie-Hellman parameters */
+        EC_KEY * ecdh;
+    } parameters;
+} AlgorithmIdentifier;
+
+/**
+ * This data structure provides detailed information on an implementation of
+ * PACE.
+ */
+typedef struct paceinfo {
+	/** NID to identify the exact protocol to be used, including methods for
+	 *  key agreement, mapping of domain parameters, encryption and integrity
+	 *  protection */
+	int protocol;
+	/** Version of the protocol, MUST be 1 or 2 */
+	int version;
+	/** Used to indicate the local domain parameter identifier */
+	int parameterId;
+} PACEInfo;
+
+/**
+ * This data structure provides one set of domain parameters for PACE.
+ */
+typedef struct pacedomainparameterinfo {
+	/** NID to identify the type of domain parameters */
+	int protocol;
+	/** Structure that contains the actual domain parameters */
+	AlgorithmIdentifier  * domainParameter;
+	/** Used to indicate the local domain parameter identifier */
+	int parameterId;
+} PACEDomainParameterInfo;
+
+/** AES message authentication: CMAC of 8 bytes length */
+#define PACE_AES_MAC_LENGTH 8
+
+/** Perform PACE according to TR-03110 v2.01 */
+#define PACE_TR_VERSION_2_01 1
+/** Perform PACE according to TR-03110 v2.02 and later */
+#define PACE_TR_VERSION_2_02 2
+
+/** Context structure used in all protocol steps. Encompasses information
+ * about cipher, message digest, key agreement scheme, mapping method. */
+typedef struct pace_ctx {
+    /** version of TR-03110 */
+    int tr_version;
+    /** \c BN_CTX object for various operations */
+    BN_CTX * bn_ctx;
+    /** Which hash function to use for Key Derivation */
+    const EVP_MD * md;
+    /** \c BN_CTX object for md */
+    EVP_MD_CTX * md_ctx;
+    /** \c ENGINE object for md */
+    ENGINE * md_engine;
+    /** \c CMAC_CTX object for cmac */
+    CMAC_CTX * cmac_ctx;
+    /** \c EVP_CIPHER object to use for encryption/decryption */
+    const EVP_CIPHER * cipher;
+    /** \c EVP_CIPHER_CTX object for cipher */
+    EVP_CIPHER_CTX * cipher_ctx;
+    /** \c ENGINE object for cipher */
+    ENGINE * cipher_engine;
+    /** Initialisation vector for encryption/decryption */
+    unsigned char * iv;
+    /** Points to the implementation of a specific mapping
+     * @see PACE_STEP3A_map_generate_key() */
+    BUF_MEM * (*map_generate_key)(const PACEDomainParameterInfo * dp,
+            const struct pace_ctx * ctx);
+    /** Points to the implementation of a specific mapping
+     * @see PACE_STEP3A_map_compute_key() */
+    PACEDomainParameterInfo * (*map_compute_key)(const PACEDomainParameterInfo * dp_in,
+            const struct pace_ctx * ctx, const BUF_MEM * s,
+            const BUF_MEM * in);
+} PACE_CTX;
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup manage              Data Managment
+ *
+ * @brief Create, destroy and initialize OpenPACE objects
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Frees a \c AlgorithmIdentifier object and all of its components
+ *
+ * @param[in] dp Object to free (optional)
+ */
+void AlgorithmIdentifier_clear_free(AlgorithmIdentifier * dp);
+/**
+ * @brief Creates a new \c AlgorithmIdentifier object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+AlgorithmIdentifier * AlgorithmIdentifier_new(void);
+/**
+ * @brief Duplicates a \c AlgorithmIdentifier object without preserving private keys
+ *
+ * @param[in] dp_in Object to duplicate
+ *
+ * @return Duplicate of dp_in without private and public keys or NULL if an
+ * error occurred
+ */
+AlgorithmIdentifier * AlgorithmIdentifier_dup(const AlgorithmIdentifier * dp_in);
+/**
+ * @brief Frees a \c PACE_SEC object and all its of components
+ *
+ * @param[in] s Object to free (optional)
+ */
+void PACE_SEC_clean_free(PACE_SEC * s);
+/**
+ * @brief Creates a new \c PACE_SEC object and initializes it with a secret
+ * @param[in] sec Secret
+ * @param[in] sec_len Length of secret in bytes
+ * @param[in] type Type of secret
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type);
+/**
+ * @brief Frees a \c PACE_CTX object
+ *
+ * @param[in] s Object to free (optional)
+ */
+void PACE_CTX_free(PACE_CTX * s);
+/**
+ * @brief Frees a \c PACE_CTX object and all its components
+ *
+ * @param[in] s Object to free (optional)
+ */
+void PACE_CTX_clear_free(PACE_CTX * s);
+/**
+ * @brief Creates a new \c PACE_CTX object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACE_CTX * PACE_CTX_new(void);
+/**
+ * @brief Initializes a \c PACE_CTX object using the information given in a
+ *        \c PACEInfo object
+ *
+ * @param[in,out] ctx The ctx object to initialise
+ * @param[in] info The \c PACEInfo object containing a valid protocol OID
+ *
+ * @return 1 in case of success, 0 otherwise
+ */
+int PACE_CTX_init(PACE_CTX * ctx, PACEInfo * info);
+/**
+ * @brief Creates a new \c PACEInfo object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACEInfo * PACEInfo_new(void);
+/**
+ * @brief Frees a \c PACEInfo object
+ *
+ * @param[in] info Object to free (optional)
+ */
+void PACEInfo_free(PACEInfo * info);
+/**
+ * @brief Frees a PACEDomainParameterInfo object
+ *
+ * @param[in] dp Object to free (optional)
+ */
+void PACEDomainParameterInfo_free(PACEDomainParameterInfo * dp);
+/**
+ * @brief Frees a \c PACEDomainParameterInfo object and all its components
+ *
+ * @param[in] dp Object to free (optional)
+ */
+void PACEDomainParameterInfo_clear_free(PACEDomainParameterInfo * dp);
+ /**
+  * @brief Creates a new \c PACEDomainParameterInfo object
+  *
+  * @return Pointer to the new object or NULL on error
+  */
+PACEDomainParameterInfo * PACEDomainParameterInfo_new(void);
+/**
+ * @brief Duplicates a \c PACEDomainParameterInfo object
+ *
+ * @param[in] dp_in \c PACEDomainParameterInfo object to duplicate (optional)
+ * @return Pointer to the duplicated object or NULL on error
+ */
+PACEDomainParameterInfo * PACEDomainParameterInfo_dup(const
+		PACEDomainParameterInfo * dp_in);
+/**
+ * @brief Initializes \c PACE_CTX, \c PACEDomainParameterInfo and \c PACEInfo objects
+ *
+ * @param[in,out] ctx Object to initialize
+ * @param[in,out] dp Object to initialize
+ * @param[in,out] info Object to initialize
+ * @param[in] nid Identifier to use for PACEInfo->protocol
+ * @param[in] ka_obj Depending on nid either a \c DH or a \c EC_KEY object (optional)
+ *
+ * @return 1 on success and 0 if an error occurred
+ */
+int
+PACE_init(PACE_CTX * ctx, PACEDomainParameterInfo * dp, PACEInfo * info,
+        int nid, void *ka_obj);
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup proto               Protocol Steps
+ *
+ * @brief Protocol steps to establish a PACE channel
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Generates and encrypts a nonce.
+ *
+ * @param[in] pi        Shared secret for key derivation (see kdf_pi())
+ * @param[in] ctx       \c PACE_CTX object
+ * @param[out] nonce     Where to save the new object containing the nonce
+ * @param[out] enc_nonce Where to save the new object containing the encrypted nonce
+ *
+ * @return          1 on success and 0 if an error occurred
+ */
+int PACE_STEP1_enc_nonce(const PACE_SEC * pi, PACE_CTX * ctx,
+        BUF_MEM ** nonce, BUF_MEM ** enc_nonce);
+/**
+ * @brief Decrypt the Nonce from the other party.
+ *
+ * @param[in] pi PACE secret used to derive the symmetric key
+ * @param[in] enc_nonce Encrypted nonce
+ * @param[in] ctx Context object that contains information about encryption and
+ * hash algorithms to use
+ *
+ * @return Plaintext nonce or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP2_dec_nonce(const PACE_SEC * pi,
+        const BUF_MEM * enc_nonce, PACE_CTX * ctx);
+/**
+ * @brief Generate a public keypair to perform the mapping to new domain
+ * parameters
+ *
+ * @param[in] dp Domain parameters
+ * @param[in] ctx \c PACE_CTX object
+ *
+ * @return Buffer to be transmitted to the other party or NULL if an error
+ * occurred
+ */
+BUF_MEM *
+PACE_STEP3A_generate_mapping_data(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx);
+/**
+ * @brief Get the ephemeral domain parameters.
+ *
+ * Compute the shared secret from our own private key and the other
+ * parties public key. Then map the static domain parameters to new,
+ * ephemeral ones.
+ *
+ * @param[in] dp_in Static domain parameters
+ * @param[in] ctx
+ * @param[in] s Nonce used for computing the ephemeral domain parameters
+ * @param[in] in Public key from the other party
+ *
+ * @return Ephemeral domain parameters or NULL if an error occurred
+ */
+PACEDomainParameterInfo *
+PACE_STEP3A_map_dp(const PACEDomainParameterInfo * dp_in,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Generate a keypair for key agreement
+ *
+ * @param[in] dp Ephemeral domain parameters (generated in PACE_STEP3A_map_dp())
+ * @param[in] ctx \c PACE_CTX object
+ *
+ * @return Public key or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP3B_generate_ephemeral_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx);
+/**
+ * @brief Compute the shared secret
+ *
+ * @param[in] dp Ephemeral domain parameters (generated in PACE_STEP3A_map_dp())
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] in Public key from the other party
+ *
+ * @return Shared secret or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP3B_compute_ephemeral_key(const PACEDomainParameterInfo *
+        dp, const PACE_CTX * ctx, const BUF_MEM * in);
+/**
+ * @brief Derives encryption and authentication keys
+ *
+ * @param[in] key Shared secret (computed in PACE_STEP3B_compute_ephemeral_key())
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] info The \c PACEInfo object containing a valid protocol OID
+ * @param[out] k_mac Where to store the authentication key
+ * @param[out] k_enc Where to store the encryption key
+ *
+ * @return          1 on success and 0 if an error occurred
+ */
+int PACE_STEP3C_derive_keys(const BUF_MEM *key, PACE_CTX *ctx, PACEInfo *info,
+        BUF_MEM **k_mac, BUF_MEM **k_enc);
+/**
+ * @brief Compute the authentication token from domain parameters
+ *           and public key
+ *
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] dp Ephemeral domain parameters (generated in PACE_STEP3A_map_dp())
+ * @param[in] info \c PACEInfo containing information about the MAC to be used
+ * @param[in] pub Public key from the other party (generated in PACE_STEP3B_generate_ephemeral_key())
+ * @param[in] key Authentication key (computed in PACE_STEP3C_derive_keys())
+ *
+ * @return Authentication token or NULL in case of error
+ */
+BUF_MEM * PACE_STEP3D_compute_authentication_token(PACE_CTX * ctx,
+		PACEDomainParameterInfo * dp, const PACEInfo * info, BUF_MEM * pub,
+		BUF_MEM * key);
+/**
+ * @brief Verifies an authentication token.
+ *
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] dp Ephemeral domain parameters (generated in PACE_STEP3A_map_dp())
+ * @param[in] info \c PACEInfo containing information about the MAC to be used
+ * @param[in] key Authentication key (computed in PACE_STEP3C_derive_keys())
+ * @param[in] token Authentication token from the other party
+ *
+ * @return 1 if the token has been verified as correct, 0 if not, -1 if an error
+ * occurred.
+ */
+int PACE_STEP3D_verify_authentication_token(PACE_CTX * ctx,
+		PACEDomainParameterInfo * dp, const PACEInfo * info, BUF_MEM * key,
+		BUF_MEM * token);
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup asn1              ASN1 parsing functions
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Generates \c PACEInfo and \c PACEDomainParameterInfo objects from
+ * EF.CardAccess
+ *
+ * @param[in] in Buffer with EF.CardAccess
+ * @param[in] in_len Length of EF.CardAccess
+ * @param[out] info where to write the new \c PACEInfo object
+ * @param[out] dp where to write the new \c PACEDomainParameterInfo object
+ *
+ * @return 1 on success and 0 if an error occurred
+ */
+int parse_ef_card_access(unsigned const char * in, unsigned int in_len,
+        PACEInfo ** info, PACEDomainParameterInfo ** dp);
+
+/**
+ * @brief Initialises \c PACEInfo and \c PACEDomainParameterInfo objects from
+ * EF.CardAccess
+ * @param[in] in Buffer with EF.CardAccess
+ * @param[in] in_len Length of EF.CardAccess
+ * @param[out] info pointer to the \c PACEInfo strcture to initialise
+ * @param[out] dp pointer to the \c PACEDomainParameterInfo structure to initialise
+ */
+int simple_parse_ef_card_access(unsigned char *in, unsigned int in_len,
+        PACEInfo *info, PACEDomainParameterInfo *dp);
+
+/**
+ * @brief Generate an EC Key from the ASN1 encoded parameters. This function is
+ * needed because asn1.h does not export a d2i_asn1 function
+ *
+ * @param[out] key where to write the new EC key
+ * @param[in] p prime modulus of the field
+ * @param[in] a first coefficient of the curve
+ * @param[in] b second coefficient of the curve
+ * @param[in] base generator of the curve
+ * @param[in] base_order order of the generator
+ * @param[in] pub public point of the key
+ * @param[in] cofactor
+ */
+int ec_key_from_asn1(EC_KEY **key, ASN1_OCTET_STRING *p, ASN1_OCTET_STRING *a,
+        ASN1_OCTET_STRING *b, ASN1_OCTET_STRING *base, ASN1_OCTET_STRING
+        *base_order, ASN1_OCTET_STRING *pub, ASN1_OCTET_STRING *cofactor);
+
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup convenience              Convenience functions
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Padds a buffer using ISO/IEC 9797-1 padding method 2.
+ *
+ * @param[in] m buffer to padd
+ * @param[in] block_size pad to this block size
+ *
+ * @return new buffer with the padded input or NULL if an error occurred
+ */
+BUF_MEM *
+PACE_add_iso_pad(const BUF_MEM * m, int block_size);
+
+/**
+ * @brief Encrypts data according to TR-03110 F.2.
+ *
+ * Send sequence counter is used to generate initialisation vector for
+ * encryption.
+ *
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] ssc send sequence counter
+ * @param[in] key_enc key for encryption
+ * @param[in] data data to encrypt
+ * @note data must already be padded to block length
+ *
+ * @return new buffer with the encrypted data or NULL if an error occurred
+ */
+BUF_MEM *
+PACE_encrypt(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc,
+        const BUF_MEM *data);
+
+/**
+ * @brief Decrypts data according to TR-03110 F.2.
+ *
+ * Send sequence counter is used to generate initialisation vector for
+ * decryption.
+ *
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] ssc send sequence counter
+ * @param[in] key_enc key for encryption
+ * @param[in] data data to decrypt
+ * @note data must already be padded to block length
+ *
+ * @return new buffer with the decrypted data or NULL if an error occurred
+ */
+BUF_MEM *
+PACE_decrypt(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc,
+        const BUF_MEM *data);
+
+/**
+ * @brief Authenticates data according to TR-03110 F.2.
+ *
+ * Send sequence counter is encoded and prepended to the data.
+ *
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] ssc send sequence counter
+ * @param[in] k_mac key for authentication
+ * @param[in] data data to authenticate
+ * @param[in] datalen length of \a data
+ * @note data must already be padded to block length
+ *
+ * @return new buffer with the message authentication code or NULL if an error occurred
+ */
+BUF_MEM *
+PACE_authenticate(const PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *k_mac,
+        const unsigned char *data, size_t datalen);
+
+/**
+ * @brief Compresses a public key according to TR-03110 Table A.2.
+ *
+ * @param[in] dp Ephemeral domain parameters (generated in PACE_STEP3A_map_dp())
+ * @param[in] ctx \c PACE_CTX object
+ * @param[in] pub public key from the other party or generated in PACE_STEP3A_generate_mapping_data()
+ *
+ * @return new buffer with the message authentication code or NULL if an error occurred
+ */
+BUF_MEM *
+PACE_Comp(const PACEDomainParameterInfo *dp, PACE_CTX *ctx, const BUF_MEM *pub);
+BUF_MEM *
+PACE_hash_certificate_description(const unsigned char *cert_desc,
+        size_t cert_desc_len);
+/** @} ***********************************************************************/
+
+
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+/** Load the error strings for the PACE sub library */
+void ERR_load_PACE_strings(void);
+
+/* Error codes for the PACE functions. */
+
+/* Function codes. */
+#define PACE_F_ASN1_PUBKEY				 100
+#define PACE_F_DH_GET_ORDER				 101
+#define PACE_F_DH_GET_SG_PRIME				 102
+#define PACE_F_DH_GM_COMPUTE_KEY			 103
+#define PACE_F_DH_IM_COMPUTE_KEY			 104
+#define PACE_F_ECDH_INTEGRATED_MAPPING			 105
+#define PACE_F_INIT_DH					 106
+#define PACE_F_PACE_STEP3B_PROCESS			 107
+
+/* Reason codes. */
+#define PACE_R_BAD_DH_GENERATOR				 100
+#define PACE_R_BAD_DH_OR_ECKEY_OBJECT			 101
+#define PACE_R_BAD_FORMAT				 102
+#define PACE_R_UNABLE_TO_GET_ORDER			 103
+#define PACE_R_UNABLE_TO_GET_SG_PRIME			 104
+#define PACE_R_UNSUITED_CURVE				 105
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/pace/pace_asn1.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_asn1.c	2010-10-26 11:18:00.000000000 +0200
@@ -0,0 +1,576 @@
+/**
+ * @file
+ * @brief ASN.1 structures related to PACE
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/asn1.h>
+#include <openssl/pace.h>
+#include <openssl/cv_cert.h>
+#include "pace_asn1.h"
+
+static unsigned int
+getlen (unsigned const char * in, unsigned int * len_len);
+
+static int copy_ec_params(EC_KEY **dst, PACE_ECPARAMETERS *src);
+
+static int copy_dh_params(DH ** dst, DH *src);
+
+/* the OpenSSL ASN.1 definitions */
+ASN1_SEQUENCE(PACE_X9_62_PENTANOMIAL) = {
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k1, LONG),
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k2, LONG),
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k3, LONG)
+} ASN1_SEQUENCE_END(PACE_X9_62_PENTANOMIAL)
+
+DECLARE_ASN1_ALLOC_FUNCTIONS(PACE_X9_62_PENTANOMIAL)
+IMPLEMENT_ASN1_ALLOC_FUNCTIONS(PACE_X9_62_PENTANOMIAL)
+
+ASN1_ADB_TEMPLATE(char_two_def) = ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.other, ASN1_ANY);
+
+ASN1_ADB(PACE_X9_62_CHARACTERISTIC_TWO) = {
+    ADB_ENTRY(NID_X9_62_onBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.onBasis, ASN1_NULL)),
+    ADB_ENTRY(NID_X9_62_tpBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.tpBasis, ASN1_INTEGER)),
+    ADB_ENTRY(NID_X9_62_ppBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.ppBasis, PACE_X9_62_PENTANOMIAL))
+} ASN1_ADB_END(PACE_X9_62_CHARACTERISTIC_TWO, 0, type, 0, &char_two_def_tt, NULL);
+
+ASN1_SEQUENCE(PACE_X9_62_CHARACTERISTIC_TWO) = {
+    ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, m, LONG),
+    ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, type, ASN1_OBJECT),
+    ASN1_ADB_OBJECT(PACE_X9_62_CHARACTERISTIC_TWO)
+} ASN1_SEQUENCE_END(PACE_X9_62_CHARACTERISTIC_TWO)
+
+DECLARE_ASN1_ALLOC_FUNCTIONS(PACE_X9_62_CHARACTERISTIC_TWO)
+IMPLEMENT_ASN1_ALLOC_FUNCTIONS(PACE_X9_62_CHARACTERISTIC_TWO)
+
+ASN1_ADB_TEMPLATE(fieldID_def) = ASN1_SIMPLE(PACE_X9_62_FIELDID, p.other, ASN1_ANY);
+
+ASN1_ADB(PACE_X9_62_FIELDID) = {
+    ADB_ENTRY(NID_X9_62_prime_field, ASN1_SIMPLE(PACE_X9_62_FIELDID, p.prime, ASN1_INTEGER)),
+    ADB_ENTRY(NID_X9_62_characteristic_two_field, ASN1_SIMPLE(PACE_X9_62_FIELDID, p.char_two, PACE_X9_62_CHARACTERISTIC_TWO))
+} ASN1_ADB_END(PACE_X9_62_FIELDID, 0, fieldType, 0, &fieldID_def_tt, NULL);
+
+ASN1_SEQUENCE(PACE_X9_62_FIELDID) = {
+    ASN1_SIMPLE(PACE_X9_62_FIELDID, fieldType, ASN1_OBJECT),
+    ASN1_ADB_OBJECT(PACE_X9_62_FIELDID)
+} ASN1_SEQUENCE_END(PACE_X9_62_FIELDID)
+
+ASN1_SEQUENCE(PACE_X9_62_CURVE) = {
+    ASN1_SIMPLE(PACE_X9_62_CURVE, a, ASN1_OCTET_STRING),
+    ASN1_SIMPLE(PACE_X9_62_CURVE, b, ASN1_OCTET_STRING),
+    ASN1_OPT(PACE_X9_62_CURVE, seed, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(PACE_X9_62_CURVE)
+
+ASN1_SEQUENCE(PACE_ECPARAMETERS) = {
+    ASN1_SIMPLE(PACE_ECPARAMETERS, version, ASN1_INTEGER),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, fieldID, PACE_X9_62_FIELDID),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, curve, PACE_X9_62_CURVE),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, base, ASN1_OCTET_STRING),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, order, ASN1_INTEGER),
+    ASN1_OPT(PACE_ECPARAMETERS, cofactor, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_ECPARAMETERS)
+
+DECLARE_ASN1_FUNCTIONS(PACE_ECPARAMETERS)
+IMPLEMENT_ASN1_FUNCTIONS(PACE_ECPARAMETERS)
+
+/* I stole this from dh_asn1.c */
+ASN1_SEQUENCE_cb(PACE_DHparams, dh_cb) = {
+    ASN1_SIMPLE(DH, p, BIGNUM),
+    ASN1_SIMPLE(DH, g, BIGNUM),
+    ASN1_OPT(DH, length, ZLONG),
+} ASN1_SEQUENCE_END_cb(DH, PACE_DHparams)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DH, PACE_DHparams, PACE_DHparams)
+
+ASN1_SEQUENCE(PACE_INFO) = {
+    ASN1_SIMPLE(PACE_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(PACE_INFO, version, ASN1_INTEGER),
+    ASN1_OPT(PACE_INFO, parameterId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(PACE_INFO)
+
+ASN1_ADB_TEMPLATE(aid_def) = ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.other, ASN1_ANY);
+
+ASN1_ADB(ALGORITHM_IDENTIFIER) = {
+        ADB_ENTRY(NID_ecka_dh_SessionKDF_AES128, ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.ec, PACE_ECPARAMETERS)),
+        ADB_ENTRY(NID_dhpublicnumber, ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.dh, PACE_DHparams))
+} ASN1_ADB_END(ALGORITHM_IDENTIFIER, 0, algorithm, 0, &aid_def_tt, NULL);
+
+ASN1_SEQUENCE(ALGORITHM_IDENTIFIER) = {
+        ASN1_SIMPLE(ALGORITHM_IDENTIFIER, algorithm, ASN1_OBJECT),
+        ASN1_ADB_OBJECT(ALGORITHM_IDENTIFIER)
+} ASN1_SEQUENCE_END(ALGORITHM_IDENTIFIER)
+
+DECLARE_ASN1_ALLOC_FUNCTIONS(ALGORITHM_IDENTIFIER)
+IMPLEMENT_ASN1_ALLOC_FUNCTIONS(ALGORITHM_IDENTIFIER)
+
+/* PACEDomainParameterInfo */
+ASN1_SEQUENCE(PACE_DP_INFO) = {
+    ASN1_SIMPLE(PACE_DP_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(PACE_DP_INFO, aid, ALGORITHM_IDENTIFIER),
+    ASN1_OPT(PACE_DP_INFO, parameterId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_DP_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(PACE_DP_INFO)
+
+int
+dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
+{
+    if(operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)DH_new();
+        if(*pval) return 2;
+        return 0;
+    } else if(operation == ASN1_OP_FREE_PRE) {
+        DH_free((DH *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+int
+ec_key_from_asn1(EC_KEY **key, ASN1_OCTET_STRING *p, ASN1_OCTET_STRING *a,
+        ASN1_OCTET_STRING *b, ASN1_OCTET_STRING *base, ASN1_OCTET_STRING *base_order,
+        ASN1_OCTET_STRING *pub, ASN1_OCTET_STRING *cofactor)
+{
+    int ret = 0;
+    BIGNUM *p_bn = NULL, *cofactor_bn = NULL, *order_bn = NULL, *a_bn = NULL,
+            *b_bn = NULL;
+    BN_CTX *bn_ctx = NULL;
+    EC_GROUP *group = NULL;
+    EC_POINT *generator = NULL, *pub_point = NULL;
+    EC_KEY *tmp = NULL;
+
+    if (!key || !p || !a || !b || !base || !base_order || !cofactor)
+        goto err;
+
+    p_bn = BN_new();
+    a_bn = BN_new();
+    b_bn = BN_new();
+    order_bn = BN_new();
+    cofactor_bn = BN_new();
+    bn_ctx = BN_CTX_new();
+
+    if (!p_bn || !a_bn || !b_bn || !order_bn || !cofactor_bn || !bn_ctx)
+        goto err;
+
+    /* Copy field and curve */
+    if (!BN_bin2bn(ASN1_STRING_data(p), ASN1_STRING_length(p), p_bn) ||
+        !BN_bin2bn(ASN1_STRING_data(a), ASN1_STRING_length(a), a_bn) ||
+        !BN_bin2bn(ASN1_STRING_data(b), ASN1_STRING_length(b), b_bn))
+            goto err;
+    else
+        group = EC_GROUP_new_curve_GFp(p_bn, a_bn, b_bn, bn_ctx);
+
+    if (!group)
+        goto err;
+
+    /* Set generator, order and cofactor */
+    if (!ASN1_INTEGER_to_BN(cofactor, cofactor_bn) ||
+        !ASN1_INTEGER_to_BN(base_order, order_bn))
+            goto err;
+
+    generator = EC_POINT_new(group);
+    if (!generator)
+        goto err;
+
+    if (!EC_POINT_oct2point(group, generator, ASN1_STRING_data(base),
+            ASN1_STRING_length(base), bn_ctx))
+        goto err;
+
+    if (!EC_GROUP_set_generator(group, generator, order_bn, cofactor_bn))
+        goto err;
+
+    /* Set the group for the key*/
+    if (!*key) {
+        tmp = EC_KEY_new();
+        if(!tmp)
+            goto err;
+    } else
+        tmp = *key;
+
+    if( !EC_KEY_set_group(tmp, group))
+        goto err;
+
+    /* Set the public point if available */
+    if (pub) {
+        pub_point = EC_POINT_new(group);
+        if (!pub_point)
+            goto err;
+
+        if (!EC_POINT_oct2point(group, pub_point, ASN1_STRING_data(pub),
+                ASN1_STRING_length(pub), bn_ctx))
+            goto err;
+
+        if (!EC_KEY_set_public_key(tmp, pub_point))
+            goto err;
+    }
+
+    if (!*key)
+        *key = tmp;
+
+    ret = 1;
+
+err:
+    if (bn_ctx)
+        BN_CTX_free(bn_ctx);
+    if (!*key && tmp && !ret)
+        EC_KEY_free(tmp);
+    if (group)
+        EC_GROUP_clear_free(group);
+    if (generator)
+        EC_POINT_clear_free(generator);
+    if (pub_point)
+        EC_POINT_clear_free(pub_point);
+    if(cofactor_bn)
+        BN_clear_free(cofactor_bn);
+    if(order_bn)
+        BN_clear_free(order_bn);
+    if(a_bn)
+        BN_clear_free(a_bn);
+    if(b_bn)
+        BN_clear_free(b_bn);
+    if(p_bn)
+        BN_clear_free(p_bn);
+
+    return ret;
+}
+
+int
+copy_ec_params(EC_KEY **dst, PACE_ECPARAMETERS *src)
+{
+    int ret = 0;
+
+    if (!src || !src->curve || !src->fieldID)
+        goto err;
+
+    ret = ec_key_from_asn1(dst, src->fieldID->p.prime, src->curve->a, src->curve->b,
+            src->base, src->order, NULL, src->cofactor);
+
+err:
+    return ret;
+}
+
+int
+copy_dh_params(DH ** dst, DH *src)
+{
+    DH *tmp = NULL;
+    if (!dst || !*dst) {
+        tmp = DH_new();
+        if (!tmp)
+            goto err;
+    } else
+        tmp = *dst;
+
+    /* dh.h doesn't have setter methods, so we have to set the members manually */
+    tmp->p = BN_dup(src->p);
+    tmp->g = BN_dup(src->g);
+    if (src->length)
+        tmp->length = src->length;
+    if (src->j)
+        tmp->j = BN_dup(src->j);
+
+    if(!*dst)
+        *dst = tmp;
+    return 1;
+
+err:
+    if (!*dst && tmp)
+        DH_free(tmp);
+    return 0;
+}
+
+unsigned int
+getlen (unsigned const char * in, unsigned int * len_len)
+{
+    unsigned int len = 0;
+    int i = 0;
+
+    if (!in || !len_len)
+        return 0;
+
+    if ((in[0] & 0x80) == 0x80 ) { /* MSB set => long form */
+        *len_len = (in[0] & 0x7F) + 1;
+        for (i = 0; i < *len_len - 1; i++) {
+            len <<= i*8;
+            len += in[i+1];
+        }
+    }
+    else {/* MSB not set => short form */
+        len = (unsigned int) in[0];
+        *len_len = 1;
+    }
+    return len;
+}
+
+int
+parse_ef_card_access(unsigned const char * in, unsigned int in_len, PACEInfo ** info,
+        PACEDomainParameterInfo ** dp)
+{
+    unsigned int len = 0, len_len = 0, oid_len = 0;
+    int todo = in_len;
+    ASN1_OBJECT *a = NULL;
+    unsigned const char *oid_pos = NULL, *seq_pos = NULL;
+    int nid;
+    PACE_INFO *tmp_info = NULL;
+    PACEInfo *new_info = NULL;
+    PACE_DP_INFO *tmp_dp_info = NULL;
+    PACEDomainParameterInfo *new_dp_info = NULL;
+
+    if (!in)
+        goto err;
+    if (in[0] != 0x31) /* SET */
+        goto err;
+
+    len = getlen(++in, &len_len); /* Length of SET */
+    in += len_len;
+    todo -= len_len + 1;
+
+    while(todo > 0) {
+        if(in[0] != 0x30) /* SEQUENCE */
+            goto err;
+        seq_pos = in;
+        len = getlen(++in, &len_len); /* Length of SEQUENCE */
+        oid_pos = in + len_len;
+        in += len + len_len;
+        todo -= len + len_len + 1;
+
+        /* Read OID */
+        if(oid_pos[0] != 0x06) /* OBJECT IDENTIFIER */
+            goto err;
+        oid_len = getlen(oid_pos+1, &len_len); /* Length of OBJECT IDENTIFIER */
+
+        /* XXX: I don't understand, why we have to increment the last parameter
+         *      by two. This was found to work by trial and error. */
+        if (d2i_ASN1_OBJECT(&a, &oid_pos, oid_len+2) == NULL)
+            goto err;
+        else {
+            nid = OBJ_obj2nid(a);
+            switch (nid) {
+                case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+                case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+                case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+                case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+                    tmp_info = d2i_PACE_INFO(NULL, &seq_pos, len+2);
+                    if (!tmp_info)
+                        goto err;
+                    new_info = PACEInfo_new();
+                    new_info->version = (int) ASN1_INTEGER_get(tmp_info->version);
+                    if (new_info->version < 0 || new_info->version > 1)
+                        goto err;
+                    new_info->protocol = OBJ_obj2nid(tmp_info->protocol);
+                    if(tmp_info->parameterId)
+                        new_info->parameterId = (int) ASN1_INTEGER_get(tmp_info->parameterId);
+                    break;
+                case NID_id_PACE_ECDH_GM:
+                case NID_id_PACE_ECDH_IM:
+                case NID_id_PACE_DH_GM:
+                case NID_id_PACE_DH_IM:
+                    tmp_dp_info = d2i_PACE_DP_INFO(NULL, &seq_pos, len+3);
+                    if (!tmp_dp_info)
+                        goto err;
+
+                    new_dp_info = PACEDomainParameterInfo_new();
+                    if (!new_dp_info)
+                        goto err;
+                    new_dp_info->protocol = nid;
+                    if(tmp_dp_info->parameterId)
+                        new_dp_info->parameterId = (int) ASN1_INTEGER_get(tmp_dp_info->parameterId);
+
+                    new_dp_info->domainParameter = AlgorithmIdentifier_new();
+                    if(!new_dp_info->domainParameter)
+                        goto err;
+                    new_dp_info->domainParameter->algorithm = OBJ_obj2nid(tmp_dp_info->aid->algorithm);
+
+                    /* Extraxt actual parameters */
+                    switch (new_dp_info->domainParameter->algorithm) {
+                        case NID_dhpublicnumber:
+                            copy_dh_params(&new_dp_info->domainParameter->parameters.dh,
+                                    tmp_dp_info->aid->parameters.dh);
+                            break;
+                        case NID_X9_62_id_ecPublicKey:
+                        case NID_ecka_dh_SessionKDF_DES3:
+                        case NID_ecka_dh_SessionKDF_AES128:
+                        case NID_ecka_dh_SessionKDF_AES192:
+                        case NID_ecka_dh_SessionKDF_AES256:
+                            copy_ec_params(&new_dp_info->domainParameter->parameters.ecdh,
+                                    tmp_dp_info->aid->parameters.ec);
+                            break;
+                        default:
+                            goto err;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    if (info) { //Memory leak if (*info)
+        if(new_info)
+            *info = new_info;
+    }
+    if (dp) { //Memory leak if (*dp)
+        if(new_dp_info)
+            *dp = new_dp_info;
+    }
+
+    if (tmp_info)
+        PACE_INFO_free(tmp_info);
+    if (tmp_dp_info)
+        PACE_DP_INFO_free(tmp_dp_info);
+    ASN1_OBJECT_free(a);
+    return 1;
+
+err:
+    if (a)
+        ASN1_OBJECT_free(a);
+    if (tmp_info)
+        PACE_INFO_free(tmp_info);
+    if (tmp_dp_info)
+        PACE_DP_INFO_free(tmp_dp_info);
+    return 0;
+}
+
+int
+simple_parse_ef_card_access(unsigned char *in, unsigned int in_len, PACEInfo *info,
+            PACEDomainParameterInfo *dp)
+{
+    unsigned int len = 0, len_len = 0, oid_len = 0;
+    ASN1_OBJECT *a = NULL;
+    unsigned const char *oid_pos = NULL, *seq_pos = NULL;
+    int nid;
+    PACE_INFO *tmp_info = NULL;
+    PACE_DP_INFO *tmp_dp_info = NULL;
+
+    if (!info || !dp)
+        goto err;
+
+    if (!in)
+        goto err;
+    if (in[0] != 0x31) /* SET */
+        goto err;
+
+    len = getlen(++in, &len_len); /* Length of SET */
+    in += len_len;
+    in_len -= len_len + 1;
+
+    while(in_len != 0) {
+        if(in[0] != 0x30) /* SEQUENCE */
+            goto err;
+        seq_pos = in;
+        len = getlen(++in, &len_len); /* Length of SEQUENCE */
+        oid_pos = in + len_len;
+        in += len + len_len;
+        in_len -= len + len_len + 1;
+
+        /* Read OID */
+        if(oid_pos[0] != 0x06) /* OBJECT IDENTIFIER */
+            goto err;
+        oid_len = getlen(oid_pos+1, &len_len); /* Length of OBJECT IDENTIFIER */
+
+        /* XXX: I don't understand, why we have to increment the last parameter
+         *      by two. This was found to work by trial and error. */
+        if (d2i_ASN1_OBJECT(&a, &oid_pos, oid_len+2) == NULL)
+            goto err;
+        else {
+            nid = OBJ_obj2nid(a);
+            switch (nid) {
+                case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+                case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+                case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+                case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+                case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+                case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+                case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+                case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+                    tmp_info = d2i_PACE_INFO(NULL, &seq_pos, len+2);
+                    if (!tmp_info)
+                        goto err;
+                    info->version = (int) ASN1_INTEGER_get(tmp_info->version);
+                    if (info->version < 0 || info->version > 1)
+                        goto err;
+                    info->protocol = OBJ_obj2nid(tmp_info->protocol);
+                    if(tmp_info->parameterId)
+                        info->parameterId = (int) ASN1_INTEGER_get(tmp_info->parameterId);
+                    break;
+                case NID_id_PACE_ECDH_GM:
+                case NID_id_PACE_ECDH_IM:
+                case NID_id_PACE_DH_GM:
+                case NID_id_PACE_DH_IM:
+                    tmp_dp_info = d2i_PACE_DP_INFO(NULL, &seq_pos, len+3);
+                    if (!tmp_dp_info)
+                        goto err;
+
+                    dp->protocol = nid;
+                    if(tmp_dp_info->parameterId)
+                        dp->parameterId = (int) ASN1_INTEGER_get(tmp_dp_info->parameterId);
+
+                    dp->domainParameter = AlgorithmIdentifier_new();
+                    if(!dp->domainParameter)
+                        goto err;
+                    dp->domainParameter->algorithm = OBJ_obj2nid(tmp_dp_info->aid->algorithm);
+
+                    /* Extract actual parameters */
+                    switch (dp->domainParameter->algorithm) {
+                        case NID_dhpublicnumber:
+                            copy_dh_params(&dp->domainParameter->parameters.dh,
+                                    tmp_dp_info->aid->parameters.dh);
+                            break;
+                        case NID_X9_62_id_ecPublicKey:
+                        case NID_ecka_dh_SessionKDF_DES3:
+                        case NID_ecka_dh_SessionKDF_AES128:
+                        case NID_ecka_dh_SessionKDF_AES192:
+                        case NID_ecka_dh_SessionKDF_AES256:
+                            copy_ec_params(&dp->domainParameter->parameters.ecdh,
+                                    tmp_dp_info->aid->parameters.ec);
+                            break;
+                        default:
+                            goto err;
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    if (tmp_info)
+        PACE_INFO_free(tmp_info);
+    if (tmp_dp_info)
+        PACE_DP_INFO_free(tmp_dp_info);
+    ASN1_OBJECT_free(a);
+    return 1;
+
+err:
+    if (a)
+        ASN1_OBJECT_free(a);
+    if (tmp_info)
+        PACE_INFO_free(tmp_info);
+    if (tmp_dp_info)
+        PACE_DP_INFO_free(tmp_dp_info);
+    return 0;
+}
Index: openssl/crypto/pace/pace_asn1.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_asn1.h	2010-10-18 12:09:39.000000000 +0200
@@ -0,0 +1,63 @@
+/**
+ * @file
+ * @brief Interface to ASN.1 structures related to PACE
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_ASN1_H_
+#define PACE_ASN1_H_
+
+#include <openssl/ec.h>
+#include <openssl/dh.h>
+#include <openssl/asn1t.h>
+#include <openssl/bn.h>
+#include <openssl/objects.h>
+
+/**
+ * @defgroup DH_ASN1     ASN1 structures for Diffie Hellman
+ * @{ ************************************************************************/
+/* I stole this from dh_asn1.c */
+int dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg);
+
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup PACE_ASN1     ASN1 structures for PACE
+ * @{ ************************************************************************/
+/** PACEInfo structure */
+typedef struct pace_info_st {
+    /** OID of the algorithm to be used */
+    ASN1_OBJECT *protocol;
+    /** Protocol Version number. Version number 1 is deprecated, version 2 is
+        recommended */
+    ASN1_INTEGER *version;
+    /** Indicates the domain parameter identifier */
+    ASN1_INTEGER *parameterId;
+    } PACE_INFO;
+
+/** Algorithm Identifier structure */
+typedef struct algorithm_identifier_st {
+    /** OID of the algorithm */
+    ASN1_OBJECT *algorithm;
+    union {
+        PACE_ECPARAMETERS *ec;
+        DH *dh;
+        ASN1_TYPE *other;
+    } parameters;
+} ALGORITHM_IDENTIFIER;
+
+/** Domain parameter structure */
+typedef struct pace_dp_info_st {
+    /** OID of the type of domain parameters*/
+    ASN1_OBJECT *protocol;
+    /** The actual domain parameters */
+    ALGORITHM_IDENTIFIER *aid;
+    /** Optional: specifies the local domain parameters if multiple sets of domain
+        parameters are provided */
+    ASN1_INTEGER *parameterId;
+} PACE_DP_INFO;
+/** @} ***********************************************************************/
+
+#endif /* PACE_ASN1_H_ */
Index: openssl/crypto/pace/pace_dh.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_dh.c	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,214 @@
+/**
+ * @file
+ * @brief Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include "pace_dh.h"
+
+int
+init_dh(DH ** dh)
+{
+    int i;
+    DH *tmp = NULL;
+
+    if (!*dh) {
+        tmp = DH_new();
+        if(!tmp || !DH_generate_parameters_ex(tmp, 64, DH_GENERATOR_5, NULL))
+            goto err;
+    } else
+    	tmp = *dh;
+
+    if (!DH_check(tmp, &i) || i) {
+        if (i)
+            PACEerr(PACE_F_INIT_DH, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+        goto err;
+    }
+
+    if (!*dh) {
+    	*dh = tmp;
+    }
+
+    return 1;
+
+err:
+    if (!*dh && tmp) {
+        DH_free(tmp);
+    }
+
+    return 0;
+}
+
+int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret)
+{
+    BIGNUM *bn = NULL;
+    int ok = 0;
+
+    if (!dh)
+        goto err;
+
+    /* Verify that y lies within the interval [2,p-1]. */
+    if (!DH_check_pub_key(dh, dh->pub_key, ret))
+        goto err;
+
+    /* If the DH is conform to RFC 2631 it should have a non-NULL q.
+     * Others (like the DHs generated from OpenSSL) might have a problem with
+     * this check. */
+    if (dh->q) {
+        /* Compute y^q mod p. If the result == 1, the key is valid. */
+        bn = BN_new();
+        if (!bn || !BN_mod_exp(bn, dh->pub_key, dh->q, dh->p, ctx))
+            goto err;
+        if (!BN_is_one(bn))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
+    }
+    ok = 1;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+
+    return ok;
+}
+
+
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *q = NULL, *bn = NULL;
+    int i;
+
+    if (!dh->q) {
+        q = BN_new();
+        bn = BN_dup(dh->p);
+        /* DH primes should be strong, based on a Sophie Germain prime q
+         * p=(2*q)+1 or (p-1)/2=q */
+        if (!q || !bn ||
+                !BN_sub_word(bn, 1) ||
+                !BN_rshift1(q, bn)) {
+            goto err;
+        }
+        BN_clear_free(bn);
+    } else {
+        q = BN_dup(dh->q);
+    }
+
+    /* q should always be prime */
+    i = BN_is_prime(q, BN_prime_checks, NULL, ctx, NULL);
+    if (i <= 0) {
+        if (i == 0)
+            PACEerr(PACE_F_DH_GET_SG_PRIME, PACE_R_UNABLE_TO_GET_SG_PRIME);
+        goto err;
+    }
+
+    return q;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (q)
+        BN_clear_free(q);
+
+    return NULL;
+}
+
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *order = NULL, *bn = NULL;
+
+    if (!dh)
+        goto err;
+
+    /* suppose the order of g is q-1 */
+    order = DH_get_q(dh, ctx);
+    bn = BN_new();
+    if (!bn || !order || !BN_sub_word(order, 1) ||
+            !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+        goto err;
+
+    if (BN_cmp(bn, BN_value_one()) != 0) {
+        /* if bn != 1, then q-1 is not the order of g, but p-1 should be */
+        if (!BN_sub(order, dh->p, BN_value_one()) ||
+                !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+            goto err;
+        if (BN_cmp(bn, BN_value_one()) != 0) {
+            PACEerr(PACE_F_DH_GET_ORDER, PACE_R_UNABLE_TO_GET_ORDER);
+            goto err;
+        }
+    }
+
+    BN_clear_free(bn);
+
+    return order;
+
+err:
+    if (order)
+        BN_clear_free(order);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
+
+BUF_MEM *
+dh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    int ret;
+
+    if (!dp || !dp->domainParameter || !ctx ||
+            !DH_generate_key(dp->domainParameter->parameters.dh) ||
+            !DH_check_pub_key_rfc(dp->domainParameter->parameters.dh,
+                    ctx->bn_ctx, &ret))
+        return NULL;
+
+    if (ret) {
+        PACEerr(PACE_F_DH_GM_COMPUTE_KEY, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+        return NULL;
+    }
+
+    return BN_bn2buf(dp->domainParameter->parameters.dh->pub_key);
+}
+
+BUF_MEM *
+dh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    BIGNUM * bn = NULL;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.dh ||
+            !ctx || !in)
+        goto err;
+
+    /* decode public key */
+    bn = BN_bin2bn((unsigned char *) in->data, in->length, bn);
+    if (!bn)
+        goto err;
+
+    out = BUF_MEM_create(DH_size(dp->domainParameter->parameters.dh));
+    if (!out)
+        goto err;
+
+    out->length = DH_compute_key((unsigned char *) out->data, bn,
+            dp->domainParameter->parameters.dh);
+    if (out->length < 0)
+        goto err;
+
+    BN_clear_free(bn);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
+
Index: openssl/crypto/pace/pace_dh.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_dh.h	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,92 @@
+/**
+ * @file
+ * @brief Interface to Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_DH_H_
+#define PACE_DH_H_
+
+#include <openssl/bn.h>
+#include <openssl/dh.h>
+#include <openssl/buffer.h>
+
+/**
+ * @brief initializes a DH key structure. If the structure is already initialised,
+ * nothing is done
+ *
+ * @param dh DH object to use
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_dh(DH ** dh);
+/**
+ * @brief Computes the prime on which the modulus is based.
+ *
+ * If DH->q does not exist, tries to guess a Sophie Germain prime matching the
+ * DH's modulus.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object
+ *
+ * @return q or NULL if an error occurred
+ */
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Computes the order of the DH's generator.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object (optional)
+ *
+ * @return order of g or NULL if an error occurred
+ *
+ * @note This calculation is for DHs using a safe prime, which will generate
+ * either an order-q or an order-2q group (see crypto/dh/dh_gen.c:151).
+ */
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Public key validation method described in RFC 2631.
+ *
+ * Verify that DH->pub_key lies within the interval [2,p-1]. If it does not,
+ * the key is invalid.
+ * If DH->q exists, compute y^q mod p. If the result == 1, the key is valid.
+ * Otherwise the key is invalid.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object
+ * @param ret Can contain these flags as result:
+ * DH_CHECK_PUBKEY_TOO_SMALL (smaller than 2)
+ * DH_CHECK_PUBKEY_TOO_LARGE (bigger than p-1)
+ * DH_CHECK_PUBKEY_INVALID (y^q mod p != 1)
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret);
+#define DH_CHECK_PUBKEY_INVALID		0x04
+
+/**
+ * @brief Generates a DH keypair
+ *
+ * @param dp object containing the DH object
+ * @param ctx
+ *
+ * @return public key of the generated keypair or NULL if an error occurred
+ */
+BUF_MEM *
+dh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes a DH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+dh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+		const BUF_MEM * in);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/pace/pace_ecdh.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_ecdh.c	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,163 @@
+/**
+ * @file
+ * @brief Elliptic curve Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/objects.h>
+#include "pace_ecdh.h"
+
+int
+init_ecdh(EC_KEY ** ecdh)
+{
+    EC_KEY * tmp = NULL;
+
+    if (!*ecdh) {
+        /* Use default curve */
+        tmp = EC_KEY_new_by_curve_name(NID_brainpoolP256r1);
+        if (!tmp)
+            goto err;
+    }
+
+    if (!*ecdh)
+        *ecdh = tmp;
+    return 1;
+
+err:
+    if (!*ecdh && tmp)
+        EC_KEY_free(tmp);
+    return 0;
+}
+
+BUF_MEM *
+ecdh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    if (!dp || !ctx || !dp->domainParameter
+            || !dp->domainParameter->parameters.ecdh)
+        return NULL;
+    if (!EC_KEY_generate_key(dp->domainParameter->parameters.ecdh))
+        return NULL;
+
+    /* The key agreement algorithm ECKA prevents small subgroup attacks by
+     * using compatible cofactor multiplication. */
+
+    return EC_POINT_point2buf(dp->domainParameter->parameters.ecdh, ctx->bn_ctx,
+            EC_KEY_get0_public_key(dp->domainParameter->parameters.ecdh));
+}
+
+BUF_MEM *
+ecdh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EC_POINT * ecp = NULL;
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !in)
+        goto err;
+
+    /* decode public key */
+    ecp = EC_POINT_new(EC_KEY_get0_group(dp->domainParameter->parameters.ecdh));
+    if (!ecp || !EC_POINT_oct2point(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), ecp,
+            (unsigned char *) in->data, in->length, ctx->bn_ctx))
+        goto err;
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(EC_POINT_point2oct(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), ecp, EC_KEY_get_conv_form(
+            dp->domainParameter->parameters.ecdh), NULL, 0, ctx->bn_ctx));
+    if (!out)
+        goto err;
+
+    /* copy data and set length */
+    out->length = ECDH_compute_key(out->data, out->max, ecp,
+            dp->domainParameter->parameters.ecdh, NULL);
+
+    EC_POINT_free(ecp);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (ecp)
+        EC_POINT_free(ecp);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+dp_ecdh_new_generator(const PACEDomainParameterInfo *template,
+        const EC_POINT *g, BN_CTX *ctx)
+{
+    BIGNUM *order = NULL, *cofactor = NULL;
+    PACEDomainParameterInfo * out = NULL;
+    EC_GROUP *group = NULL;
+    const EC_GROUP *old_group;
+
+    if (!template || !template->domainParameter
+            || !template->domainParameter->parameters.ecdh)
+        goto err;
+
+    old_group = EC_KEY_get0_group(template->domainParameter->parameters.ecdh);
+    order = BN_new();
+    cofactor = BN_new();
+    if (!order || !cofactor || !EC_GROUP_get_order(old_group, order, ctx)
+            || !EC_GROUP_get_cofactor(old_group, cofactor, ctx))
+        goto err;
+
+    group = EC_GROUP_dup(old_group);
+    out = PACEDomainParameterInfo_dup(template);
+    if (!group || !out || !EC_POINT_is_on_curve(group, g, ctx)
+            || !EC_GROUP_set_generator(group, g, order, cofactor)
+            || !EC_GROUP_check(group, ctx) || !EC_KEY_set_group(
+            out->domainParameter->parameters.ecdh, group))
+        goto err;
+
+    BN_clear_free(cofactor);
+    BN_clear_free(order);
+    EC_GROUP_clear_free(group);
+
+    return out;
+
+err:
+    if (group)
+        EC_GROUP_clear_free(group);
+    if (cofactor)
+        BN_clear_free(cofactor);
+    if (order)
+        BN_clear_free(order);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+dp_ecdh_new_generator_by_coordinates(const PACEDomainParameterInfo *template,
+        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
+{
+    EC_POINT *g;
+    PACEDomainParameterInfo *out;
+    if (!template || !template->domainParameter
+            || !template->domainParameter->parameters.ecdh)
+        return NULL;
+
+    g = EC_POINT_new(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh));
+    if (!g)
+        return NULL;
+    if (!EC_POINT_set_affine_coordinates_GFp(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh), g, x, y, ctx)) {
+        EC_POINT_free(g);
+        return NULL;
+    }
+
+    out = dp_ecdh_new_generator(template, g, ctx);
+
+    EC_POINT_free(g);
+
+    return out;
+}
Index: openssl/crypto/pace/pace_ecdh.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_ecdh.h	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,77 @@
+/**
+ * @file
+ * @brief Interface to elliptic curve Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_ECDH_H_
+#define PACE_ECDH_H_
+
+#include <openssl/ec.h>
+#include <openssl/pace.h>
+#include <openssl/buffer.h>
+#include <openssl/bn.h>
+/**
+ * @brief initializes a key for ECDH. If the object is already initialised,
+ * nothing is don
+ *
+ * @param ecdh elliptic curve object to use
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_ecdh(EC_KEY ** ecdh);
+/**
+ * @brief Generates an ECDH keypair
+ *
+ * @param dp object containing the EC_KEY object
+ * @param ctx
+ *
+ * @return public key of the generated keypair or NULL if an error occurred
+ */
+BUF_MEM *
+ecdh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes an ECDH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+ecdh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+		const BUF_MEM * in);
+
+/**
+ * @brief creates a duplicate of template and changes the generator of its
+ * EC_KEY object
+ *
+ * @param template
+ * @param g the generator to use
+ * @param ctx (optional)
+ *
+ * @return the new and modified PACEDomainParameterInfo object or NULL if an
+ * error occurred
+ */
+PACEDomainParameterInfo *
+dp_ecdh_new_generator(const PACEDomainParameterInfo *template, const EC_POINT *g,
+		BN_CTX *ctx);
+/**
+ * @brief creates a duplicate of template and changes the generator of its
+ * EC_KEY object
+ *
+ * @param template
+ * @param x affine coordinate of the generator
+ * @param y affine coordinate of the generator
+ * @param ctx (optional)
+ *
+ * @return the new and modified PACEDomainParameterInfo object or NULL if an
+ * error occurred
+ *
+ * @see dp_ecdh_new_generator()
+ */
+PACEDomainParameterInfo *
+dp_ecdh_new_generator_by_coordinates(const PACEDomainParameterInfo *template,
+		const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);
+
+#endif /*PACE_ECDH_H_*/
Index: openssl/crypto/pace/pace_err.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_err.c	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,107 @@
+/* crypto/pace/pace_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2009 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_PACE,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_PACE,0,reason)
+
+static ERR_STRING_DATA PACE_str_functs[]=
+	{
+{ERR_FUNC(PACE_F_ASN1_PUBKEY),	"ASN1_PUBKEY"},
+{ERR_FUNC(PACE_F_DH_GET_ORDER),	"DH_GET_ORDER"},
+{ERR_FUNC(PACE_F_DH_GET_SG_PRIME),	"DH_GET_SG_PRIME"},
+{ERR_FUNC(PACE_F_DH_GM_COMPUTE_KEY),	"DH_GM_COMPUTE_KEY"},
+{ERR_FUNC(PACE_F_DH_IM_COMPUTE_KEY),	"DH_IM_COMPUTE_KEY"},
+{ERR_FUNC(PACE_F_ECDH_INTEGRATED_MAPPING),	"ECDH_INTEGRATED_MAPPING"},
+{ERR_FUNC(PACE_F_INIT_DH),	"INIT_DH"},
+{ERR_FUNC(PACE_F_PACE_STEP3B_PROCESS),	"PACE_STEP3B_PROCESS"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA PACE_str_reasons[]=
+	{
+{ERR_REASON(PACE_R_BAD_DH_GENERATOR)     ,"bad dh generator"},
+{ERR_REASON(PACE_R_BAD_DH_OR_ECKEY_OBJECT),"bad dh or eckey object"},
+{ERR_REASON(PACE_R_BAD_FORMAT)           ,"bad format"},
+{ERR_REASON(PACE_R_UNABLE_TO_GET_ORDER)  ,"unable to get order"},
+{ERR_REASON(PACE_R_UNABLE_TO_GET_SG_PRIME),"unable to get sg prime"},
+{ERR_REASON(PACE_R_UNSUITED_CURVE)       ,"unsuited curve"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_PACE_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(PACE_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,PACE_str_functs);
+		ERR_load_strings(0,PACE_str_reasons);
+		}
+#endif
+	}
Index: openssl/crypto/pace/pace_kdf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_kdf.c	2010-10-26 11:06:04.000000000 +0200
@@ -0,0 +1,96 @@
+/**
+ * @file
+ * @brief Key derivation functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+
+#include "pace_kdf.h"
+#include "pace_util.h"
+
+BUF_MEM *
+kdf(const BUF_MEM * key, const BUF_MEM * nonce, const uint32_t counter,
+        const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, int keylen)
+{
+    int inlen;
+    BUF_MEM *in = NULL, *digest = NULL, *out = NULL;
+
+    if (!key || keylen > EVP_MD_size(md))
+        goto err;
+
+    in = BUF_MEM_new();
+    if (!in)
+        goto err;
+
+    /* Concatenate secret || nonce || counter
+     * nonce is optional */
+    if (nonce) {
+        inlen = key->length + nonce->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        /* Flawfinder: ignore */
+        memcpy(in->data, key->data, key->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length, nonce->data, nonce->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length + nonce->length, &counter, sizeof counter);
+    } else {
+        inlen = key->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        /* Flawfinder: ignore */
+        memcpy(in->data, key->data, key->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length, &counter, sizeof counter);
+    }
+
+    digest = hash(md, ctx, impl, in);
+    if (!digest)
+        goto err;
+
+    /* Truncate the hash to keylen Bytes */
+    out = BUF_MEM_create_init(digest->data, keylen);
+
+    OPENSSL_cleanse(in->data, in->max);
+    BUF_MEM_free(in);
+    OPENSSL_cleanse(digest->data, digest->max);
+    BUF_MEM_free(digest);
+
+    return out;
+
+err:
+    if (in) {
+        OPENSSL_cleanse(in->data, in->max);
+        BUF_MEM_free(in);
+    }
+    if (out) {
+        OPENSSL_cleanse(out->data, out->max);
+        BUF_MEM_free(out);
+    }
+    if (digest) {
+        OPENSSL_cleanse(digest->data, digest->max);
+        BUF_MEM_free(digest);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+kdf_pi(const PACE_SEC * pi, const BUF_MEM * nonce, const EVP_MD * md,
+        EVP_MD_CTX * ctx, ENGINE * impl, int keylen)
+{
+    BUF_MEM * out;
+    BUF_MEM * enc = encoded_secret(pi);
+    if (!enc)
+        return NULL;
+
+    out = kdf(enc, nonce, htonl(KDF_PI_COUNTER), md, ctx, impl, keylen);
+
+    OPENSSL_cleanse(enc->data, enc->max);
+    BUF_MEM_free(enc);
+
+    return out;
+}
Index: openssl/crypto/pace/pace_kdf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_kdf.h	2010-10-26 11:05:52.000000000 +0200
@@ -0,0 +1,65 @@
+/**
+ * @file
+ * @brief Interface to key derivation functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_KDF_H_
+#define PACE_KDF_H_
+
+#include <netinet/in.h>
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/pace.h>
+#include <stdint.h>
+
+/**
+ * @defgroup kdf            Key Derivation Functions
+ * @{ ************************************************************************/
+
+/**
+ * @brief General key derivation function according to TR-3110 F.3.1
+ *
+ * @param key Shared secret
+ * @param nonce (optional)
+ * @param counter Formatted in big endian
+ * @param md Message digest to use
+ * @param ctx EVP_MD_CTX object to use (optional)
+ * @param impl ENGINE object to use for message digest (optional)
+ * @param keylen Size of the output key. Must be smaller than the size of the
+ *               hash function
+ *
+ * @return derivated key or NULL if an error occurred
+ */
+BUF_MEM * kdf(const BUF_MEM * key, const BUF_MEM * nonce,
+        const uint32_t counter, const EVP_MD * md, EVP_MD_CTX * ctx,
+        ENGINE * impl, int keylen);
+#define KDF_ENC_COUNTER 1
+#define KDF_MAC_COUNTER 2
+#define KDF_PI_COUNTER  3
+/**
+ * @brief Key derivation function to derive encryption key
+ *
+ * @see kdf()
+ */
+#define kdf_enc(key, nonce, md, ctx, impl, keylen) \
+    kdf(key, nonce, htonl(KDF_ENC_COUNTER), md, ctx, impl, keylen)
+/**
+ * @brief Key derivation function to derive authentication key
+ *
+ * @see kdf()
+ */
+#define kdf_mac(key, nonce, md, ctx, impl, keylen) \
+    kdf(key, nonce, htonl(KDF_MAC_COUNTER), md, ctx, impl, keylen)
+/**
+ * @brief Key derivation function from a password pi
+ *
+ * @see kdf()
+ */
+BUF_MEM * kdf_pi(const PACE_SEC * pi, const BUF_MEM * nonce,
+        const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, int keylen);
+/** @} ***********************************************************************/
+
+#endif /*PACE_KDF_H_*/
Index: openssl/crypto/pace/pace_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_lib.c	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,528 @@
+/**
+ * @file
+ * @brief Data management functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include "pace_mappings.h"
+#include "pace_dh.h"
+#include "pace_ecdh.h"
+
+void
+AlgorithmIdentifier_clear_free(AlgorithmIdentifier * dp)
+{
+    if (dp) {
+        switch (dp->algorithm) {
+            case NID_dhpublicnumber:
+                if (dp->parameters.dh) {
+                    DH_free(dp->parameters.dh);
+                }
+                break;
+            case NID_X9_62_id_ecPublicKey:
+            /* Note: Test cards differ from the official specification, therefore
+             *       we need to handle some additional OIDs */
+            case NID_ecka_dh_SessionKDF_DES3:
+            case NID_ecka_dh_SessionKDF_AES128:
+            case NID_ecka_dh_SessionKDF_AES192:
+            case NID_ecka_dh_SessionKDF_AES256:
+                if (dp->parameters.ecdh)
+                    EC_KEY_free(dp->parameters.ecdh);
+                break;
+            default:
+                break;
+        }
+        OPENSSL_free(dp);
+    }
+}
+
+AlgorithmIdentifier *
+AlgorithmIdentifier_new(void)
+{
+    AlgorithmIdentifier * out =
+            (AlgorithmIdentifier *) OPENSSL_malloc(sizeof(AlgorithmIdentifier));
+    if (!out)
+        return NULL;
+
+    out->algorithm = NID_undef;
+    out->parameters.dh = NULL;
+    /*out->parameters.ecdh = NULL;*/
+
+    return out;
+}
+
+AlgorithmIdentifier *
+AlgorithmIdentifier_dup(const AlgorithmIdentifier * dp_in)
+{
+    AlgorithmIdentifier * out = NULL;
+
+    if (!dp_in)
+        goto err;
+
+    out = AlgorithmIdentifier_new();
+    if (!out)
+        goto err;
+
+    out->algorithm = dp_in->algorithm;
+    switch (dp_in->algorithm) {
+        case NID_dhpublicnumber:
+            if (dp_in->parameters.dh) {
+                out->parameters.dh = DHparams_dup(dp_in->parameters.dh);
+                if (!out->parameters.dh)
+                    goto err;
+                BN_clear_free(out->parameters.dh->priv_key);
+                BN_clear_free(out->parameters.dh->pub_key);
+            }
+            break;
+
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards differ from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            if (dp_in->parameters.ecdh) {
+                out->parameters.ecdh = EC_KEY_dup(dp_in->parameters.ecdh);
+                if (!out->parameters.ecdh)
+                    goto err;
+                /* Note: functions will return 0, but nothing bad happens */
+                EC_KEY_set_private_key(out->parameters.ecdh, NULL);
+                EC_KEY_set_public_key(out->parameters.ecdh, NULL);
+            }
+            break;
+
+        default:
+            goto err;
+    }
+
+    return out;
+
+err:
+    if (out)
+        AlgorithmIdentifier_clear_free(out);
+
+    return NULL;
+}
+
+void
+PACE_SEC_clean_free(PACE_SEC * s)
+{
+    if (s) {
+        if (s->mem) {
+            OPENSSL_cleanse(s->mem->data, s->mem->max);
+            BUF_MEM_free(s->mem);
+        }
+        OPENSSL_free(s);
+    }
+}
+
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type)
+{
+    PACE_SEC * out = (PACE_SEC *) OPENSSL_malloc(sizeof(PACE_SEC));
+    if (!out)
+        goto err;
+
+    switch (type) {
+        case PACE_PUK:
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_MRZ:
+        case PACE_RAW:
+            out->type = type;
+            break;
+
+        default:
+            goto err;
+    }
+
+    out->mem = BUF_MEM_create_init(sec, sec_len);
+    if (!out->mem)
+        goto err;
+
+    return out;
+
+err:
+    PACE_SEC_clean_free(out);
+
+    return NULL;
+}
+
+void
+PACE_CTX_clear_free(PACE_CTX * ctx)
+{
+    if (ctx) {
+        if (ctx->bn_ctx)
+            BN_CTX_free(ctx->bn_ctx);
+        if (ctx->md_ctx)
+            EVP_MD_CTX_destroy(ctx->md_ctx);
+        if (ctx->cipher_ctx)
+            EVP_CIPHER_CTX_free(ctx->cipher_ctx);
+        if (ctx->cmac_ctx) /* FIXME: Segfaults if CMAC_Init has not been called */
+            CMAC_CTX_free(ctx->cmac_ctx);
+        OPENSSL_free(ctx);
+    }
+}
+
+PACE_CTX *
+PACE_CTX_new(void)
+{
+    PACE_CTX * out = (PACE_CTX *) OPENSSL_malloc(sizeof(PACE_CTX));
+    if (!out)
+        return NULL;
+
+    out->bn_ctx = NULL;
+    out->md = NULL;
+    out->md_ctx = NULL;
+    out->md_engine = NULL;
+    out->cmac_ctx = NULL;
+    out->cipher_ctx = NULL;
+    out->cipher_engine = NULL;
+    out->iv = NULL;
+
+    return out;
+}
+
+int
+PACE_CTX_init(PACE_CTX * ctx, PACEInfo * info)
+{
+    EVP_MD_CTX *md_ctx = NULL;
+    EVP_CIPHER_CTX *cipher_ctx = NULL;
+    BN_CTX *bn_ctx = NULL;
+    CMAC_CTX *cmac_ctx = NULL;
+
+    if (!ctx || !info)
+        goto err;
+
+    ctx->iv = NULL;
+    ctx->tr_version = PACE_TR_VERSION_2_02;
+
+    switch (info->protocol) {
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            break;
+
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+            /*if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            /*if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_im_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_im_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+/*            if (!ctx->cmac_ctx) {
+                cmac_ctx = CMAC_CTX_new();
+                if (!cmac_ctx)
+                    goto err;
+            }*/
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->map_generate_key = ecdh_im_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            ctx->map_generate_key = ecdh_im_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            break;
+
+        default:
+            goto err;
+    }
+
+    if (!ctx->md_ctx) {
+        md_ctx = EVP_MD_CTX_create();
+        if (!md_ctx)
+            goto err;
+    }
+    if (!ctx->cipher_ctx) {
+        cipher_ctx = EVP_CIPHER_CTX_new();
+        if (!cipher_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(cipher_ctx);
+        if (!EVP_CipherInit_ex(cipher_ctx, ctx->cipher,
+                    ctx->cipher_engine, ctx->iv, NULL, -1))
+            goto err;
+    }
+    if (!ctx->bn_ctx) {
+        bn_ctx = BN_CTX_new();
+        if (!bn_ctx)
+            goto err;
+    }
+
+    if (md_ctx)
+        ctx->md_ctx = md_ctx;
+    if (cipher_ctx)
+        ctx->cipher_ctx = cipher_ctx;
+    if (bn_ctx)
+        ctx->bn_ctx = bn_ctx;
+    if (cmac_ctx)
+        ctx->cmac_ctx = cmac_ctx;
+
+    return 1;
+
+err:
+    if (md_ctx)
+        EVP_MD_CTX_destroy(md_ctx);
+    if (cipher_ctx)
+        EVP_CIPHER_CTX_cleanup(cipher_ctx);
+    if (bn_ctx)
+        BN_CTX_free(bn_ctx);
+    if (cmac_ctx)
+        CMAC_CTX_free(cmac_ctx);
+
+    return 0;
+}
+
+PACEInfo *
+PACEInfo_new(void)
+{
+    PACEInfo * out = (PACEInfo *) OPENSSL_malloc(sizeof(PACEInfo));
+
+    if (!out)
+        goto err;
+
+    out->parameterId = 0;
+    out->protocol = 0;
+    out->version = 0;
+
+    return out;
+
+err:
+    return NULL;
+}
+
+void
+PACEInfo_free(PACEInfo * info)
+{
+    if (info)
+        OPENSSL_free(info);
+    return;
+}
+
+void
+PACEDomainParameterInfo_clear_free(PACEDomainParameterInfo * dp)
+{
+    if (dp && dp->domainParameter) {
+        AlgorithmIdentifier_clear_free(dp->domainParameter);
+    }
+
+    PACEDomainParameterInfo_free(dp);
+}
+
+void
+PACEDomainParameterInfo_free(PACEDomainParameterInfo * dp)
+{
+    if (dp) {
+        OPENSSL_free(dp);
+    }
+}
+
+PACEDomainParameterInfo *
+PACEDomainParameterInfo_new(void)
+{
+    PACEDomainParameterInfo * out = (PACEDomainParameterInfo *) OPENSSL_malloc(
+            sizeof(PACEDomainParameterInfo));
+    if (!out)
+        return NULL;
+
+    out->domainParameter = NULL;
+    out->parameterId = 0;
+    out->protocol = NID_undef;
+
+    return out;
+}
+
+PACEDomainParameterInfo *
+PACEDomainParameterInfo_dup(const PACEDomainParameterInfo * dp_in)
+{
+    PACEDomainParameterInfo * dp_out = NULL;
+
+    if (!dp_in) {
+        goto err;
+    }
+
+    dp_out = PACEDomainParameterInfo_new();
+    if (!dp_out)
+        goto err;
+
+    if (dp_in->domainParameter) {
+        dp_out->domainParameter = AlgorithmIdentifier_dup(
+                dp_in->domainParameter);
+        if (!dp_out->domainParameter)
+            goto err;
+    }
+
+    dp_out->protocol = dp_in->protocol;
+    dp_out->parameterId = dp_in->parameterId;
+
+    return dp_out;
+
+err:
+    PACEDomainParameterInfo_clear_free(dp_out);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_mappings.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_mappings.c	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,391 @@
+/**
+ * @file
+ * @brief Functions for domain parameter mappings
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/bn.h>
+#include <openssl/ec.h>
+#include <openssl/err.h>
+#include "pace_mappings.h"
+#include "pace_util.h"
+#include "pace_dh.h"
+#include "pace_ecdh.h"
+
+PACEDomainParameterInfo *
+dh_gm_compute_key(const PACEDomainParameterInfo * dp_info,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL, *bn_h = NULL, *bn_g = NULL;
+
+    if (!dp_info || !ctx || !s)
+        goto err;
+
+    out = PACEDomainParameterInfo_dup(dp_info);
+    if (!out)
+        goto err;
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    /* complete the DH and convert the result to a BIGNUM */
+    mem_h = dh_compute_key(dp_info, ctx, in);
+    if (!mem_h)
+        goto err;
+    bn_h = BN_bin2bn((unsigned char *) mem_h->data, mem_h->length, bn_h);
+    if (!bn_h)
+        goto err;
+
+    /* map to new generator */
+    bn_g = BN_new();
+    if (!bn_g ||
+        /* bn_g = g^s mod p */
+        !BN_mod_exp(bn_g, dp_info->domainParameter->parameters.dh->g, bn_s,
+                dp_info->domainParameter->parameters.dh->p, ctx->bn_ctx) ||
+        /* out->parameters.dh->g = bn_g * h mod p = g^s * h mod p */
+        !BN_mod_mul(out->domainParameter->parameters.dh->g, bn_g, bn_h,
+                dp_info->domainParameter->parameters.dh->p, ctx->bn_ctx))
+        goto err;
+
+    BUF_MEM_free(mem_h);
+    BN_clear_free(bn_h);
+    BN_clear_free(bn_g);
+    BN_clear_free(bn_s);
+
+    return out;
+
+err:
+    if (mem_h)
+        BUF_MEM_free(mem_h);
+    if (bn_h)
+        BN_clear_free(bn_h);
+    if (bn_g)
+        BN_clear_free(bn_g);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+dh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    if (!ctx)
+        return NULL;
+
+    return randb(EVP_CIPHER_key_length(ctx->cipher));
+}
+
+PACEDomainParameterInfo *
+dh_im_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BUF_MEM * x_mem = NULL;
+    BIGNUM * x_bn = NULL, *a = NULL, *p_1 = NULL, *q = NULL;
+
+    if (!in || in->length < EVP_CIPHER_key_length(ctx->cipher)
+            || !dp->domainParameter || !dp->domainParameter->parameters.dh)
+        goto err;
+
+    out = PACEDomainParameterInfo_dup(dp);
+    x_mem = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *) in->data, ctx->iv, 1, s, 1);
+    if (!x_mem)
+        goto err;
+    x_bn = BN_bin2bn((unsigned char *) x_mem->data, x_mem->length, x_bn);
+    a = BN_new();
+    q = DH_get_q(dp->domainParameter->parameters.dh, ctx->bn_ctx);
+    p_1 = BN_dup(dp->domainParameter->parameters.dh->p);
+    if (!out || !x_bn || !a || !q || !p_1 ||
+            /* p_1 = p-1 */
+            !BN_sub_word(p_1, 1) ||
+            /* a = p-1 / q */
+            !BN_div(a, NULL, p_1, q, ctx->bn_ctx) ||
+            /* g~ = x^a mod p */
+            !BN_mod_exp(out->domainParameter->parameters.dh->g, x_bn, a,
+                dp->domainParameter->parameters.dh->p, ctx->bn_ctx))
+        goto err;
+
+    /* check if g~ != 1 */
+    if (BN_is_one(out->domainParameter->parameters.dh->g))
+        PACEerr(PACE_F_DH_IM_COMPUTE_KEY, PACE_R_BAD_DH_GENERATOR);
+
+    BN_clear_free(q);
+    BN_clear_free(p_1);
+    BN_clear_free(a);
+    BN_clear_free(x_bn);
+    BUF_MEM_free(x_mem);
+
+    return out;
+
+err:
+    if (q)
+        BN_clear_free(q);
+    if (p_1)
+        BN_clear_free(p_1);
+    if (a)
+        BN_clear_free(a);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+    if (x_bn)
+        BN_clear_free(x_bn);
+    if (x_mem)
+        BUF_MEM_free(x_mem);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+ecdh_gm_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL;
+    EC_POINT * ecp_h = NULL, *ecp_g = NULL;
+    const ECDH_METHOD *default_method;
+    const EC_GROUP * group;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !s)
+        goto err;
+
+    group = EC_KEY_get0_group(dp->domainParameter->parameters.ecdh);
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    default_method = ECDH_get_default_method();
+    ECDH_set_default_method(ECDH_OpenSSL_Point());
+    /* complete the ECDH and get the resulting point h */
+    mem_h = ecdh_compute_key(dp, ctx, in);
+    ECDH_set_default_method(default_method);
+    ecp_h = EC_POINT_new(group);
+    if (!mem_h || !ecp_h || !EC_POINT_oct2point(group, ecp_h,
+            (unsigned char *) mem_h->data, mem_h->length, ctx->bn_ctx))
+        goto err;
+
+    /* map to new generator */
+    ecp_g = EC_POINT_new(group);
+    /* g' = g*s + h*1 */
+    if (!EC_POINT_mul(group, ecp_g, bn_s, ecp_h, BN_value_one(), ctx->bn_ctx))
+        goto err;
+
+    /* configure the new EC_KEY */
+    out = dp_ecdh_new_generator(dp, ecp_g, ctx->bn_ctx);
+
+    EC_POINT_clear_free(ecp_g);
+    EC_POINT_clear_free(ecp_h);
+    BUF_MEM_free(mem_h);
+    BN_clear_free(bn_s);
+
+    return out;
+
+err:
+    if (ecp_g)
+        EC_POINT_clear_free(ecp_g);
+    if (ecp_h)
+        EC_POINT_clear_free(ecp_h);
+    if (mem_h)
+        BUF_MEM_free(mem_h);
+    if (bn_s)
+        BN_clear_free(bn_s);
+
+    return NULL;
+}
+
+BUF_MEM *
+ecdh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    if (!ctx)
+        return NULL;
+
+    return randb(EVP_CIPHER_key_length(ctx->cipher));
+}
+
+PACEDomainParameterInfo *
+ecdh_im_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BUF_MEM * x_mem = NULL;
+    BIGNUM * a = NULL, *b = NULL, *p = NULL;
+    BIGNUM * x = NULL, *y = NULL, *v = NULL, *u = NULL;
+    BIGNUM * tmp = NULL, *tmp2 = NULL, *bn_const = NULL, *bn_inv = NULL;
+    BIGNUM * two = NULL, *three = NULL, *four = NULL, *six = NULL;
+    BIGNUM * twentyseven = NULL;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !s)
+        goto err;
+
+    /* Setup all the variables*/
+    a = BN_new();
+    b = BN_new();
+    p = BN_new();
+    x = BN_new();
+    y = BN_new();
+    v = BN_new();
+    two = BN_new();
+    three = BN_new();
+    four = BN_new();
+    six = BN_new();
+    twentyseven = BN_new();
+    tmp = BN_new();
+    tmp2 = BN_new();
+    bn_const = BN_new();
+    bn_inv = BN_new();
+    if (!a || !b || !p || !x || !y || !v ||
+            !two || !three || !three || !four || !six || !twentyseven ||
+            !tmp || !tmp2 || !bn_const ||
+            !bn_inv)
+        goto err;
+
+    /* Encrypt the Nonce using the symmetric key in */
+    x_mem = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *) in->data, ctx->iv, 1, s, 1);
+    if (!x_mem)
+        goto err;
+
+    /* Fetch the curve parameters */
+    if (!EC_GROUP_get_curve_GFp(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), p, a, b, ctx->bn_ctx))
+        goto err;
+
+    /* Assign constants */
+    if (    !BN_set_word(two,2)||
+            !BN_set_word(three,3)||
+            !BN_set_word(four,4)||
+            !BN_set_word(six,6)||
+            !BN_set_word(twentyseven,27)
+            ) goto err;
+
+    /* Check prerequisites for curve parameters */
+    if (
+            /* p > 3;*/
+           (BN_cmp(p, three) != 1) ||
+           /* p mod 3 = 2; (p has the form p=q^n, q prime) */
+           !BN_nnmod(tmp, p, three, ctx->bn_ctx) ||
+           (BN_cmp(tmp, two) != 0)) {
+        PACEerr(PACE_F_ECDH_INTEGRATED_MAPPING, PACE_R_UNSUITED_CURVE);
+        goto err;
+    }
+
+    /* Convert encrypted nonce to BIGNUM */
+    u = BN_bin2bn((unsigned char *) x_mem->data, x_mem->length, u);
+    if (!u)
+        goto err;
+
+    if ( /* v = (3a - u^4) / 6u mod p */
+            !BN_mod_mul(tmp, three, a, p, ctx->bn_ctx) ||
+            !BN_mod_exp(tmp2, u, four, p, ctx->bn_ctx) ||
+            !BN_mod_sub(v, tmp, tmp2, p, ctx->bn_ctx) ||
+            !BN_mod_mul(tmp, u, six, p, ctx->bn_ctx) ||
+            /* For division within a galois field we need to compute
+             * the multiplicative inverse of a number */
+            !BN_mod_inverse(bn_inv, tmp, p, ctx->bn_ctx) ||
+            !BN_mod_mul(v, v, bn_inv, p, ctx->bn_ctx) ||
+
+            /* x = (v^2 - b - ((u^6)/27)) */
+            !BN_mod_sqr(tmp, v, p, ctx->bn_ctx) ||
+            !BN_mod_sub(tmp2, tmp, b, p, ctx->bn_ctx) ||
+            !BN_mod_exp(tmp, u, six, p, ctx->bn_ctx) ||
+            !BN_mod_inverse(bn_inv, twentyseven, p, ctx->bn_ctx) ||
+            !BN_mod_mul(tmp, tmp, bn_inv, p, ctx->bn_ctx) ||
+            !BN_mod_sub(x, tmp2, tmp, p, ctx->bn_ctx) ||
+
+            /* x -> x^(1/3) = x^((2p^n -1)/3) */
+            !BN_mul(tmp, two, p, ctx->bn_ctx) ||
+            !BN_sub(tmp, tmp, BN_value_one()) ||
+
+            /* Division is defined, because p^n = 2 mod 3 */
+            !BN_div(tmp, y, tmp, three, ctx->bn_ctx) ||
+            !BN_mod_exp(tmp2, x, tmp, p, ctx->bn_ctx) ||
+            !BN_copy(x, tmp2) ||
+
+            /* x += (u^2)/3 */
+            !BN_mod_sqr(tmp, u, p, ctx->bn_ctx) ||
+            !BN_mod_inverse(bn_inv, three, p, ctx->bn_ctx) ||
+            !BN_mod_mul(tmp2, tmp, bn_inv, p, ctx->bn_ctx) ||
+            !BN_mod_add(tmp, x, tmp2, p, ctx->bn_ctx) ||
+            !BN_copy(x, tmp) ||
+
+            /* y = ux + v */
+            !BN_mod_mul(y, u, x, p, ctx->bn_ctx) ||
+            !BN_mod_add(tmp, y, v, p, ctx->bn_ctx) ||
+            !BN_copy(y, tmp)
+            )
+        goto err;
+
+    /* configure the new EC_KEY */
+    out = dp_ecdh_new_generator_by_coordinates(dp, x, y, ctx->bn_ctx);
+
+    BUF_MEM_free(x_mem); //XXX: Should we clean the memory?
+    BN_clear_free(a);
+    BN_clear_free(b);
+    BN_clear_free(p);
+    BN_clear_free(x);
+    BN_clear_free(y);
+    BN_clear_free(v);
+    BN_clear_free(u);
+    BN_clear_free(two);
+    BN_clear_free(three);
+    BN_clear_free(four);
+    BN_clear_free(six);
+    BN_clear_free(twentyseven);
+    BN_clear_free(tmp);
+    BN_clear_free(tmp2);
+    BN_clear_free(bn_const);
+    BN_clear_free(bn_inv);
+
+    return out;
+
+err:
+    if (x_mem)
+        BUF_MEM_free(x_mem); //XXX: Should we clean the memory?
+    if (a)
+        BN_clear_free(a);
+    if (b)
+        BN_clear_free(b);
+    if (p)
+        BN_clear_free(p);
+    if (x)
+        BN_clear_free(x);
+    if (y)
+        BN_clear_free(y);
+    if (v)
+        BN_clear_free(v);
+    if (u)
+        BN_clear_free(u);
+    if (two)
+        BN_clear_free(two);
+    if (three)
+        BN_clear_free(three);
+    if (four)
+        BN_clear_free(four);
+    if (six)
+        BN_clear_free(six);
+    if (twentyseven)
+        BN_clear_free(twentyseven);
+    if (tmp)
+        BN_clear_free(tmp);
+    if (tmp2)
+        BN_clear_free(tmp2);
+    if (bn_const)
+        BN_clear_free(bn_const);
+    if (bn_inv)
+        BN_clear_free(bn_inv);
+    PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_mappings.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_mappings.h	2010-10-14 13:47:07.000000000 +0200
@@ -0,0 +1,68 @@
+/**
+ * @file
+ * @brief Interface to functions for domain parameter mappings
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_MAPPINGS_H_
+#define PACE_MAPPINGS_H_
+
+#include <openssl/pace.h>
+#include <openssl/buffer.h>
+
+/**
+ * @defgroup encoding               Mapping
+ * @{ ************************************************************************/
+
+/**
+ * @brief Computes a key for DH Generic Mapping (see TR-3110 A.3.5.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+dh_gm_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Generates a key for DH Integrated Mapping (see TR-3110 A.3.5.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+BUF_MEM *
+dh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes a key for DH Integrated Mapping (see TR-3110 A.3.5.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+dh_im_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Computes a key for ECDH Generic Mapping (see TR-3110 A.3.4.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+ecdh_gm_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Generates a key for ECDH Integrated Mapping (see TR-3110 A.3.4.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+BUF_MEM *
+ecdh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes a key for ECDH Integrated Mapping (see TR-3110 A.3.4.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+ecdh_im_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+
+/** @} ***********************************************************************/
+
+#endif /*PACE_MAPPINGS_H_*/
Index: openssl/crypto/pace/pace_util.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_util.c	2010-10-26 11:18:00.000000000 +0200
@@ -0,0 +1,857 @@
+/**
+ * @file
+ * @brief Utility functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include <openssl/bio.h>
+#include <openssl/rand.h>
+#include <openssl/asn1.h>
+#include <openssl/conf.h>
+#include <openssl/err.h>
+#include "pace_util.h"
+#include "pace_dh.h"
+#include "pace.h"
+
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EVP_MD_CTX * tmp_ctx = NULL;
+    unsigned int tmp_len;
+
+    if (!md || !in)
+        goto err;
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_MD_CTX_create();
+        if (!tmp_ctx)
+            goto err;
+    }
+
+    tmp_len = EVP_MD_size(md);
+    out = BUF_MEM_create(tmp_len);
+    if (!out || !EVP_DigestInit_ex(tmp_ctx, md, impl) ||
+            !EVP_DigestUpdate(tmp_ctx, in->data, in->length) ||
+            !EVP_DigestFinal_ex(tmp_ctx, (unsigned char *) out->data,
+                &tmp_len))
+        goto err;
+    out->length = tmp_len;
+
+    if (!ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (tmp_ctx && !ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return NULL;
+}
+
+BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        const unsigned char *key, const unsigned char *iv, int enc, const BUF_MEM * in,
+        int init)
+{
+    BUF_MEM * out = NULL;
+    EVP_CIPHER_CTX * tmp_ctx = NULL;
+    int i;
+
+    if (!in)
+        goto err;
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_CIPHER_CTX_new();
+        if (!tmp_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(tmp_ctx);
+    }
+
+    if (tmp_ctx->flags & EVP_CIPH_NO_PADDING) {
+        i = in->length;
+        if (in->length % EVP_CIPHER_block_size(type) != 0) {
+            printf("Input length is not a multiple of block length\n");
+            goto err;
+        }
+    } else
+        i = in->length + EVP_CIPHER_block_size(type);
+
+    out = BUF_MEM_create(i);
+    if (!out)
+        goto err;
+
+    /* get cipher */
+    if (ctx && init)
+        if (!EVP_CipherInit_ex(tmp_ctx, type, impl, key, iv, enc))
+            goto err;
+
+    if (!EVP_CipherUpdate(tmp_ctx, (unsigned char *) out->data, &i,
+            (unsigned char *) in->data, in->length))
+        goto err;
+    out->length = i;
+
+    if (!EVP_CipherFinal_ex(tmp_ctx, (unsigned char *) (out->data + out->length),
+            &i))
+            goto err;
+
+    if (!(tmp_ctx->flags & EVP_CIPH_NO_PADDING))
+        out->length += i;
+
+    if (!ctx) {
+        EVP_CIPHER_CTX_cleanup(tmp_ctx);
+        EVP_CIPHER_CTX_free(tmp_ctx);
+    }
+
+    return out;
+
+err:
+
+    if (out)
+        BUF_MEM_free(out);
+    if (!ctx && tmp_ctx) {
+        EVP_CIPHER_CTX_cleanup(tmp_ctx);
+        EVP_CIPHER_CTX_free(tmp_ctx);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+cipher_no_pad(PACE_CTX *ctx, const BUF_MEM *key_enc, const BUF_MEM *data, int enc)
+{
+    BUF_MEM *out = NULL;
+    EVP_CIPHER_CTX *tmp_ctx = NULL;
+
+    if (!ctx)
+        goto err;
+
+    if (ctx->cipher_ctx)
+        tmp_ctx = ctx->cipher_ctx;
+    else {
+        tmp_ctx = EVP_CIPHER_CTX_new();
+        if (!tmp_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(tmp_ctx);
+    }
+
+    if (!EVP_CipherInit_ex(tmp_ctx, ctx->cipher, ctx->cipher_engine,
+                (unsigned char *)key_enc->data, ctx->iv, enc)
+            || !EVP_CIPHER_CTX_set_padding(tmp_ctx, 0))
+        goto err;
+
+    out = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *)key_enc->data, ctx->iv, enc, data, 0);
+
+    /* Reenable padding */
+    if (!EVP_CIPHER_CTX_set_padding(ctx->cipher_ctx, 1))
+            goto err;
+
+err:
+    if (!ctx && tmp_ctx) {
+        EVP_CIPHER_CTX_cleanup(tmp_ctx);
+        EVP_CIPHER_CTX_free(tmp_ctx);
+    }
+
+    return out;
+}
+
+BUF_MEM *
+base64(const BUF_MEM * in)
+{
+    BIO *bmem = NULL, *b64 = NULL;
+    BUF_MEM *out = NULL;
+
+    if (!in)
+        goto err;
+
+    b64 = BIO_new(BIO_f_base64());
+    if (!b64)
+        goto err;
+    /* usually base64 adds newline */
+    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+
+    bmem = BIO_new(BIO_s_mem());
+    if (!bmem)
+        goto err;
+    /* So BIO_free() leaves BUF_MEM alone */
+    if (!BIO_set_close(bmem, BIO_NOCLOSE))
+        goto err;
+    BIO_push(b64, bmem);
+
+    if ((BIO_write(b64, in->data, in->length) < 0) || (BIO_flush(b64) <= 0))
+        goto err;
+    BIO_get_mem_ptr(b64, &out);
+
+    BIO_free_all(b64);
+
+    return out;
+
+err:
+    if (b64)
+        BIO_free(b64);
+    if (bmem)
+        BIO_free(bmem);
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, unsigned int maclen)
+{
+    CMAC_CTX * cmac_ctx = NULL;
+    BUF_MEM * out = NULL;
+
+    if (!key || !in || !type ||
+            (key->length < EVP_CIPHER_key_length(type)))
+        goto err;
+
+    if (ctx)
+        cmac_ctx = ctx;
+    else {
+        cmac_ctx = CMAC_CTX_new();
+    }
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(maclen);
+    if (!out)
+        goto err;
+
+    if (!cmac_ctx ||
+            !CMAC_Init(cmac_ctx, type, (unsigned char*) key->data,
+                EVP_CIPHER_key_length(type) * 8) ||
+            !CMAC_Update(cmac_ctx, (unsigned char*) in->data, in->length) ||
+            !CMAC_Final(cmac_ctx, (unsigned char*) out->data, maclen))
+        goto err;
+
+    if (!ctx)
+        CMAC_CTX_free(cmac_ctx);
+
+    return out;
+
+err:
+    if (cmac_ctx && !ctx) {
+        CMAC_CTX_free(cmac_ctx);
+    }
+    if (out) {
+        BUF_MEM_free(out);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+randb(int numbytes)
+{
+    BUF_MEM * r = BUF_MEM_new();
+    if (!r || !BUF_MEM_grow(r, numbytes) ||
+            !RAND_bytes((unsigned char *) r->data, numbytes))
+        goto err;
+
+    return r;
+
+err:
+    if (r)
+        BUF_MEM_free(r);
+
+    return NULL;
+}
+
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in)
+{
+    /* XXX use des implementations from evp.h or des.h */
+    /* ISO 9797-1 algorithm 3 retail mac without any padding */
+    BUF_MEM * c_tmp = NULL, *d_tmp = NULL, *mac = NULL, *block = NULL;
+    EVP_CIPHER_CTX * ctx = NULL;
+    size_t len;
+
+    if (!key)
+        goto err;
+
+    /* Flawfinder: ignore */
+    len = EVP_CIPHER_block_size(EVP_des_cbc());
+    if ( key->length < 2*len ) /* key too short */
+        goto err;
+
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx)
+        goto err;
+    EVP_CIPHER_CTX_init(ctx);
+    /* Flawfinder: ignore */
+    if (!EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data, NULL, 1) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+
+    /* get last block of des_cbc encrypted input */
+    /* Flawfinder: ignore */
+    c_tmp = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 1, in, 0);
+    if (!c_tmp)
+        goto err;
+    block = BUF_MEM_create_init(c_tmp->data + c_tmp->length - len, len);
+
+    /* decrypt last block with the rest of the key */
+    /* IV is always NULL */
+    /* Flawfinder: ignore */
+    if (!block || !EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data + len, NULL, 0) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+    /* Flawfinder: ignore */
+    d_tmp = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 0, block, 0);
+
+    /* encrypt last block with the first key */
+    /* IV is always NULL */
+    /* Flawfinder: ignore */
+    if (!d_tmp || !EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data, NULL, 1) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+    /* Flawfinder: ignore */
+    mac = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 1, d_tmp, 0);
+
+    BUF_MEM_free(block);
+    BUF_MEM_free(c_tmp);
+    BUF_MEM_free(d_tmp);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
+
+    return mac;
+
+err:
+    if (block)
+        BUF_MEM_free(block);
+    if (c_tmp)
+        BUF_MEM_free(c_tmp);
+    if (d_tmp)
+        BUF_MEM_free(d_tmp);
+    if (ctx) {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
+    }
+
+    return NULL;
+}
+
+int
+is_no_valid_integer_hexstr(const char * str)
+{
+    if (!str || (strnlen(str, 2) < 2))
+        return 0;
+
+    /* negative INTEGERs are forbidden (TR-3110 D.2.1.1.), but they shouldn't occur anyway */
+    return (str[0] == '0') && (str[1] == '0');
+}
+
+int
+is_char_str(const BUF_MEM * str)
+{
+    const unsigned char * s = (unsigned char *) str->data;
+    int i = str->length;
+
+    while (i) {
+        if (*s <= 0x1f || (0x7f < *s && *s < 0x9f))
+            return 0;
+        s++;
+        i--;
+    }
+
+    return 1;
+}
+
+BUF_MEM *
+encoded_secret(const PACE_SEC * pi)
+{
+    /* Encoding of the secret according to TR-03110 2.02 Table A3 */
+    BUF_MEM * out;
+
+    if (!pi)
+        return NULL;
+
+    switch (pi->type) {
+        case PACE_PUK:
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_RAW:
+            if (!is_char_str(pi->mem))
+                return NULL;
+
+            out = BUF_MEM_create_init(pi->mem->data, pi->mem->length);
+            break;
+        case PACE_MRZ:
+            out = encoded_mrz(pi->mem->data, pi->mem->length);
+            break;
+        default:
+            return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+encoded_mrz(const char *in, size_t len)
+{
+    const char *serial, *dob, *doe;
+    BUF_MEM *cat = NULL, *out = NULL;
+
+    if (!in
+            || len < MRZ_SERIALNUMBER_OFF + MRZ_SERIALNUMBER_LEN
+            || len < MRZ_DATEOFBIRTH_OFF + MRZ_DATEOFBIRTH_LEN
+            || len < MRZ_DATEOFEXPIRY_OFF + MRZ_DATEOFEXPIRY_LEN)
+        goto err;
+
+    /* Parse MRZ */
+    if (strncmp(in, "IDD<<", 5) != 0)
+        goto err;
+    serial = in + MRZ_SERIALNUMBER_OFF;
+    dob = in + MRZ_DATEOFBIRTH_OFF;
+    doe = in + MRZ_DATEOFEXPIRY_OFF;
+
+    /* Concatenate Serial Number || Date of Birth || Date of Expiry */
+    cat = BUF_MEM_create(MRZ_SERIALNUMBER_LEN + MRZ_DATEOFBIRTH_LEN +
+            MRZ_DATEOFEXPIRY_LEN);
+    if (!cat)
+        goto err;
+    /* Flawfinder: ignore */
+    memcpy(cat->data, serial, MRZ_SERIALNUMBER_LEN);
+    /* Flawfinder: ignore */
+    memcpy(cat->data + MRZ_SERIALNUMBER_LEN, dob, MRZ_DATEOFBIRTH_LEN);
+    /* Flawfinder: ignore */
+    memcpy(cat->data + MRZ_SERIALNUMBER_LEN + MRZ_DATEOFBIRTH_LEN,
+            doe, MRZ_DATEOFEXPIRY_LEN);
+
+    /* Compute and output SHA1 hash of concatenation */
+    out = hash(EVP_sha1(), NULL, NULL, cat);
+
+err:
+    if(cat)
+        BUF_MEM_free(cat);
+
+    return out;
+}
+
+int encode_ssc(const BIGNUM *ssc, const PACE_CTX *ctx, unsigned char **encoded)
+{
+    unsigned char *p;
+    size_t en_len, bn_len;
+
+    if (!ctx || !encoded)
+        return -1;
+
+    en_len = EVP_CIPHER_block_size(ctx->cipher);
+    p = realloc(*encoded, en_len);
+    if (!p)
+        return -1;
+    *encoded = p;
+
+    bn_len = BN_num_bytes(ssc);
+
+    if (bn_len <= en_len) {
+        memset(*encoded, 0, en_len - bn_len);
+        BN_bn2bin(ssc, *encoded + en_len - bn_len);
+    } else {
+        p = malloc(bn_len);
+        if (!p)
+            return -1;
+        BN_bn2bin(ssc, p);
+        /* Flawfinder: ignore */
+        memcpy(*encoded, p + bn_len - en_len, en_len);
+        free(p);
+    }
+
+    return en_len;
+}
+
+int update_iv(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc)
+{
+    BUF_MEM *sscbuf = NULL, *ivbuf = NULL;
+    const EVP_CIPHER *ivcipher = NULL, *oldcipher;
+    unsigned char *ssc_buf = NULL;
+    unsigned char *p;
+    int r = 0;
+
+    if (!ctx)
+        goto err;
+
+    switch (EVP_CIPHER_nid(ctx->cipher)) {
+        case NID_aes_128_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_128_ecb();
+            /* fall through */
+        case NID_aes_192_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_192_ecb();
+            /* fall through */
+        case NID_aes_256_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_256_ecb();
+
+            /* For AES decryption the IV is not needed,
+             * so we always set it to the encryption IV=E(K_Enc, SSC) */
+            r = encode_ssc(ssc, ctx, &ssc_buf);
+            if (r < 0)
+                goto err;
+            sscbuf = BUF_MEM_create_init(ssc_buf, r);
+            if (!sscbuf) {
+                goto err;
+            }
+            oldcipher = ctx->cipher;
+            ctx->cipher = ivcipher;
+            ivbuf = cipher_no_pad(ctx, key_enc, sscbuf, 1);
+            ctx->cipher = oldcipher;
+            if (!ivbuf) {
+                goto err;
+            }
+            p = realloc(ctx->iv, ivbuf->length);
+            if (!p) {
+                goto err;
+            }
+            ctx->iv = p;
+            /* Flawfinder: ignore */
+            memcpy(ctx->iv, ivbuf->data, ivbuf->length);
+            break;
+        case NID_des_ede_cbc:
+            /* For 3DES encryption or decryption the IV is always NULL */
+            if (ctx->iv)
+                free(ctx->iv);
+            ctx->iv = NULL;
+            break;
+        default:
+            goto err;
+    }
+
+    r = 1;
+
+err:
+    if (ssc_buf)
+        free(ssc_buf);
+    if (sscbuf)
+        BUF_MEM_free(sscbuf);
+    if (ivbuf)
+        BUF_MEM_free(ivbuf);
+
+    return r;
+}
+
+BUF_MEM *
+authenticate(const PACE_CTX *ctx, const BUF_MEM *k_mac, const BUF_MEM *data)
+{
+    switch (EVP_CIPHER_nid(ctx->cipher)) {
+        case NID_des_ede_cbc:
+            return retail_mac_des(k_mac, data);
+        case NID_aes_128_cbc:
+        case NID_aes_192_cbc:
+        case NID_aes_256_cbc:
+            return cmac(ctx->cmac_ctx, ctx->cipher, k_mac, data,
+                    PACE_AES_MAC_LENGTH);
+        default:
+            return NULL;
+    }
+}
+
+BUF_MEM *
+asn1_pubkey(BN_CTX *ctx, const PACEDomainParameterInfo *dp, const PACEInfo *info,
+        int include_dp)
+{
+    BIO *bio = NULL;
+    BIGNUM *bn = NULL, *a_bn = NULL, *b_bn = NULL;
+    char *p = NULL, *q = NULL, *g = NULL, *y = NULL, *a = NULL, *b = NULL,
+        *G = NULL, *r = NULL, *Y = NULL, *f = NULL;
+    const char *sn;
+    const EC_GROUP *group;
+
+    if (!dp || !dp->domainParameter)
+        goto err;
+
+    bio = BIO_new(BIO_s_mem());
+    sn = OBJ_nid2sn(info->protocol);
+    if (!bio || !sn || (BIO_printf(bio,
+            "asn1=IMPLICIT:73A,SEQUENCE:domainParameter\n"
+                "[domainParameter]\n"
+                "algorithm=OID:%s\n", sn) < 0))
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            if (!dp->domainParameter->parameters.dh)
+                goto err;
+
+            if (include_dp) {
+                /* Prime modulus */
+                p = BN_bn2hex(dp->domainParameter->parameters.dh->p);
+
+                /* Order of the subgroup */
+                bn = DH_get_order(dp->domainParameter->parameters.dh, ctx);
+                q = BN_bn2hex(bn);
+
+                /* Generator */
+                g = BN_bn2hex(dp->domainParameter->parameters.dh->g);
+
+                if (is_no_valid_integer_hexstr(g)
+                        || is_no_valid_integer_hexstr(q)
+                        || is_no_valid_integer_hexstr(p)) {
+                    PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                    goto err;
+                }
+                if (BIO_printf(bio,
+                            "p=IMPLICIT:1C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "q=IMPLICIT:2C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "g=IMPLICIT:3C,FORMAT:HEX,OCTETSTRING:%s\n",
+                            p, q, g) < 0)
+                    goto err;
+
+                OPENSSL_free(g);
+                OPENSSL_free(q);
+                BN_clear_free(bn);
+                OPENSSL_free(p);
+            }
+
+            /* Public value */
+            y = BN_bn2hex(dp->domainParameter->parameters.dh->pub_key);
+
+            if (is_no_valid_integer_hexstr(y)) {
+                PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                goto err;
+            }
+            if (BIO_printf(bio,
+                "y=IMPLICIT:4C,FORMAT:HEX,OCTETSTRING:%s", y) < 0)
+                goto err;
+
+            OPENSSL_free(y);
+            break;
+
+        case NID_X9_62_id_ecPublicKey:
+        /* Note: Test cards derive from the official specification, therefore
+         *       we need to handle some additional OIDs */
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            if (!dp->domainParameter->parameters.ecdh)
+                goto err;
+
+            group = EC_KEY_get0_group(dp->domainParameter->parameters.ecdh);
+
+            if (include_dp) {
+                bn = BN_new();
+                a_bn = BN_new();
+                b_bn = BN_new();
+                if (!bn || !a_bn || !b_bn
+                        || !EC_GROUP_get_curve_GFp(group, bn, a_bn, b_bn, ctx))
+                    goto err;
+                /* Prime modulus */
+                p = BN_bn2hex(bn);
+                /* First coefficient */
+                a = BN_bn2hex(a_bn);
+                /* Second coefficient */
+                b = BN_bn2hex(b_bn);
+
+                /* Base Point */
+                G = EC_POINT_point2hex(group, EC_GROUP_get0_generator(group),
+                        EC_KEY_get_conv_form(dp->domainParameter->parameters.ecdh),
+                        ctx);
+
+                /* Order of the base point */
+                if (!EC_GROUP_get_order(group, bn, ctx))
+                    goto err;
+                r = BN_bn2hex(bn);
+
+                if (is_no_valid_integer_hexstr(r)
+                        || is_no_valid_integer_hexstr(b)
+                        || is_no_valid_integer_hexstr(a)
+                        || is_no_valid_integer_hexstr(p)) {
+                    PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                    goto err;
+                }
+                if (BIO_printf(bio,
+                            "p=IMPLICIT:1C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "a=IMPLICIT:2C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "b=IMPLICIT:3C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "G=IMPLICIT:4C,FORMAT:HEX,OCTETSTRING:%s\n"
+                            "r=IMPLICIT:5C,FORMAT:HEX,OCTETSTRING:%s\n",
+                            p, a, b, G, r) < 0)
+                    goto err;
+
+                OPENSSL_free(r);
+                OPENSSL_free(G);
+                BN_clear_free(a_bn);
+                BN_clear_free(b_bn);
+                OPENSSL_free(b);
+                OPENSSL_free(a);
+                OPENSSL_free(p);
+            }
+
+            /* Public point */
+            Y = EC_POINT_point2hex(group,
+                    EC_KEY_get0_public_key(dp->domainParameter->parameters.ecdh),
+                    EC_KEY_get_conv_form(dp->domainParameter->parameters.ecdh),
+                    ctx);
+
+            if (BIO_printf(bio,
+                        "Y=IMPLICIT:6C,FORMAT:HEX,OCTETSTRING:%s\n", Y) < 0)
+                goto err;
+
+            OPENSSL_free(Y);
+
+            if (include_dp) {
+                /* Cofactor */
+                if (!EC_GROUP_get_cofactor(group, bn, ctx))
+                    goto err;
+                f = BN_bn2hex(bn);
+
+                if (is_no_valid_integer_hexstr(f)) {
+                    PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                    goto err;
+                }
+                if (BIO_printf(bio,
+                            "f=IMPLICIT:7C,FORMAT:HEX,OCTETSTRING:%s", f) < 0)
+                    goto err;
+
+                OPENSSL_free(f);
+                BN_clear_free(bn);
+            }
+            break;
+
+        default:
+            goto err;
+    }
+
+    if (BIO_flush(bio) <= 0)
+        goto err;
+
+    return bio2asn1bin(bio);
+
+err:
+    if (y)
+        OPENSSL_free(y);
+    if (g)
+        OPENSSL_free(g);
+    if (q)
+        OPENSSL_free(q);
+    if (p)
+        OPENSSL_free(p);
+
+    if (f)
+        OPENSSL_free(f);
+    if (Y)
+        OPENSSL_free(Y);
+    if (r)
+        OPENSSL_free(r);
+    if (G)
+        OPENSSL_free(G);
+    if (a_bn)
+        BN_clear_free(a_bn);
+    if (b_bn)
+        BN_clear_free(b_bn);
+    if (b)
+        OPENSSL_free(b);
+    if (a)
+        OPENSSL_free(a);
+    if (p)
+        OPENSSL_free(p);
+
+    if (bn)
+        BN_clear_free(bn);
+
+    if (bio)
+        BIO_free(bio);
+
+    return NULL;
+}
+
+BUF_MEM *
+compute_authentication_token(PACE_CTX *ctx, PACEDomainParameterInfo *dp_opp,
+        const PACEInfo *info, BUF_MEM * k_mac)
+{
+    BUF_MEM *asn1 = NULL, *out = NULL, *pad =NULL;
+
+    if (!info || !ctx)
+        goto err;
+
+    if (ctx->tr_version == PACE_TR_VERSION_2_01)
+        asn1 = asn1_pubkey(ctx->bn_ctx, dp_opp, info, 1);
+    else
+        asn1 = asn1_pubkey(ctx->bn_ctx, dp_opp, info, 0);
+
+    /* ISO 9797-1 algorithm 3 retail mac now needs extra padding (padding method 2) */
+    if (EVP_CIPHER_nid(ctx->cipher) == NID_des_ede_cbc) {
+        pad = PACE_add_iso_pad(asn1, EVP_CIPHER_block_size(ctx->cipher));
+        if (!pad)
+            goto err;
+        out = authenticate(ctx, k_mac, pad);
+    } else {
+        out = authenticate(ctx, k_mac, asn1);
+    }
+
+err:
+    if (asn1)
+        BUF_MEM_free(asn1);
+    if (pad)
+        BUF_MEM_free(pad);
+
+    return out;
+}
+
+BUF_MEM *
+bio2asn1bin(BIO *bio)
+{
+    CONF *conf = NULL;
+    ASN1_TYPE *atyp = NULL;
+    char *genstr = NULL;
+    BUF_MEM *out = NULL;
+    int len;
+    unsigned char *d;
+
+    if (!bio)
+        goto err;
+
+    conf = NCONF_new(NULL);
+    if (!conf || (NCONF_load_bio(conf, bio, NULL) <= 0))
+        goto err;
+
+    genstr = NCONF_get_string(conf, "default", "asn1");
+    if (!genstr)
+        goto err;
+    atyp = ASN1_generate_nconf(genstr, conf);
+    if (!atyp)
+        goto err;
+
+    len = i2d_ASN1_TYPE(atyp, NULL);
+    if (len <= 0)
+        goto err;
+    out = BUF_MEM_create(len);
+    if (!out)
+        goto err;
+    d = (unsigned char *) out->data;
+    out->length = i2d_ASN1_TYPE(atyp, &d);
+
+    ASN1_TYPE_free(atyp);
+    NCONF_free(conf);
+    BIO_free(bio);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (atyp)
+        ASN1_TYPE_free(atyp);
+    if (conf)
+        NCONF_free(conf);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_util.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pace_util.h	2010-10-26 11:17:30.000000000 +0200
@@ -0,0 +1,230 @@
+/**
+ * @file
+ * @brief Interface to utility functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_UTIL_H_
+#define PACE_UTIL_H_
+
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/cmac.h>
+#include <openssl/ec.h>
+#include <openssl/pace.h>
+
+/**
+ * @defgroup wrapper               Wrapper functions
+ * @{ ************************************************************************/
+/**
+ * @brief Wrapper for the OpenSSL hash functions.
+ *
+ * @param md
+ * @param ctx (optional)
+ * @param impl (optional)
+ * @param in
+ *
+ * @return message digest or NULL if an error occurred
+ */
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in);
+/**
+ * @brief Wrapper to the OpenSSL encryption functions.
+ *
+ * @param ctx (optional)
+ * @param type
+ * @param impl only evaluated if init is 1. (optional)
+ * @param key only evaluated if init is 1.
+ * @param iv only evaluated if init is 1. (optional)
+ * @param enc only evaluated if init is 1.
+ * @param in
+ * @param init whether to initialize (1) the given ctx or not (0).
+ *
+ * @return cipher of in or NULL if an error occurred
+ */
+BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        const unsigned char *key, const unsigned char *iv, int enc, const BUF_MEM * in,
+        const int init);
+/**
+ * @brief Wrapper to the OpenSSL encryption functions.
+ * Automatic padding is disabled.
+ *
+ * @param ctx
+ * @param key_enc
+ * @param data
+ * @param enc
+ *
+ * @return encrypted/decrypted data or NULL if an error occurred
+ */
+BUF_MEM *
+cipher_no_pad(PACE_CTX *ctx, const BUF_MEM *key_enc, const BUF_MEM *data, int enc);
+/**
+ * @brief Wrapper to the OpenSSL pseudo-random number generator.
+ *
+ * @param numbytes number of bytes to randomize
+ *
+ * @return a buffer of randomized bytes or NULL if an error occurred
+ */
+BUF_MEM *
+randb(int numbytes);
+/**
+ * @brief Computes message authentication code in retail-mode according to
+ * ISO/IEC 9797-1 MAC algorithm 3 / padding method 2 with block cipher DES and
+ * IV=0.
+ *
+ * @param key authentication key
+ * @param in buffer to authenticate
+ *
+ * @return message authentication code or NULL if an error occurred
+ */
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in);
+/**
+ * @brief Compute a CMAC of the input buffer using the encryption algorithm
+ *           specified in the PACE context structure
+ *
+ * @param ctx EVP_CIPHER_CTX object (optional)
+ * @param type contains the encryption algorithm to use
+ * @param key the symmetric key used for the computation. The key must have
+ *           the correct length for the encryption algorithm used
+ * @param in buffer that contains the data to for CMAC computation
+ * @param maclen length in number of bytes of the MAC
+ *
+ * @return buffer containing the CMAC or NULL in case of error
+ */
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, unsigned int maclen);
+/**
+ * @brief encodes a buffer in base64
+ *
+ * @param in buffer to encode
+ *
+ * @return base 64 encoded buffer or NULL if an error occurred
+ */
+BUF_MEM *
+base64(const BUF_MEM * in);
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup encoding               Encoding
+ * @{ ************************************************************************/
+
+/**
+ * @brief Checks if str is NOT a INTEGER string in hex format according to TR-3110
+ * D.2.1.1.
+ *
+ * @param str hex string (must be NULL terminated)
+ *
+ * @return 1 if str is NOT a valid integer hex string or 0 if it is
+ */
+int is_no_valid_integer_hexstr(const char * str);
+/**
+ * @brief Checks if str is a character string according to TR-3110 D.2.1.4
+ *
+ * @param str BUF_MEM object with the string to check
+ *
+ * @return 1 if str is a character string or 0 if it is not
+ */
+int is_char_str(const BUF_MEM * str);
+/**
+ * @brief Encodes a shared secret according to TR-3110 Table F.2
+ *
+ * @param pi Password to encode
+ *
+ * @return BUF_MEM object containing the encoded password or NULL if an error occurred
+ *
+ * @note This function is automatically called during PACE, normally you should not need to use it.
+ */
+BUF_MEM * encoded_secret(const PACE_SEC * pi);
+#define MRZ_SERIALNUMBER_LEN    10
+#define MRZ_DATEOFBIRTH_LEN     6
+#define MRZ_DATEOFEXPIRY_LEN    6
+#define MRZ_SERIALNUMBER_OFF    5
+#define MRZ_DATEOFBIRTH_OFF     30
+#define MRZ_DATEOFEXPIRY_OFF    38
+/**
+ * @brief Encodes the Machine readable zone according to TR-03110 table A.3
+ *
+ * @param mrz buffer containing the MRZ
+ * @param len size of the buffer
+ *
+ * @return the encoded MRZ or NULL on error
+ */
+BUF_MEM * encoded_mrz(const char *mrz, size_t len);
+/**
+ * @brief Encodes a send sequence counter according to TR-3110 F.3
+ *
+ * @param ssc Send sequence counter to encode
+ * @param ctx PACE_CTX object
+ * @param encoded where to store the encoded SSC
+ *
+ * @return length of encoded SSC or -1 if an error occurred
+ */
+int encode_ssc(const BIGNUM *ssc, const PACE_CTX *ctx, unsigned char **encoded);
+
+/**
+ * @brief Computes the new initialisation vector according to the SSC and the
+ * algorithm
+ *
+ * @param[in,out] ctx contains the parameters needed for the generation of the IV
+ * and the IV itself
+ * @param[in] ssc the send sequence counter
+ * @param[in] key_enc the encryption key
+ *
+ * @return 1 if everything worked, 0 in case of an error
+ */
+int update_iv(PACE_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *key_enc);
+/** @} ***********************************************************************/
+
+/**
+ * @brief Authenticate data with the algorithm specified by the \c PACE_CTX and
+ * the key k_mac
+ *
+ * @param[in] ctx contains the information on how to authenticate the data
+ * @param[in] k_mac the key used for authentication
+ * @param[data] the data that should be authenticated
+ *
+ * @return the authenticated data or NULL in case of an error
+ * @note the data has to be padded correctly for this function
+ */
+BUF_MEM *
+authenticate(const PACE_CTX *ctx, const BUF_MEM *k_mac, const BUF_MEM *data);
+/**
+ * @brief Encodes public key data objects of the domain parameters in ASN.1
+ * (see TR-3110 D.3.2 and D.3.3)
+ *
+ * @param ctx
+ * @param dp PACEDomainParameterInfo object containing an AlgorithmIdentifier,
+ * which includes the DH or EC_KEY object
+ * @param info
+ * @param include_dp set to 1 if the domain parameter should be included, 0
+ * otherwise.
+ *
+ * @return ASN.1 encoded public key data objects or NULL if an error occurred
+ */
+BUF_MEM *
+asn1_pubkey(BN_CTX  *ctx, const PACEDomainParameterInfo *dp, const PACEInfo *info,
+        int include_dp);
+
+BUF_MEM *
+compute_authentication_token(PACE_CTX *ctx, PACEDomainParameterInfo *dp_opp,
+        const PACEInfo *info, BUF_MEM * k_mac);
+
+/**
+ * @brief Generates the ASN.1 encoding from a prepared BIO
+ *
+ * @param bio The BIO should contain a name value pair to be encoded in ASN.1.
+ * The name must be "asn1" in the default section.
+ *
+ * @return ASN.1 encoded object or NULL if an error occurred
+ *
+ * @see config(5), ASN1_generate_nconf(3)
+ */
+BUF_MEM *
+bio2asn1bin(BIO *bio);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/pace/pacetest.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/pace/pacetest.c	2010-10-26 11:18:00.000000000 +0200
@@ -0,0 +1,818 @@
+#include <openssl/opensslconf.h>	/* for OPENSSL_NO_PACE */
+#include <stdio.h>
+#ifdef OPENSSL_NO_PACE
+int
+main(int argc, char *argv[])
+{
+    printf("No PACE support\n");
+    return (0);
+}
+#else
+#include <openssl/asn1.h>
+#include <openssl/buffer.h>
+#include <openssl/conf.h>
+#include <openssl/ec.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include <openssl/cv_cert.h>
+#include <openssl/bio.h>
+#include <string.h>
+
+#define err(s) { printf(s "\n"); ERR_print_errors_fp(stdout); goto err; }
+#define errstay(s) { printf(s "\n"); ERR_print_errors_fp(stdout); }
+#define verb(s) { if (verbose) printf(s "\n"); else printf("."); }
+
+static char verbose=0;
+static char debug=0;
+
+/* http://www.internet-sicherheit.de/forschung/aktuelle-forschungsprojekte/elektronischer-personalausweis/berechtigungszertifikat/ */
+/*static unsigned const char CVCert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x89, 0x7f, 0x4e, 0x82, 0x01, 0x49, 0x5f,
+    0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41,
+    0x45, 0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x81,
+    0xfd, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02,
+    0x02, 0x02, 0x81, 0x1c, 0xd7, 0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66,
+    0x86, 0x2a, 0x18, 0x30, 0x25, 0x75, 0xd1, 0xd7, 0x87, 0xb0, 0x9f,
+    0x07, 0x57, 0x97, 0xda, 0x89, 0xf5, 0x7e, 0xc8, 0xc0, 0xff, 0x82,
+    0x1c, 0x68, 0xa5, 0xe6, 0x2c, 0xa9, 0xce, 0x6c, 0x1c, 0x29, 0x98,
+    0x03, 0xa6, 0xc1, 0x53, 0x0b, 0x51, 0x4e, 0x18, 0x2a, 0xd8, 0xb0,
+    0x04, 0x2a, 0x59, 0xca, 0xd2, 0x9f, 0x43, 0x83, 0x1c, 0x25, 0x80,
+    0xf6, 0x3c, 0xcf, 0xe4, 0x41, 0x38, 0x87, 0x07, 0x13, 0xb1, 0xa9,
+    0x23, 0x69, 0xe3, 0x3e, 0x21, 0x35, 0xd2, 0x66, 0xdb, 0xb3, 0x72,
+    0x38, 0x6c, 0x40, 0x0b, 0x84, 0x39, 0x04, 0x0d, 0x90, 0x29, 0xad,
+    0x2c, 0x7e, 0x5c, 0xf4, 0x34, 0x08, 0x23, 0xb2, 0xa8, 0x7d, 0xc6,
+    0x8c, 0x9e, 0x4c, 0xe3, 0x17, 0x4c, 0x1e, 0x6e, 0xfd, 0xee, 0x12,
+    0xc0, 0x7d, 0x58, 0xaa, 0x56, 0xf7, 0x72, 0xc0, 0x72, 0x6f, 0x24,
+    0xc6, 0xb8, 0x9e, 0x4e, 0xcd, 0xac, 0x24, 0x35, 0x4b, 0x9e, 0x99,
+    0xca, 0xa3, 0xf6, 0xd3, 0x76, 0x14, 0x02, 0xcd, 0x85, 0x1c, 0xd7,
+    0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66, 0x86, 0x2a, 0x18, 0x30, 0x25,
+    0x75, 0xd0, 0xfb, 0x98, 0xd1, 0x16, 0xbc, 0x4b, 0x6d, 0xde, 0xbc,
+    0xa3, 0xa5, 0xa7, 0x93, 0x9f, 0x86, 0x39, 0x04, 0x39, 0x3e, 0xe8,
+    0xe0, 0x6d, 0xb6, 0xc7, 0xf5, 0x28, 0xf8, 0xb4, 0x26, 0x0b, 0x49,
+    0xaa, 0x93, 0x30, 0x98, 0x24, 0xd9, 0x2c, 0xdb, 0x18, 0x07, 0xe5,
+    0x43, 0x7e, 0xe2, 0xe2, 0x6e, 0x29, 0xb7, 0x3a, 0x71, 0x11, 0x53,
+    0x0f, 0xa8, 0x6b, 0x35, 0x00, 0x37, 0xcb, 0x94, 0x15, 0xe1, 0x53,
+    0x70, 0x43, 0x94, 0x46, 0x37, 0x97, 0x13, 0x9e, 0x14, 0x87, 0x01,
+    0x01, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x45,
+    0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x4c, 0x0e, 0x06,
+    0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x01, 0x53,
+    0x01, 0xc1, 0x5f, 0x25, 0x06, 0x00, 0x07, 0x00, 0x04, 0x00, 0x01,
+    0x5f, 0x24, 0x06, 0x00, 0x09, 0x00, 0x04, 0x00, 0x01, 0x5f, 0x37,
+    0x38, 0x4c, 0xcf, 0x25, 0xc5, 0x9f, 0x36, 0x12, 0xee, 0xe1, 0x88,
+    0x75, 0xf6, 0xc5, 0xf2, 0xe2, 0xd2, 0x1f, 0x03, 0x95, 0x68, 0x3b,
+    0x53, 0x2a, 0x26, 0xe4, 0xc1, 0x89, 0xb7, 0x1e, 0xfe, 0x65, 0x9c,
+    0x3f, 0x26, 0xe0, 0xeb, 0x9a, 0xea, 0xe9, 0x98, 0x63, 0x10, 0x7f,
+    0x9b, 0x0d, 0xad, 0xa1, 0x64, 0x14, 0xff, 0xa2, 0x04, 0x51, 0x6a,
+    0xee, 0x2b
+};*/
+
+static const unsigned char CVCert[] = {
+    0x7F, 0x21, 0x82, 0x01, 0x41, 0x7F, 0x4E, 0x81, 0xFA, 0x5F, 0x29,
+    0x01, 0x00, 0x42, 0x0D, 0x5A, 0x5A, 0x44, 0x56, 0x43, 0x41, 0x41,
+    0x54, 0x41, 0x30, 0x30, 0x30, 0x33, 0x7F, 0x49, 0x4F, 0x06, 0x0A,
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+    0x41, 0x04, 0x19, 0xD1, 0x75, 0x45, 0xD3, 0xFE, 0x0B, 0x34, 0x3E,
+    0x7E, 0xE2, 0xAE, 0x4E, 0x2B, 0xC9, 0x2D, 0x51, 0x35, 0x1C, 0xC1,
+    0x17, 0xA4, 0x7F, 0xA9, 0x51, 0x9A, 0xDB, 0x1E, 0x40, 0x5E, 0xE6,
+    0xB8, 0x12, 0x12, 0x80, 0xBC, 0xC2, 0xFF, 0xF0, 0x35, 0x7A, 0x19,
+    0x7D, 0xE7, 0x39, 0xA7, 0xFD, 0x2E, 0xF0, 0x22, 0x10, 0xEF, 0x34,
+    0x3C, 0xDB, 0xE7, 0x9E, 0xF9, 0x4B, 0x8E, 0x28, 0x59, 0x1B, 0xB9,
+    0x5F, 0x20, 0x0B, 0x5A, 0x5A, 0x44, 0x4B, 0x42, 0x32, 0x30, 0x30,
+    0x30, 0x30, 0x52, 0x7F, 0x4C, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7F,
+    0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x00, 0x03, 0x01,
+    0xDF, 0x04, 0x5F, 0x25, 0x06, 0x01, 0x00, 0x00, 0x02, 0x01, 0x07,
+    0x5F, 0x24, 0x06, 0x01, 0x00, 0x00, 0x03, 0x03, 0x01, 0x65, 0x5E,
+    0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01,
+    0x03, 0x01, 0x80, 0x20, 0x75, 0xE0, 0xC4, 0xAC, 0x36, 0xC2, 0x5A,
+    0x33, 0xAC, 0x0E, 0x9A, 0x75, 0xEB, 0x79, 0x2A, 0x72, 0xF3, 0x31,
+    0xA5, 0x1E, 0x28, 0x63, 0x4E, 0xCC, 0x2E, 0xD6, 0x2E, 0x54, 0xF3,
+    0xC6, 0x93, 0xDA, 0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00,
+    0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x18, 0x12, 0x65, 0x74,
+    0x49, 0xFC, 0xF1, 0xD3, 0xDA, 0xD8, 0x3D, 0x13, 0x14, 0x29, 0x17,
+    0x5C, 0x61, 0x8B, 0x21, 0xBA, 0xF0, 0xAF, 0x44, 0xAC, 0xE3, 0x8C,
+    0xB2, 0xC1, 0x2C, 0xEB, 0x2A, 0x56, 0x5F, 0x37, 0x40, 0x54, 0x0F,
+    0x85, 0x09, 0x12, 0xAB, 0xD3, 0x51, 0xF8, 0xF5, 0x56, 0x9B, 0x53,
+    0x4A, 0x5C, 0x8F, 0x64, 0x54, 0x5B, 0x51, 0xA7, 0x34, 0x70, 0xBE,
+    0x5A, 0xD2, 0x89, 0xC1, 0x9A, 0x5E, 0x13, 0x52, 0x53, 0xD3, 0xBB,
+    0x15, 0x52, 0x26, 0x21, 0x7B, 0x41, 0xE7, 0xF0, 0x68, 0xB3, 0x52,
+    0x3F, 0x3A, 0x63, 0x92, 0x22, 0xAF, 0x2B, 0x62, 0x8C, 0x39, 0x7D,
+    0x4F, 0xD4, 0x02, 0x1E, 0xDE, 0x00, 0xDC
+};
+
+//static const unsigned int CVCert_len = 398;
+static const unsigned int CVCert_len = 326;
+
+static const unsigned char certDesc[] = {
+    0x30, 0x82, 0x01, 0x90, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03,
+    0x01, 0x03, 0x01, 0x01, 0xA1, 0x16, 0x0C, 0x14, 0x42, 0x75, 0x6E, 0x64,
+    0x65, 0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x20,
+    0x47, 0x6D, 0x62, 0x48, 0xA2, 0x24, 0x13, 0x22, 0x68, 0x74, 0x74, 0x70,
+    0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x75, 0x6E, 0x64, 0x65,
+    0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x2E, 0x64,
+    0x65, 0x2F, 0x64, 0x76, 0x63, 0x61, 0xA3, 0x18, 0x0C, 0x16, 0x44, 0x65,
+    0x75, 0x74, 0x73, 0x63, 0x68, 0x65, 0x20, 0x4B, 0x72, 0x65, 0x64, 0x69,
+    0x74, 0x62, 0x61, 0x6E, 0x6B, 0x20, 0x41, 0x47, 0xA4, 0x13, 0x13, 0x11,
+    0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64,
+    0x6B, 0x62, 0x2E, 0x64, 0x65, 0xA5, 0x82, 0x01, 0x13, 0x0C, 0x82, 0x01,
+    0x0F, 0x54, 0x61, 0x75, 0x62, 0x65, 0x6E, 0x73, 0x74, 0x72, 0x2E, 0x20,
+    0x37, 0x2D, 0x39, 0x0D, 0x0A, 0x31, 0x30, 0x31, 0x31, 0x37, 0x20, 0x42,
+    0x65, 0x72, 0x6C, 0x69, 0x6E, 0x0D, 0x0A, 0x69, 0x6E, 0x66, 0x6F, 0x40,
+    0x64, 0x6B, 0x62, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6,
+    0x66, 0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73,
+    0x20, 0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A, 0x42, 0x65, 0x72,
+    0x6C, 0x69, 0x6E, 0x65, 0x72, 0x20, 0x42, 0x65, 0x61, 0x75, 0x66, 0x74,
+    0x72, 0x61, 0x67, 0x74, 0x65, 0x72, 0x20, 0x66, 0xC3, 0xBC, 0x72, 0x20,
+    0x44, 0x61, 0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x20,
+    0x75, 0x6E, 0x64, 0x20, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74,
+    0x69, 0x6F, 0x6E, 0x73, 0x66, 0x72, 0x65, 0x69, 0x68, 0x65, 0x69, 0x74,
+    0x2C, 0x20, 0x41, 0x6E, 0x20, 0x64, 0x65, 0x72, 0x20, 0x55, 0x72, 0x61,
+    0x6E, 0x69, 0x61, 0x20, 0x34, 0x2D, 0x31, 0x30, 0x2C, 0x20, 0x31, 0x30,
+    0x37, 0x38, 0x37, 0x20, 0x42, 0x65, 0x72, 0x6C, 0x69, 0x6E, 0x2C, 0x20,
+    0x30, 0x33, 0x30, 0x2F, 0x31, 0x33, 0x20, 0x38, 0x38, 0x39, 0x2D, 0x30,
+    0x2C, 0x20, 0x6D, 0x61, 0x69, 0x6C, 0x62, 0x6F, 0x78, 0x40, 0x64, 0x61,
+    0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65,
+    0x72, 0x6C, 0x69, 0x6E, 0x2E, 0x64, 0x65, 0x2C, 0x20, 0x68, 0x74, 0x74,
+    0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x61, 0x74, 0x65,
+    0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65, 0x72, 0x6C,
+    0x69, 0x6E, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6, 0x66,
+    0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73, 0x20,
+    0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A
+};
+
+static const unsigned int certDesc_len = 404;
+
+static const unsigned char EFCardAccess[] = {
+    0x31, 0x82, 0x02, 0x64, 0x30, 0x0d, 0x06, 0x08, 0x04, 0x00, 0x7f,
+    0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0f, 0x06,
+    0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x02,
+    0x02, 0x01, 0x02, 0x30, 0x0f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00,
+    0x07, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x30, 0x2f,
+    0x06, 0x08, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x06, 0x16,
+    0x23, 0x41, 0x77, 0x54, 0x20, 0x65, 0x50, 0x41, 0x20, 0x2d, 0x20,
+    0x42, 0x44, 0x72, 0x20, 0x47, 0x6d, 0x62, 0x48, 0x20, 0x2d, 0x20,
+    0x54, 0x65, 0x73, 0x74, 0x6b, 0x61, 0x72, 0x74, 0x65, 0x20, 0x76,
+    0x31, 0x2e, 0x30, 0x30, 0x81, 0xfe, 0x06, 0x09, 0x04, 0x00, 0x7f,
+    0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x81, 0xf0, 0x06, 0x0b,
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x01, 0x01, 0x05, 0x02, 0x02, 0x02,
+    0x30, 0x81, 0xe0, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xa9, 0xfb,
+    0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d,
+    0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28,
+    0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x77, 0x30, 0x44, 0x04,
+    0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66,
+    0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5,
+    0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x74,
+    0x04, 0x20, 0x66, 0x2c, 0x61, 0xc4, 0x30, 0xd8, 0x4e, 0xa4, 0xfe,
+    0x66, 0xa7, 0x73, 0x3d, 0x0b, 0x76, 0xb7, 0xbf, 0x93, 0xeb, 0xc4,
+    0xaf, 0x2f, 0x49, 0x25, 0x6a, 0xe5, 0x81, 0x01, 0xfe, 0xe9, 0x2b,
+    0x04, 0x04, 0x41, 0x04, 0xa3, 0xe8, 0xeb, 0x3c, 0xc1, 0xcf, 0xe7,
+    0xb7, 0x73, 0x22, 0x13, 0xb2, 0x3a, 0x65, 0x61, 0x49, 0xaf, 0xa1,
+    0x42, 0xc4, 0x7a, 0xaf, 0xbc, 0x2b, 0x79, 0xa1, 0x91, 0x56, 0x2e,
+    0x13, 0x05, 0xf4, 0x2d, 0x99, 0x6c, 0x82, 0x34, 0x39, 0xc5, 0x6d,
+    0x7f, 0x7b, 0x22, 0xe1, 0x46, 0x44, 0x41, 0x7e, 0x69, 0xbc, 0xb6,
+    0xde, 0x39, 0xd0, 0x27, 0x00, 0x1d, 0xab, 0xe8, 0xf3, 0x5b, 0x25,
+    0xc9, 0xbe, 0x02, 0x21, 0x00, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee,
+    0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71, 0x8c,
+    0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82,
+    0x97, 0x48, 0x56, 0xa7, 0x02, 0x01, 0x01, 0x30, 0x81, 0xfe, 0x06,
+    0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x04, 0x02, 0x30,
+    0x81, 0xf0, 0x06, 0x0b, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x01, 0x01,
+    0x05, 0x02, 0x02, 0x02, 0x30, 0x81, 0xe0, 0x02, 0x01, 0x01, 0x30,
+    0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02,
+    0x21, 0x00, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e,
+    0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23,
+    0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53,
+    0x77, 0x30, 0x44, 0x04, 0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee,
+    0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e,
+    0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d,
+    0x1f, 0x6e, 0x53, 0x74, 0x04, 0x20, 0x66, 0x2c, 0x61, 0xc4, 0x30,
+    0xd8, 0x4e, 0xa4, 0xfe, 0x66, 0xa7, 0x73, 0x3d, 0x0b, 0x76, 0xb7,
+    0xbf, 0x93, 0xeb, 0xc4, 0xaf, 0x2f, 0x49, 0x25, 0x6a, 0xe5, 0x81,
+    0x01, 0xfe, 0xe9, 0x2b, 0x04, 0x04, 0x41, 0x04, 0xa3, 0xe8, 0xeb,
+    0x3c, 0xc1, 0xcf, 0xe7, 0xb7, 0x73, 0x22, 0x13, 0xb2, 0x3a, 0x65,
+    0x61, 0x49, 0xaf, 0xa1, 0x42, 0xc4, 0x7a, 0xaf, 0xbc, 0x2b, 0x79,
+    0xa1, 0x91, 0x56, 0x2e, 0x13, 0x05, 0xf4, 0x2d, 0x99, 0x6c, 0x82,
+    0x34, 0x39, 0xc5, 0x6d, 0x7f, 0x7b, 0x22, 0xe1, 0x46, 0x44, 0x41,
+    0x7e, 0x69, 0xbc, 0xb6, 0xde, 0x39, 0xd0, 0x27, 0x00, 0x1d, 0xab,
+    0xe8, 0xf3, 0x5b, 0x25, 0xc9, 0xbe, 0x02, 0x21, 0x00, 0xa9, 0xfb,
+    0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d,
+    0x83, 0x8d, 0x71, 0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7,
+    0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7, 0x02, 0x01, 0x01
+};
+
+static const unsigned int EF_len = 616;
+
+static void hexdump(const char *title, const BUF_MEM *s)
+{
+    int n=0;
+
+    fprintf(stdout,"%s",title);
+    for(; n < s->length; ++n)
+    {
+        if((n%16) == 0)
+        fprintf(stdout,"\n    ");
+        fprintf(stdout,"%02x:",(unsigned char) s->data[n]);
+    }
+    fprintf(stdout,"\n");
+}
+
+static void dump_pace_info(PACEInfo * info) {
+    if(!info)
+        return;
+    printf("PACE Info:\n");
+    printf("\tProtocol: %s\n", OBJ_nid2sn(info->protocol));
+    printf("\tVersion: %d\n", info->version);
+    if (info->parameterId)
+        printf("\tParameterId: %d\n", info->parameterId);
+    return;
+}
+
+static void dump_dh(DH *dh) {
+    if (!dh)
+        printf("No DH parameters found");
+    else
+        printf("DH Parameters:\n");
+    DHparams_print_fp(stdout, dh);
+    return;
+}
+
+static void dump_ecdh(EC_KEY *ec) {
+    if (!ec)
+        printf("No EC parameters found");
+    else
+        printf("EC Parameters:\n");
+    ECParameters_print_fp(stdout, ec);
+    return;
+}
+
+static void dump_aid(AlgorithmIdentifier * aid) {
+    if(!aid)
+        return;
+
+    printf("Algorithm Identifier: \n");
+    printf("\tAlgorithm: %s\n", OBJ_nid2sn(aid->algorithm));
+    switch(aid->algorithm) {
+        case NID_dhpublicnumber:
+            dump_dh(aid->parameters.dh);
+            break;
+        case NID_X9_62_id_ecPublicKey:
+        case NID_ecka_dh_SessionKDF_DES3:
+        case NID_ecka_dh_SessionKDF_AES128:
+        case NID_ecka_dh_SessionKDF_AES192:
+        case NID_ecka_dh_SessionKDF_AES256:
+            dump_ecdh(aid->parameters.ecdh);
+            break;
+        default:
+            printf("\tNo parameters found\n");
+    }
+    return;
+}
+
+static void dump_pace_dp(PACEDomainParameterInfo * dp) {
+    if (!dp)
+        return;
+
+    printf("PACE Domain Parameter Info:\n");
+    printf("\tProtocol: %s\n", OBJ_nid2sn(dp->protocol));
+    if (dp->parameterId)
+        printf("\tParameter ID: %d\n", dp->parameterId);
+    if (dp->domainParameter)
+        dump_aid(dp->domainParameter);
+    else
+        printf("\tMissing Algorithm Identifier\n");
+    return;
+}
+
+int do_test(char *sec_str, int sec_type, int curve, int algorithm)
+{
+    int ok = 1;
+    PACE_SEC *s = NULL;
+    PACE_CTX *ctx = NULL;
+    PACEInfo *info = NULL;
+    PACEDomainParameterInfo *dp_info_picc = NULL, *dp_info_picc_static = NULL,
+                            *dp_info_pcd = NULL;
+    BUF_MEM *nonce_picc = NULL, *enc_nonce = NULL, *nonce_pcd = NULL,
+            *map_pub_picc = NULL, *map_pub_pcd = NULL, *pub_picc = NULL,
+            *pub_pcd = NULL, *key_picc = NULL, *key_pcd = NULL, *k_mac = NULL,
+            *k_enc = NULL, *token_pcd = NULL, * token_picc = NULL, *tmp = NULL,
+            *id_picc = NULL, *id_pcd = NULL;
+    PACEDomainParameterInfo *map_dp_info_picc = NULL, *map_dp_info_pcd = NULL;
+    void *ka_obj = NULL;
+
+    ctx = PACE_CTX_new();
+    dp_info_picc_static = PACEDomainParameterInfo_new();
+    info = PACEInfo_new();
+    if (!ctx || !dp_info_picc_static || !info)
+        err("Error allocating memory");
+
+    s = PACE_SEC_new(sec_str, strlen(sec_str), sec_type);
+    if (!s)
+        err("Error initializing PACE secret");
+    if (debug)
+        hexdump("Initialized PACE secret", s->mem);
+
+    if (curve != NID_undef)
+        ka_obj = EC_KEY_new_by_curve_name(curve);
+    if (!PACE_init(ctx, dp_info_picc_static, info, algorithm, ka_obj))
+        err("Error initializing domain parameters and PACE_CTX object for PICC");
+    ctx->tr_version = PACE_TR_VERSION_2_01;
+    if (curve == NID_undef) {
+        if (!DH_generate_key(
+                    dp_info_picc_static->domainParameter->parameters.dh))
+            err("Error initializing domain parameters for PICC");
+    } else {
+        if (!EC_KEY_generate_key(
+                    dp_info_picc_static->domainParameter->parameters.ecdh))
+            err("Error initializing domain parameters for PICC");
+    }
+    dp_info_picc = PACEDomainParameterInfo_dup(dp_info_picc_static);
+    if (!dp_info_picc_static)
+        err("Error initializing domain parameters for PICC");
+
+    dp_info_pcd = PACEDomainParameterInfo_dup(dp_info_picc);
+    if (!dp_info_pcd)
+        err("Error initializing domain parameters and PACE_CTX object for PCD");
+
+    printf("Using ");
+    switch (s->type) {
+        case PACE_PUK:
+            printf("PUK");
+            break;
+        case PACE_CAN:
+            printf("CAN");
+            break;
+        case PACE_PIN:
+            printf("PIN");
+            break;
+        case PACE_MRZ:
+            printf("MRZ");
+            break;
+        case PACE_RAW:
+            printf("RAW");
+            break;
+        default:
+            err("\ncannot happen");
+    }
+    const char *sn = OBJ_nid2sn(info->protocol);
+    if (!sn)
+        err("\nError generating short name from nid.");
+    if (verbose)
+        printf(" with %s\n", sn);
+    else
+        printf(" with %s\t", sn);
+    if (debug)
+        switch (dp_info_picc->domainParameter->algorithm) {
+            case NID_dhpublicnumber:
+                DHparams_print_fp(stdout, dp_info_picc->domainParameter->parameters.dh);
+                break;
+            case NID_X9_62_id_ecPublicKey:
+                printf("Using curve: %s\n", OBJ_nid2sn(curve));
+                ECParameters_print_fp(stdout, dp_info_picc->domainParameter->parameters.ecdh);
+                break;
+            default:
+                err("cannot happen");
+        }
+
+    verb("STEP1");
+    if (!PACE_STEP1_enc_nonce(s, ctx, &nonce_picc, &enc_nonce))
+        err("Error generating or encrypting nonce");
+    verb("MRTD generated and encrypted nonce.");
+    if (debug) {
+        hexdump("MRTD generated Nonce", nonce_picc);
+        hexdump("Encrypted nonce", enc_nonce);
+    }
+
+    verb("STEP2");
+    nonce_pcd = PACE_STEP2_dec_nonce(s, enc_nonce, ctx);
+    if (!nonce_pcd)
+        err("Error decrypting nonce");
+    if (nonce_picc->length != nonce_pcd->length ||
+            memcmp(nonce_picc->data, nonce_pcd->data, nonce_pcd->length) != 0)
+        err("Error decrypting nonce (doesn't match nonce)");
+    verb("Terminal decrypted the correct nonce");
+
+    verb("STEP3A generate key");
+    map_pub_picc = PACE_STEP3A_generate_mapping_data(dp_info_picc, ctx);
+    if(!map_pub_picc)
+        err("Error generating keypair to map domain parameters");
+    verb("Generated keypair on MRTD for mapping");
+    map_pub_pcd = PACE_STEP3A_generate_mapping_data(dp_info_pcd, ctx);
+    if(!map_pub_pcd)
+        err("Error generating keypair to map domain parameters");
+    verb("Generated keypair on Terminal for mapping");
+    if (debug) {
+        hexdump("Public key MRTD", map_pub_picc);
+        hexdump("Public key Terminal", map_pub_pcd);
+    }
+
+    verb("STEP3A compute key");
+    switch (dp_info_picc->protocol) {
+        case NID_id_PACE_DH_IM:
+        case NID_id_PACE_ECDH_IM:
+            /* Integrated Mapping is special, only the terminal generates the key */
+            map_dp_info_picc = PACE_STEP3A_map_dp(dp_info_picc, ctx,
+                    nonce_picc, map_pub_picc);
+            break;
+        default:
+            map_dp_info_picc = PACE_STEP3A_map_dp(dp_info_picc, ctx,
+                    nonce_picc, map_pub_pcd);
+            break;
+    }
+    if(!map_dp_info_picc)
+        err("Error computing mapped domain parameters");
+    verb("Computed mapped domain parameters on MRTD");
+    map_dp_info_pcd = PACE_STEP3A_map_dp(dp_info_pcd,
+            ctx, nonce_pcd, map_pub_picc);
+    if(!map_dp_info_pcd)
+        err("Error computing mapped domain parameters");
+    verb("Computed mapped domain parameters on MRTD and Terminal");
+    switch (map_dp_info_picc->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            if (BN_cmp(map_dp_info_picc->domainParameter->parameters.dh->g,
+                        map_dp_info_pcd->domainParameter->parameters.dh->g) != 0)
+                err("Error computing mapped domain parameters (MRTD and TERMINAL differ)");
+            if (debug) {
+                printf("Mapped domain parameters:\n");
+                DHparams_print_fp(stdout, map_dp_info_picc->domainParameter->parameters.dh);
+            }
+            break;
+        case NID_X9_62_id_ecPublicKey:
+            if(EC_GROUP_cmp(EC_KEY_get0_group(map_dp_info_picc->domainParameter->parameters.ecdh),
+                        EC_KEY_get0_group(map_dp_info_pcd->domainParameter->parameters.ecdh),
+                        ctx->bn_ctx) != 0)
+                err("Error computing mapped domain parameters (MRTD and TERMINAL differ)");
+            if (debug) {
+                printf("Mapped domain parameters on MRTD and Terminal:\n");
+                ECParameters_print_fp(stdout, map_dp_info_picc->domainParameter->parameters.ecdh);
+            }
+            break;
+        default:
+            err("cannot happen");
+    }
+
+    verb("STEP3B");
+    pub_picc = PACE_STEP3B_generate_ephemeral_key(map_dp_info_picc, ctx);
+    if(!pub_picc)
+        err("Error generating keypair for key derivation on MRTD");
+    verb("Generated keypair on MRTD for key derivation");
+    pub_pcd = PACE_STEP3B_generate_ephemeral_key(map_dp_info_pcd, ctx);
+    if(!pub_pcd)
+        err("Error generating keypair for key derivation on Terminal");
+    verb("Generated keypair on Terminal for key derivation");
+    key_picc = PACE_STEP3B_compute_ephemeral_key(map_dp_info_picc, ctx, pub_pcd);
+    if(!key_picc)
+        err("Error computing key for key derivation on MRTD");
+    key_pcd = PACE_STEP3B_compute_ephemeral_key(map_dp_info_pcd, ctx, pub_picc);
+    if(!key_pcd)
+        err("Error computing key for key derivation on Terminal");
+    if (key_pcd->length != key_picc->length ||
+            memcmp(key_picc->data, key_pcd->data, key_pcd->length) != 0)
+        err("Error computing key for key derivation (MRTD and TERMINAL differ)");
+    verb("Computed the same key on MRTD and TERMINAL for key derivation");
+
+    verb("STEP3C");
+    /* Note: Since the key is the same for MRTD and TERMINAL, k_enc and
+     * k_mac are the same, too */
+    if (!PACE_STEP3C_derive_keys(key_picc, ctx, info, &k_mac, &k_enc))
+        err("Error during key derivation");
+    verb("Derived authentication and encryption key");
+    if (debug) {
+        hexdump("Derived authentication key", k_mac);
+        hexdump("Derived encryption key", k_enc);
+    }
+
+    verb("STEP3D");
+    token_pcd = PACE_STEP3D_compute_authentication_token(ctx, map_dp_info_pcd, info,
+            pub_picc, k_mac);
+    if (!token_pcd) {
+        err("Failed to compute authentication token from Terminal");
+    }
+    verb("Computed authentication token for Terminal");
+    token_picc = PACE_STEP3D_compute_authentication_token(ctx, map_dp_info_picc, info,
+            pub_pcd, k_mac);
+    if (!token_picc) {
+        err("Failed to compute authentication token from MRTD");
+    }
+    verb("Computed authentication token for MRTD");
+    if (debug) {
+        hexdump("Authentication token from MRTD", token_picc);
+        hexdump("Authentication token from TERMINAL", token_pcd);
+    }
+    if (PACE_STEP3D_verify_authentication_token(ctx, map_dp_info_pcd, info,
+                k_mac, token_picc) != 1) {
+        err("Could not verify authentication token.");
+    }
+    verb("Authentication token verified.");
+
+    id_picc = PACE_Comp(map_dp_info_picc, ctx, pub_picc);
+    id_pcd = PACE_Comp(map_dp_info_pcd, ctx, pub_pcd);
+    if (!id_picc || !id_pcd) {
+        err("Failed to compute IDs");
+    }
+    verb("Computed ID of MRTD and Terminal");
+    if (debug) {
+        hexdump("ID of MRTD", id_picc);
+        hexdump("ID of Terminal", id_pcd);
+    }
+
+    ok = 0;
+
+err:
+    if (token_picc)
+        BUF_MEM_free(token_picc);
+    if (token_pcd)
+        BUF_MEM_free(token_pcd);
+    if (k_mac) {
+        OPENSSL_cleanse(k_mac->data, k_mac->max);
+        BUF_MEM_free(k_mac);
+    }
+    if (k_enc) {
+        OPENSSL_cleanse(k_enc->data, k_enc->max);
+        BUF_MEM_free(k_enc);
+    }
+    if (key_picc) {
+        OPENSSL_cleanse(key_picc->data, key_picc->max);
+        BUF_MEM_free(key_picc);
+    }
+    if (key_pcd) {
+        OPENSSL_cleanse(key_pcd->data, key_pcd->max);
+        BUF_MEM_free(key_pcd);
+    }
+    if (tmp)
+        BUF_MEM_free(tmp);
+    if (pub_picc)
+        BUF_MEM_free(pub_picc);
+    if (pub_pcd)
+        BUF_MEM_free(pub_pcd);
+    if (map_pub_picc)
+        BUF_MEM_free(map_pub_picc);
+    if (map_pub_pcd)
+        BUF_MEM_free(map_pub_pcd);
+    if (nonce_pcd) {
+        OPENSSL_cleanse(nonce_pcd->data, nonce_pcd->max);
+        BUF_MEM_free(nonce_pcd);
+    }
+    if (nonce_picc) {
+        OPENSSL_cleanse(nonce_picc->data, nonce_picc->max);
+        BUF_MEM_free(nonce_picc);
+    }
+    if (enc_nonce)
+        BUF_MEM_free(enc_nonce);
+    if (id_picc)
+        BUF_MEM_free(id_picc);
+    if (id_pcd)
+        BUF_MEM_free(id_pcd);
+    PACEDomainParameterInfo_clear_free(map_dp_info_pcd);
+    PACEDomainParameterInfo_clear_free(map_dp_info_picc);
+    PACEDomainParameterInfo_clear_free(dp_info_pcd);
+    PACEDomainParameterInfo_clear_free(dp_info_picc);
+    PACEDomainParameterInfo_clear_free(dp_info_picc_static);
+    PACEInfo_free(info);
+    PACE_CTX_clear_free(ctx);
+    PACE_SEC_clean_free(s);
+
+    if (verbose) {
+        if (ok == 0)
+            printf("Everything works as expected.\n");
+        else
+            printf("Some error occurred.\n");
+    } else {
+        if (ok == 0)
+            printf(" ok\n");
+        else
+            printf(" error\n");
+    }
+
+    return ok;
+}
+
+int real_life_test()
+{
+    int r = 0;
+    if (verbose)
+        printf("Starting a real life test");
+
+    enum s_type pace_sec_type [] = {
+        PACE_PUK,
+        PACE_CAN,
+        PACE_PIN,
+        PACE_MRZ,
+        PACE_RAW,
+        PACE_SEC_UNDEF,
+    };
+    enum s_type * sec_type = pace_sec_type;
+    char * pace_sec_str [] = {
+        "PUK",
+        "CAN",
+        "PIN",
+        /* ePA MRZ: https://www.bsi.bund.de/cae/servlet/contentblob/650964/normal/37609/ePA_beideSeiten.jpg */
+        /* ePA MRZ: http://www.cio.bund.de/cln_093/sid_AF344A548BB315C1B49C3F627F830E35/SharedDocs/Kurzmeldungen/DE/2009/091217_finales_muster_neuer_personalausweis.html */
+        "IDD<<T220001293<<<<<<<<<<<<<<<6408125<1010318D<<<<<<<<<<<<<<MUSTERMANN<<ERIKA<<<<<<<<<<<<<",
+        "RAW",
+        NULL,
+    };
+    char ** sec_str = pace_sec_str;
+    int algorithm_type [] = {
+        NID_id_PACE_DH_IM_3DES_CBC_CBC,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_128,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_192,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_256,
+        NID_id_PACE_ECDH_IM_3DES_CBC_CBC,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256,
+        NID_id_PACE_DH_GM_3DES_CBC_CBC,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_128,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_192,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_256,
+        NID_id_PACE_ECDH_GM_3DES_CBC_CBC,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256,
+        NID_undef,
+    };
+    int * algorithm = algorithm_type;
+    int curve_type [] = {
+        /* Note: Only some curves work with IM, but all should work with GM */
+        NID_brainpoolP256r1,
+        NID_brainpoolP256t1,
+        NID_brainpoolP320r1,
+        NID_brainpoolP320t1,
+        NID_brainpoolP512r1,
+        NID_brainpoolP512t1,
+        NID_brainpoolP160r1,
+        NID_brainpoolP160t1,
+        NID_brainpoolP192r1,
+        NID_brainpoolP192t1,
+        NID_brainpoolP224r1,
+        NID_brainpoolP224t1,
+        NID_brainpoolP384r1,
+        NID_brainpoolP384t1,
+        NID_undef,
+    };
+    int * curve = curve_type;
+
+
+    while (*algorithm != NID_undef) {
+        switch (*algorithm) {
+            case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+                r += do_test(*sec_str, *sec_type, *curve, *algorithm);
+                if(*curve != NID_undef)
+                    curve++;
+                break;
+            default:
+                r += do_test(*sec_str, *sec_type, NID_undef, *algorithm);
+                break;
+        }
+
+        sec_str++;
+        sec_type++;
+        if (*sec_str == NULL || *sec_type == PACE_SEC_UNDEF) {
+            sec_str = pace_sec_str;
+            sec_type = pace_sec_type;
+        }
+        algorithm++;
+    }
+
+    return r;
+}
+
+int parse_test()
+{
+    int ok = 1;
+    printf("Testing parsing capabilities ");
+    if (verbose)
+        printf("\n");
+
+    PACEInfo *info = NULL;
+    PACEDomainParameterInfo *dp = NULL;
+    CVC_CERT *cvc_cert = NULL;
+    CVC_CERTIFICATE_DESCRIPTION *cert_desc = NULL;
+    const unsigned char *p;
+    BIO *bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE);
+    if (!bio_stdout)
+        err("Could not get output buffer");
+
+    if (!parse_ef_card_access(EFCardAccess, EF_len, &info, &dp))
+        err("Could not parse EFCardAccess");
+    verb("Parsed EF.CardAccess");
+    if (debug) {
+        dump_pace_info(info);
+        dump_pace_dp(dp);
+    }
+
+    p = CVCert;
+    cvc_cert = CVC_d2i_CVC_CERT(NULL, &p, CVCert_len);
+    if (!cvc_cert)
+        err("Could not parse CV Cert");
+    verb("Parsed CV Cert");
+    if (debug)
+        if (!cvc_print(bio_stdout, cvc_cert, "\t"))
+            err("Error printing CV Cert");
+
+    p = certDesc;
+    cert_desc = d2i_CVC_CERTIFICATE_DESCRIPTION(NULL, &p, certDesc_len);
+    if (!cvc_cert)
+        err("Could not parse Certificate Description");
+    verb("Parsed Certificate Description");
+    if (debug)
+        if (!certificate_description_print(bio_stdout, certDesc, certDesc_len, "\t"))
+            err("Could not print Certificate Description");
+
+    if (!CVC_check_cert(cvc_cert, certDesc, certDesc_len))
+        err("Certificate Description doesn't match Certificate\n");
+    verb("Certificate Description matches Certificate");
+
+    /* FIXME: CVC_CERT_print_ctx -> segfault
+    CVC_CERT_print_ctx(bio_stdout, cvc_cert, 1, NULL); */
+
+    ok = 0;
+
+err:
+    PACEInfo_free(info);
+    PACEDomainParameterInfo_clear_free(dp);
+    if (cvc_cert)
+        CVC_CERT_free(cvc_cert);
+    if (cert_desc)
+        CVC_CERTIFICATE_DESCRIPTION_free(cert_desc);
+    if (bio_stdout)
+        BIO_free_all(bio_stdout);
+
+    if (verbose) {
+        if (ok == 0)
+            printf("Everything works as expected.\n");
+        else
+            printf("Some error occurred.\n");
+    } else {
+        if (ok == 0)
+            printf(" ok\n");
+        else
+            printf(" error\n");
+    }
+
+    return ok;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+    for (i=1; i<argc; i++)
+    {
+        if ((strcmp(argv[i], "--verbose") == 0)
+                || (strcmp(argv[i], "-v") == 0)) {
+            verbose++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--debug") == 0)
+                || (strcmp(argv[i], "-d") == 0)) {
+            verbose++;
+            debug++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--help") == 0)
+                || (strcmp(argv[i], "-h") == 0)) {
+            fprintf(stderr,
+                    "%s tests the OpenSSL implementation of Password Authentication Connection Establishment (PACE)\n"
+                    "\n"
+                    "Usage: %s [Options]\n"
+                    "\n"
+                    "Options:\n"
+                    "  -h,--help         show this help message and exit\n"
+                    "  -v,--verbose      more verbosity\n"
+                    "     --version      print version information and exit\n"
+                    , argv[0], argv[0]
+            );
+            return 0;
+        }
+        if (strcmp(argv[i], "--version") == 0) {
+            fprintf(stderr,
+                    "%s 0.1\n"
+                    "\n"
+                    "Written by Frank Morgner and Dominik Oepen.\n"
+                    , argv[0]
+            );
+            return 0;
+        }
+
+        fprintf(stderr, "unrecognized option \"%s\"\n", argv[i]);
+        return 1;
+    }
+
+    /*printf("%s:%d\n", __FILE__, __LINE__);*/
+    int out = 0;
+    out += real_life_test();
+    out += parse_test();
+
+    return -out;
+}
+
+#endif /* OPENSSL_NO_PACE */
Index: openssl/makevms.com
===================================================================
--- openssl.orig/makevms.com	2010-10-14 13:47:08.000000000 +0200
+++ openssl/makevms.com	2010-10-14 13:47:08.000000000 +0200
@@ -254,6 +254,7 @@
 		     HMAC,-
 		     IDEA,-
 		     JPAKE,-
+		     PACE,-
 		     KRB5,-
 		     LHASH,-
 		     MD2,-
@@ -635,7 +636,7 @@
    BN,EC,RSA,DSA,ECDSA,DH,ECDH,DSO,ENGINE,-
    BUFFER,BIO,STACK,LHASH,RAND,ERR,-
    EVP,ASN1,PEM,X509,X509V3,CONF,TXT_DB,PKCS7,PKCS12,COMP,OCSP,UI,KRB5,-
-   STORE,CMS,PQUEUE,TS,JPAKE
+   STORE,CMS,PQUEUE,TS,JPAKE,PACE
 $ EXHEADER_ := crypto.h,opensslv.h,ebcdic.h,symhacks.h,ossl_typ.h
 $ EXHEADER__'ARCH' := opensslconf.h
 $ EXHEADER_OBJECTS := objects.h,obj_mac.h
@@ -692,6 +693,7 @@
 $ EXHEADER_PQUEUE := pqueue.h
 $ EXHEADER_TS := ts.h
 $ EXHEADER_JPAKE := jpake.h
+$ EXHEADER_PACE := pace.h
 $
 $ I = 0
 $ LOOP_SDIRS: 
Index: openssl/test/Makefile
===================================================================
--- openssl.orig/test/Makefile	2010-10-14 13:47:08.000000000 +0200
+++ openssl/test/Makefile	2010-10-14 13:47:08.000000000 +0200
@@ -64,10 +64,12 @@
 ASN1TEST=	asn1test
 GCMTESTA=	aesgcmtest
 CMACTESTA=	cmac_test
+PACETEST=	pacetest
+
 
 TESTS=		alltests
 
-EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
+EXE=	$(PACETEST)$(EXE_EXT) $(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
 	$(MD2TEST)$(EXE_EXT)  $(MD4TEST)$(EXE_EXT) $(MD5TEST)$(EXE_EXT) $(HMACTEST)$(EXE_EXT) $(WPTEST)$(EXE_EXT) \
 	$(RC2TEST)$(EXE_EXT) $(RC4TEST)$(EXE_EXT) $(RC5TEST)$(EXE_EXT) \
 	$(DESTEST)$(EXE_EXT) $(SHATEST)$(EXE_EXT) $(SHA1TEST)$(EXE_EXT) $(SHA256TEST)$(EXE_EXT) $(SHA512TEST)$(EXE_EXT) \
@@ -88,7 +90,7 @@
 	$(RANDTEST).o $(DHTEST).o $(ENGINETEST).o $(CASTTEST).o \
 	$(BFTEST).o  $(SSLTEST).o  $(DSATEST).o  $(EXPTEST).o $(RSATEST).o \
 	$(EVPTEST).o $(IGETEST).o $(JPAKETEST).o $(ASN1TEST).o \
-	$(GCMTESTA).o $(CMACTESTA).o
+	$(GCMTESTA).o $(CMACTESTA).o $(PACETEST).o
 SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
 	$(HMACTEST).c $(WPTEST).c \
@@ -97,7 +99,7 @@
 	$(RANDTEST).c $(DHTEST).c $(ENGINETEST).c $(CASTTEST).c \
 	$(BFTEST).c  $(SSLTEST).c $(DSATEST).c   $(EXPTEST).c $(RSATEST).c \
 	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c $(ASN1TEST).c \
-	$(GCMTESTA).c $(CMACTESTA).c
+	$(GCMTESTA).c $(CMACTESTA).c $(PACETEST).c
 
 EXHEADER= 
 HEADER=	$(EXHEADER)
@@ -140,7 +142,7 @@
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_ssl test_tsa test_ige \
-	test_jpake test_cms test_aes_gcm test_cmac
+	test_jpake test_cms test_aes_gcm test_cmac test_pace
 
 test_evp:
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
@@ -322,6 +324,10 @@
 	@echo "Test CMAC modes"
 	../util/shlib_wrap.sh  ./$(CMACTESTA)$(EXE_EXT)
 
+test_pace: $(PACETEST)$(EXE_EXT)
+	@echo "Test PACE"
+	../util/shlib_wrap.sh ./$(PACETEST)
+
 lint:
 	lint -DLINT $(INCLUDES) $(SRC)>fluff
 
@@ -464,6 +470,9 @@
 $(CMACTESTA)$(EXE_EXT): $(CMACTESTA).o  $(DLIBCRYPTO)
 	@target=$(CMACTESTA); $(BUILD_CMD)
 
+$(PACETEST)$(EXE_EXT): $(PACETEST).o  $(DLIBCRYPTO)
+	@target=$(PACETEST); $(BUILD_CMD)
+
 #$(AESTEST).o: $(AESTEST).c
 #	$(CC) -c $(CFLAGS) -DINTERMEDIATE_VALUE_KAT -DTRACE_KAT_MCT $(AESTEST).c
 
@@ -479,6 +488,15 @@
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
 
+aesgcmtest.o: ../include/openssl/aes.h ../include/openssl/aes_gcm.h
+aesgcmtest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+aesgcmtest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+aesgcmtest.o: ../include/openssl/err.h ../include/openssl/evp.h
+aesgcmtest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+aesgcmtest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+aesgcmtest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+aesgcmtest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
+aesgcmtest.o: ../include/openssl/symhacks.h aesgcmtest.c
 asn1test.o: ../include/openssl/asn1.h ../include/openssl/asn1_mac.h
 asn1test.o: ../include/openssl/bio.h ../include/openssl/buffer.h
 asn1test.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
@@ -509,36 +527,46 @@
 bntest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bntest.c
 casttest.o: ../e_os.h ../include/openssl/cast.h ../include/openssl/e_os2.h
 casttest.o: ../include/openssl/opensslconf.h casttest.c
+cmac_test.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+cmac_test.o: ../include/openssl/cmac.h ../include/openssl/crypto.h
+cmac_test.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+cmac_test.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+cmac_test.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+cmac_test.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+cmac_test.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
+cmac_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+cmac_test.o: cmac_test.c
 destest.o: ../include/openssl/des.h ../include/openssl/des_old.h
 destest.o: ../include/openssl/e_os2.h ../include/openssl/opensslconf.h
 destest.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
 destest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 destest.o: ../include/openssl/ui.h ../include/openssl/ui_compat.h destest.c
 dhtest.o: ../e_os.h ../include/openssl/bio.h ../include/openssl/bn.h
-dhtest.o: ../include/openssl/crypto.h ../include/openssl/dh.h
-dhtest.o: ../include/openssl/e_os2.h ../include/openssl/err.h
-dhtest.o: ../include/openssl/lhash.h ../include/openssl/opensslconf.h
-dhtest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-dhtest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
-dhtest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h dhtest.c
+dhtest.o: ../include/openssl/buffer.h ../include/openssl/crypto.h
+dhtest.o: ../include/openssl/dh.h ../include/openssl/e_os2.h
+dhtest.o: ../include/openssl/err.h ../include/openssl/lhash.h
+dhtest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+dhtest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
+dhtest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
+dhtest.o: ../include/openssl/symhacks.h dhtest.c
 dsatest.o: ../e_os.h ../include/openssl/bio.h ../include/openssl/bn.h
-dsatest.o: ../include/openssl/crypto.h ../include/openssl/dh.h
-dsatest.o: ../include/openssl/dsa.h ../include/openssl/e_os2.h
-dsatest.o: ../include/openssl/err.h ../include/openssl/lhash.h
-dsatest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-dsatest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
-dsatest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
-dsatest.o: ../include/openssl/symhacks.h dsatest.c
+dsatest.o: ../include/openssl/buffer.h ../include/openssl/crypto.h
+dsatest.o: ../include/openssl/dh.h ../include/openssl/dsa.h
+dsatest.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+dsatest.o: ../include/openssl/lhash.h ../include/openssl/opensslconf.h
+dsatest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+dsatest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+dsatest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h dsatest.c
 ecdhtest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ecdhtest.o: ../include/openssl/bn.h ../include/openssl/crypto.h
-ecdhtest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ecdhtest.o: ../include/openssl/ecdh.h ../include/openssl/err.h
-ecdhtest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ecdhtest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ecdhtest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ecdhtest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
-ecdhtest.o: ../include/openssl/sha.h ../include/openssl/stack.h
-ecdhtest.o: ../include/openssl/symhacks.h ecdhtest.c
+ecdhtest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ecdhtest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+ecdhtest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ecdhtest.o: ../include/openssl/err.h ../include/openssl/lhash.h
+ecdhtest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ecdhtest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ecdhtest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
+ecdhtest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ecdhtest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h ecdhtest.c
 ecdsatest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
 ecdsatest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 ecdsatest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
@@ -593,12 +621,12 @@
 evp_test.o: ../include/openssl/symhacks.h ../include/openssl/x509.h
 evp_test.o: ../include/openssl/x509_vfy.h evp_test.c
 exptest.o: ../e_os.h ../include/openssl/bio.h ../include/openssl/bn.h
-exptest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
-exptest.o: ../include/openssl/err.h ../include/openssl/lhash.h
-exptest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-exptest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
-exptest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
-exptest.o: ../include/openssl/symhacks.h exptest.c
+exptest.o: ../include/openssl/buffer.h ../include/openssl/crypto.h
+exptest.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+exptest.o: ../include/openssl/lhash.h ../include/openssl/opensslconf.h
+exptest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+exptest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+exptest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h exptest.c
 hmactest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 hmactest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 hmactest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
@@ -645,6 +673,17 @@
 mdc2test.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
 mdc2test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 mdc2test.o: ../include/openssl/ui.h ../include/openssl/ui_compat.h mdc2test.c
+pacetest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+pacetest.o: ../include/openssl/buffer.h ../include/openssl/cmac.h
+pacetest.o: ../include/openssl/conf.h ../include/openssl/crypto.h
+pacetest.o: ../include/openssl/dh.h ../include/openssl/e_os2.h
+pacetest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+pacetest.o: ../include/openssl/err.h ../include/openssl/evp.h
+pacetest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+pacetest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+pacetest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+pacetest.o: ../include/openssl/pace.h ../include/openssl/safestack.h
+pacetest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h pacetest.c
 randtest.o: ../e_os.h ../include/openssl/e_os2.h
 randtest.o: ../include/openssl/opensslconf.h ../include/openssl/ossl_typ.h
 randtest.o: ../include/openssl/rand.h randtest.c
@@ -666,13 +705,13 @@
 rmdtest.o: ../include/openssl/ripemd.h ../include/openssl/safestack.h
 rmdtest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h rmdtest.c
 rsa_test.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-rsa_test.o: ../include/openssl/bn.h ../include/openssl/crypto.h
-rsa_test.o: ../include/openssl/e_os2.h ../include/openssl/err.h
-rsa_test.o: ../include/openssl/lhash.h ../include/openssl/opensslconf.h
-rsa_test.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-rsa_test.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-rsa_test.o: ../include/openssl/safestack.h ../include/openssl/stack.h
-rsa_test.o: ../include/openssl/symhacks.h rsa_test.c
+rsa_test.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+rsa_test.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+rsa_test.o: ../include/openssl/err.h ../include/openssl/lhash.h
+rsa_test.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+rsa_test.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
+rsa_test.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+rsa_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h rsa_test.c
 sha1test.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 sha1test.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 sha1test.o: ../include/openssl/evp.h ../include/openssl/obj_mac.h
Index: openssl/test/tests.com
===================================================================
--- openssl.orig/test/tests.com	2010-10-14 13:47:08.000000000 +0200
+++ openssl/test/tests.com	2010-10-14 13:47:08.000000000 +0200
@@ -35,7 +35,7 @@
 	test_enc,test_x509,test_rsa,test_crl,test_sid,-
 	test_gen,test_req,test_pkcs7,test_verify,test_dh,test_dsa,-
 	test_ss,test_ca,test_engine,test_evp,test_ssl,test_tsa,test_ige,-
-	test_jpake,test_cms
+	test_jpake,test_cms,test_pace
 $	endif
 $	tests = f$edit(tests,"COLLAPSE")
 $
@@ -70,6 +70,7 @@
 $	EVPTEST :=	evp_test
 $	IGETEST :=	igetest
 $	JPAKETEST :=	jpaketest
+$	PACETEST :=	pacetest
 $
 $	tests_i = 0
 $ loop_tests:
@@ -291,6 +292,10 @@
 $	write sys$output "CMS consistency test"
 $	perl CMS-TEST.PL
 $	return
+$ test_pace:
+$	write sys$output "Test PACE"
+$	mcr 'texe_dir''pacetest'
+$	return
 $
 $
 $ exit:
