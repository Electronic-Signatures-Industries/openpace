Index: openssl/Configure
===================================================================
--- openssl.orig/Configure	2012-04-04 22:45:10.417275965 +0200
+++ openssl/Configure	2012-04-04 23:15:24.591305684 +0200
@@ -713,7 +713,8 @@
 		 "gmp"		  => "default",
 		 "jpake"          => "experimental",
 		 "md2"            => "default",
-		 "rc5"            => "default",
+		 "pace"           => "experimental",
+ 		 "rc5"            => "default",
 		 "rfc3779"	  => "default",
 		 "sctp"       => "default",
 		 "shared"         => "default",
@@ -725,7 +726,7 @@
 
 # This is what $depflags will look like with the above defaults
 # (we need this to see if we should advise the user to run "make depend"):
-my $default_depflags = " -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_STORE";
+my $default_depflags = " -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_MD2 DOPENSSL_NO_PACE -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_STORE";
 
 # Explicit "no-..." options will be collected in %disabled along with the defaults.
 # To remove something from %disabled, use "enable-foo" (unless it's experimental).
Index: openssl/Makefile.org
===================================================================
--- openssl.orig/Makefile.org	2012-04-04 22:45:10.417275965 +0200
+++ openssl/Makefile.org	2012-04-04 23:15:24.595305708 +0200
@@ -147,7 +147,7 @@
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts jpake srp store cmac
+	cms pqueue ts jpake srp store cmac eac
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
Index: openssl/crypto/bn/bn.h
===================================================================
--- openssl.orig/crypto/bn/bn.h	2012-04-04 22:45:10.065098218 +0200
+++ openssl/crypto/bn/bn.h	2012-04-04 23:15:24.583305644 +0200
@@ -447,6 +447,15 @@
 int	BN_bn2bin(const BIGNUM *a, unsigned char *to);
 BIGNUM *BN_mpi2bn(const unsigned char *s,int len,BIGNUM *ret);
 int	BN_bn2mpi(const BIGNUM *a, unsigned char *to);
+/**
+ * @brief converts an BIGNUM object to a BUF_MEM object
+ *
+ * @param bn bignumber to convert
+ *
+ * @return converted bignumber or NULL if an error occurred
+ */
+BUF_MEM *
+BN_bn2buf(const BIGNUM *bn);
 int	BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int	BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
 int	BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
Index: openssl/crypto/bn/bn_lib.c
===================================================================
--- openssl.orig/crypto/bn/bn_lib.c	2012-04-04 22:45:10.065098218 +0200
+++ openssl/crypto/bn/bn_lib.c	2012-04-04 23:15:24.583305644 +0200
@@ -66,6 +66,7 @@
 #include <stdio.h>
 #include "cryptlib.h"
 #include "bn_lcl.h"
+#include <openssl/buffer.h>
 
 const char BN_version[]="Big Number" OPENSSL_VERSION_PTEXT;
 
@@ -824,3 +825,20 @@
 		}
 	return bn_cmp_words(a,b,cl);
 	}
+
+BUF_MEM *
+BN_bn2buf(const BIGNUM *bn)
+{
+    BUF_MEM * out;
+
+    if (!bn)
+        return NULL;
+
+    out = BUF_MEM_create(BN_num_bytes(bn));
+    if (!out)
+        return NULL;
+
+    out->length = BN_bn2bin(bn, (unsigned char *) out->data);
+
+    return out;
+}
Index: openssl/crypto/buffer/buffer.c
===================================================================
--- openssl.orig/crypto/buffer/buffer.c	2012-04-04 22:45:10.145138615 +0200
+++ openssl/crypto/buffer/buffer.c	2012-04-04 23:15:24.579305623 +0200
@@ -184,3 +184,57 @@
 			}
 		}
 	}
+
+BUF_MEM *
+BUF_MEM_create(size_t len)
+{
+    BUF_MEM *out = BUF_MEM_new();
+    if (!out)
+        return NULL;
+
+    if (!BUF_MEM_grow(out, len)) {
+        BUF_MEM_free(out);
+        return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len)
+{
+    BUF_MEM *out;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    memcpy(out->data, buf, len);
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+
+    if (!in)
+        return NULL;
+
+    out = BUF_MEM_create(in->length);
+    if (!out)
+        goto err;
+
+    memcpy(out->data, in->data, in->length);
+    out->max = in->max;
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
Index: openssl/crypto/buffer/buffer.h
===================================================================
--- openssl.orig/crypto/buffer/buffer.h	2012-04-04 22:45:10.145138615 +0200
+++ openssl/crypto/buffer/buffer.h	2012-04-04 23:15:24.579305623 +0200
@@ -89,7 +89,34 @@
 char *	BUF_strndup(const char *str, size_t siz);
 void *	BUF_memdup(const void *data, size_t siz);
 void	BUF_reverse(unsigned char *out, unsigned char *in, size_t siz);
-
+/**
+ * @brief Creates a BUF_MEM object
+ *
+ * @param len required length of the buffer
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create(size_t len);
+/**
+ * @brief Creates and initializes a BUF_MEM object
+ *
+ * @param buf Initial data
+ * @param len Length of buf
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len);
+/**
+ * @brief duplicates a BUF_MEM structure
+ *
+ * @param in BUF_MEM to duplicate
+ *
+ * @return pointer to the new BUF_MEM or NULL in case of error
+ */
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in);
 /* safe string functions */
 size_t BUF_strlcpy(char *dst,const char *src,size_t siz);
 size_t BUF_strlcat(char *dst,const char *src,size_t siz);
Index: openssl/crypto/crypto-lib.com
===================================================================
--- openssl.orig/crypto/crypto-lib.com	2012-04-04 22:45:10.177154780 +0200
+++ openssl/crypto/crypto-lib.com	2012-04-04 23:15:24.583305644 +0200
@@ -117,7 +117,7 @@
 		  "BUFFER,BIO,STACK,LHASH,RAND,ERR,"+ -
 		  "EVP,EVP_2,EVP_3,ASN1,ASN1_2,PEM,X509,X509V3,"+ -
 		  "CONF,TXT_DB,PKCS7,PKCS12,COMP,OCSP,UI,KRB5,"+ -
-		  "CMS,PQUEUE,TS,JPAKE,SRP,STORE,CMAC"
+		  "CMS,PQUEUE,TS,JPAKE,SRP,STORE,CMAC,EAC"
 $!
 $! Check To Make Sure We Have Valid Command Line Parameters.
 $!
@@ -346,6 +346,9 @@
 $ LIB_SRP = "srp_lib,srp_vfy"
 $ LIB_STORE = "str_err,str_lib,str_meth,str_mem"
 $ LIB_CMAC = "cmac,cm_ameth.c,cm_pmeth"
+$ LIB_PACE = "ca_lib,cv_cert,eac_asn1,eac,eac_ca,eac_dh,eac_ecdh,eac_err,"+ -
+    "eac_kdf,eac_lib,eac_print,eac_util,pace,pace_lib,pace_mappings,ri," + -
+    "ri_lib,ta,ta_lib"
 $!
 $! Setup exceptional compilations
 $!
Index: openssl/crypto/eac/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/Makefile	2012-04-04 23:15:48.435423918 +0200
@@ -0,0 +1,324 @@
+#
+# OpenSSL/crypto/eac/Makefile
+#
+
+DIR=    eac
+TOP=	../..
+CC=	cc
+INCLUDES=-I$(TOP) -I../../include -I..
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+RANLIB=		ranlib
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=eactest.c cv_cert_test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=eac_err.c pace_lib.c eac_util.c pace.c eac_dh.c eac_kdf.c eac_ecdh.c pace_mappings.c eac_asn1.c eac.c ta_lib.c ca_lib.c eac_lib.c eac_ca.c ri.c ri_lib.c ta.c cv_cert.c eac_print.c
+LIBOBJ=eac_err.o pace_lib.o eac_util.o pace.o eac_dh.o eac_kdf.o eac_ecdh.o pace_mappings.o eac_asn1.o eac.o ta_lib.o ca_lib.o eac_lib.o eac_ca.o ri.o ri_lib.o ta.o cv_cert.o eac_print.o
+SRC= $(LIBSRC)
+
+EXHEADER=pace.h eac.h ca.h ta.h ri.h cv_cert.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+ca_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+ca_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+ca_lib.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+ca_lib.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+ca_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+ca_lib.o: ../../include/openssl/ec.h ../../include/openssl/err.h
+ca_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+ca_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+ca_lib.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+ca_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
+ca_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+ca_lib.o: ca_lib.c eac_lib.h
+cv_cert.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+cv_cert.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+cv_cert.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+cv_cert.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+cv_cert.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+cv_cert.o: ../../include/openssl/ec.h ../../include/openssl/err.h
+cv_cert.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+cv_cert.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+cv_cert.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+cv_cert.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rsa.h
+cv_cert.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+cv_cert.o: ../../include/openssl/symhacks.h cv_cert.c cv_cert.h eac_asn1.h
+cv_cert.o: eac_util.h
+eac.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+eac.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+eac.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+eac.o: ../../include/openssl/ec.h ../../include/openssl/err.h
+eac.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+eac.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+eac.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+eac.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+eac.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac.o: ../../include/openssl/symhacks.h eac.c eac_kdf.h eac_lib.h eac_util.h
+eac_asn1.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_asn1.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_asn1.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+eac_asn1.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+eac_asn1.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+eac_asn1.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_asn1.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+eac_asn1.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+eac_asn1.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+eac_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_asn1.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+eac_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+eac_asn1.o: eac_asn1.c eac_asn1.h eac_dh.h pace_lib.h
+eac_ca.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_ca.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_ca.o: ../../include/openssl/buffer.h ../../include/openssl/ca.h
+eac_ca.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+eac_ca.o: ../../include/openssl/cv_cert.h ../../include/openssl/dh.h
+eac_ca.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+eac_ca.o: ../../include/openssl/ec.h ../../include/openssl/err.h
+eac_ca.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+eac_ca.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+eac_ca.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+eac_ca.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+eac_ca.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac_ca.o: ../../include/openssl/symhacks.h eac_asn1.h eac_ca.c eac_lib.h
+eac_ca.o: eac_util.h
+eac_dh.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_dh.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_dh.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+eac_dh.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+eac_dh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+eac_dh.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_dh.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+eac_dh.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+eac_dh.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+eac_dh.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_dh.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac_dh.o: ../../include/openssl/symhacks.h eac_dh.c eac_dh.h
+eac_ecdh.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_ecdh.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_ecdh.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+eac_ecdh.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+eac_ecdh.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+eac_ecdh.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+eac_ecdh.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+eac_ecdh.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+eac_ecdh.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+eac_ecdh.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_ecdh.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+eac_ecdh.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+eac_ecdh.o: eac_ecdh.c eac_ecdh.h
+eac_err.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_err.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+eac_err.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+eac_err.o: ../../include/openssl/cv_cert.h ../../include/openssl/e_os2.h
+eac_err.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_err.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+eac_err.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+eac_err.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+eac_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac_err.o: ../../include/openssl/symhacks.h eac_err.c
+eac_kdf.o: ../../e_os.h ../../include/openssl/asn1.h
+eac_kdf.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+eac_kdf.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+eac_kdf.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+eac_kdf.o: ../../include/openssl/cv_cert.h ../../include/openssl/e_os2.h
+eac_kdf.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_kdf.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+eac_kdf.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+eac_kdf.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+eac_kdf.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_kdf.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+eac_kdf.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+eac_kdf.o: ../cryptlib.h eac_kdf.c eac_kdf.h eac_util.h
+eac_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_lib.o: ../../include/openssl/buffer.h ../../include/openssl/ca.h
+eac_lib.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+eac_lib.o: ../../include/openssl/cv_cert.h ../../include/openssl/dh.h
+eac_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+eac_lib.o: ../../include/openssl/ec.h ../../include/openssl/err.h
+eac_lib.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+eac_lib.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+eac_lib.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+eac_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+eac_lib.o: ../../include/openssl/ri.h ../../include/openssl/safestack.h
+eac_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+eac_lib.o: ../../include/openssl/ta.h ca_lib.h eac_dh.h eac_ecdh.h eac_lib.c
+eac_lib.o: eac_lib.h eac_util.h pace_lib.h ta_lib.h
+eac_print.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_print.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+eac_print.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+eac_print.o: ../../include/openssl/cv_cert.h ../../include/openssl/e_os2.h
+eac_print.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_print.o: ../../include/openssl/evp.h ../../include/openssl/obj_mac.h
+eac_print.o: ../../include/openssl/objects.h
+eac_print.o: ../../include/openssl/opensslconf.h
+eac_print.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_print.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac_print.o: ../../include/openssl/symhacks.h eac_print.c
+eac_util.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+eac_util.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+eac_util.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+eac_util.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+eac_util.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+eac_util.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+eac_util.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+eac_util.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+eac_util.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+eac_util.o: ../../include/openssl/opensslconf.h
+eac_util.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+eac_util.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+eac_util.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+eac_util.o: ../../include/openssl/symhacks.h eac_asn1.h eac_dh.h eac_ecdh.h
+eac_util.o: eac_util.c eac_util.h
+pace.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+pace.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+pace.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+pace.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+pace.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace.o: eac_kdf.h eac_lib.h eac_util.h pace.c pace_mappings.h
+pace_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+pace_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+pace_lib.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_lib.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+pace_lib.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_lib.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+pace_lib.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_lib.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_lib.o: eac_dh.h eac_ecdh.h eac_lib.h eac_util.h pace_lib.c pace_mappings.h
+pace_mappings.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+pace_mappings.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+pace_mappings.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_mappings.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+pace_mappings.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_mappings.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+pace_mappings.o: ../../include/openssl/ecdh.h ../../include/openssl/err.h
+pace_mappings.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+pace_mappings.o: ../../include/openssl/obj_mac.h
+pace_mappings.o: ../../include/openssl/objects.h
+pace_mappings.o: ../../include/openssl/opensslconf.h
+pace_mappings.o: ../../include/openssl/opensslv.h
+pace_mappings.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+pace_mappings.o: ../../include/openssl/safestack.h
+pace_mappings.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_mappings.o: eac_dh.h eac_ecdh.h eac_util.h pace_mappings.c pace_mappings.h
+ri.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+ri.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+ri.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+ri.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+ri.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+ri.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+ri.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+ri.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+ri.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+ri.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ri.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+ri.o: ../../include/openssl/symhacks.h eac_lib.h eac_util.h ri.c
+ri_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+ri_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+ri_lib.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+ri_lib.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+ri_lib.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+ri_lib.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+ri_lib.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+ri_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+ri_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+ri_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ri_lib.o: ../../include/openssl/ri.h ../../include/openssl/safestack.h
+ri_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+ri_lib.o: eac_dh.h eac_ecdh.h eac_lib.h eac_util.h ri_lib.c
+ta.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+ta.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+ta.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+ta.o: ../../include/openssl/crypto.h ../../include/openssl/cv_cert.h
+ta.o: ../../include/openssl/e_os2.h ../../include/openssl/eac.h
+ta.o: ../../include/openssl/ec.h ../../include/openssl/ecdsa.h
+ta.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+ta.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+ta.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+ta.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ta.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+ta.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+ta.o: ../../include/openssl/ta.h eac_lib.h eac_util.h ta.c ta_lib.h
+ta_lib.o: ../../include/openssl/asn1.h ../../include/openssl/asn1t.h
+ta_lib.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+ta_lib.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+ta_lib.o: ../../include/openssl/cv_cert.h ../../include/openssl/e_os2.h
+ta_lib.o: ../../include/openssl/eac.h ../../include/openssl/ec.h
+ta_lib.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+ta_lib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+ta_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+ta_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+ta_lib.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+ta_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+ta_lib.o: ../../include/openssl/ta.h eac_util.h ta_lib.c
Index: openssl/crypto/eac/ca.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ca.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,129 @@
+/**
+ * @file ca.h
+ * @brief Interface for Chip Authentication
+ *
+ * Chip Authentication (CA) is a protocol which is used to
+ * check the authenticity of a MRTD chip and establish a
+ * secure channel for further communication. The chip contains
+ * one or more key pairs used for key agreement. After successful
+ * key agreement symmetric keys are derived from the shared secret.
+ * OpenPACE implements CA version 2.
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef CA_H_
+#define CA_H_
+
+#include <openssl/buffer.h>
+#include <openssl/eac.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Extract the public key from a EF.CardSecurity file
+ *
+ * @param[in] ef_cardsecurity buffer containing the ASN.1 encoded EF.CardSecurity
+ * @param[in] ef_cardsecurity_len length of \a ef_cardsecurity
+ *
+ * @return The public key or NULL in case of an error
+ */
+BUF_MEM *
+CA_get_pubkey(const unsigned char *ef_cardsecurity,
+        size_t ef_cardsecurity_len);
+
+/**
+ * @addtogroup caproto
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Get the PICC's encoded public key.
+ *
+ * @param[in] ctx EAC context
+ *
+ * @return Encoded public key or NULL in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+BUF_MEM *
+CA_STEP1_get_pubkey(const EAC_CTX *ctx);
+/**
+ * @brief Get the PCD's ephemeral public key (generated in TA step 3)
+ *
+ * @param[in] ctx EAC context
+ *
+ * @return Public key or NULL in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+BUF_MEM *
+CA_STEP2_get_eph_pubkey(const EAC_CTX *ctx);
+/**
+ * @brief Check whether the public key matches the compressed public key
+ * previously received in TA
+ *
+ * @param[in] ctx EAC context
+ * @param[in] comp_pubkey Compressed public key (received in TA step 3)
+ * @param[in] pubkey Uncompressed public key (received in CA step 2)
+ *
+ * @return 1 if the keys match, 0 if they don't or -1 in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+int
+CA_STEP3_check_pcd_pubkey(const EAC_CTX *ctx,
+        const BUF_MEM *comp_pubkey, const BUF_MEM *pubkey);
+/**
+ * @brief Compute the shared secret using the PICC's static key pair and the
+ * PCD's ephemeral key pair.
+ *
+ * @param[in,out] ctx EAC context. The secret is saved in \a ctx.
+ * @param[in] pubkey Public key from the other party
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+int
+CA_STEP4_compute_shared_secret(const EAC_CTX *ctx, const BUF_MEM *pubkey);
+
+/**
+ * @brief Derives the PICC's encryption and authentication keys
+ *
+ * @param[in,out] ctx EAC context. The keys are saved in \a ctx.
+ * @param[in]  pub   PCD's ephemeral public key
+ * @param[out] nonce Generated nonce
+ * @param[out] token Authentication token
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+int
+CA_STEP5_derive_keys(const EAC_CTX *ctx, const BUF_MEM *pub,
+                   BUF_MEM **nonce, BUF_MEM **token);
+
+/**
+ * @brief Derives the PCD's encryption and authentication keys
+ *
+ * @param[in,out] ctx EAC context. The keys are saved in \a ctx.
+ * @param[in] nonce PICC's generated nonce
+ * @param[in] token PICC's authentication token to verify
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see CA's @ref caps describes this protocol step
+ */
+int
+CA_STEP6_derive_keys(EAC_CTX *ctx, const BUF_MEM *nonce, const BUF_MEM *token);
+
+/** @} ***********************************************************************/
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/ca_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ca_lib.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,53 @@
+/**
+ * @file
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_lib.h"
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+
+CA_CTX *
+CA_CTX_new(void)
+{
+    CA_CTX *ctx = OPENSSL_malloc(sizeof(CA_CTX));
+    if (!ctx)
+        return NULL;
+
+    ctx->ka_ctx = KA_CTX_new();
+    if (!ctx->ka_ctx) {
+            OPENSSL_free(ctx);
+            return NULL;
+    }
+    ctx->version = 0;
+    ctx->protocol = NID_undef;
+
+    return ctx;
+}
+
+void
+CA_CTX_clear_free(CA_CTX *ctx)
+{
+    if (ctx) {
+        KA_CTX_clear_free(ctx->ka_ctx);
+        OPENSSL_free(ctx);
+    }
+}
+
+int
+CA_CTX_set_protocol(CA_CTX * ctx, int protocol)
+{
+    if (!ctx) {
+        EACerr(EAC_F_CA_CTX_SET_PROTOCOL, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    if (!KA_CTX_set_protocol(ctx->ka_ctx, protocol))
+        return 0;
+
+    ctx->protocol = protocol;
+
+    return 1;
+}
Index: openssl/crypto/eac/ca_lib.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ca_lib.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,41 @@
+/**
+ * @file
+ * @brief Interface for Chip Authentication library functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef CA_LIB_H_
+#define CA_LIB_H_
+
+#include <openssl/eac.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int
+CA_CTX_set_protocol(CA_CTX * ctx, int protocol);
+
+/**
+ * @brief Create a new \CA_CTX structure
+ * @return The new structure or NULL in case of an error
+ */
+CA_CTX *
+CA_CTX_new(void);
+
+/**
+ * @brief Free a \c CA_CTX object and all its components.
+ *
+ * Sensitive memory is cleared with OPENSSL_cleanse().
+ *
+ * @param ctx The \c CA_CTX to free
+ */
+void
+CA_CTX_clear_free(CA_CTX *ctx);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/cv_cert.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/cv_cert.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,932 @@
+/**
+ * @file
+ * @brief Library for card verifiable certificates
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/asn1t.h>
+#include <openssl/buffer.h>
+#include <openssl/eac.h>
+#include <openssl/ec.h>
+#include <openssl/err.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/rsa.h>
+#include <string.h>
+
+#include "cv_cert.h"
+#include "eac_asn1.h"
+#include "eac_util.h"
+
+/** Check whether or not  a specific bit is set */
+#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
+
+/* Number of bits and bytes of the relative authorization field in the CHAT.
+ * See TR-03110 pp. 85 */
+#define EAC_AT_CHAT_BYTES 5
+#define EAC_AT_CHAT_BITS 38
+#define EAC_IS_CHAT_BYTES 1
+#define EAC_IS_CHAT_BITS 6
+#define EAC_ST_CHAT_BYTES 1
+#define EAC_ST_CHAT_BITS 6
+
+/** Application specific, IMPLICIT tagged ASN1 type */
+#define ASN1_APP_IMP(stname, field, type, tag) ASN1_EX_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, tag, stname, field, type)
+/** Application specific, IMPLICIT tagged, optional ASN1 type */
+#define ASN1_APP_IMP_OPT(stname, field, type, tag) ASN1_EX_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION|ASN1_TFLG_OPTIONAL, tag, stname, field, type)
+/** Application specific, EXPLICIT tagged, optional ASN1 type */
+#define ASN1_APP_EXP_OPT(stname, field, type, tag) ASN1_EX_TYPE(ASN1_TFLG_EXPTAG|ASN1_TFLG_APPLICATION|ASN1_TFLG_OPTIONAL, tag, stname, field, type)
+
+/** Human readable names of the individual bits of the CHAT of an
+    authentication terminal*/
+static const char *at_chat_strings[] = {
+        "Age Verification",
+        "Community ID Verification",
+        "Restricted Identification",
+        "Privileged Terminal",
+        "CAN allowed",
+        "PIN Management",
+        "Install Certificate",
+        "Install Qualified Certificate",
+        "Read DG 1 (Document Type)",
+        "Read DG 2 (Issuing State)",
+        "Read DG 3 (Date of Expiry)",
+        "Read DG 4 (Given Names)",
+        "Read DG 5 (Family Names)",
+        "Read DG 6 (Religious/Artistic Name)",
+        "Read DG 7 (Academic Title)",
+        "Read DG 8 (Date of Birth)",
+        "Read DG 9 (Place of Birth)",
+        "Read DG 10 (Nationality)",
+        "Read DG 11 (Sex)",
+        "Read DG 12 (OptionalDataR)",
+        "Read DG 13",
+        "Read DG 14",
+        "Read DG 15",
+        "Read DG 16",
+        "Read DG 17 (Normal Place of Residence)",
+        "Read DG 18 (Community ID)",
+        "Read DG 19 (Residence Permit I)",
+        "Read DG 20 (Residence Permit II)",
+        "Read DG 21 (OptionalDataRW)",
+        "RFU",
+        "RFU",
+        "RFU",
+        "RFU",
+        "Write DG 21 (OptionalDataRW)",
+        "Write DG 20 (Residence Permit I)",
+        "Write DG 19 (Residence Permit II)",
+        "Write DG 18 (Community ID)",
+        "Write DG 17 (Normal Place of Residence)"
+};
+
+/** Human readable names of the individual bits of the CHAT of an
+    inspection system */
+static const char *is_chat_strings[] = {
+        "Read fingerprint",
+        "Read iris",
+        "RFU",
+        "RFU",
+        "RFU",
+        "Read eID application"
+};
+
+/** Human readable names of the individual bits of the CHAT of a
+    signature terminal */
+static const char *st_chat_strings[] = {
+        "Generate electronic signature",
+        "Generate qualified electronic signature",
+        "RFU",
+        "RFU",
+        "RFU",
+        "RFU"
+};
+
+/** Human readable names of the individual members of a certificate description */
+static const char *cert_desc_field_strings[] = {
+    "issuerName",
+    "issuerURL",
+    "subjectName",
+    "subjectURL",
+    "redirectURL",
+    "termsOfUsage",
+};
+
+/**
+ * @defgroup CVC_CERT_ASN1     ASN1 structures for Card Verifiable Certificates
+ * @{ ************************************************************************/
+
+ASN1_SEQUENCE(CVC_CHAT_SEQ) = {
+        ASN1_SIMPLE(CVC_CHAT_SEQ, terminal_type, ASN1_OBJECT),
+        /* tag: 0x53*/
+        ASN1_APP_IMP(CVC_CHAT_SEQ, relative_authorization, ASN1_OCTET_STRING, 0x13) /* discretionary data */
+} ASN1_SEQUENCE_END(CVC_CHAT_SEQ)
+/* Change the tag of the CHAT to 0x7f4c */
+ASN1_ITEM_TEMPLATE(CVC_CHAT) =
+        ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, 0x4c, CVC_CHAT, CVC_CHAT_SEQ)
+ASN1_ITEM_TEMPLATE_END(CVC_CHAT)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CHAT)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CHAT)
+
+/* Actually we would need two types of public keys: one for ECDSA and one for
+ * RSA. Since I did not find a suitable solution using the OpenSSL ASN.1 macros,
+ * I used an ugly hack. The same type is used for both kind of keys. The optional
+ * members modulus and a can are used to hold the modulus and the public exponent
+ * in the RSA case. In this case these members actually are not optional, so we
+ * need additional sanity checks in the corresponding d2i functions */
+ASN1_SEQUENCE(CVC_PUBKEY) = {
+    ASN1_SIMPLE(CVC_PUBKEY, oid, ASN1_OBJECT),
+    /* tag: 0x81 */
+    ASN1_IMP_OPT(CVC_PUBKEY, modulus, ASN1_OCTET_STRING, 0x1),
+    /* tag: 0x82 */
+    ASN1_IMP_OPT(CVC_PUBKEY, a, ASN1_OCTET_STRING, 0x2),
+    /* tag: 0x83 */
+    ASN1_IMP_OPT(CVC_PUBKEY, b, ASN1_OCTET_STRING, 0x3),
+    /* tag: 0x84 */
+    ASN1_IMP_OPT(CVC_PUBKEY, base, ASN1_OCTET_STRING, 0x4),
+    /* tag: 0x85 */
+    ASN1_IMP_OPT(CVC_PUBKEY, base_order, ASN1_OCTET_STRING, 0x5),
+    /* tag: 0x86 */
+    ASN1_IMP_OPT(CVC_PUBKEY, public_point, ASN1_OCTET_STRING, 0x6),
+    /* tag: 0x87 */
+    ASN1_IMP_OPT(CVC_PUBKEY, cofactor, ASN1_OCTET_STRING, 0x7)
+} ASN1_SEQUENCE_END(CVC_PUBKEY)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_PUBKEY)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_PUBKEY)
+
+ASN1_SEQUENCE(CVC_DISCRETIONARY_DATA_TEMPLATE) = {
+    ASN1_SIMPLE(CVC_DISCRETIONARY_DATA_TEMPLATE, type, ASN1_OBJECT),
+    /* tag: 0x80 */
+    ASN1_IMP_OPT(CVC_DISCRETIONARY_DATA_TEMPLATE, discretionary_data1, ASN1_OCTET_STRING, 0),
+    /* tag: 0x81 */
+    ASN1_IMP_OPT(CVC_DISCRETIONARY_DATA_TEMPLATE, discretionary_data2, ASN1_OCTET_STRING, 1),
+    /* tag: 0x53*/
+    ASN1_APP_IMP_OPT(CVC_DISCRETIONARY_DATA_TEMPLATE, discretionary_data3, ASN1_OCTET_STRING, 19),
+} ASN1_SEQUENCE_END(CVC_DISCRETIONARY_DATA_TEMPLATE)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_DISCRETIONARY_DATA_TEMPLATE)
+
+/* XXX: Probably rather ANS1_ADB (see TR-03110 C.3)? */
+ASN1_SEQUENCE(CVC_DISCRETIONARY_DATA_TEMPLATES) = {
+    ASN1_APP_IMP_OPT(CVC_DISCRETIONARY_DATA_TEMPLATES, template1, CVC_DISCRETIONARY_DATA_TEMPLATE, 0x13),
+    ASN1_APP_IMP_OPT(CVC_DISCRETIONARY_DATA_TEMPLATES, template2, CVC_DISCRETIONARY_DATA_TEMPLATE, 0x13),
+} ASN1_SEQUENCE_END(CVC_DISCRETIONARY_DATA_TEMPLATES)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_DISCRETIONARY_DATA_TEMPLATES)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_DISCRETIONARY_DATA_TEMPLATES)
+
+ASN1_SEQUENCE(CVC_CERT_BODY_SEQ) = {
+        /* tag: 0x5f29 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, certificate_profile_identifier, ASN1_INTEGER, 0x29),
+        /* tag: 0x42 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, certificate_authority_reference, ASN1_OCTET_STRING, 0x2),
+        /* public key: tag:0x7f49 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, public_key, CVC_PUBKEY, 0x49),
+        /* tag: 0x5f20 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, certificate_holder_reference, ASN1_OCTET_STRING, 0x20),
+        /* tag: 0x7f4c */
+        ASN1_SIMPLE(CVC_CERT_BODY_SEQ, chat, CVC_CHAT),
+        /* tag: 0x5f25 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, certificate_effective_date, ASN1_OCTET_STRING, 0x25),
+        /* tag: 0x5f24 */
+        ASN1_APP_IMP(CVC_CERT_BODY_SEQ, certificate_expiration_date, ASN1_OCTET_STRING, 0x24),
+        /* tag: 0x65 */
+        ASN1_APP_IMP_OPT(CVC_CERT_BODY_SEQ, certificate_extensions, CVC_DISCRETIONARY_DATA_TEMPLATES, 0x5)
+} ASN1_SEQUENCE_END(CVC_CERT_BODY_SEQ)
+/* Change the tag of the Certificate Body to 0x7f4e */
+ASN1_ITEM_TEMPLATE(CVC_CERT_BODY) =
+        ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, 0x4e, CVC_CERT_BODY, CVC_CERT_BODY_SEQ)
+ASN1_ITEM_TEMPLATE_END(CVC_CERT_BODY)
+DECLARE_ASN1_FUNCTIONS(CVC_CERT_BODY)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERT_BODY)
+
+ASN1_SEQUENCE(CVC_CERT_SEQ) = {
+        /* tag: 0x7F4E */
+        ASN1_SIMPLE(CVC_CERT_SEQ, body, CVC_CERT_BODY),
+        /* tag: 0x5F37 */
+        ASN1_APP_IMP(CVC_CERT_SEQ, signature, ASN1_OCTET_STRING, 0x37),
+} ASN1_SEQUENCE_END(CVC_CERT_SEQ)
+
+/* Change the tag of the CV Cert to 0x7f21 */
+ASN1_ITEM_TEMPLATE(CVC_CERT) =
+        ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION, 0x21, CVC_CERT, CVC_CERT_SEQ)
+ASN1_ITEM_TEMPLATE_END(CVC_CERT)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERT)
+/*IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CERT)*/
+/*IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CHAT)*/
+
+ASN1_ADB_TEMPLATE(cert_def) = ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.other, ASN1_ANY, 0x05);
+
+ASN1_ADB(CVC_CERTIFICATE_DESCRIPTION) = {
+        ADB_ENTRY(NID_id_plainFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.plainTerms, ASN1_UTF8STRING, 0x05)),
+        ADB_ENTRY(NID_id_htmlFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.htmlTerms, ASN1_IA5STRING, 0x05)),
+        ADB_ENTRY(NID_id_pdfFormat, ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, termsOfUsage.pdfTerms, ASN1_OCTET_STRING, 0x05))
+} ASN1_ADB_END(CVC_CERTIFICATE_DESCRIPTION, 0, descriptionType, 0, &cert_def_tt, NULL);
+
+ASN1_SEQUENCE(CVC_CERTIFICATE_DESCRIPTION) = {
+        ASN1_SIMPLE(CVC_CERTIFICATE_DESCRIPTION, descriptionType, ASN1_OBJECT),
+        ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, issuerName, ASN1_UTF8STRING, 0x01),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, issuerURL, ASN1_PRINTABLESTRING, 0x02),
+        ASN1_IMP(CVC_CERTIFICATE_DESCRIPTION, subjectName, ASN1_UTF8STRING, 0x03),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, subjectURL, ASN1_PRINTABLESTRING, 0x04),
+        ASN1_ADB_OBJECT(CVC_CERTIFICATE_DESCRIPTION),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, redirectURL, ASN1_PRINTABLESTRING, 0x06),
+        ASN1_IMP_OPT(CVC_CERTIFICATE_DESCRIPTION, commCertificates, ASN1_OCTET_STRING, 0x07),
+} ASN1_SEQUENCE_END(CVC_CERTIFICATE_DESCRIPTION)
+IMPLEMENT_ASN1_FUNCTIONS(CVC_CERTIFICATE_DESCRIPTION)
+IMPLEMENT_ASN1_PRINT_FUNCTION(CVC_CERTIFICATE_DESCRIPTION)
+/** @} ***********************************************************************/
+
+/** Convert the CAR or CHR to a human readable string */
+static BUF_MEM *
+cvc_get_reference_string(ASN1_OCTET_STRING *ref);
+/** Convert the profile identifier to an integer*/
+static short
+cvc_get_profile_identifier(ASN1_INTEGER *id);
+/**
+ *  @brief Convert the effective date and expiration date,
+ *         of a certificate to a string
+ *
+ *  @param[in] date Octet string that holds the date
+ *
+ *  @return Null terminated string representation of the date
+ */
+static char *
+cvc_get_date_string(ASN1_OCTET_STRING *date);
+/**
+ * @brief Extract the rsa public key from a CV certificate
+ * @param cert CV certificate
+ * @return the rsa public key or NULL in case of an error
+ */
+static RSA *
+CVC_get_rsa_pubkey(const CVC_CERT *cert);
+/**
+ * @brief Extract the ECC public key from a CV certificate
+ * @param cert CV certificate
+ * @param domainParameters used in case of a DV or terminal certificate
+ * @return the ECC public key or NULL in case of an error
+ */
+static EC_KEY *
+CVC_get_ec_pubkey(EVP_PKEY *domainParameters, const CVC_CERT *cert, BN_CTX *bn_ctx);
+
+CVC_CERT *
+CVC_d2i_CVC_CERT(CVC_CERT **cert, const unsigned char **in, long len)
+{
+    CVC_CERT *ret = NULL;
+
+    ret = d2i_CVC_CERT(cert, in, len);
+    if (!ret)
+        goto err;
+
+    /* Check whether or not all the necessary parameters for the given type of
+     * public key are provided. This is necessary because of the ugly hack used
+     * to support both ECDSA and RSA keys (see comment at the definition of
+     * CVC_PUBKEY for details) */
+    switch(OBJ_obj2nid(ret->body->public_key->oid)) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            if (!ret->body->public_key->public_point)
+                goto err;
+            break;
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+        case NID_id_TA_RSA_PSS_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            if (!ret->body->public_key->modulus || !ret->body->public_key->a)
+                goto err;
+            break;
+        default:
+            goto err;
+    }
+
+    return ret;
+
+err:
+    if(ret) {
+        CVC_CERT_free(ret);
+        ret = NULL;
+    }
+
+    return ret;
+}
+
+int
+CVC_verify_signature(const CVC_CERT *cert, EVP_PKEY *key)
+{
+    int r = -1;
+    unsigned char *body = NULL;
+    int body_len;
+    BUF_MEM *signature = NULL, *body_buf = NULL;
+    EVP_PKEY_CTX *tmp_key_ctx = NULL;
+
+    if (!cert || !cert->signature || !key)
+        goto err;
+
+
+    body_len = i2d_CVC_CERT_BODY(cert->body, &body);
+    if (body_len <= 0)
+        goto err;
+    body_buf = BUF_MEM_create_init(body, (size_t) body_len);
+
+    /* Get signature from certificate and convert it to a X9.62 representation */
+    signature = BUF_MEM_create_init(cert->signature->data, cert->signature->length);
+
+    r = EAC_verify(OBJ_obj2nid(cert->body->public_key->oid),
+            key, signature, body_buf);
+
+err:
+    if (tmp_key_ctx)
+        EVP_PKEY_CTX_free(tmp_key_ctx);
+    if (body)
+        OPENSSL_free(body);
+    if (body_buf)
+        BUF_MEM_free(body_buf);
+    if (signature)
+        BUF_MEM_free(signature);
+
+    return r;
+}
+
+int
+CVC_get_role(CVC_CHAT *chat) {
+
+    if (!chat || !chat->relative_authorization
+            || !chat->relative_authorization->data)
+        return -1;
+
+    /* The two most significant bits encode the terminal type */
+    return (chat->relative_authorization->data[chat->relative_authorization->length - 1] >> 6) & 3;
+}
+
+EVP_PKEY *
+CVC_get_pubkey(EVP_PKEY *domainParameters, const CVC_CERT *cert, BN_CTX *bn_ctx) {
+    EVP_PKEY *key = NULL;
+    EC_KEY *ec = NULL;
+    RSA *rsa = NULL;
+    int oid;
+
+    if (!cert || !cert->body || !cert->body->public_key)
+        goto err;
+
+    key = EVP_PKEY_new();
+    if (!key)
+        goto err;
+
+    oid = OBJ_obj2nid(cert->body->public_key->oid);
+    switch(oid) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            ec = CVC_get_ec_pubkey(domainParameters, cert, bn_ctx);
+            if (!ec)
+                goto err;
+            EVP_PKEY_set1_EC_KEY(key, ec);
+            break;
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+        case NID_id_TA_RSA_PSS_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            rsa = CVC_get_rsa_pubkey(cert);
+            if (!rsa)
+                goto err;
+            EVP_PKEY_set1_RSA(key, rsa);
+            break;
+        default:
+            EACerr(EAC_F_CVC_GET_PUBKEY, EAC_R_UNKNOWN_PROTOCOL);
+            goto err;
+    }
+
+    if (ec)
+        EC_KEY_free(ec);
+    if (rsa)
+        RSA_free(rsa);
+    return key;
+
+err:
+    if (ec)
+        EC_KEY_free(ec);
+    if (rsa)
+        RSA_free(rsa);
+    if (key)
+        EVP_PKEY_free(key);
+    return NULL;
+}
+
+RSA *CVC_get_rsa_pubkey(const CVC_CERT *cert) {
+    RSA *key = NULL;
+
+    if (!cert || !cert->body || !cert->body->public_key)
+        goto err;
+
+    /* The RSA parameters are contained in the EC parameters (see the comment in
+     * line 128 */
+    if (!cert->body->public_key->modulus || !cert->body->public_key->a) {
+        EACerr(EAC_F_CVC_GET_RSA_PUBKEY, EAC_R_INVALID_KEY_FORMAT);
+        goto err;
+    }
+
+    key = RSA_new();
+    if (!key)
+        goto err;
+
+    /* There are no setter functions in rsa.h so we need to modify the
+     * struct directly */
+    key->n = BN_bin2bn(cert->body->public_key->modulus->data,
+            cert->body->public_key->modulus->length, key->n);
+    key->e = BN_bin2bn(cert->body->public_key->a->data,
+            cert->body->public_key->a->length, key->e);
+
+    if (!key->n || !key->e)
+        goto err;
+
+    return key;
+
+err:
+    if (key)
+        RSA_free(key);
+    return NULL;
+}
+
+EC_KEY *
+CVC_get_ec_pubkey(EVP_PKEY *domainParameters, const CVC_CERT *cert, BN_CTX *bn_ctx)
+{
+    EC_KEY *key = NULL;
+    const EC_GROUP *group;
+    EC_POINT *point = NULL;
+
+    if (!cert || !cert->body || !cert->body->public_key || !cert->body->chat)
+        goto err;
+
+    /* If cert is a CVCA certificate it MUST contain all domain parameters (and
+     * we can ignore the domainParameters parameter). */
+    if (CVC_get_role(cert->body->chat) == CVC_CVCA) {
+        if (!cert->body->public_key->public_point
+                || !cert->body->public_key->modulus
+                || !cert->body->public_key->a
+                || !cert->body->public_key->b
+                || !cert->body->public_key->base
+                || !cert->body->public_key->base_order
+                || !cert->body->public_key->cofactor) {
+            EACerr(EAC_F_CVC_GET_EC_PUBKEY, EAC_R_INVALID_KEY_FORMAT);
+            goto err;
+        }
+
+        key = EC_KEY_new();
+        if (!key)
+            goto err;
+
+        if (!EAC_ec_key_from_asn1(&key, cert->body->public_key->modulus,
+                    cert->body->public_key->a,
+                    cert->body->public_key->b,
+                    cert->body->public_key->base,
+                    cert->body->public_key->base_order,
+                    cert->body->public_key->public_point,
+                    cert->body->public_key->cofactor,
+                    bn_ctx))
+                goto err;
+    } else {
+        /* If cert is not a CVCA certificate it MUST NOT contain any domain
+         * parameters. We take the domain parameters from the domainParameters
+         * parameter and the public point from the certificate. */
+        if (!cert->body->public_key->public_point
+                || cert->body->public_key->modulus
+                || cert->body->public_key->a
+                || cert->body->public_key->b
+                || cert->body->public_key->base
+                || cert->body->public_key->base_order
+                || cert->body->public_key->cofactor) {
+            EACerr(EAC_F_CVC_GET_EC_PUBKEY, EAC_R_INVALID_KEY_FORMAT);
+            goto err;
+        }
+
+        if (!domainParameters || (EVP_PKEY_type(domainParameters->type) != EVP_PKEY_EC)) {
+            EACerr(EAC_F_CVC_GET_EC_PUBKEY, EAC_R_INCORRECT_DOMAIN_PARAMETERS);
+            goto err;
+        }
+
+        key = EVP_PKEY_get1_EC_KEY(domainParameters);
+        if (!key)
+            goto err;
+        group = EC_KEY_get0_group(key);
+        point = EC_POINT_new(group);
+        if (!point
+                || !EC_POINT_oct2point(group, point,
+                    cert->body->public_key->public_point->data,
+                    cert->body->public_key->public_point->length,
+                    bn_ctx)
+                || !EC_KEY_set_public_key(key, point)
+                || !EC_KEY_check_key(key))
+            goto err;
+    }
+
+    EC_POINT_free(point);
+    return key;
+
+err:
+    if (key)
+        EC_KEY_free(key);
+    if (point)
+        EC_POINT_free(point);
+    return NULL;
+}
+
+int
+cvc_print(BIO *bio, CVC_CERT *cv, int indent)
+{
+    int r = 0;
+    char *effective_date = NULL, *expiration_date = NULL;
+    BUF_MEM *car = NULL, *chr = NULL;
+
+    if (!bio || !cv || !cv->body || !cv->body->public_key)
+        goto err;
+
+    effective_date = cvc_get_date_string(cv->body->certificate_effective_date);
+    expiration_date = cvc_get_date_string(cv->body->certificate_expiration_date);
+    car = cvc_get_reference_string(cv->body->certificate_authority_reference);
+    chr = cvc_get_reference_string(cv->body->certificate_holder_reference);
+
+    if (!effective_date || !expiration_date || !car || !chr)
+        goto err;
+
+    if (!BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "Profile identifier: %d\n", cvc_get_profile_identifier(cv->body->certificate_profile_identifier))
+            || !BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "CAR: %s\n", car->data)
+            || !CVC_PUBKEY_print_ctx(bio, cv->body->public_key, indent, NULL)
+            || !BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "CHR: %s\n", chr->data)
+            || !BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "CHAT:\n")
+            || !cvc_chat_print(bio, cvc_get_chat(cv), indent+2)
+            || !BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "Effective Date: %s\n", effective_date)
+            || !BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "Expiration Date: %s\n", expiration_date)
+            || !CVC_DISCRETIONARY_DATA_TEMPLATES_print_ctx(bio, cv->body->certificate_extensions, indent, NULL))
+        goto err;
+
+    r = 1;
+
+err:
+    if (effective_date)
+        OPENSSL_free(effective_date);
+    if (expiration_date)
+        OPENSSL_free(expiration_date);
+    if (car)
+        BUF_MEM_free(car);
+    if (chr)
+        BUF_MEM_free(chr);
+
+    return r;
+}
+
+int
+cvc_chat_print_authorizations(BIO *bio, CVC_CHAT *chat, int indent)
+{
+	int ok = 0, nid = 0, rel_auth_len = 0, rel_auth_num_bytes = 0, i, j = 1;
+	const char **strings;
+
+	if (!bio || !chat || !chat->relative_authorization
+	            || !chat->relative_authorization->data)
+	        goto err;
+
+	/* Figure out what kind of CHAT we have */
+	nid = OBJ_obj2nid(chat->terminal_type);
+	switch(nid) {
+		case NID_id_AT:
+			strings = at_chat_strings;
+			rel_auth_len = EAC_AT_CHAT_BITS;
+			rel_auth_num_bytes = EAC_AT_CHAT_BYTES;
+			break;
+		case NID_id_IS:
+			strings = is_chat_strings;
+			rel_auth_len = EAC_IS_CHAT_BITS;
+			rel_auth_num_bytes = EAC_IS_CHAT_BYTES;
+			break;
+		case NID_id_ST:
+			strings = st_chat_strings;
+			rel_auth_len = EAC_ST_CHAT_BITS;
+			rel_auth_num_bytes = EAC_ST_CHAT_BYTES;
+			break;
+		default:
+			goto err;
+	}
+
+    /* Sanity check: Does the received CHAT have the correct length? */
+    if(chat->relative_authorization->length != rel_auth_num_bytes)
+        goto err;
+
+    /* Dump the relative authorization bit string in human readable form.
+     * Each set Bit means one authorization */
+    for (i = 0; i < rel_auth_len; i++) {
+        if (i % 8 == 0 && i != 0)
+            j++;
+        if (CHECK_BIT(chat->relative_authorization->data[rel_auth_num_bytes - j],
+                i % 8)) {
+            if (!BIO_indent(bio, indent, 80)
+                    || !BIO_printf(bio, "%s\n", strings[i]))
+                goto err;
+        }
+    }
+
+    ok = 1;
+
+err:
+	return ok;
+}
+
+int
+cvc_chat_print(BIO *bio, CVC_CHAT *chat, int indent)
+{
+
+    int ok = 0, nid = 0, role;
+
+    if (!bio || !chat || !chat->relative_authorization
+            || !chat->relative_authorization->data)
+        goto err;
+
+    /* Figure out what kind of CHAT we have */
+    nid = OBJ_obj2nid(chat->terminal_type);
+    switch(nid) {
+        case NID_id_AT:
+            if (!BIO_indent(bio, indent, 80)
+                    || !BIO_printf(bio, "Authentication terminal\n"))
+                goto err;
+            break;
+        case NID_id_IS:
+            if (!BIO_indent(bio, indent, 80)
+                    || !BIO_printf(bio, "Inspection system\n"))
+                goto err;
+            break;
+        case NID_id_ST:
+            if (!BIO_indent(bio, indent, 80)
+                    || !BIO_printf(bio, "Signature terminal\n"))
+                goto err;
+            break;
+        default:
+            BIO_indent(bio, indent, 80);
+            BIO_printf(bio, "Invalid terminal type\n");
+            goto err;
+    }
+
+    cvc_chat_print_authorizations(bio, chat, indent+2);
+
+    /* The most significant two bits contain the role of the terminal */
+    role = CVC_get_role(chat);
+    switch(role) {
+        case CVC_CVCA:
+            if (!BIO_indent(bio, indent+2, 80)
+                    || !BIO_printf(bio, "CVCA certificate\n"))
+                goto err;
+            break;
+        case CVC_DV:
+        case CVC_DocVer:
+            if (!BIO_indent(bio, indent+2, 80)
+                    || !BIO_printf(bio, "DV certificate\n"))
+                goto err;
+            break;
+        case CVC_Terminal:
+            if (!BIO_indent(bio, indent+2, 80)
+                    || !BIO_printf(bio, "Terminal certificate\n"))
+                goto err;
+            break;
+        default:
+            goto err;
+    }
+
+    ok = 1;
+
+err:
+    return ok;
+}
+
+short
+cvc_get_profile_identifier(ASN1_INTEGER *id)
+{
+    long l;
+    if (!id || !id->data)
+        return -1;
+    l = ASN1_INTEGER_get(id);
+    return (l == 0) ? 0 : -1; /* The only specified version number is 0 right now */
+}
+
+BUF_MEM *
+cvc_get_reference_string(ASN1_OCTET_STRING *ref)
+{
+    /* Used to check CAR and CHR */
+    /* Max length is 16 byte: 2 Byte country code (ASCII), max. 9 Byte Holder
+     *      Mnemonic, 5 Byte Sequence Number (ASCII A-Z, 0-9) */
+
+    BUF_MEM *ret = NULL;
+
+    if (!ref || !ref->data || ref->length > 16)
+        return NULL;
+
+    ret = BUF_MEM_create_init(ref->data, ref->length);
+    if (!ret)
+        return NULL;
+
+    if (!is_char_str(ret)) {
+        goto err;
+    }
+
+    /* Null-terminate string */
+    if (!BUF_MEM_grow(ret, ret->length + 1))
+        goto err;
+    ret->data[ret->length] = 0;
+
+    return ret;
+
+err:
+    if (ret)
+        BUF_MEM_free(ret);
+    return NULL;
+}
+
+char *
+cvc_get_date_string(ASN1_OCTET_STRING *date)
+{
+    char *ret;
+
+    if (!date || !date->data || date->length != 6
+            || !is_bcd(date->data, date->length))
+        return NULL;
+
+    ret = OPENSSL_malloc(11);
+    if (!ret)
+        return NULL;
+
+    /* Convert to ASCII date */
+    ret[0] = '2';
+    ret[1] = '0';
+    ret[2] = date->data[0] + 0x30;
+    ret[3] = date->data[1] + 0x30;
+    ret[4] = '-';
+    ret[5] = date->data[2] + 0x30;
+    ret[6] = date->data[3] + 0x30;
+    ret[7] = '-';
+    ret[8] = date->data[4] + 0x30;
+    ret[9] = date->data[5] + 0x30;
+    ret[10] = '\0';
+
+    return ret;
+}
+
+int
+certificate_description_print(BIO *bio, CVC_CERTIFICATE_DESCRIPTION *desc,
+        int indent)
+{
+    int ret, nid;
+
+    if (desc == NULL)
+        return 0;
+
+    if (!BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "%s\t%s\n", cert_desc_field_strings[0],
+                desc->issuerName->data))
+        return 0;
+    if (desc->issuerURL) {
+        if (!BIO_indent(bio, indent, 80)
+                || !BIO_printf(bio, "%s\t%s\n", cert_desc_field_strings[1],
+                    desc->issuerURL->data))
+            return 0;
+    }
+    if (!BIO_indent(bio, indent, 80)
+            || !BIO_printf(bio, "%s\t%s\n", cert_desc_field_strings[2],
+                desc->subjectName->data))
+        return 0;
+    if (desc->subjectURL) {
+        if (!BIO_indent(bio, indent, 80)
+                || !BIO_printf(bio, "%s\t%s\n", cert_desc_field_strings[3],
+                    desc->subjectURL->data))
+            return 0;
+    }
+    if (desc->redirectURL) {
+        if (!BIO_indent(bio, indent, 80)
+                || !BIO_printf(bio, "%s\t%s\n", cert_desc_field_strings[4],
+                    desc->redirectURL->data))
+            return 0;
+    }
+
+    nid = OBJ_obj2nid(desc->descriptionType);
+    switch (nid) {
+        case NID_id_plainFormat:
+            if (!BIO_indent(bio, indent, 80)
+                    || !BIO_printf(bio, "%s\n%s\n", cert_desc_field_strings[5],
+                        desc->termsOfUsage.plainTerms->data))
+                return 0;
+            ret = 1;
+            break;
+        case NID_id_htmlFormat:
+            ret = 2;
+            break;
+        case NID_id_pdfFormat:
+            ret = 3;
+            break;
+        default:
+            /* Unknown format for terms of usage */
+            ret = 4;
+            break;
+    }
+
+    return ret;
+}
+
+CVC_CHAT*
+cvc_get_chat(CVC_CERT *cvc)
+{
+
+    if (!cvc || !cvc->body)
+        return NULL;
+
+    return cvc->body->chat;
+}
+
+int
+CVC_check_description(CVC_CERT *cv, const unsigned char *cert_desc_in,
+        const unsigned int cert_desc_in_len)
+{
+
+    BUF_MEM *desc_hash = NULL;
+    const EVP_MD *md;
+    ASN1_OCTET_STRING *hash_check = NULL;
+    BUF_MEM *cert_desc = BUF_MEM_create_init(cert_desc_in, cert_desc_in_len);
+
+    unsigned int ret = -1;
+
+    if (!cv || !cv->body || !cv->body->public_key)
+        goto err;
+
+    /* Choose the correct hash function */
+    switch(OBJ_obj2nid(cv->body->public_key->oid)) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_1:
+            md = EVP_sha1();
+            break;
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_256:
+            md = EVP_sha256();
+            break;
+        case NID_id_TA_ECDSA_SHA_512:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            md = EVP_sha512();
+            break;
+        case NID_id_TA_ECDSA_SHA_224:
+            md = EVP_sha224();
+            break;
+        case NID_id_TA_ECDSA_SHA_384:
+            md = EVP_sha384();
+            break;
+        default:
+            goto err;
+    }
+
+    if (cv->body->certificate_extensions) {
+        if (cv->body->certificate_extensions->template1
+                && OBJ_obj2nid(cv->body->certificate_extensions->template1->type) ==
+                        NID_id_description)
+            hash_check = cv->body->certificate_extensions->template1->discretionary_data1;
+        else if (cv->body->certificate_extensions->template2
+                && OBJ_obj2nid(cv->body->certificate_extensions->template2->type) ==
+                        NID_id_description)
+            hash_check = cv->body->certificate_extensions->template2->discretionary_data1;
+    }
+
+    if (hash_check) {
+
+        /* Check whether or not the hash in the certificate has the correct size */
+        if (hash_check->length != EVP_MD_size(md)) {
+            ret = 0;
+            goto err;
+        }
+
+        /* Hash the certificate description */
+        desc_hash = hash(md, NULL, NULL, cert_desc);
+
+        /* Compare it with the hash in the certificate */
+        if (!memcmp(desc_hash->data, hash_check->data, desc_hash->length))
+            ret = 1;
+    } else
+        ret = 0;
+
+err:
+    if (desc_hash)
+        BUF_MEM_free(desc_hash);
+    if (cert_desc)
+        BUF_MEM_free(cert_desc);
+
+    return ret;
+}
Index: openssl/crypto/eac/cv_cert.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/cv_cert.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,422 @@
+/**
+ * @file
+ * @brief Interface for Card Verifiable Certificates
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef CVC_CERT_H_
+#define CVC_CERT_H_
+
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/bio.h>
+
+/** There are three types of certificates specified by their terminal type:
+ * CVCA certificates, DV certificates and terminal certificates */
+enum cvc_terminal_type {
+    /** @brief Regular terminal */
+    CVC_Terminal = 0,
+    /** @brief Document verifier */
+    CVC_DV,
+    /** @brief Undefined */
+    CVC_DocVer, //FIXME: Ugly
+    /** @brief Country Validating Certificate Authority */
+    CVC_CVCA
+};
+
+/** @brief Certificate Holder Authentication Template
+ *
+ * @see TR-03110 C.1.5. */
+typedef struct cvc_chat_seq_st {
+    /** @brief Role of terminal to which this certificate belongs (Inspection
+     * System, Authentication Terminal or Signature Terminal) */
+    ASN1_OBJECT *terminal_type;
+    /** @brief Access rights of the terminal to which this certificate belongs. */
+    ASN1_OCTET_STRING *relative_authorization;
+} CVC_CHAT_SEQ;
+/** @brief Short name for CVC_CHAT_SEQ */
+typedef CVC_CHAT_SEQ CVC_CHAT;
+DECLARE_ASN1_FUNCTIONS(CVC_CHAT)
+
+/**
+ * @brief Public key data object which may contain domain parameters.
+ *
+ * This data structure is used for defined public keys (RSA public key, DH
+ * public key, EC public key).
+ *
+ * @see TR-03110 D.3.
+ */
+typedef struct cvc_pubkey_st {
+    /** @brief Object Identifier which specifies the exact protocol to be used during TA */
+    ASN1_OBJECT *oid;
+    /** @brief Composite modulus (RSA)/prime modulus (DH, EC) */
+    ASN1_OCTET_STRING *modulus;
+    /** @brief Public exponent (RSA)/order of the Subgroup (DH)/first coefficient (EC) */
+    ASN1_OCTET_STRING *a;
+    /** @brief Order of the subgroup (DH)/second coefficient (EC) */
+    ASN1_OCTET_STRING *b;
+    /** @brief Generator (DH)/base point (EC) */
+    ASN1_OCTET_STRING *base;
+    /** @brief Public value (DH)/order of the base point (EC) */
+    ASN1_OCTET_STRING *base_order;
+    /** @brief Public point (EC) */
+    ASN1_OCTET_STRING *public_point;
+    /** @brief Cofactor (EC) */
+    ASN1_OCTET_STRING *cofactor;
+} CVC_PUBKEY;
+
+/**
+ * @brief Discretionary data template, used to encode certificate extensions.
+ *
+ * Consists of an OID and up to two hash values. This data structure is used
+ * for both possible certificate extensions.
+ */
+typedef struct cvc_discretionary_data_template_st {
+    /** OID which specifies the type of the extension **/
+    ASN1_OBJECT *type;
+    ASN1_OCTET_STRING *discretionary_data1;
+    ASN1_OCTET_STRING *discretionary_data2;
+    ASN1_OCTET_STRING *discretionary_data3;
+} CVC_DISCRETIONARY_DATA_TEMPLATE;
+DECLARE_ASN1_FUNCTIONS(CVC_DISCRETIONARY_DATA_TEMPLATE)
+
+/* XXX: This should actually not be a SEQUENCE */
+/** @brief Certificate Extensions
+ * @see TR-03110 C.3. */
+typedef struct cvc_discretionary_data_template_seq_st {
+    /** @brief Contains a certificate extension
+     *
+     *  @see TR-03110 C.3. */
+    CVC_DISCRETIONARY_DATA_TEMPLATE *template1;
+    /** @brief Contains a certificate extension
+     *
+     * @see TR-03110 C.3. */
+    CVC_DISCRETIONARY_DATA_TEMPLATE *template2;
+} CVC_DISCRETIONARY_DATA_TEMPLATES;
+DECLARE_ASN1_FUNCTIONS(CVC_DISCRETIONARY_DATA_TEMPLATES)
+
+/** @brief The body of the CV certificate (without signature)
+ *
+ * @see TR-03110 C.1. */
+typedef struct cvc_cert_body_seq_st {
+    /** @brief Certificate Profile of this certificate (must be 0).
+     *
+     * @see TR-03110 C.1.1. */
+    ASN1_INTEGER *certificate_profile_identifier;
+    /** @brief Reference to certificate authority that issued this certificate (in Latin1)
+     *
+     * @see TR-03110 C.1.2. */
+    ASN1_UTF8STRING *certificate_authority_reference;
+    /** @brief Public key associated with this certificate
+     *
+     * @see TR-03110 C.1.3. */
+    CVC_PUBKEY *public_key;
+    /** @brief Reference to the holder of this certificate (in Latin1)
+     *
+     * @see TR-03110 C.1.4. */
+    ASN1_UTF8STRING *certificate_holder_reference;
+    /** @brief Certificate Holder Authorisation Template */
+    CVC_CHAT *chat;
+    /** @brief Date the certificate was issued (YYMMDD, BCD encoded)
+     *
+     * @see TR-03110 C.1.5. */
+    ASN1_OCTET_STRING *certificate_effective_date;
+    /** @brief Date until which the certicate is valid (YYMMDD, BCD encoded)
+     *
+     * @see TR-03110 C.1.6. */
+    ASN1_OCTET_STRING *certificate_expiration_date;
+    /** @brief Optional extensions
+     *
+     * @see TR-03110 C.1.7. */
+    CVC_DISCRETIONARY_DATA_TEMPLATES *certificate_extensions;
+} CVC_CERT_BODY_SEQ;
+typedef CVC_CERT_BODY_SEQ CVC_CERT_BODY;
+
+/** @brief The actual certifcate, consisting of the body and a signature
+ *
+ *  @see TR-03110 C.1. */
+typedef struct cvc_cert_seq_st {
+    /** @brief Body of the certificate */
+    CVC_CERT_BODY *body;
+    /** @brief Signature calculated over the hash of the certificate body */
+    ASN1_OCTET_STRING *signature;
+} CVC_CERT_SEQ;
+/** @brief Short name for CVC_CERT_SEQ */
+typedef CVC_CERT_SEQ CVC_CERT;
+/*void CVC_CERT_print_ctx(BIO *bio, CVC_CERT *cert, int indent, const ASN1_PCTX *pctx);*/
+//DECLARE_ASN1_PRINT_FUNCTION(CVC_CERT)
+//DECLARE_ASN1_PRINT_FUNCTION(CVC_CHAT)
+
+/**
+ * @brief This structure holds further information about a card verifiable
+ * certificate in human readable form.
+ *
+ * The certificate description is used by a local terminal as part of the user
+ * interaction for online authentication of a remote terminal and may be
+ * ignored by the MRTD chip.
+ *
+ *  @see TR-03110 C.3.1.
+ */
+ typedef struct cvc_certificate_description_st {
+    /** @brief Format of the description (Plain Text, PDF or HTML) */
+    ASN1_OBJECT *descriptionType;
+    /** @brief Human readable name of the issuer of this certificate */
+    ASN1_UTF8STRING *issuerName;
+    /** @brief Optional URL that points to informations about the issuer of this
+     *  certificate */
+    ASN1_PRINTABLESTRING *issuerURL;
+    /** @brief Human readable name of the holder of this certificate */
+    ASN1_UTF8STRING *subjectName;
+    /** @brief Optional URL that points to informations about the holder of this
+     *  certificate */
+    ASN1_PRINTABLESTRING *subjectURL;
+    union {
+        /** @brief Plain text Terms of Usage */
+        ASN1_UTF8STRING *plainTerms;
+        /** @brief HTML formatted Terms of Usage */
+        ASN1_IA5STRING *htmlTerms;
+        /** @brief PDF formatted Terms of Usage */
+        ASN1_OCTET_STRING *pdfTerms;
+        /** @brief Otherwise formatted Terms of Usage (not specified) */
+        ASN1_TYPE *other;
+    } termsOfUsage; /**
+     *  @brief termsOfUsage Terms of Usage of the Service holding the certificate. May be
+     *  formatted as either plain text, HTML or PDF
+     */
+
+    /** Not used */
+    ASN1_PRINTABLESTRING *redirectURL;
+    /** Contains hash values of admissible X.509 certificates of the remote
+     *  terminal (optional)
+     *  Note that this is an ugly hack to not bother with STACK_OF structures */
+    ASN1_OCTET_STRING *commCertificates;
+} CVC_CERTIFICATE_DESCRIPTION;
+DECLARE_ASN1_FUNCTIONS(CVC_CERTIFICATE_DESCRIPTION)
+DECLARE_ASN1_PRINT_FUNCTION(CVC_CERTIFICATE_DESCRIPTION)
+
+/**
+ * @addtogroup management
+ * @{ ************************************************************************/
+
+/**
+ * @brief Convert ASN1 formatted CV certificate to the internal structure
+ *
+ * @param[in,out] cert (optional) Where to save the CV certificate
+ * @param[in] in ASN1 formatted CV certificate
+ * @param[in] len Length of \a in
+ *
+ * @return CV certificate or NULL in case of an error
+ * */
+CVC_CERT *CVC_d2i_CVC_CERT(CVC_CERT **cert, const unsigned char **in, long len);
+
+/**
+ * @brief Convert a CV certificate description to its ASN1 representation
+ *
+ * @param[in] a CV certificate description
+ * @param[out] out Where to write the ASN1 representation of \a a
+ *
+ * @return Number of bytes successfully encoded or a negative value if an
+ * error occured.
+ */
+int i2d_CVC_CERT(CVC_CERT *a, unsigned char **out);
+
+/**
+ * @brief Duplicate a CV certificate
+ *
+ * @param[in] x CV certificate to duplicate
+ *
+ * @return Duplicated CV certificate or NULL in case of an error
+ */
+#define CVC_CERT_dup(x) ASN1_dup_of(CVC_CERT, i2d_CVC_CERT, CVC_d2i_CVC_CERT, x)
+
+/**
+ * @brief Allocate memory for a CV certificate
+ * */
+CVC_CERT *CVC_CERT_new(void);
+/**
+ * @brief Free a CV certificate.
+ *
+ * @param[in] a CV certificate to free
+ * */
+void CVC_CERT_free(CVC_CERT *a);
+
+
+
+/** @} ***********************************************************************/
+
+/**
+ * @addtogroup printing
+ * @{ ************************************************************************/
+
+/**
+ * @brief Print CV certificate description in human readable form
+ *
+ * @param[in] bio Where to print the data
+ * @param[in] desc CV certificate desciption to print
+ * @param[in] indent Number of spaces to prepend
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int certificate_description_print(BIO *bio, CVC_CERTIFICATE_DESCRIPTION *desc,
+        int indent);
+
+/**
+ * @brief Print CHAT in human readable form
+ *
+ * @param[in] bio Where to print the data
+ * @param[in] chat CHAT to dump
+ * @param[in] indent Number of spaces to prepend
+ *
+ * @return 1 on success or 0 in case of an error
+ * */
+int
+cvc_chat_print(BIO *bio, CVC_CHAT *chat, int indent);
+
+/**
+ * @brief Print the relative authorization contained in a CHAT in human readable
+ * form
+ *
+ * @param[in] bio Where to print the data
+ * @param[in] chat CHAT which contains the relative authorization
+ * @param[in] indent Number of spaces to prepend
+ *
+ * @return 1 on success or 0 in case of an error
+ * */
+int
+cvc_chat_print_authorizations(BIO *bio, CVC_CHAT *chat, int indent);
+
+/**
+ * @brief Print CV certificate in human readable form
+ *
+ * @param[in] bio Where to print the data
+ * @param[in] cv CV certificate to print
+ * @param[in] indent Number of spaces to prepend
+ *
+ * @return 1 on success or 0 in case of an error
+ * */
+int
+cvc_print(BIO *bio, CVC_CERT *cv, int indent);
+
+/**
+ *  @brief Get the CHAT contained in a CV certifcate.
+ *
+ *  @param[in] cvc CV certificate
+
+ *  @return Pointer to the CHAT of \a cvc or NULL in case of an error
+ */
+CVC_CHAT *
+cvc_get_chat(CVC_CERT *cvc);
+
+/** @} ***********************************************************************/
+
+/**
+ * @brief Extract the public key from a CV certificate. Since EC domain parameters
+ * are only included in CVCA certificates, they must be passed as parameters
+ * for DV and terminal certificates
+ *
+ * @param domainParameters domain parameters for DV and terminal certificates (optional)
+ * @param cert the certificate containing the public key
+ * @param bn_ctx
+ *
+ * @return An EVP_PKEY container with the public key or NULL in case of an error
+ */
+EVP_PKEY *CVC_get_pubkey(EVP_PKEY *domainParameters, const CVC_CERT *cert, BN_CTX *bn_ctx);
+
+/**
+ * @brief Extract the terminal-type (terminal, DV, CVCA) from the CHAT
+ *
+ * @param chat CHAT
+ *
+ * @return -1 in case of an error or one of the following values:
+ * - \c CVC_CVCA (CVCA certificate)
+ * - \c CVC_DV (DVCA certificate)
+ * - \c CVC_DocVer (DVCA certificate)
+ * - \c CVC_Terminal (terminal certificate)
+ */
+int
+CVC_get_role(CVC_CHAT *chat);
+
+/**
+ * @brief Verify the signature of a CV certificate using the public key of the
+ * certificate issuer
+ *
+ * @param[in] cert CV certificate to verify
+ * @param[in] key Public key used for verification
+ *
+ * @return 1 if the signature was verified, 0 if not and a negative value in
+ * case of an error.
+ */
+int
+CVC_verify_signature(const CVC_CERT *cert, EVP_PKEY *key);
+
+/**
+ * @brief Check whether or not the certificate contains the correct hash of the
+ * CV certificate description
+ *
+ * @param[in] cv CV certificate
+ * @param[in] cert_desc_in ASN1 representation of the CV certificate description
+ * @param[in] cert_desc_in_len Length of \a cvc_desc_in
+ *
+ * @return 1 if the certificate contains the correct hash, 0 if not or -1 in
+ * case of an error.
+ */
+int
+CVC_check_description(CVC_CERT *cv, const unsigned char *cert_desc_in,
+        const unsigned int cert_desc_in_len);
+
+/** @cond */
+/* I stole these from ec_asn1.c */
+typedef struct x9_62_pentanomial_st {
+    long k1;
+    long k2;
+    long k3;
+    } PACE_X9_62_PENTANOMIAL;
+
+typedef struct pace_x9_62_characteristic_two_st {
+    long m;
+    ASN1_OBJECT  *type;
+    union   {
+        char *ptr;
+        /* NID_X9_62_onBasis */
+        ASN1_NULL    *onBasis;
+        /* NID_X9_62_tpBasis */
+        ASN1_INTEGER *tpBasis;
+        /* NID_X9_62_ppBasis */
+        PACE_X9_62_PENTANOMIAL *ppBasis;
+        /* anything else */
+        ASN1_TYPE *other;
+        } p;
+    } PACE_X9_62_CHARACTERISTIC_TWO;
+
+typedef struct pace_x9_62_fieldid_st {
+        ASN1_OBJECT *fieldType;
+    union   {
+        char *ptr;
+        /* NID_X9_62_prime_field */
+        ASN1_INTEGER *prime;
+        /* NID_X9_62_characteristic_two_field */
+        PACE_X9_62_CHARACTERISTIC_TWO *char_two;
+        /* anything else */
+        ASN1_TYPE *other;
+        } p;
+    } PACE_X9_62_FIELDID;
+
+typedef struct pace_x9_62_curve_st {
+        ASN1_OCTET_STRING *a;
+        ASN1_OCTET_STRING *b;
+        ASN1_BIT_STRING   *seed;
+        } PACE_X9_62_CURVE;
+
+typedef struct pace_ec_parameters_st {
+    ASN1_INTEGER           *version;
+    PACE_X9_62_FIELDID     *fieldID;
+    PACE_X9_62_CURVE       *curve;
+    ASN1_OCTET_STRING *base;
+    ASN1_INTEGER      *order;
+    ASN1_INTEGER      *cofactor;
+    } PACE_ECPARAMETERS;
+/** @endcond */
+
+#endif /* CVC_CERT_H_ */
Index: openssl/crypto/eac/cv_cert_test.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/cv_cert_test.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,320 @@
+#include <openssl/opensslconf.h>    /* for OPENSSL_NO_PACE */
+#include <stdio.h>
+#ifdef OPENSSL_NO_PACE
+int
+main(int argc, char *argv[])
+{
+    printf("No PACE support\n");
+    return (0);
+}
+#else
+#include <openssl/bio.h>
+#include <openssl/cv_cert.h>
+#include <openssl/err.h>
+#include <string.h>
+
+#define err(s) { printf(s "\n"); ERR_print_errors_fp(stdout); goto err; }
+#define verb(s) { if (verbose) printf(s "\n"); else printf("."); }
+
+static char verbose=0;
+static char debug=0;
+
+/* http://www.internet-sicherheit.de/forschung/aktuelle-forschungsprojekte/elektronischer-personalausweis/berechtigungszertifikat/ */
+/*static unsigned const char CVCert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x89, 0x7f, 0x4e, 0x82, 0x01, 0x49, 0x5f,
+    0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41,
+    0x45, 0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x81,
+    0xfd, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02,
+    0x02, 0x02, 0x81, 0x1c, 0xd7, 0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66,
+    0x86, 0x2a, 0x18, 0x30, 0x25, 0x75, 0xd1, 0xd7, 0x87, 0xb0, 0x9f,
+    0x07, 0x57, 0x97, 0xda, 0x89, 0xf5, 0x7e, 0xc8, 0xc0, 0xff, 0x82,
+    0x1c, 0x68, 0xa5, 0xe6, 0x2c, 0xa9, 0xce, 0x6c, 0x1c, 0x29, 0x98,
+    0x03, 0xa6, 0xc1, 0x53, 0x0b, 0x51, 0x4e, 0x18, 0x2a, 0xd8, 0xb0,
+    0x04, 0x2a, 0x59, 0xca, 0xd2, 0x9f, 0x43, 0x83, 0x1c, 0x25, 0x80,
+    0xf6, 0x3c, 0xcf, 0xe4, 0x41, 0x38, 0x87, 0x07, 0x13, 0xb1, 0xa9,
+    0x23, 0x69, 0xe3, 0x3e, 0x21, 0x35, 0xd2, 0x66, 0xdb, 0xb3, 0x72,
+    0x38, 0x6c, 0x40, 0x0b, 0x84, 0x39, 0x04, 0x0d, 0x90, 0x29, 0xad,
+    0x2c, 0x7e, 0x5c, 0xf4, 0x34, 0x08, 0x23, 0xb2, 0xa8, 0x7d, 0xc6,
+    0x8c, 0x9e, 0x4c, 0xe3, 0x17, 0x4c, 0x1e, 0x6e, 0xfd, 0xee, 0x12,
+    0xc0, 0x7d, 0x58, 0xaa, 0x56, 0xf7, 0x72, 0xc0, 0x72, 0x6f, 0x24,
+    0xc6, 0xb8, 0x9e, 0x4e, 0xcd, 0xac, 0x24, 0x35, 0x4b, 0x9e, 0x99,
+    0xca, 0xa3, 0xf6, 0xd3, 0x76, 0x14, 0x02, 0xcd, 0x85, 0x1c, 0xd7,
+    0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66, 0x86, 0x2a, 0x18, 0x30, 0x25,
+    0x75, 0xd0, 0xfb, 0x98, 0xd1, 0x16, 0xbc, 0x4b, 0x6d, 0xde, 0xbc,
+    0xa3, 0xa5, 0xa7, 0x93, 0x9f, 0x86, 0x39, 0x04, 0x39, 0x3e, 0xe8,
+    0xe0, 0x6d, 0xb6, 0xc7, 0xf5, 0x28, 0xf8, 0xb4, 0x26, 0x0b, 0x49,
+    0xaa, 0x93, 0x30, 0x98, 0x24, 0xd9, 0x2c, 0xdb, 0x18, 0x07, 0xe5,
+    0x43, 0x7e, 0xe2, 0xe2, 0x6e, 0x29, 0xb7, 0x3a, 0x71, 0x11, 0x53,
+    0x0f, 0xa8, 0x6b, 0x35, 0x00, 0x37, 0xcb, 0x94, 0x15, 0xe1, 0x53,
+    0x70, 0x43, 0x94, 0x46, 0x37, 0x97, 0x13, 0x9e, 0x14, 0x87, 0x01,
+    0x01, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x45,
+    0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x4c, 0x0e, 0x06,
+    0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x01, 0x53,
+    0x01, 0xc1, 0x5f, 0x25, 0x06, 0x00, 0x07, 0x00, 0x04, 0x00, 0x01,
+    0x5f, 0x24, 0x06, 0x00, 0x09, 0x00, 0x04, 0x00, 0x01, 0x5f, 0x37,
+    0x38, 0x4c, 0xcf, 0x25, 0xc5, 0x9f, 0x36, 0x12, 0xee, 0xe1, 0x88,
+    0x75, 0xf6, 0xc5, 0xf2, 0xe2, 0xd2, 0x1f, 0x03, 0x95, 0x68, 0x3b,
+    0x53, 0x2a, 0x26, 0xe4, 0xc1, 0x89, 0xb7, 0x1e, 0xfe, 0x65, 0x9c,
+    0x3f, 0x26, 0xe0, 0xeb, 0x9a, 0xea, 0xe9, 0x98, 0x63, 0x10, 0x7f,
+    0x9b, 0x0d, 0xad, 0xa1, 0x64, 0x14, 0xff, 0xa2, 0x04, 0x51, 0x6a,
+    0xee, 0x2b
+};*/
+
+static const unsigned char CVCert[] = {
+    0x7F, 0x21, 0x82, 0x01, 0x41, 0x7F, 0x4E, 0x81, 0xFA, 0x5F, 0x29,
+    0x01, 0x00, 0x42, 0x0D, 0x5A, 0x5A, 0x44, 0x56, 0x43, 0x41, 0x41,
+    0x54, 0x41, 0x30, 0x30, 0x30, 0x33, 0x7F, 0x49, 0x4F, 0x06, 0x0A,
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+    0x41, 0x04, 0x19, 0xD1, 0x75, 0x45, 0xD3, 0xFE, 0x0B, 0x34, 0x3E,
+    0x7E, 0xE2, 0xAE, 0x4E, 0x2B, 0xC9, 0x2D, 0x51, 0x35, 0x1C, 0xC1,
+    0x17, 0xA4, 0x7F, 0xA9, 0x51, 0x9A, 0xDB, 0x1E, 0x40, 0x5E, 0xE6,
+    0xB8, 0x12, 0x12, 0x80, 0xBC, 0xC2, 0xFF, 0xF0, 0x35, 0x7A, 0x19,
+    0x7D, 0xE7, 0x39, 0xA7, 0xFD, 0x2E, 0xF0, 0x22, 0x10, 0xEF, 0x34,
+    0x3C, 0xDB, 0xE7, 0x9E, 0xF9, 0x4B, 0x8E, 0x28, 0x59, 0x1B, 0xB9,
+    0x5F, 0x20, 0x0B, 0x5A, 0x5A, 0x44, 0x4B, 0x42, 0x32, 0x30, 0x30,
+    0x30, 0x30, 0x52, 0x7F, 0x4C, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7F,
+    0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x00, 0x03, 0x01,
+    0xDF, 0x04, 0x5F, 0x25, 0x06, 0x01, 0x00, 0x00, 0x02, 0x01, 0x07,
+    0x5F, 0x24, 0x06, 0x01, 0x00, 0x00, 0x03, 0x03, 0x01, 0x65, 0x5E,
+    0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01,
+    0x03, 0x01, 0x80, 0x20, 0x75, 0xE0, 0xC4, 0xAC, 0x36, 0xC2, 0x5A,
+    0x33, 0xAC, 0x0E, 0x9A, 0x75, 0xEB, 0x79, 0x2A, 0x72, 0xF3, 0x31,
+    0xA5, 0x1E, 0x28, 0x63, 0x4E, 0xCC, 0x2E, 0xD6, 0x2E, 0x54, 0xF3,
+    0xC6, 0x93, 0xDA, 0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00,
+    0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x18, 0x12, 0x65, 0x74,
+    0x49, 0xFC, 0xF1, 0xD3, 0xDA, 0xD8, 0x3D, 0x13, 0x14, 0x29, 0x17,
+    0x5C, 0x61, 0x8B, 0x21, 0xBA, 0xF0, 0xAF, 0x44, 0xAC, 0xE3, 0x8C,
+    0xB2, 0xC1, 0x2C, 0xEB, 0x2A, 0x56, 0x5F, 0x37, 0x40, 0x54, 0x0F,
+    0x85, 0x09, 0x12, 0xAB, 0xD3, 0x51, 0xF8, 0xF5, 0x56, 0x9B, 0x53,
+    0x4A, 0x5C, 0x8F, 0x64, 0x54, 0x5B, 0x51, 0xA7, 0x34, 0x70, 0xBE,
+    0x5A, 0xD2, 0x89, 0xC1, 0x9A, 0x5E, 0x13, 0x52, 0x53, 0xD3, 0xBB,
+    0x15, 0x52, 0x26, 0x21, 0x7B, 0x41, 0xE7, 0xF0, 0x68, 0xB3, 0x52,
+    0x3F, 0x3A, 0x63, 0x92, 0x22, 0xAF, 0x2B, 0x62, 0x8C, 0x39, 0x7D,
+    0x4F, 0xD4, 0x02, 0x1E, 0xDE, 0x00, 0xDC
+};
+
+/*static const unsigned int CVCert_len = 398;*/
+static const unsigned int CVCert_len = 326;
+
+static const unsigned char certDesc[] = {
+    0x30, 0x82, 0x01, 0x90, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03,
+    0x01, 0x03, 0x01, 0x01, 0xA1, 0x16, 0x0C, 0x14, 0x42, 0x75, 0x6E, 0x64,
+    0x65, 0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x20,
+    0x47, 0x6D, 0x62, 0x48, 0xA2, 0x24, 0x13, 0x22, 0x68, 0x74, 0x74, 0x70,
+    0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x75, 0x6E, 0x64, 0x65,
+    0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x2E, 0x64,
+    0x65, 0x2F, 0x64, 0x76, 0x63, 0x61, 0xA3, 0x18, 0x0C, 0x16, 0x44, 0x65,
+    0x75, 0x74, 0x73, 0x63, 0x68, 0x65, 0x20, 0x4B, 0x72, 0x65, 0x64, 0x69,
+    0x74, 0x62, 0x61, 0x6E, 0x6B, 0x20, 0x41, 0x47, 0xA4, 0x13, 0x13, 0x11,
+    0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64,
+    0x6B, 0x62, 0x2E, 0x64, 0x65, 0xA5, 0x82, 0x01, 0x13, 0x0C, 0x82, 0x01,
+    0x0F, 0x54, 0x61, 0x75, 0x62, 0x65, 0x6E, 0x73, 0x74, 0x72, 0x2E, 0x20,
+    0x37, 0x2D, 0x39, 0x0D, 0x0A, 0x31, 0x30, 0x31, 0x31, 0x37, 0x20, 0x42,
+    0x65, 0x72, 0x6C, 0x69, 0x6E, 0x0D, 0x0A, 0x69, 0x6E, 0x66, 0x6F, 0x40,
+    0x64, 0x6B, 0x62, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6,
+    0x66, 0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73,
+    0x20, 0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A, 0x42, 0x65, 0x72,
+    0x6C, 0x69, 0x6E, 0x65, 0x72, 0x20, 0x42, 0x65, 0x61, 0x75, 0x66, 0x74,
+    0x72, 0x61, 0x67, 0x74, 0x65, 0x72, 0x20, 0x66, 0xC3, 0xBC, 0x72, 0x20,
+    0x44, 0x61, 0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x20,
+    0x75, 0x6E, 0x64, 0x20, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74,
+    0x69, 0x6F, 0x6E, 0x73, 0x66, 0x72, 0x65, 0x69, 0x68, 0x65, 0x69, 0x74,
+    0x2C, 0x20, 0x41, 0x6E, 0x20, 0x64, 0x65, 0x72, 0x20, 0x55, 0x72, 0x61,
+    0x6E, 0x69, 0x61, 0x20, 0x34, 0x2D, 0x31, 0x30, 0x2C, 0x20, 0x31, 0x30,
+    0x37, 0x38, 0x37, 0x20, 0x42, 0x65, 0x72, 0x6C, 0x69, 0x6E, 0x2C, 0x20,
+    0x30, 0x33, 0x30, 0x2F, 0x31, 0x33, 0x20, 0x38, 0x38, 0x39, 0x2D, 0x30,
+    0x2C, 0x20, 0x6D, 0x61, 0x69, 0x6C, 0x62, 0x6F, 0x78, 0x40, 0x64, 0x61,
+    0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65,
+    0x72, 0x6C, 0x69, 0x6E, 0x2E, 0x64, 0x65, 0x2C, 0x20, 0x68, 0x74, 0x74,
+    0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x61, 0x74, 0x65,
+    0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65, 0x72, 0x6C,
+    0x69, 0x6E, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6, 0x66,
+    0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73, 0x20,
+    0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A
+};
+
+static const unsigned int certDesc_len = 404;
+
+static int parse_cv_cert(const unsigned char *cert, const unsigned int cert_len,
+        const unsigned char *cert_desc, const unsigned int cert_desc_len) {
+    BIO *bio_stdout = NULL;
+    CVC_CERT *cvc_cert = NULL;
+    CVC_CERTIFICATE_DESCRIPTION *desc = NULL;
+    const unsigned char *p;
+    int fail = 1;
+
+    printf("Test CV certificate parsing ");
+    if (verbose)
+        printf("\n");
+
+    bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE);
+    if (!bio_stdout)
+        err("Could not get output buffer");
+
+    p = cert;
+    cvc_cert = CVC_d2i_CVC_CERT(NULL, &p, cert_len);
+    if (!cvc_cert)
+        err("Could not parse CV Cert");
+    verb("Parsed CV Cert");
+    if (debug) {
+        if (!cvc_print(bio_stdout, cvc_cert, 4))
+            err("Could not print CV certificate");
+    }
+
+    /* FIXME: CVC_CERT_print_ctx -> segfault */
+    /* CVC_CERT_print_ctx(bio_stdout, cvc_cert, 1, NULL); */
+
+    if (cert_desc) {
+        p = cert_desc;
+        desc = d2i_CVC_CERTIFICATE_DESCRIPTION(NULL, &p, cert_desc_len);
+        if (!desc)
+            err("Could not parse Certificate Description");
+        verb("\nParsed Certificate Description");
+        if (debug)
+            if (!certificate_description_print(bio_stdout, desc, 4))
+                err("Could not print Certificate Description");
+
+        if (!CVC_check_description(cvc_cert, cert_desc, cert_desc_len)) {
+            err("Certificate Description doesn't match Certificate\n");
+        } else {
+            verb("Certificate Description matches Certificate");
+        }
+    }
+
+    fail = 0;
+
+err:
+    if (desc)
+        CVC_CERTIFICATE_DESCRIPTION_free(desc);
+    if (cvc_cert)
+        CVC_CERT_free(cvc_cert);
+    if (bio_stdout)
+        BIO_free_all(bio_stdout);
+    return fail;
+}
+
+static int parse_cv_file(char *filename) {
+
+    FILE *fp = NULL;
+    int fail = 1;
+    long filesize = 0;
+    unsigned char *cv_data = NULL;
+
+    fp = fopen(filename, "rb");
+    if (!fp)
+        err("Could not open file\n");
+
+    fseek(fp, 0L, SEEK_END);
+    filesize = ftell(fp);
+    fseek(fp, 0L, SEEK_SET);
+
+    cv_data = (unsigned char*) malloc(filesize);
+    if (!cv_data)
+        err("Failed to allocate memory\n");
+
+    if (filesize != fread(cv_data, sizeof(unsigned char), filesize, fp))
+        err("Failed to read file\n");
+
+    fail = parse_cv_cert(cv_data, filesize, NULL, 0);
+
+    if (verbose)
+        printf("Parsed %s\n", filename);
+    else
+        printf(".");
+
+
+err:
+    if (fp)
+        fclose(fp);
+    if(cv_data)
+        free(cv_data);
+
+    return fail;
+}
+
+int main(int argc, char *argv[])
+{
+    BIO *bio_file = NULL;
+    int fail = 1, i = 1;
+        char *filename = NULL;
+
+
+    for (i=1; i<argc; i++)
+    {
+        if ((strcmp(argv[i], "--verbose") == 0)
+                || (strcmp(argv[i], "-v") == 0)) {
+            verbose++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--debug") == 0)
+                || (strcmp(argv[i], "-d") == 0)) {
+            verbose++;
+            debug++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--file") == 0)
+                || (strcmp(argv[i], "-f") == 0)) {
+            if (i++>=argc) {
+                fprintf(stderr, "%d %d-f,--file requires an argument\n", i, argc);
+                return fail;
+            }
+            filename = argv[i];
+            continue;
+        }
+        if ((strcmp(argv[i], "--help") == 0)
+                || (strcmp(argv[i], "-h") == 0)) {
+            fprintf(stderr,
+                    "%s tests the OpenSSL parser for card verifiable certificates\n"
+                    "\n"
+                    "Usage: %s [Options]\n"
+                    "\n"
+                    "Options:\n"
+                    "  -f,--file         file with cv certificate to parse\n"
+                    "  -h,--help         show this help message and exit\n"
+                    "  -v,--verbose      more verbosity\n"
+                    "     --version      print version information and exit\n"
+                    , argv[0], argv[0]
+            );
+            return fail;
+        }
+        if (strcmp(argv[i], "--version") == 0) {
+            fprintf(stderr,
+                    "%s 0.1\n"
+                    "\n"
+                    "Written by Frank Morgner and Dominik Oepen.\n"
+                    , argv[0]
+            );
+            return fail;
+        }
+
+        fprintf(stderr, "unrecognized option \"%s\"\n", argv[i]);
+        return fail;
+    }
+
+
+    if (filename)
+        fail = parse_cv_file(filename);
+    else
+        fail = parse_cv_cert(CVCert, CVCert_len, certDesc, certDesc_len);
+
+    fail = 0;
+
+    if (bio_file)
+        BIO_free_all(bio_file);
+
+    if (verbose) {
+        if (fail)
+            printf("Some error occurred.\n");
+        else
+            printf("Everything works as expected.\n");
+    } else {
+        if (!fail)
+            printf(" ok\n");
+        else
+            printf(" error\n");
+    }
+
+    return fail;
+}
+
+#endif /* OPENSSL_NO_PACE */
Index: openssl/crypto/eac/eac.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,257 @@
+/**
+ * @file
+ * @brief OpenEAC implementation
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_util.h"
+#include "eac_kdf.h"
+#include "eac_lib.h"
+#include <openssl/eac.h>
+#include <openssl/pace.h>
+#include <openssl/err.h>
+#include <string.h>
+
+BUF_MEM *
+EAC_add_iso_pad(const BUF_MEM * m, int block_size)
+{
+    BUF_MEM * out = NULL;
+    int p_len;
+
+    if (!m) {
+        EACerr(EAC_F_EAC_ADD_ISO_PAD, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* calculate length of padded message */
+    p_len = (m->length / block_size) * block_size + block_size;
+
+    out = BUF_MEM_create(p_len);
+    if (!out)
+        goto err;
+
+    /* Flawfinder: ignore */
+    memcpy(out->data, m->data, m->length);
+
+    /* now add iso padding */
+    memset(out->data + m->length, 0x80, 1);
+    memset(out->data + m->length + 1, 0, p_len - m->length - 1);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+EAC_encrypt(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data)
+{
+    if(!ctx || !ctx->key_ctx) {
+        EACerr(EAC_F_EAC_ENCRYPT, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    if (!update_iv(ctx->key_ctx, ctx->cipher_ctx, ssc))
+        return NULL;
+
+    return cipher_no_pad(ctx->key_ctx, ctx->cipher_ctx, ctx->key_ctx->k_enc, data, 1);
+}
+
+BUF_MEM *
+EAC_decrypt(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data)
+{
+    if (!ctx || !ctx->key_ctx) {
+        EACerr(EAC_F_EAC_DECRYPT, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    if (!update_iv(ctx->key_ctx, ctx->cipher_ctx, ssc))
+        return NULL;
+
+    return cipher_no_pad(ctx->key_ctx, ctx->cipher_ctx, ctx->key_ctx->k_enc, data, 0);
+}
+
+BUF_MEM *
+EAC_authenticate(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data)
+{
+    int l;
+    BUF_MEM *out = NULL, *to_authenticate = NULL;
+    unsigned char *ssc_buf = NULL;
+
+    if (!ctx || !data) {
+        EACerr(EAC_F_EAC_AUTHENTICATE, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    l = encode_ssc(ssc, ctx->key_ctx, &ssc_buf);
+    if (l < 0) {
+        goto err;
+    }
+
+    to_authenticate = BUF_MEM_create(l + data->length);
+    if (!to_authenticate) {
+        goto err;
+    }
+    /* Flawfinder: ignore */
+    memcpy(to_authenticate->data, ssc_buf, l);
+    /* Flawfinder: ignore */
+    memcpy(to_authenticate->data + l, data->data, data->length);
+    to_authenticate->length = l + data->length;
+
+    out = authenticate(ctx->key_ctx, to_authenticate);
+
+err:
+    if (ssc_buf)
+        free(ssc_buf);
+    /* TR-03110 uses Encrypt then authenticate, so no need to wipe the memory
+     * from the authenticated data */
+    if (to_authenticate)
+        BUF_MEM_free(to_authenticate);
+
+    return out;
+}
+
+BUF_MEM *
+EAC_Comp(const EAC_CTX *ctx, int id, const BUF_MEM *pub)
+{
+    switch (id) {
+        case EAC_ID_PACE:
+            if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->ka_ctx) {
+                EACerr(EAC_F_EAC_COMP, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            return Comp(ctx->pace_ctx->ka_ctx->key, pub, ctx->bn_ctx, ctx->md_ctx);
+
+        case EAC_ID_TA:
+            if (!ctx || !ctx->ta_ctx) {
+                EACerr(EAC_F_EAC_COMP, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            if (ctx->ta_ctx->priv_key)
+                return Comp(ctx->ta_ctx->priv_key, pub, ctx->bn_ctx, ctx->md_ctx);
+            else
+                return Comp(ctx->ta_ctx->pub_key, pub, ctx->bn_ctx, ctx->md_ctx);
+
+        case EAC_ID_CA:
+            if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx) {
+                EACerr(EAC_F_EAC_COMP, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            return Comp(ctx->ca_ctx->ka_ctx->key, pub, ctx->bn_ctx, ctx->md_ctx);
+
+        default:
+            EACerr(EAC_F_EAC_COMP, EAC_R_INVALID_ARGUMENTS);
+            return NULL;
+    }
+}
+
+BUF_MEM *
+EAC_hash_certificate_description(const unsigned char *cert_desc,
+        size_t cert_desc_len)
+{
+    BUF_MEM *cd, *out;
+
+    cd = BUF_MEM_create_init(cert_desc, cert_desc_len);
+    out = hash(EVP_sha256(), NULL, NULL, cd);
+    if (cd)
+        BUF_MEM_free(cd);
+
+    return out;
+}
+
+int
+EAC_CTX_set_encryption_ctx(EAC_CTX *ctx, int id)
+{
+    const KA_CTX *new;
+
+    switch (id) {
+        case EAC_ID_PACE:
+            if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->ka_ctx ||
+                    !ctx->pace_ctx->ka_ctx->k_enc || !ctx->pace_ctx->ka_ctx->k_mac) {
+                EACerr(EAC_F_EAC_CTX_SET_ENCRYPTION_CTX, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            new = ctx->pace_ctx->ka_ctx;
+            break;
+
+        case EAC_ID_CA:
+            if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx ||
+                    !ctx->ca_ctx->ka_ctx->k_enc || !ctx->ca_ctx->ka_ctx->k_mac) {
+                EACerr(EAC_F_EAC_CTX_SET_ENCRYPTION_CTX, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            new = ctx->ca_ctx->ka_ctx;
+            break;
+
+        case EAC_ID_EAC:
+            if (!ctx || !ctx->key_ctx || !ctx->key_ctx->k_enc || !ctx->key_ctx->k_mac) {
+                EACerr(EAC_F_EAC_CTX_SET_ENCRYPTION_CTX, EAC_R_INVALID_ARGUMENTS);
+                return 0;
+            }
+            return 1;
+            break;
+
+        default:
+            EACerr(EAC_F_EAC_CTX_SET_ENCRYPTION_CTX, EAC_R_INVALID_ARGUMENTS);
+            return 0;
+    }
+
+    KA_CTX_clear_free(ctx->key_ctx);
+    ctx->key_ctx = KA_CTX_dup(new);
+    if (!ctx->key_ctx)
+        return 0;
+
+    return 1;
+}
+
+BUF_MEM *
+KA_CTX_generate_key(const KA_CTX *ctx, BN_CTX *bn_ctx)
+{
+    if (!ctx || !ctx->generate_key) {
+        EACerr(EAC_F_KA_CTX_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return ctx->generate_key(ctx->key, bn_ctx);
+}
+
+int
+KA_CTX_compute_key(KA_CTX *ctx, const BUF_MEM *in, BN_CTX *bn_ctx)
+{
+    if (!ctx || !ctx->compute_key) {
+        EACerr(EAC_F_KA_CTX_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    BUF_MEM_clear_free(ctx->shared_secret);
+    ctx->shared_secret = ctx->compute_key(ctx->key, in, bn_ctx);
+    if (!ctx->shared_secret)
+        return 0;
+
+    return 1;
+}
+
+int
+KA_CTX_derive_keys(KA_CTX *ctx, const BUF_MEM *nonce, EVP_MD_CTX *md_ctx)
+{
+    if (!ctx) {
+        EACerr(EAC_F_KA_CTX_DERIVE_KEYS, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    BUF_MEM_clear_free(ctx->k_mac);
+    ctx->k_mac = kdf_mac(nonce, ctx, md_ctx);
+
+    BUF_MEM_clear_free(ctx->k_enc);
+    ctx->k_enc = kdf_enc(nonce, ctx, md_ctx);
+
+    if (!ctx->k_mac || !ctx->k_enc)
+        return 0;
+
+    return 1;
+}
Index: openssl/crypto/eac/eac.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,687 @@
+/**
+ * @file eac.h
+ * @brief Interface for Extended Access Control
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef EAC_H_
+#define EAC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <openssl/asn1.h>
+#include <openssl/buffer.h>
+#include <openssl/cmac.h>
+#include <openssl/cv_cert.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+
+/** Identification of the specifications to use.
+ * @note TR-03110 v2.01 differs from all later versions of the Technical
+ * Guideline in how the authentication token is calculated. Therefore old test
+ * cards are incompatible with the newer specification.
+ */
+enum eac_tr_version {
+    /** Undefined type, if nothing else matches */
+    EAC_TR_VERSION = 0,
+    /** Perform EAC according to TR-03110 v2.01 */
+    EAC_TR_VERSION_2_01,
+    /** Perform EAC according to TR-03110 v2.02 and later */
+    EAC_TR_VERSION_2_02,
+};
+
+/**
+ * @brief Context for a key agreement and subsequent derivation of session
+ * keys.
+ * @note The key agreement itself is usually done via an underlying DH or ECDH.
+ */
+typedef struct ka_ctx {
+        /** @brief Digest to use for key derivation */
+        const EVP_MD * md;
+        /** @brief Digest's engine */
+        ENGINE * md_engine;
+        /** @brief Context for CMAC */
+        CMAC_CTX * cmac_ctx;
+        /** @brief Cipher to use for encryption/decryption */
+        const EVP_CIPHER * cipher;
+        /** @brief Cipher's engine */
+        ENGINE * cipher_engine;
+        /** @brief Initialisation vector for encryption/decryption */
+        unsigned char * iv;
+        /** @brief Length of the computed key for the message authentication code */
+        int mac_keylen;
+        /** @brief Length of the computed key for the encryption/decryption */
+        int enc_keylen;
+
+         /**
+         * @brief Generates a key pair for key agreement.
+         *
+         * @param[in] key Object for key generation, usually \c &KA_CTX.key
+         * @param[in] bn_ctx (optional)
+         *
+         * @return Public key or NULL in case of an error
+         */
+        BUF_MEM * (*generate_key)(EVP_PKEY *key, BN_CTX *bn_ctx);
+        /**
+         * @brief Completes a key agreement by computing the shared secret
+         *
+         * @param[in] key Object for key computation, usually \c &KA_CTX.key
+         * @param[in] in Public key from the other party
+         * @param[in] bn_ctx (optional)
+         *
+         * @return Shared secret or NULL in case of an error
+         */
+        BUF_MEM * (*compute_key)(EVP_PKEY *key, const BUF_MEM *in, BN_CTX *bn_ctx);
+
+        /** @brief Container for the key pair used for key agreement */
+        EVP_PKEY *key;
+
+        /** @brief Shared secret computed during the key agreement protocol */
+        BUF_MEM *shared_secret;
+        /** @brief Symmetric key used for encryption/decryption. Derived from KA_CTX.shared_secret. */
+        BUF_MEM *k_enc;
+        /** @brief Symmetric key used for integrity protection. Derived from KA_CTX.shared_secret. */
+        BUF_MEM *k_mac;
+} KA_CTX;
+
+/** @brief Context for the Password Authenticated Connection Establishment protocol
+ *
+ * Encompasses information about cipher, message digest, key agreement scheme,
+ * mapping method.
+ */
+typedef struct pace_ctx {
+    /** @brief Identifier of the protocol's OID specifying the exact PACE parameters
+     * to use
+     *
+     * The OID of the \c PACEInfo structure in the \c EF.CardAccess is used,
+     * because it is more specific than the OID contained in the (optional) \c
+     * PaceDomainParameterInfo structures.
+     *
+     * Accepts the following values:
+     * - \c NID_id_PACE_DH_GM_3DES_CBC_CBC
+     * - \c NID_id_PACE_DH_GM_AES_CBC_CMAC_128
+     * - \c NID_id_PACE_DH_GM_AES_CBC_CMAC_192
+     * - \c NID_id_PACE_DH_GM_AES_CBC_CMAC_256
+     * - \c NID_id_PACE_ECDH_GM_3DES_CBC_CBC
+     * - \c NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128
+     * - \c NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192
+     * - \c NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256
+     * - \c NID_id_PACE_DH_IM_3DES_CBC_CBC
+     * - \c NID_id_PACE_DH_IM_AES_CBC_CMAC_128
+     * - \c NID_id_PACE_DH_IM_AES_CBC_CMAC_192
+     * - \c NID_id_PACE_DH_IM_AES_CBC_CMAC_256
+     * - \c NID_id_PACE_ECDH_IM_3DES_CBC_CBC
+     * - \c NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128
+     * - \c NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192
+     * - \c NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256
+     */
+    int protocol;
+    /** @brief (currently unused) Version of the PACE protocol, MUST be 1 or 2 */
+    unsigned char version;
+    /** @brief Points to the implementation of a specific mapping
+     *
+     * @see PACE_STEP3A_generate_mapping_data() */
+    BUF_MEM * (*map_generate_key)(const struct pace_ctx *ctx, BN_CTX *bn_ctx);
+    /** @brief Points to the implementation of a specific mapping
+     *
+     * @see PACE_STEP3A_map_generator() */
+    int (*map_compute_key)(struct pace_ctx * ctx, const BUF_MEM * s,
+                    const BUF_MEM * in, BN_CTX *bn_ctx);
+
+    /** @brief PICC's static domain parameters */
+    EVP_PKEY *static_key;
+    /** @brief Key agreement object used with the ephemeral domain parameters */
+    KA_CTX *ka_ctx;
+    /** @brief PICC's decrypted challenge generated in PACE step 1 */
+    BUF_MEM *nonce;
+    /** @brief The own ephemeral public key generated in PACe step 3b */
+    BUF_MEM *my_eph_pubkey;
+} PACE_CTX;
+
+/** @brief Context for the Restricted Identification protocol
+ *
+ * Encompasses information about hash function, message digest, key agreement scheme,
+ * mapping method.
+ */
+typedef struct ri_ctx {
+    /** @brief Identifier of the hash function
+     * to use
+     *
+     * see tr 03110 p. 60
+     * - \c NID_id_RI_DH_SHA_1
+     * - \c NID_id_RI_DH_SHA_224
+     * - \c NID_id_RI_DH_SHA_256
+     * - \c NID_id_RI_DH_SHA_384
+     * - \c NID_id_RI_DH_SHA_512
+     * - \c NID_id_RI_ECDH_SHA_1
+     * - \c NID_id_RI_ECDH_SHA_224
+     * - \c NID_id_RI_ECDH_SHA_256
+     * - \c NID_id_RI_ECDH_SHA_384
+     * - \c NID_id_RI_ECDH_SHA_512
+     */
+    int protocol;
+    /** @brief Digest to use for derivation of I^{sector}_{ID} */
+    const EVP_MD * md;
+    /**
+    * @brief Generates a key pair for key agreement.
+    *
+    * @param[in] key Object for key generation, usually \c &KA_CTX.key
+    * @param[in] bn_ctx (optional)
+    *
+    * @return Public key or NULL in case of an error
+    */
+    BUF_MEM * (*generate_key)(EVP_PKEY *key, BN_CTX *bn_ctx);
+    /**
+     * @brief Completes a key agreement by computing the shared secret
+     *
+     * @param[in] key Object for key computation, usually \c &KA_CTX.key
+     * @param[in] in Public key from the other party
+     * @param[in] bn_ctx (optional)
+     *
+     * @return Shared secret or NULL in case of an error
+     */
+    BUF_MEM * (*compute_key)(EVP_PKEY *key, const BUF_MEM *in, BN_CTX *bn_ctx);
+    /** @brief PICC's static domain parameters */
+    EVP_PKEY *static_key;
+} RI_CTX;
+
+/** @brief Context for the Terminal Authentication protocol */
+typedef struct ta_ctx {
+    /** @brief (currently unused) Version of the TA protocol, MUST be 1 or 2 */
+    unsigned char version;
+    /** @brief Identifier of the protocol's OID specifying the exact TA
+     * parameters to use.
+     *
+     * Accepts the following values:
+     * - \c NID_id_TA_RSA_v1_5_SHA_1
+     * - \c NID_id_TA_RSA_v1_5_SHA_256
+     * - \c NID_id_TA_RSA_PSS_SHA_1
+     * - \c NID_id_TA_RSA_PSS_SHA_256
+     * - \c NID_id_TA_RSA_v1_5_SHA_512
+     * - \c NID_id_TA_RSA_PSS_SHA_512
+     * - \c NID_id_TA_ECDSA_SHA_1
+     * - \c NID_id_TA_ECDSA_SHA_224
+     * - \c NID_id_TA_ECDSA_SHA_256
+     * - \c NID_id_TA_ECDSA_SHA_384
+     * - \c NID_id_TA_ECDSA_SHA_512
+     */
+    int protocol;
+    /** @brief (currently unused) engine for signing and signature verification */
+    ENGINE *key_engine;
+    /** @brief TA private key used for signing the challenge */
+    EVP_PKEY *priv_key;
+    /** @brief TA public key used for signing the challenge */
+    EVP_PKEY *pub_key;
+    /** @brief PCD's public key extracted from it's CV certificate */
+    BUF_MEM *pk_pcd;
+    /** @brief PICC's challenge */
+    BUF_MEM *nonce;
+    /** @brief Trust anchor for CV certificate validation */
+    CVC_CERT *trust_anchor;
+    /** @brief Most recent verified CV certificate in a certificate chain */
+    CVC_CERT *current_cert;
+    /** @brief When a complete CV certificate chain has been verified, this will be the new trust anchor */
+    CVC_CERT *new_trust_anchor;
+    int flags;
+} TA_CTX;
+
+/** @brief Context for the Chip Authentication protocol */
+typedef struct ca_ctx {
+    /** @brief (currently unused) Version of the CA protocol, MUST be 1 or 2 */
+    unsigned char version;
+    /** @brief Identifier of the protocol's OID specifying the exact CA parameters to use.
+     *
+     * Accepts the following values:
+     * - \c NID_id_CA_DH_3DES_CBC_CBC
+     * - \c NID_id_CA_DH_AES_CBC_CMAC_128
+     * - \c NID_id_CA_DH_AES_CBC_CMAC_192
+     * - \c NID_id_CA_DH_AES_CBC_CMAC_256
+     * - \c NID_id_CA_ECDH_3DES_CBC_CBC
+     * - \c NID_id_CA_ECDH_AES_CBC_CMAC_128
+     * - \c NID_id_CA_ECDH_AES_CBC_CMAC_192
+     * - \c NID_id_CA_ECDH_AES_CBC_CMAC_256
+     */
+    int protocol;
+    /** @brief Key agreement object used with the PICC's private key */
+    KA_CTX *ka_ctx;
+} CA_CTX;
+
+/** @brief Context for the Extended Access Control protocol */
+typedef struct eac_ctx {
+    /** @brief Perform EAC conforming to this version of TR-03110 */
+    enum eac_tr_version tr_version;
+    /** @brief Context for various operations with \c BIGNUM objects */
+    BN_CTX * bn_ctx;
+    /** @brief Context for various hashing operations */
+    EVP_MD_CTX * md_ctx;
+    /** @brief Context for various cipher operations */
+    EVP_CIPHER_CTX * cipher_ctx;
+    /** @brief Context for the Password Authenticated Connection Establishment protocol */
+    PACE_CTX *pace_ctx;
+    /** @brief Context for the Restricted Identification protocol */
+    RI_CTX *ri_ctx;
+    /** @brief Context for the Terminal Authentication protocol */
+    TA_CTX *ta_ctx;
+    /** @brief Context for the Chip Authentication protocol */
+    CA_CTX *ca_ctx;
+    /** @brief Context for secure messaging established with PACE or CA */
+    KA_CTX *key_ctx;
+} EAC_CTX;
+
+/** @brief TR-03110 always uses CMAC of 8 bytes length for AES MAC */
+#define EAC_AES_MAC_LENGTH 8
+
+/**
+ * @addtogroup management
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Create a new EAC context
+ * @return New EAC context or NULL in case of an error
+ */
+EAC_CTX *
+EAC_CTX_new(void);
+
+/**
+ * @brief Free an EAC context.
+ *
+ * Sensitive memory is cleared with OPENSSL_cleanse().
+ *
+ * @param[in] ctx EAC context to free
+ */
+void EAC_CTX_clear_free(EAC_CTX *ctx);
+
+/**
+ * @brief Initialize an EAC context for PACE
+ *
+ * @param[in,out] ctx EAC context to initialize
+ * @param[in] protocol Identifier of the protocol's OID specifying the exact PACE parameters
+ * @param[in] curve Standardized domain parameter identifier
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see PACE_CTX.protocol lists possible values for \a protocol
+ */
+int
+EAC_CTX_init_pace(EAC_CTX *ctx, int protocol, int curve);
+
+/**
+ * @brief Initialize an EAC context for TA with the terminal's PKI data. Use
+ * either a CV certificate or a known CAR for initialization.
+ *
+ * @param[in,out] ctx EAC context
+ * @param[in] privkey (optional) Private key to the given CV certificate
+ * @param[in] privkey_len Length of \a privkey
+ * @param[in] cert (optional) CV certificate to use as trust anchor for verification
+ * @param[in] cert_len (optional) Length of \a cert
+ * @param[in] car (optional) Certificate Authorisation Reference
+ * @param[in] car_len (optional) Length of \a car
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int
+EAC_CTX_init_ta(const EAC_CTX *ctx,
+           const unsigned char *privkey, size_t privkey_len,
+           const unsigned char *cert, size_t cert_len,
+           const unsigned char *car, size_t car_len);
+
+/**
+  * @brief Initialize an EAC context for Chip Authentication
+  *
+  * @param[in, out] ctx EAC context
+  * @param[in] protocol Identifier of the protocol's OID specifying the exact CA parameters to use
+  * @param[in] curve Standardized domain parameter identifier
+  * @param[in] priv (optional) Private CA key
+  * @param[in] priv_len Length of \a priv
+  * @param[in] pub Public CA key
+  * @param[in] pub_len Length of \a pub
+  *
+  * @return 1 on success or 0 in case of an error
+  *
+  * @see CA_CTX.protocol lists possible values for \a protocol
+  */
+int EAC_CTX_init_ca(const EAC_CTX *ctx, int protocol, int curve,
+                const unsigned char *priv, size_t priv_len,
+                const unsigned char *pub, size_t pub_len);
+
+/**
+ * @brief Initialize an EAC context for Restricted Identification
+ *
+ * @param[in, out] ctx EAC context
+ * @param[in] protocol protocol Identifier of the protocol's OID specifying the exact RI parameters to use
+ * @param[in] stnd_dp Standardized domain parameter identifier
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see RI_CTX.protocol lists possible values for \a protocol
+ */
+int
+EAC_CTX_init_ri(EAC_CTX *ctx, int protocol, int stnd_dp);
+
+/**
+ * @brief Initialize an EAC context for PACE, TA and CA from the data
+ * given in an \c EF.CardAccess
+ *
+ * @param[in] in \c EF.CardAccess
+ * @param[in] in_len Length of \a in
+ * @param[in,out] ctx EAC context to initialize
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int EAC_CTX_init_ef_cardaccess(unsigned const char * in, unsigned int in_len,
+        EAC_CTX *ctx);
+
+/** @} ***********************************************************************/
+
+/**
+ * @addtogroup sm
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Pad a buffer using ISO/IEC 9797-1 padding method 2.
+ *
+ * @param[in] m Buffer to pad
+ * @param[in] block_size Pad to this block size
+ *
+ * @return Padded input or NULL in case of an error
+ */
+BUF_MEM *
+EAC_add_iso_pad(const BUF_MEM * m, int block_size);
+
+/**
+ * @brief Encrypts data according to TR-03110 F.2.
+ *
+ * \a ssc is used to generate initialization vector for encryption.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] ssc Send sequence counter
+ * @param[in] data Data to encrypt
+ *
+ * @return Encrypted data or NULL in case of an error
+ *
+ * @note \a data must already be padded to block length
+ */
+BUF_MEM *
+EAC_encrypt(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data);
+
+/**
+ * @brief Decrypt data according to TR-03110 F.2.
+ *
+ * \a ssc is used to generate initialisation vector for decryption.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] ssc Send sequence counter
+ * @param[in] data Data to decrypt
+ *
+ * @return Decrypted data or NULL in case of an error
+ *
+ * @note \a data must already be padded to block length
+ */
+BUF_MEM *
+EAC_decrypt(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data);
+
+/**
+ * @brief Authenticate data according to TR-03110 F.2.
+ *
+ * \a ssc is encoded and prepended to the data.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] ssc Send sequence counter
+ * @param[in] data Data to authenticate
+ * @param[in] datalen Length of \a data
+ *
+ * @return MAC or NULL in case of an error
+ *
+ * @note \a data must already be padded to block length
+ */
+BUF_MEM *
+EAC_authenticate(const EAC_CTX *ctx, const BIGNUM *ssc, const BUF_MEM *data);
+
+/**
+ * @brief Compresse a public key according to TR-03110 Table A.2.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] id accepts \c EAC_ID_PACE, \c EAC_ID_CA, \c EAC_ID_TA
+ * @param[in] pub Raw public key
+ *
+ * @return Compressed public key or NULL in case of an error
+ */
+BUF_MEM *
+EAC_Comp(const EAC_CTX *ctx, int id, const BUF_MEM *pub);
+
+/**
+ * @brief Compute the hash of a CV certificate description.
+ *
+ * The hash can then be compared to the hash contained in the corresponding CV
+ * certificate.
+ *
+ * @param[in] cert_desc ASN1 encoded CV certificate description
+ * @param[in] cert_desc_len Length of \a cert_desc
+ *
+ * @return Hash of \a cert_desc or NULL in case of an error
+ */
+BUF_MEM *
+EAC_hash_certificate_description(const unsigned char *cert_desc,
+        size_t cert_desc_len);
+
+/** @brief Identifies the PACE context */
+#define EAC_ID_PACE 0
+/** @brief Identifies the CA context */
+#define EAC_ID_CA 1
+/** @brief Identifies the TA context */
+#define EAC_ID_TA 2
+/** @brief Identifies the currently used channel for encryption/decryption */
+#define EAC_ID_EAC 3
+
+/**
+ * @brief Set the SM context for encryption, decryption and authentication.
+ *
+ * @param[in,out] ctx EAC context
+ * @param[in] id accepts \c EAC_ID_PACE, \c EAC_ID_CA, \c EAC_ID_EAC
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int
+EAC_CTX_set_encryption_ctx(EAC_CTX *ctx, int id);
+
+/** @} ***********************************************************************/
+
+/**
+ * @addtogroup printing
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Print EAC context including private data.
+ *
+ * @param[in] out Where to print the data
+ * @param[in] ctx EAC context to be printed
+ * @param[in] indent Number of whitespaces used for indenting the output
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int EAC_CTX_print_private(BIO *out, const EAC_CTX *ctx, int indent);
+/**
+ * @brief Prints buffer
+ *
+ * @param[in] out Where to print the data
+ * @param[in] buf Buffer to print
+ * @param[in] indent Number of whitespaces used for indenting the output
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int BUF_MEM_print(BIO *out, const BUF_MEM *buf, int indent);
+
+/** @} ***********************************************************************/
+
+/** @cond */
+/* Here are following OpenSSL internal function and error codes, generated with
+ * `make errors` */
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_EAC_strings(void);
+
+/* Error codes for the EAC functions. */
+
+/* Function codes. */
+#define EAC_F_ASN1_PUBKEY				 100
+#define EAC_F_AUTHENTICATE				 191
+#define EAC_F_CA_CTX_SET_PROTOCOL			 101
+#define EAC_F_CA_STEP1_GET_PUBKEY			 102
+#define EAC_F_CA_STEP2_GET_EPH_PUBKEY			 103
+#define EAC_F_CA_STEP3_CHECK_PCD_PUBKEY			 104
+#define EAC_F_CA_STEP4_COMPUTE_SHARED_SECRET		 105
+#define EAC_F_CA_STEP5_DERIVE_KEYS			 106
+#define EAC_F_CA_STEP6_DERIVE_KEYS			 190
+#define EAC_F_CERT_FROM_CAR				 208
+#define EAC_F_CIPHER					 107
+#define EAC_F_CIPHER_NO_PAD				 108
+#define EAC_F_CMAC					 109
+#define EAC_F_COMP					 110
+#define EAC_F_COMPUTE_AUTHENTICATION_TOKEN		 111
+#define EAC_F_CONVERT_FROM_PLAIN_SIG			 112
+#define EAC_F_CONVERT_TO_PLAIN_SIG			 113
+#define EAC_F_CVC_GET_EC_PUBKEY				 197
+#define EAC_F_CVC_GET_PUBKEY				 199
+#define EAC_F_CVC_GET_RSA_PUBKEY			 198
+#define EAC_F_CVC_GET_TERMINAL_TYPE			 114
+#define EAC_F_DH_CHECK_PUB_KEY_RFC			 115
+#define EAC_F_DH_COMPUTE_KEY				 116
+#define EAC_F_DH_GENERATE_KEY				 117
+#define EAC_F_DH_GET_ORDER				 118
+#define EAC_F_DH_GET_Q					 119
+#define EAC_F_DH_GET_SG_PRIME				 120
+#define EAC_F_DH_GM_COMPUTE_KEY				 121
+#define EAC_F_DH_GM_GENERATE_KEY			 122
+#define EAC_F_DH_IM_COMPUTE_KEY				 123
+#define EAC_F_DH_IM_GENERATE_KEY			 124
+#define EAC_F_EAC_ADD_ISO_PAD				 125
+#define EAC_F_EAC_AUTHENTICATE				 126
+#define EAC_F_EAC_COMP					 127
+#define EAC_F_EAC_CTX_INIT_CA				 128
+#define EAC_F_EAC_CTX_INIT_EF_CARDACCESS		 129
+#define EAC_F_EAC_CTX_INIT_EF_CARD_ACCESS		 203
+#define EAC_F_EAC_CTX_INIT_PACE				 130
+#define EAC_F_EAC_CTX_INIT_RI				 204
+#define EAC_F_EAC_CTX_INIT_TA				 131
+#define EAC_F_EAC_CTX_INIT_TA_COMPAT			 132
+#define EAC_F_EAC_CTX_SET_ENCRYPTION_CTX		 133
+#define EAC_F_EAC_DECRYPT				 134
+#define EAC_F_EAC_EC_KEY_FROM_ASN1			 135
+#define EAC_F_EAC_ENCRYPT				 136
+#define EAC_F_EAC_OID2MD				 200
+#define EAC_F_EAC_SIGN					 201
+#define EAC_F_EAC_VERIFY				 202
+#define EAC_F_ECDH_COMPUTE_KEY				 137
+#define EAC_F_ECDH_GENERATE_KEY				 138
+#define EAC_F_ECDH_GM_COMPUTE_KEY			 139
+#define EAC_F_ECDH_GM_GENERATE_KEY			 140
+#define EAC_F_ECDH_IM_COMPUTE_KEY			 141
+#define EAC_F_ECDH_IM_GENERATE_KEY			 142
+#define EAC_F_ECDH_INTEGRATED_MAPPING			 143
+#define EAC_F_EC_KEY_FROM_PACE_ECPARAMETERS		 144
+#define EAC_F_ENCODED_MRZ				 145
+#define EAC_F_ENCODED_SECRET				 146
+#define EAC_F_ENCODE_SSC				 147
+#define EAC_F_EVP_PKEY_DUP				 148
+#define EAC_F_EVP_PKEY_FROM_PUBKEY			 149
+#define EAC_F_EVP_PKEY_SET_KEYS				 150
+#define EAC_F_EVP_PKEY_SET_STD_DP			 151
+#define EAC_F_GETLEN					 152
+#define EAC_F_GET_AUTHENTICATION_TOKEN			 153
+#define EAC_F_GET_PUBKEY				 154
+#define EAC_F_GET_RFC5114_MODP				 192
+#define EAC_F_GET_TA_SIGDATA				 155
+#define EAC_F_HASH					 156
+#define EAC_F_INIT_DH					 157
+#define EAC_F_INIT_ECDH					 158
+#define EAC_F_IS_CHAR_STR				 193
+#define EAC_F_KA_CTX_COMPUTE_KEY			 159
+#define EAC_F_KA_CTX_DERIVE_KEYS			 160
+#define EAC_F_KA_CTX_DUP				 161
+#define EAC_F_KA_CTX_GENERATE_KEY			 162
+#define EAC_F_KA_CTX_SET_PROTOCOL			 163
+#define EAC_F_KDF					 164
+#define EAC_F_KDF_ENC					 165
+#define EAC_F_KDF_MAC					 166
+#define EAC_F_PACE_CTX_SET_PROTOCOL			 167
+#define EAC_F_PACE_SEC_NEW				 194
+#define EAC_F_PACE_STEP1_ENC_NONCE			 168
+#define EAC_F_PACE_STEP2_DEC_NONCE			 169
+#define EAC_F_PACE_STEP3A_GENERATE_MAPPING_DATA		 170
+#define EAC_F_PACE_STEP3A_MAP_DP			 171
+#define EAC_F_PACE_STEP3A_MAP_GENERATOR			 195
+#define EAC_F_PACE_STEP3B_COMPUTE_EPHEMERAL_KEY		 172
+#define EAC_F_PACE_STEP3B_COMPUTE_SHARED_SECRET		 196
+#define EAC_F_PACE_STEP3B_GENERATE_EPHEMERAL_KEY	 173
+#define EAC_F_PACE_STEP3B_PROCESS			 174
+#define EAC_F_PACE_STEP3C_DERIVE_KEYS			 175
+#define EAC_F_PACE_STEP3D_				 176
+#define EAC_F_PACE_STEP3D_COMPUTE_AUTHENTICATION_TOKEN	 189
+#define EAC_F_PACE_STEP3D_VERIFY_AUTHENTICATION_TOKEN	 177
+#define EAC_F_RETAIL_MAC_DES				 178
+#define EAC_F_RI_CTX_COMPUTE_KEY			 205
+#define EAC_F_RI_CTX_GENERATE_KEY			 206
+#define EAC_F_RI_CTX_SET_PROTOCOL			 207
+#define EAC_F_RI_STEP2_COMPUTE_IDENTIFIER		 210
+#define EAC_F_TA_CTX_IMPORT_CERTIFICATE			 179
+#define EAC_F_TA_CTX_INIT_COMPAT			 180
+#define EAC_F_TA_CTX_SET_MD				 181
+#define EAC_F_TA_SET_NONCE				 209
+#define EAC_F_TA_STEP2_IMPORT_CERTIFICATE		 182
+#define EAC_F_TA_STEP3_GENERATE_EPHEMERAL_KEY		 183
+#define EAC_F_TA_STEP4_GET_NONCE			 184
+#define EAC_F_TA_STEP4_SET_NONCE			 211
+#define EAC_F_TA_STEP5_SIGN				 185
+#define EAC_F_TA_STEP6_VERIFY				 186
+#define EAC_F_UPDATE_IV					 187
+#define EAC_F_VERIFY_AUTHENTICATION_TOKEN		 188
+
+/* Reason codes. */
+#define EAC_R_BAD_DH_GENERATOR				 100
+#define EAC_R_BAD_DH_KEY				 110
+#define EAC_R_BAD_DH_OR_ECKEY_OBJECT			 101
+#define EAC_R_CONDITIONS_NOT_SATISFIED			 132
+#define EAC_R_COULD_NOT_DECODE_CA_DP_INFO		 125
+#define EAC_R_COULD_NOT_DECODE_CA_INFO			 126
+#define EAC_R_COULD_NOT_DECODE_EC_KEY			 127
+#define EAC_R_COULD_NOT_DECODE_PACE_DP_INFO		 128
+#define EAC_R_COULD_NOT_DECODE_PACE_INFO		 129
+#define EAC_R_COULD_NOT_DECODE_TA_INFO			 130
+#define EAC_R_CURRENT_CAR_DOES_NOT_MATCH_NEXT_CHR	 111
+#define EAC_R_CURRENT_CHR_DOES_NOT_MATCH_NEXT_CAR	 119
+#define EAC_R_CURRENT_SIGNATURE_NOT_VERIFIED		 120
+#define EAC_R_DATA_IS_NOT_OF_BLOCKLENGTH		 112
+#define EAC_R_FAILED_TO_COPY				 131
+#define EAC_R_FAILED_TO_SET_PADDING			 121
+#define EAC_R_IM_ONLY_SUPPORTED_FOR_TR_201_AND_EARLIER	 122
+#define EAC_R_INCOMPLETE_DOMAIN_PARAMETERS		 123
+#define EAC_R_INCORRECT_DOMAIN_PARAMETERS		 124
+#define EAC_R_INVALID_ARGUMENTS				 102
+#define EAC_R_INVALID_DATA				 106
+#define EAC_R_INVALID_KEY_FORMAT			 118
+#define EAC_R_KEY_TOO_SHORT				 113
+#define EAC_R_MESSAGE_DIGEST_NOT_SUITABLE_FOR_CIPHER	 114
+#define EAC_R_REALLOC_FAILED				 115
+#define EAC_R_UNABLE_TO_GET_ORDER			 103
+#define EAC_R_UNABLE_TO_GET_SG_PRIME			 104
+#define EAC_R_UNKNOWN_CIPHER				 116
+#define EAC_R_UNKNOWN_PACE_PARAMETERS			 107
+#define EAC_R_UNKNOWN_PARAMETERS			 108
+#define EAC_R_UNKNOWN_PROTOCOL				 117
+#define EAC_R_UNSUITED_CURVE				 105
+#define EAC_R_WRONG_PUBLIC_KEY				 109
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/eac_asn1.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_asn1.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,1022 @@
+/**
+ * @file
+ * @brief ASN.1 structures related to PACE
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_asn1.h"
+#include "eac_dh.h"
+#include "pace_lib.h"
+#include <openssl/asn1.h>
+#include <openssl/dh.h>
+#include <openssl/eac.h>
+#include <openssl/ec.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include <openssl/err.h>
+
+/** PACEInfo structure */
+typedef struct pace_info_st {
+    /** OID of the algorithm to be used */
+    ASN1_OBJECT *protocol;
+    /** Protocol Version number. Version number 1 is deprecated, version 2 is
+        recommended */
+    ASN1_INTEGER *version;
+    /** Indicates the domain parameter identifier */
+    ASN1_INTEGER *parameterId;
+    } PACE_INFO;
+
+/** Algorithm Identifier structure */
+typedef struct algorithm_identifier_st {
+    /** OID of the algorithm */
+    ASN1_OBJECT *algorithm;
+    union {
+        PACE_ECPARAMETERS *ec;
+        DH *dh;
+        ASN1_TYPE *other;
+    } parameters;
+    ASN1_INTEGER *standardizedDomainParameters;
+} ALGORITHM_IDENTIFIER;
+
+/** Subject Public Key Info structure */
+typedef struct subject_public_key_info_st {
+    ALGORITHM_IDENTIFIER *algorithmIdentifier;
+    ASN1_BIT_STRING *subjectPublicKey;
+} SUBJECT_PUBLIC_KEY_INFO;
+
+/** Domain parameter structure */
+typedef struct pace_dp_info_st {
+    /** OID of the type of domain parameters*/
+    ASN1_OBJECT *protocol;
+    /** The actual domain parameters */
+    ALGORITHM_IDENTIFIER *aid;
+    /** Optional: specifies the local domain parameters if multiple sets of domain
+        parameters are provided */
+    ASN1_INTEGER *parameterId;
+} PACE_DP_INFO;
+
+/** ChipAuthenticationInfo structure */
+typedef struct ca_info_st {
+    /** OID */
+    ASN1_OBJECT *protocol;
+    /** Protocol Version number. Currently Version 1 and Version 2 are supported */
+    ASN1_INTEGER *version;
+    /** keyID MAY be used to indicate the local key identifier */
+    ASN1_INTEGER *keyId;
+} CA_INFO;
+
+/** CA Domain parameter structure */
+typedef struct ca_dp_info_st {
+    /** OID of the type of domain parameters*/
+    ASN1_OBJECT *protocol;
+    /** The actual domain parameters */
+    ALGORITHM_IDENTIFIER *aid;
+    /** Optional: specifies the local domain parameters if multiple sets of domain
+        parameters are provided */
+    ASN1_INTEGER *keyId;
+} CA_DP_INFO;
+
+/** CA public key info */
+typedef struct ca_public_key_info_st {
+    /** OID of the type of domain parameters*/
+    ASN1_OBJECT *protocol;
+    /** The actual public key */
+    SUBJECT_PUBLIC_KEY_INFO *chipAuthenticationPublicKeyInfo;
+    /** Optional: specifies the local domain parameters if multiple sets of domain
+        parameters are provided */
+    ASN1_INTEGER *keyId;
+} CA_PUBLIC_KEY_INFO;
+
+/** File ID */
+typedef struct file_id_st {
+    /** File identifier */
+    ASN1_OCTET_STRING *fid;
+    /** Short file ifentifier */
+    ASN1_OCTET_STRING *sfid;
+} FILE_ID;
+
+/** TerminalAuthenticationInfo */
+typedef struct ta_info_st {
+    /** OID */
+    ASN1_OBJECT *protocol;
+    /** Protocol Version number. Currently Version 1 and Version 2 are supported */
+    ASN1_INTEGER *version;
+    /** FileIdentifier of EF.CVCA */
+    FILE_ID *efCVCA;
+} TA_INFO;
+
+/** ProtocolParams */
+typedef struct protocol_params_st {
+    /* Protocol version. Currently only version 1 is supported */
+    ASN1_INTEGER *version;
+    /** keyId identifies the private key that shall be used */
+    ASN1_INTEGER *keyId;
+    /** Indicates whether explicit authorization is required to use the
+     * corresponding secret key */
+    ASN1_BOOLEAN *authorizedOnly;
+} PROTOCOL_PARAMS;
+
+/** Restricted Authentication Info*/
+typedef struct ri_info_st {
+    /** OID */
+    ASN1_OBJECT *protocol;
+    /** Protocol parameters */
+    PROTOCOL_PARAMS *params;
+    /** indicates the maximum length of the supported sector
+     * specific public keys */
+    ASN1_INTEGER *maxKeyLen;
+} RI_INFO;
+
+/** Card Info Locator */
+typedef struct card_info_locator_st {
+    /** OID */
+    ASN1_OBJECT *protocol;
+    ASN1_IA5STRING *url;
+    FILE_ID *efCardInfo;
+} CARD_INFO_LOCATOR;
+
+typedef struct dh_pubkey_st {
+    /** Object Identifier */
+    ASN1_OBJECT *oid;
+    /** Prime modulus */
+    ASN1_OCTET_STRING *p;
+    /** Order of the subgroup */
+    ASN1_OCTET_STRING *q;
+    /** Generator */
+    ASN1_OCTET_STRING *g;
+    /** Public value */
+    ASN1_OCTET_STRING *y;
+} DH_PUBKEY_BODY;
+typedef DH_PUBKEY_BODY DH_PUBKEY;
+
+typedef struct ecdh_pubkey_st {
+    /** Object Identifier */
+    ASN1_OBJECT *oid;
+    /** Prime modulus */
+    ASN1_OCTET_STRING *p;
+    /** First coefficient */
+    ASN1_OCTET_STRING *a;
+    /** Second coefficient */
+    ASN1_OCTET_STRING *b;
+    /** Base point
+     * Note: This is an Elliptic Curve Point */
+    ASN1_OCTET_STRING *G;
+    /** Order of the base point */
+    ASN1_OCTET_STRING *r;
+    /** Public point
+     * Note: This is an Elliptic Curve Point */
+    ASN1_OCTET_STRING *Y;
+    /** Cofactor */
+    ASN1_OCTET_STRING *f;
+} ECDH_PUBKEY_BODY;
+typedef ECDH_PUBKEY_BODY ECDH_PUBKEY;
+
+static unsigned int
+getlen (unsigned const char * in, unsigned int * len_len, const unsigned int max_len);
+static int
+dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg);
+
+/* the OpenSSL ASN.1 definitions */
+ASN1_SEQUENCE(PACE_X9_62_PENTANOMIAL) = {
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k1, LONG),
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k2, LONG),
+    ASN1_SIMPLE(PACE_X9_62_PENTANOMIAL, k3, LONG)
+} ASN1_SEQUENCE_END(PACE_X9_62_PENTANOMIAL)
+
+ASN1_ADB_TEMPLATE(char_two_def) = ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.other, ASN1_ANY);
+
+ASN1_ADB(PACE_X9_62_CHARACTERISTIC_TWO) = {
+    ADB_ENTRY(NID_X9_62_onBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.onBasis, ASN1_NULL)),
+    ADB_ENTRY(NID_X9_62_tpBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.tpBasis, ASN1_INTEGER)),
+    ADB_ENTRY(NID_X9_62_ppBasis, ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, p.ppBasis, PACE_X9_62_PENTANOMIAL))
+} ASN1_ADB_END(PACE_X9_62_CHARACTERISTIC_TWO, 0, type, 0, &char_two_def_tt, NULL);
+
+ASN1_SEQUENCE(PACE_X9_62_CHARACTERISTIC_TWO) = {
+    ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, m, LONG),
+    ASN1_SIMPLE(PACE_X9_62_CHARACTERISTIC_TWO, type, ASN1_OBJECT),
+    ASN1_ADB_OBJECT(PACE_X9_62_CHARACTERISTIC_TWO)
+} ASN1_SEQUENCE_END(PACE_X9_62_CHARACTERISTIC_TWO)
+
+ASN1_ADB_TEMPLATE(fieldID_def) = ASN1_SIMPLE(PACE_X9_62_FIELDID, p.other, ASN1_ANY);
+
+ASN1_ADB(PACE_X9_62_FIELDID) = {
+    ADB_ENTRY(NID_X9_62_prime_field, ASN1_SIMPLE(PACE_X9_62_FIELDID, p.prime, ASN1_INTEGER)),
+    ADB_ENTRY(NID_X9_62_characteristic_two_field, ASN1_SIMPLE(PACE_X9_62_FIELDID, p.char_two, PACE_X9_62_CHARACTERISTIC_TWO))
+} ASN1_ADB_END(PACE_X9_62_FIELDID, 0, fieldType, 0, &fieldID_def_tt, NULL);
+
+ASN1_SEQUENCE(PACE_X9_62_FIELDID) = {
+    ASN1_SIMPLE(PACE_X9_62_FIELDID, fieldType, ASN1_OBJECT),
+    ASN1_ADB_OBJECT(PACE_X9_62_FIELDID)
+} ASN1_SEQUENCE_END(PACE_X9_62_FIELDID)
+
+ASN1_SEQUENCE(PACE_X9_62_CURVE) = {
+    ASN1_SIMPLE(PACE_X9_62_CURVE, a, ASN1_OCTET_STRING),
+    ASN1_SIMPLE(PACE_X9_62_CURVE, b, ASN1_OCTET_STRING),
+    ASN1_OPT(PACE_X9_62_CURVE, seed, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(PACE_X9_62_CURVE)
+
+ASN1_SEQUENCE(PACE_ECPARAMETERS) = {
+    ASN1_SIMPLE(PACE_ECPARAMETERS, version, ASN1_INTEGER),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, fieldID, PACE_X9_62_FIELDID),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, curve, PACE_X9_62_CURVE),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, base, ASN1_OCTET_STRING),
+    ASN1_SIMPLE(PACE_ECPARAMETERS, order, ASN1_INTEGER),
+    ASN1_OPT(PACE_ECPARAMETERS, cofactor, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_ECPARAMETERS)
+
+/* I stole this from dh_asn1.c */
+ASN1_SEQUENCE_cb(PACE_DHparams, dh_cb) = {
+    ASN1_SIMPLE(DH, p, BIGNUM),
+    ASN1_SIMPLE(DH, g, BIGNUM),
+    ASN1_OPT(DH, length, ZLONG),
+} ASN1_SEQUENCE_END_cb(DH, PACE_DHparams)
+
+ASN1_SEQUENCE(PACE_INFO) = {
+    ASN1_SIMPLE(PACE_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(PACE_INFO, version, ASN1_INTEGER),
+    ASN1_OPT(PACE_INFO, parameterId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(PACE_INFO)
+
+ASN1_ADB_TEMPLATE(aid_def) = ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.other, ASN1_ANY);
+
+ASN1_ADB(ALGORITHM_IDENTIFIER) = {
+    ADB_ENTRY(NID_ecka_dh_SessionKDF_AES128, ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.ec, PACE_ECPARAMETERS)),
+    ADB_ENTRY(NID_dhpublicnumber, ASN1_SIMPLE(ALGORITHM_IDENTIFIER, parameters.dh, PACE_DHparams)),
+    ADB_ENTRY(NID_standardizedDomainParameters, ASN1_SIMPLE(ALGORITHM_IDENTIFIER, standardizedDomainParameters, ASN1_INTEGER))
+} ASN1_ADB_END(ALGORITHM_IDENTIFIER, 0, algorithm, 0, &aid_def_tt, NULL);
+
+ASN1_SEQUENCE(ALGORITHM_IDENTIFIER) = {
+    ASN1_SIMPLE(ALGORITHM_IDENTIFIER, algorithm, ASN1_OBJECT),
+    ASN1_ADB_OBJECT(ALGORITHM_IDENTIFIER)
+} ASN1_SEQUENCE_END(ALGORITHM_IDENTIFIER)
+
+ASN1_SEQUENCE(SUBJECT_PUBLIC_KEY_INFO) = {
+        ASN1_SIMPLE(SUBJECT_PUBLIC_KEY_INFO, algorithmIdentifier, ALGORITHM_IDENTIFIER),
+        ASN1_SIMPLE(SUBJECT_PUBLIC_KEY_INFO, subjectPublicKey, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(SUBJECT_PUBLIC_KEY_INFO)
+
+/* PACEDomainParameterInfo */
+ASN1_SEQUENCE(PACE_DP_INFO) = {
+    ASN1_SIMPLE(PACE_DP_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(PACE_DP_INFO, aid, ALGORITHM_IDENTIFIER),
+    ASN1_OPT(PACE_DP_INFO, parameterId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(PACE_DP_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(PACE_DP_INFO)
+
+/* ChipAuthenticationInfo */
+ASN1_SEQUENCE(CA_INFO) = {
+    ASN1_SIMPLE(CA_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(CA_INFO, version, ASN1_INTEGER),
+    ASN1_OPT(CA_INFO, keyId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CA_INFO)
+IMPLEMENT_ASN1_FUNCTIONS(CA_INFO)
+
+/* ChipAuthenticationDomainParameterInfo */
+ASN1_SEQUENCE(CA_DP_INFO) = {
+    ASN1_SIMPLE(CA_DP_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(CA_DP_INFO, aid, ALGORITHM_IDENTIFIER),
+    ASN1_OPT(CA_DP_INFO, keyId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CA_DP_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(CA_DP_INFO)
+
+/* ChipAuthenticationPublicKeyInfo */
+ASN1_SEQUENCE(CA_PUBLIC_KEY_INFO) = {
+        ASN1_SIMPLE(CA_PUBLIC_KEY_INFO, protocol, ASN1_OBJECT),
+        ASN1_SIMPLE(CA_PUBLIC_KEY_INFO, chipAuthenticationPublicKeyInfo, SUBJECT_PUBLIC_KEY_INFO),
+        ASN1_OPT(CA_PUBLIC_KEY_INFO, keyId, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(CA_PUBLIC_KEY_INFO)
+
+/* FileId */
+ASN1_SEQUENCE(FILE_ID) = {
+    ASN1_SIMPLE(FILE_ID, fid, ASN1_OCTET_STRING),
+    ASN1_OPT(FILE_ID, sfid, ASN1_OCTET_STRING)
+} ASN1_SEQUENCE_END(FILE_ID)
+
+/* TerminalAuthenticationInfo */
+ASN1_SEQUENCE(TA_INFO) = {
+    ASN1_SIMPLE(TA_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(TA_INFO, version, ASN1_INTEGER),
+    ASN1_OPT(TA_INFO, efCVCA, FILE_ID)
+} ASN1_SEQUENCE_END(TA_INFO)
+IMPLEMENT_ASN1_FUNCTIONS(TA_INFO)
+
+/* ProtocolParams */
+ASN1_SEQUENCE(PROTOCOL_PARAMS) = {
+    ASN1_SIMPLE(PROTOCOL_PARAMS, version, ASN1_INTEGER),
+    ASN1_SIMPLE(PROTOCOL_PARAMS, keyId, ASN1_INTEGER),
+    ASN1_SIMPLE(PROTOCOL_PARAMS, authorizedOnly, ASN1_BOOLEAN)
+} ASN1_SEQUENCE_END(PROTOCOL_PARAMS)
+
+/* RestrictedIdentificationInfo */
+ASN1_SEQUENCE(RI_INFO) = {
+    ASN1_SIMPLE(RI_INFO, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(RI_INFO, params, PROTOCOL_PARAMS),
+    ASN1_OPT(RI_INFO, maxKeyLen, ASN1_INTEGER)
+} ASN1_SEQUENCE_END(RI_INFO)
+
+/* TODO: RestrictedIdentificationDomainParameterInfo */
+
+/* CardInfoLocator */
+ASN1_SEQUENCE(CARD_INFO_LOCATOR) = {
+    ASN1_SIMPLE(CARD_INFO_LOCATOR, protocol, ASN1_OBJECT),
+    ASN1_SIMPLE(CARD_INFO_LOCATOR, url, ASN1_IA5STRING),
+    ASN1_OPT(CARD_INFO_LOCATOR, efCardInfo, FILE_ID)
+} ASN1_SEQUENCE_END(CARD_INFO_LOCATOR)
+
+ASN1_SEQUENCE(DH_PUBKEY_BODY) = {
+    ASN1_SIMPLE(DH_PUBKEY_BODY, oid, ASN1_OBJECT),
+    ASN1_IMP_OPT(DH_PUBKEY_BODY, p, ASN1_OCTET_STRING, 1),
+    ASN1_IMP_OPT(DH_PUBKEY_BODY, q, ASN1_OCTET_STRING, 2),
+    ASN1_IMP_OPT(DH_PUBKEY_BODY, g, ASN1_OCTET_STRING, 3),
+    ASN1_IMP(DH_PUBKEY_BODY, y, ASN1_OCTET_STRING, 4),
+} ASN1_SEQUENCE_END(DH_PUBKEY_BODY)
+IMPLEMENT_ASN1_FUNCTIONS(DH_PUBKEY_BODY)
+
+ASN1_ITEM_TEMPLATE(DH_PUBKEY) =
+    ASN1_EX_TEMPLATE_TYPE(
+            ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION,
+            0x49, DH_PUBKEY, DH_PUBKEY_BODY)
+ASN1_ITEM_TEMPLATE_END(DH_PUBKEY)
+IMPLEMENT_ASN1_FUNCTIONS(DH_PUBKEY)
+
+ASN1_SEQUENCE(ECDH_PUBKEY_BODY) = {
+    ASN1_SIMPLE(ECDH_PUBKEY_BODY, oid, ASN1_OBJECT),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, p, ASN1_OCTET_STRING, 1),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, a, ASN1_OCTET_STRING, 2),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, b, ASN1_OCTET_STRING, 3),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, G, ASN1_OCTET_STRING, 4),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, r, ASN1_OCTET_STRING, 5),
+    ASN1_IMP(ECDH_PUBKEY_BODY, Y, ASN1_OCTET_STRING, 6),
+    ASN1_IMP_OPT(ECDH_PUBKEY_BODY, f, ASN1_OCTET_STRING, 7),
+} ASN1_SEQUENCE_END(ECDH_PUBKEY_BODY)
+IMPLEMENT_ASN1_FUNCTIONS(ECDH_PUBKEY_BODY)
+
+ASN1_ITEM_TEMPLATE(ECDH_PUBKEY) =
+    ASN1_EX_TEMPLATE_TYPE(
+            ASN1_TFLG_IMPTAG|ASN1_TFLG_APPLICATION,
+            0x49, ECDH_PUBKEY, ECDH_PUBKEY_BODY)
+ASN1_ITEM_TEMPLATE_END(ECDH_PUBKEY)
+IMPLEMENT_ASN1_FUNCTIONS(ECDH_PUBKEY)
+
+static int
+dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
+{
+    if(operation == ASN1_OP_NEW_PRE) {
+        *pval = (ASN1_VALUE *)DH_new();
+        if(*pval) return 2;
+        return 0;
+    } else if(operation == ASN1_OP_FREE_PRE) {
+        DH_free((DH *)*pval);
+        *pval = NULL;
+        return 2;
+    }
+    return 1;
+}
+
+
+int
+EAC_ec_key_from_asn1(EC_KEY **key, ASN1_OCTET_STRING *p, ASN1_OCTET_STRING *a,
+        ASN1_OCTET_STRING *b, ASN1_OCTET_STRING *base, ASN1_OCTET_STRING *base_order,
+        ASN1_OCTET_STRING *pub, ASN1_OCTET_STRING *cofactor, BN_CTX *bn_ctx)
+{
+    int ret = 0;
+    BIGNUM *p_bn = NULL, *cofactor_bn = NULL, *order_bn = NULL, *a_bn = NULL,
+            *b_bn = NULL;
+    EC_GROUP *group = NULL;
+    EC_POINT *generator = NULL, *pub_point = NULL;
+    EC_KEY *tmp = NULL;
+
+    if (!key || !p || !a || !b || !base || !base_order || !cofactor) {
+        EACerr(EAC_F_EAC_EC_KEY_FROM_ASN1, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    p_bn = BN_new();
+    a_bn = BN_new();
+    b_bn = BN_new();
+    order_bn = BN_new();
+    cofactor_bn = BN_new();
+
+    if (!p_bn || !a_bn || !b_bn || !order_bn || !cofactor_bn)
+        goto err;
+
+    /* Copy field and curve */
+    if (!BN_bin2bn(ASN1_STRING_data(p), ASN1_STRING_length(p), p_bn) ||
+        !BN_bin2bn(ASN1_STRING_data(a), ASN1_STRING_length(a), a_bn) ||
+        !BN_bin2bn(ASN1_STRING_data(b), ASN1_STRING_length(b), b_bn))
+            goto err;
+    else
+        group = EC_GROUP_new_curve_GFp(p_bn, a_bn, b_bn, bn_ctx);
+
+    if (!group)
+        goto err;
+
+    /* Set generator, order and cofactor */
+    if (!ASN1_INTEGER_to_BN(cofactor, cofactor_bn) ||
+        !ASN1_INTEGER_to_BN(base_order, order_bn))
+            goto err;
+
+    generator = EC_POINT_new(group);
+    if (!generator)
+        goto err;
+
+    if (!EC_POINT_oct2point(group, generator, ASN1_STRING_data(base),
+            ASN1_STRING_length(base), bn_ctx))
+        goto err;
+
+    if (!EC_GROUP_set_generator(group, generator, order_bn, cofactor_bn))
+        goto err;
+
+    if (!*key) {
+        tmp = EC_KEY_new();
+        if(!tmp)
+            goto err;
+    } else
+        tmp = *key;
+
+    /* Set the group for the key*/
+    if(!EC_KEY_set_group(tmp, group))
+        goto err;
+
+    /* Set the public point if available */
+    if (pub) {
+        pub_point = EC_POINT_new(group);
+        if (!pub_point)
+            goto err;
+
+        if (!EC_POINT_oct2point(group, pub_point, ASN1_STRING_data(pub),
+                ASN1_STRING_length(pub), bn_ctx))
+            goto err;
+
+        if (!EC_KEY_set_public_key(tmp, pub_point))
+            goto err;
+    }
+
+    if (!*key)
+        *key = tmp;
+
+    ret = 1;
+
+err:
+    if (!ret && tmp && key && !*key)
+        EC_KEY_free(tmp);
+    if (group)
+        EC_GROUP_clear_free(group);
+    if (generator)
+        EC_POINT_clear_free(generator);
+    if (pub_point)
+        EC_POINT_clear_free(pub_point);
+    if(cofactor_bn)
+        BN_clear_free(cofactor_bn);
+    if(order_bn)
+        BN_clear_free(order_bn);
+    if(a_bn)
+        BN_clear_free(a_bn);
+    if(b_bn)
+        BN_clear_free(b_bn);
+    if(p_bn)
+        BN_clear_free(p_bn);
+
+    return ret;
+}
+
+static EC_KEY *
+ec_key_from_PACE_ECPARAMETERS(const PACE_ECPARAMETERS *ec_params, BN_CTX *bn_ctx)
+{
+    EC_KEY *ec = NULL;
+
+    if (!ec_params || !ec_params->fieldID || !ec_params->curve) {
+        EACerr(EAC_F_EC_KEY_FROM_PACE_ECPARAMETERS, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    ec = EC_KEY_new();
+    if (!ec)
+        goto err;
+
+    if (!EAC_ec_key_from_asn1(&ec, ec_params->fieldID->p.prime, ec_params->curve->a,
+            ec_params->curve->b, ec_params->base, ec_params->order, NULL,
+            ec_params->cofactor, bn_ctx))
+            goto err;
+
+    return ec;
+
+err:
+    if (ec)
+        EC_KEY_free(ec);
+    return NULL;
+}
+
+/**
+ * @brief Decode the length field of an ASN.1 DER encoded buffer
+ * @param[in] in pointer to the beginning of the length field of the buffer
+ * @param[out] len_len the length of the length field will be stored here
+ * @return the decoded length or 0 in case of an error
+ */
+
+static unsigned int
+getlen (const unsigned char *in, unsigned int *len_len, const unsigned int max_len)
+{
+    unsigned int len = 0;
+    unsigned int i = 0;
+
+    if (!in || !len_len || !max_len)
+        return 0;
+
+    if ((in[0] & 0x80) == 0x80 ) { /* MSB set => long form */
+        *len_len = (in[0] & 0x7F) + 1;
+        if (*len_len > max_len)
+            goto err;
+
+            for (i = 0; i < *len_len - 1; i++) {
+            len <<= i*8;
+            len += in[i+1];
+            /* Check if the ASN.1 length encoded length is bigger than our buffer */
+            if (len > max_len)
+                goto err;
+        }
+    }
+    else {/* MSB not set => short form */
+        len = (unsigned int) in[0];
+        *len_len = 1;
+        /* Check if the ASN.1 length encoded length is bigger than our buffer */
+        if (len > max_len)
+            goto err;
+    }
+    return len;
+
+err:
+    *len_len = 0;
+    return 0;
+}
+
+int
+EAC_CTX_init_ef_cardaccess(const unsigned char * in, unsigned int in_len,
+        EAC_CTX *ctx)
+{
+    unsigned int len = 0, len_len = 0, oid_len = 0;
+    unsigned int todo = 0;
+    ASN1_OBJECT *a = NULL;
+    unsigned const char *oid_pos = NULL, *seq_pos = NULL;
+    int nid, ret = 0;
+    PACE_INFO *tmp_info = NULL;
+    PACE_DP_INFO *tmp_dp_info = NULL;
+TA_INFO *tmp_ta_info = NULL;
+    CA_INFO *tmp_ca_info = NULL;
+    CA_DP_INFO *tmp_ca_dp_info = NULL;
+    EC_KEY *tmp_ec = NULL;
+
+    if (!in || !ctx || !ctx->pace_ctx || !ctx->ca_ctx || !ctx->ta_ctx) {
+        EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (in[0] != 0x31) /* SET */ {
+        EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_INVALID_DATA);
+        goto err;
+    }
+
+    len = getlen(++in, &len_len, in_len - 1); /* Length of SET */
+    /* Check length of input against ASN.1 encoded length */
+    if (in_len < len + len_len + 1) { /* 1 Byte tag + length of the length field + length of data */
+        EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_INVALID_DATA);
+        goto err;
+    }
+
+    in += len_len;
+    todo = len;
+    while(todo > 0) { /* Manually extract all members of the SET OF SecurityInfos */
+        if(in[0] != 0x30) { /* SEQUENCE */
+            EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_INVALID_DATA);
+            goto err;
+        }
+
+        seq_pos = in;
+        len = getlen(++in, &len_len, todo - 1); /* Length of SEQUENCE */
+        oid_pos = in + len_len;
+        in += len + len_len;
+        todo -= len_len + 1;
+
+        /* Read OID */
+        if(oid_pos[0] != 0x06) { /* OBJECT IDENTIFIER */
+            EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_INVALID_DATA);
+            goto err;
+        }
+        oid_len = getlen(oid_pos+1, &len_len, todo); /* Length of OBJECT IDENTIFIER */
+        todo -= len; /* Point todo past the SEQUENCE */
+
+        /* XXX: I don't understand, why we have to increment the last parameter
+         *      by two. This was found to work by trial and error. */
+        if (d2i_ASN1_OBJECT(&a, &oid_pos, oid_len+2) == NULL)
+            goto err;
+
+        nid = OBJ_obj2nid(a);
+        switch (nid) {
+            /* PACEInfo */
+            case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+            case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+            case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+            case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+            case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+            case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+                tmp_info = d2i_PACE_INFO(NULL, &seq_pos, len+2);
+                if (!tmp_info) {
+                    EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_PACE_INFO);
+                    goto err;
+                }
+
+                ctx->pace_ctx->version = ASN1_INTEGER_get(tmp_info->version);
+                if (ctx->pace_ctx->version <= 0 || ctx->pace_ctx->version > 2)
+                    goto err;
+
+                ctx->pace_ctx->protocol = OBJ_obj2nid(tmp_info->protocol);
+
+                if(tmp_info->parameterId) {
+                    /* If we have standardized domain parameters we use them
+                     * to generate a static key */
+                    if (!EAC_CTX_init_pace(ctx,
+                                ctx->pace_ctx->protocol,
+                                (int) ASN1_INTEGER_get(tmp_info->parameterId)))
+                        goto err;
+                } else {
+                    /* Otherwise we only use the protocol OID to setup our
+                     * PACE context and hope to find a key in the proprietary
+                     * PACEDomainParameterInfo */
+                    if (!PACE_CTX_set_protocol(ctx->pace_ctx, ctx->pace_ctx->protocol, ctx->tr_version))
+                        goto err;
+                }
+                PACE_INFO_free(tmp_info);
+                tmp_info = NULL;
+                break;
+            /* PACEDomainParameterInfo */
+            case NID_id_PACE_ECDH_GM:
+            case NID_id_PACE_ECDH_IM:
+            case NID_id_PACE_DH_GM:
+            case NID_id_PACE_DH_IM:
+                tmp_dp_info = d2i_PACE_DP_INFO(NULL, &seq_pos, len+3);
+                if (!tmp_dp_info) {
+                    EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_PACE_DP_INFO);
+                    goto err;
+                }
+
+                /* If there is no key, allocate memory */
+                if (!ctx->pace_ctx->static_key)
+                    ctx->pace_ctx->static_key = EVP_PKEY_new();
+                if (!ctx->pace_ctx->static_key)
+                    goto err;
+
+                /* Extract actual parameters */
+                switch (OBJ_obj2nid(tmp_dp_info->aid->algorithm)) {
+                    case NID_dhpublicnumber:
+                        EVP_PKEY_set1_DH(ctx->pace_ctx->static_key,
+                                tmp_dp_info->aid->parameters.dh);
+                        break;
+                    case NID_X9_62_id_ecPublicKey:
+                    case NID_ecka_dh_SessionKDF_DES3:
+                    case NID_ecka_dh_SessionKDF_AES128:
+                    case NID_ecka_dh_SessionKDF_AES192:
+                    case NID_ecka_dh_SessionKDF_AES256:
+                        tmp_ec = ec_key_from_PACE_ECPARAMETERS(tmp_dp_info->aid->parameters.ec, ctx->bn_ctx);
+                        if (!tmp_ec) {
+                            EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_EC_KEY);
+                            goto err;
+                        }
+
+                        EVP_PKEY_set1_EC_KEY(ctx->pace_ctx->static_key,
+                                tmp_ec);
+                        break;
+                    default:
+                        EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_UNKNOWN_PACE_PARAMETERS);
+                        goto err;
+                }
+                PACE_DP_INFO_free(tmp_dp_info);
+                tmp_dp_info = NULL;
+                break;
+            /* TAInfo */
+            case NID_id_TA:
+                tmp_ta_info = d2i_TA_INFO(NULL, &seq_pos, len+2);
+                if (!tmp_ta_info) {
+                    EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_TA_INFO);
+                    goto err;
+                }
+
+                ctx->ta_ctx->version = ASN1_INTEGER_get(tmp_ta_info->version);
+                if (ctx->ta_ctx->version <= 0 || ctx->ta_ctx->version > 2)
+                    goto err;
+                /* OID in TAInfo is less specific than the one in the certificate
+                 * Therefore this OID will be overwritten when we import a certificate
+                 * later on.*/
+                ctx->ta_ctx->protocol = OBJ_obj2nid(tmp_ta_info->protocol);
+                TA_INFO_free(tmp_ta_info);
+                tmp_ta_info = NULL;
+                break;
+            /* CAINfo */
+            case NID_id_CA_DH_3DES_CBC_CBC:
+            case NID_id_CA_DH_AES_CBC_CMAC_128 :
+            case NID_id_CA_DH_AES_CBC_CMAC_192 :
+            case NID_id_CA_DH_AES_CBC_CMAC_256 :
+            case NID_id_CA_ECDH_3DES_CBC_CBC :
+            case NID_id_CA_ECDH_AES_CBC_CMAC_128 :
+            case NID_id_CA_ECDH_AES_CBC_CMAC_192 :
+            case NID_id_CA_ECDH_AES_CBC_CMAC_256 :
+                tmp_ca_info = d2i_CA_INFO(NULL, &seq_pos, len+2);
+                if (!tmp_ca_info) {
+                    EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_CA_INFO);
+                    goto err;
+                }
+
+                ctx->ca_ctx->version = ASN1_INTEGER_get(tmp_ca_info->version);
+                if (ctx->ta_ctx->version <= 0 || ctx->ta_ctx->version > 2)
+                    goto err;
+                ctx->ca_ctx->protocol = OBJ_obj2nid(tmp_ca_info->protocol);
+                CA_INFO_free(tmp_ca_info);
+                tmp_ca_info = NULL;
+                break;
+            /* CADomainParameterInfo */
+            case NID_id_CA_DH:
+            case NID_id_CA_ECDH:
+                /* HACK: the obscure offset (see line 621) must be 3 and not 2 for
+                 * CADomainParameterInfo */
+                tmp_ca_dp_info = d2i_CA_DP_INFO(NULL, &seq_pos, len+3);
+                if (!tmp_ca_dp_info) {
+                    EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_COULD_NOT_DECODE_CA_DP_INFO);
+                    goto err;
+                }
+
+                /* TODO: Copy all the public keys into the EAC context. As of now
+                 * EAC_CTX can only hold one CA public key. */
+
+                CA_DP_INFO_free(tmp_ca_dp_info);
+                tmp_ca_dp_info = NULL;
+                break;
+            /* CAPublicKeyInfo */
+            case NID_id_PK_DH:
+            case NID_id_PK_ECDH:
+                break;
+            /* ChipIdentifer */
+            case NID_id_CI:
+                break;
+            case NID_id_PT:
+                break;
+            default:
+                EACerr(EAC_F_EAC_CTX_INIT_EF_CARDACCESS, EAC_R_UNKNOWN_PARAMETERS);
+                break;
+        }
+    }
+
+    ret = 1;
+
+err:
+    if (a)
+        ASN1_OBJECT_free(a);
+    if (tmp_info)
+        PACE_INFO_free(tmp_info);
+    if (tmp_dp_info)
+        PACE_DP_INFO_free(tmp_dp_info);
+    if (tmp_ta_info)
+        TA_INFO_free(tmp_ta_info);
+    if (tmp_ca_info)
+        CA_INFO_free(tmp_ca_info);
+    if (tmp_ec)
+        EC_KEY_free(tmp_ec);
+    return ret;
+}
+
+static ASN1_OCTET_STRING *
+BN_to_ASN1_UNSIGNED_INTEGER(const BIGNUM *bn, ASN1_OCTET_STRING *in)
+{
+    BUF_MEM *bn_buf = NULL;
+    ASN1_OCTET_STRING *out;
+
+    if (!in) {
+        out = ASN1_OCTET_STRING_new();
+    } else {
+        out = in;
+    }
+
+    bn_buf = BN_bn2buf(bn);
+
+    if (!bn_buf || !out
+            /* BIGNUMs converted to binary don't have a sign,
+             * so we copy everything to the octet string */
+            || !M_ASN1_OCTET_STRING_set(out, bn_buf->data, bn_buf->length))
+        goto err;
+
+    BUF_MEM_free(bn_buf);
+
+    return out;
+
+err:
+    if (bn_buf)
+        BUF_MEM_free(bn_buf);
+    if (out && !in)
+        ASN1_OCTET_STRING_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+asn1_pubkey(int protocol, EVP_PKEY *key, BN_CTX *bn_ctx, enum eac_tr_version tr_version)
+{
+    EC_KEY *ec = NULL;
+    ECDH_PUBKEY *ecdhpub = NULL;
+    DH *dh = NULL;
+    DH_PUBKEY *dhpub = NULL;
+    BIGNUM *bn = NULL, *a_bn = NULL, *b_bn = NULL;
+    const EC_GROUP *group;
+    BUF_MEM *pubkey = NULL, *Y_buf = NULL, *G_buf = NULL;
+    int l;
+
+    if (!key) {
+        EACerr(EAC_F_ASN1_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    pubkey = BUF_MEM_new();
+    if (!pubkey)
+        goto err;
+
+    switch (EVP_PKEY_type(key->type)) {
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(key);
+            if (!dh)
+                goto err;
+
+            dhpub = DH_PUBKEY_new();
+            if (!dhpub) {
+                goto err;
+            }
+
+            /* Object Identifier */
+            dhpub->oid = OBJ_nid2obj(protocol);
+
+            /* Public value */
+            dhpub->y = BN_to_ASN1_UNSIGNED_INTEGER(dh->pub_key, dhpub->y);
+
+            if (!dhpub->oid || !dhpub->y)
+                goto err;
+
+            if (tr_version == EAC_TR_VERSION_2_01) {
+                /* Prime modulus */
+                dhpub->p = BN_to_ASN1_UNSIGNED_INTEGER(dh->p, dhpub->p);
+
+                /* Order of the subgroup */
+                bn = DH_get_order(dh, bn_ctx);
+                if (!bn)
+                    goto err;
+                dhpub->q = BN_to_ASN1_UNSIGNED_INTEGER(bn, dhpub->q);
+
+                /* Generator */
+                dhpub->g = BN_to_ASN1_UNSIGNED_INTEGER(dh->g, dhpub->g);
+
+                if (!dhpub->p|| !dhpub->q || !dhpub->g)
+                    goto err;
+
+                BN_clear_free(bn);
+            }
+
+            l = i2d_DH_PUBKEY(dhpub, (unsigned char **) &pubkey->data);
+            if (l < 0)
+                goto err;
+            pubkey->length = l;
+            pubkey->max = l;
+
+            DH_PUBKEY_free(dhpub);
+
+            break;
+
+        case EVP_PKEY_EC:
+            ec = EVP_PKEY_get1_EC_KEY(key);
+            if (!ec)
+                goto err;
+            group = EC_KEY_get0_group(ec);
+
+            ecdhpub = ECDH_PUBKEY_new();
+            if (!ecdhpub) {
+                goto err;
+            }
+
+            /* Object Identifier */
+            ecdhpub->oid = OBJ_nid2obj(protocol);
+            if (!ecdhpub->oid)
+                goto err;
+
+            /* Public point */
+            Y_buf = EC_POINT_point2buf(ec, bn_ctx, EC_KEY_get0_public_key(
+                        ec));
+
+            if (!Y_buf || !M_ASN1_OCTET_STRING_set(ecdhpub->Y, Y_buf->data,
+                        Y_buf->length))
+                goto err;
+
+            if (tr_version == EAC_TR_VERSION_2_01) {
+                bn = BN_new();
+                a_bn = BN_new();
+                b_bn = BN_new();
+                if (!bn || !a_bn || !b_bn
+                        || !EC_GROUP_get_curve_GFp(group, bn, a_bn, b_bn, bn_ctx))
+                    goto err;
+
+                /* Prime modulus */
+                ecdhpub->p = BN_to_ASN1_UNSIGNED_INTEGER(bn, ecdhpub->p);
+
+                /* First coefficient */
+                ecdhpub->a = BN_to_ASN1_UNSIGNED_INTEGER(a_bn, ecdhpub->a);
+
+                /* Second coefficient */
+                ecdhpub->b = BN_to_ASN1_UNSIGNED_INTEGER(b_bn, ecdhpub->b);
+
+                /* Base Point */
+                G_buf = EC_POINT_point2buf(ec, bn_ctx,
+                        EC_GROUP_get0_generator(group));
+                ecdhpub->G = ASN1_OCTET_STRING_new();
+                if (!ecdhpub->G
+                        || !M_ASN1_OCTET_STRING_set(
+                            ecdhpub->G, G_buf->data, G_buf->length))
+                    goto err;
+
+                /* Order of the base point */
+                if (!EC_GROUP_get_order(group, bn, bn_ctx))
+                    goto err;
+                ecdhpub->r = BN_to_ASN1_UNSIGNED_INTEGER(bn, ecdhpub->r);
+
+                /* Cofactor */
+                if (!EC_GROUP_get_cofactor(group, bn, bn_ctx))
+                    goto err;
+                ecdhpub->f = BN_to_ASN1_UNSIGNED_INTEGER(bn, ecdhpub->f);
+
+                if (!ecdhpub->p || !ecdhpub->a || !ecdhpub->b || !ecdhpub->r ||
+                        !ecdhpub->f)
+                    goto err;
+
+                BUF_MEM_free(G_buf);
+                BN_clear_free(b_bn);
+                BN_clear_free(a_bn);
+                BN_clear_free(bn);
+            }
+
+            BUF_MEM_free(Y_buf);
+
+            l = i2d_ECDH_PUBKEY(ecdhpub, (unsigned char **) &pubkey->data);
+            if (l < 0)
+                goto err;
+            pubkey->length = l;
+            pubkey->max = l;
+
+            ECDH_PUBKEY_free(ecdhpub);
+
+            break;
+
+        default:
+            goto err;
+    }
+
+    /* Decrease reference count, keys are still available in EVP_PKEY structure */
+    if (dh)
+        DH_free(dh);
+    if (ec)
+        EC_KEY_free(ec);
+
+    return pubkey;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (a_bn)
+        BN_clear_free(a_bn);
+    if (b_bn)
+        BN_clear_free(b_bn);
+    if (Y_buf)
+        BUF_MEM_free(Y_buf);
+    if (G_buf)
+        BUF_MEM_free(G_buf);
+    if (pubkey)
+        BUF_MEM_free(pubkey);
+    if (ecdhpub)
+        ECDH_PUBKEY_free(ecdhpub);
+    if (dhpub)
+        DH_PUBKEY_free(dhpub);
+    /* Decrease reference count, keys are still available in EVP_PKEY structure */
+    if (dh)
+        DH_free(dh);
+    if (ec)
+        EC_KEY_free(ec);
+
+    return NULL;
+}
Index: openssl/crypto/eac/eac_asn1.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_asn1.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,44 @@
+/**
+ * @file
+ * @brief Interface to ASN.1 structures related to PACE
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_ASN1_H_
+#define PACE_ASN1_H_
+
+#include <openssl/bn.h>
+#include <openssl/eac.h>
+#include <openssl/evp.h>
+
+/**
+ * @brief Encodes public key data objects of the domain parameters in ASN.1
+ * (see TR-3110 D.3.2 and D.3.3)
+ *
+ * @return ASN.1 encoded public key data objects or NULL if an error occurred
+ */
+BUF_MEM *
+asn1_pubkey(int protocol, EVP_PKEY *key, BN_CTX *bn_ctx, enum eac_tr_version tr_version);
+
+/**
+ * @brief Generate an EC Key from the ASN1 encoded parameters. This function is
+ * needed because asn1.h does not export a d2i_asn1 function
+ *
+ * @param[out] key where to write the new EC key
+ * @param[in] p prime modulus of the field
+ * @param[in] a first coefficient of the curve
+ * @param[in] b second coefficient of the curve
+ * @param[in] base generator of the curve
+ * @param[in] base_order order of the generator
+ * @param[in] pub public point of the key
+ * @param[in] cofactor
+ * @param[in] bn_ctx (optional)
+ */
+int
+EAC_ec_key_from_asn1(EC_KEY **key, ASN1_OCTET_STRING *p, ASN1_OCTET_STRING *a,
+        ASN1_OCTET_STRING *b, ASN1_OCTET_STRING *base, ASN1_OCTET_STRING *base_order,
+        ASN1_OCTET_STRING *pub, ASN1_OCTET_STRING *cofactor, BN_CTX *bn_ctx);
+
+#endif /* PACE_ASN1_H_ */
Index: openssl/crypto/eac/eac_ca.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_ca.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,162 @@
+/**
+ * @file
+ * @brief Chip Authentication implementation
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_asn1.h"
+#include "eac_util.h"
+#include "eac_lib.h"
+#include <openssl/ca.h>
+#include <openssl/evp.h>
+#include <openssl/ec.h>
+#include <openssl/dh.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include <string.h>
+
+BUF_MEM *
+CA_STEP1_get_pubkey(const EAC_CTX *ctx)
+{
+    if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx) {
+        EACerr(EAC_F_CA_STEP1_GET_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return asn1_pubkey(ctx->ca_ctx->protocol, ctx->ca_ctx->ka_ctx->key,
+            ctx->bn_ctx, ctx->tr_version);
+}
+
+BUF_MEM *
+CA_STEP2_get_eph_pubkey(const EAC_CTX *ctx)
+{
+    if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx) {
+        EACerr(EAC_F_CA_STEP2_GET_EPH_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return get_pubkey(ctx->ca_ctx->ka_ctx->key, ctx->bn_ctx);
+}
+
+int
+CA_STEP3_check_pcd_pubkey(const EAC_CTX *ctx,
+        const BUF_MEM *comp_pubkey, const BUF_MEM *pubkey)
+{
+    BUF_MEM *my_comp_pubkey = NULL;
+    int r = -1;
+
+    if (!ctx || !ctx->ca_ctx || !comp_pubkey || !ctx->ca_ctx->ka_ctx) {
+        EACerr(EAC_F_CA_STEP3_CHECK_PCD_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Compress own public key */
+    my_comp_pubkey = Comp(ctx->ca_ctx->ka_ctx->key, pubkey, ctx->bn_ctx, ctx->md_ctx);
+    if (!my_comp_pubkey)
+        goto err;
+
+    /* Check whether or not the received data fits the own data */
+    if (my_comp_pubkey->length != comp_pubkey->length
+            || memcmp(my_comp_pubkey->data, comp_pubkey->data, comp_pubkey->length) != 0) {
+        EACerr(EAC_F_CA_STEP3_CHECK_PCD_PUBKEY, EAC_R_WRONG_PUBLIC_KEY);
+        r = 0;
+    } else
+        r = 1;
+
+err:
+    if (my_comp_pubkey)
+        BUF_MEM_free(my_comp_pubkey);
+
+    return r;
+}
+
+int
+CA_STEP4_compute_shared_secret(const EAC_CTX *ctx, const BUF_MEM *pubkey)
+{
+    if (!ctx || !ctx->ca_ctx
+            || !KA_CTX_compute_key(ctx->ca_ctx->ka_ctx, pubkey, ctx->bn_ctx)) {
+        EACerr(EAC_F_CA_STEP4_COMPUTE_SHARED_SECRET, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    return 1;
+}
+
+BUF_MEM *
+CA_get_pubkey(const unsigned char *ef_cardsecurity, size_t ef_cardsecurity_len)
+{
+    return NULL;
+}
+
+int
+CA_STEP5_derive_keys(const EAC_CTX *ctx, const BUF_MEM *pub,
+                   BUF_MEM **nonce, BUF_MEM **token)
+{
+    BUF_MEM *r = NULL;
+    BUF_MEM *authentication_token = NULL;
+
+    if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx || !nonce || !token) {
+        EACerr(EAC_F_CA_STEP5_DERIVE_KEYS, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Generate nonce  and derive k_mac and k_enc*/
+    r = randb(EVP_CIPHER_block_size(ctx->ca_ctx->ka_ctx->cipher));
+    if (!r || !KA_CTX_derive_keys(ctx->ca_ctx->ka_ctx, r, ctx->md_ctx))
+        goto err;
+
+    /* Compute authentication token */
+    authentication_token = get_authentication_token(ctx->ca_ctx->protocol,
+            ctx->ca_ctx->ka_ctx, ctx->bn_ctx, ctx->tr_version,
+            pub);
+    if (!authentication_token)
+        goto err;
+
+    *nonce = r;
+    *token = authentication_token;
+
+    return 1;
+
+err:
+    BUF_MEM_clear_free(r);
+    if (authentication_token) {
+        BUF_MEM_free(authentication_token);
+    }
+
+    return 0;
+}
+
+int
+CA_STEP6_derive_keys(EAC_CTX *ctx, const BUF_MEM *nonce, const BUF_MEM *token)
+{
+    int rv = -1;
+
+    if (!ctx || !ctx->ca_ctx) {
+        EACerr(EAC_F_CA_STEP6_DERIVE_KEYS, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (!KA_CTX_derive_keys(ctx->ca_ctx->ka_ctx, nonce, ctx->md_ctx))
+        goto err;
+
+    rv = verify_authentication_token(ctx->ca_ctx->protocol,
+            ctx->ca_ctx->ka_ctx,
+            ctx->bn_ctx, ctx->tr_version, token);
+    if (rv < 0)
+        goto err;
+
+    /* PACE, TA and CA were successful. Update the trust anchor! */
+    if (rv) {
+        if (ctx->ta_ctx->new_trust_anchor) {
+            CVC_CERT_free(ctx->ta_ctx->trust_anchor);
+            ctx->ta_ctx->trust_anchor = ctx->ta_ctx->new_trust_anchor;
+            ctx->ta_ctx->new_trust_anchor = NULL;
+        }
+    }
+
+err:
+    return rv;
+}
Index: openssl/crypto/eac/eac_dh.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_dh.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,518 @@
+/**
+ * @file
+ * @brief Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_dh.h"
+#include <openssl/bn.h>
+#include <openssl/evp.h>
+#include <openssl/eac.h>
+
+#include <openssl/err.h>
+
+static const unsigned char rfc_5114_modp_1_p[] = {
+   0xB1, 0x0B, 0x8F, 0x96, 0xA0, 0x80, 0xE0, 0x1D, 0xDE, 0x92, 0xDE, 0x5E,
+   0xAE, 0x5D, 0x54, 0xEC, 0x52, 0xC9, 0x9F, 0xBC, 0xFB, 0x06, 0xA3, 0xC6,
+   0x9A, 0x6A, 0x9D, 0xCA, 0x52, 0xD2, 0x3B, 0x61, 0x60, 0x73, 0xE2, 0x86,
+   0x75, 0xA2, 0x3D, 0x18, 0x98, 0x38, 0xEF, 0x1E, 0x2E, 0xE6, 0x52, 0xC0,
+   0x13, 0xEC, 0xB4, 0xAE, 0xA9, 0x06, 0x11, 0x23, 0x24, 0x97, 0x5C, 0x3C,
+   0xD4, 0x9B, 0x83, 0xBF, 0xAC, 0xCB, 0xDD, 0x7D, 0x90, 0xC4, 0xBD, 0x70,
+   0x98, 0x48, 0x8E, 0x9C, 0x21, 0x9A, 0x73, 0x72, 0x4E, 0xFF, 0xD6, 0xFA,
+   0xE5, 0x64, 0x47, 0x38, 0xFA, 0xA3, 0x1A, 0x4F, 0xF5, 0x5B, 0xCC, 0xC0,
+   0xA1, 0x51, 0xAF, 0x5F, 0x0D, 0xC8, 0xB4, 0xBD, 0x45, 0xBF, 0x37, 0xDF,
+   0x36, 0x5C, 0x1A, 0x65, 0xE6, 0x8C, 0xFD, 0xA7, 0x6D, 0x4D, 0xA7, 0x08,
+   0xDF, 0x1F, 0xB2, 0xBC, 0x2E, 0x4A, 0x43, 0x71
+};
+
+static const unsigned char rfc_5114_modp_1_g[] = {
+    0xA4, 0xD1, 0xCB, 0xD5, 0xC3, 0xFD, 0x34, 0x12, 0x67, 0x65, 0xA4, 0x42,
+    0xEF, 0xB9, 0x99, 0x05, 0xF8, 0x10, 0x4D, 0xD2, 0x58, 0xAC, 0x50, 0x7F,
+    0xD6, 0x40, 0x6C, 0xFF, 0x14, 0x26, 0x6D, 0x31, 0x26, 0x6F, 0xEA, 0x1E,
+    0x5C, 0x41, 0x56, 0x4B, 0x77, 0x7E, 0x69, 0x0F, 0x55, 0x04, 0xF2, 0x13,
+    0x16, 0x02, 0x17, 0xB4, 0xB0, 0x1B, 0x88, 0x6A, 0x5E, 0x91, 0x54, 0x7F,
+    0x9E, 0x27, 0x49, 0xF4, 0xD7, 0xFB, 0xD7, 0xD3, 0xB9, 0xA9, 0x2E, 0xE1,
+    0x90, 0x9D, 0x0D, 0x22, 0x63, 0xF8, 0x0A, 0x76, 0xA6, 0xA2, 0x4C, 0x08,
+    0x7A, 0x09, 0x1F, 0x53, 0x1D, 0xBF, 0x0A, 0x01, 0x69, 0xB6, 0xA2, 0x8A,
+    0xD6, 0x62, 0xA4, 0xD1, 0x8E, 0x73, 0xAF, 0xA3, 0x2D, 0x77, 0x9D, 0x59,
+    0x18, 0xD0, 0x8B, 0xC8, 0x85, 0x8F, 0x4D, 0xCE, 0xF9, 0x7C, 0x2A, 0x24,
+    0x85, 0x5E, 0x6E, 0xEB, 0x22, 0xB3, 0xB2, 0xE5
+};
+
+static const unsigned char rfc_5114_modp_1_q[] = {
+    0xF5, 0x18, 0xAA, 0x87, 0x81, 0xA8, 0xDF, 0x27, 0x8A, 0xBA, 0x4E, 0x7D,
+    0x64, 0xB7, 0xCB, 0x9D, 0x49, 0x46, 0x23, 0x53
+};
+
+static const unsigned char rfc_5114_modp_2_p[] = {
+    0xAD, 0x10, 0x7E, 0x1E, 0x91, 0x23, 0xA9, 0xD0, 0xD6, 0x60, 0xFA, 0xA7,
+    0x95, 0x59, 0xC5, 0x1F, 0xA2, 0x0D, 0x64, 0xE5, 0x68, 0x3B, 0x9F, 0xD1,
+    0xB5, 0x4B, 0x15, 0x97, 0xB6, 0x1D, 0x0A, 0x75, 0xE6, 0xFA, 0x14, 0x1D,
+    0xF9, 0x5A, 0x56, 0xDB, 0xAF, 0x9A, 0x3C, 0x40, 0x7B, 0xA1, 0xDF, 0x15,
+    0xEB, 0x3D, 0x68, 0x8A, 0x30, 0x9C, 0x18, 0x0E, 0x1D, 0xE6, 0xB8, 0x5A,
+    0x12, 0x74, 0xA0, 0xA6, 0x6D, 0x3F, 0x81, 0x52, 0xAD, 0x6A, 0xC2, 0x12,
+    0x90, 0x37, 0xC9, 0xED, 0xEF, 0xDA, 0x4D, 0xF8, 0xD9, 0x1E, 0x8F, 0xEF,
+    0x55, 0xB7, 0x39, 0x4B, 0x7A, 0xD5, 0xB7, 0xD0, 0xB6, 0xC1, 0x22, 0x07,
+    0xC9, 0xF9, 0x8D, 0x11, 0xED, 0x34, 0xDB, 0xF6, 0xC6, 0xBA, 0x0B, 0x2C,
+    0x8B, 0xBC, 0x27, 0xBE, 0x6A, 0x00, 0xE0, 0xA0, 0xB9, 0xC4, 0x97, 0x08,
+    0xB3, 0xBF, 0x8A, 0x31, 0x70, 0x91, 0x88, 0x36, 0x81, 0x28, 0x61, 0x30,
+    0xBC, 0x89, 0x85, 0xDB, 0x16, 0x02, 0xE7, 0x14, 0x41, 0x5D, 0x93, 0x30,
+    0x27, 0x82, 0x73, 0xC7, 0xDE, 0x31, 0xEF, 0xDC, 0x73, 0x10, 0xF7, 0x12,
+    0x1F, 0xD5, 0xA0, 0x74, 0x15, 0x98, 0x7D, 0x9A, 0xDC, 0x0A, 0x48, 0x6D,
+    0xCD, 0xF9, 0x3A, 0xCC, 0x44, 0x32, 0x83, 0x87, 0x31, 0x5D, 0x75, 0xE1,
+    0x98, 0xC6, 0x41, 0xA4, 0x80, 0xCD, 0x86, 0xA1, 0xB9, 0xE5, 0x87, 0xE8,
+    0xBE, 0x60, 0xE6, 0x9C, 0xC9, 0x28, 0xB2, 0xB9, 0xC5, 0x21, 0x72, 0xE4,
+    0x13, 0x04, 0x2E, 0x9B, 0x23, 0xF1, 0x0B, 0x0E, 0x16, 0xE7, 0x97, 0x63,
+    0xC9, 0xB5, 0x3D, 0xCF, 0x4B, 0xA8, 0x0A, 0x29, 0xE3, 0xFB, 0x73, 0xC1,
+    0x6B, 0x8E, 0x75, 0xB9, 0x7E, 0xF3, 0x63, 0xE2, 0xFF, 0xA3, 0x1F, 0x71,
+    0xCF, 0x9D, 0xE5, 0x38, 0x4E, 0x71, 0xB8, 0x1C, 0x0A, 0xC4, 0xDF, 0xFE,
+    0x0C, 0x10, 0xE6, 0x4F
+};
+
+static const unsigned char rfc_5114_modp_2_g[] = {
+    0xAC, 0x40, 0x32, 0xEF, 0x4F, 0x2D, 0x9A, 0xE3, 0x9D, 0xF3, 0x0B, 0x5C,
+    0x8F, 0xFD, 0xAC, 0x50, 0x6C, 0xDE, 0xBE, 0x7B, 0x89, 0x99, 0x8C, 0xAF,
+    0x74, 0x86, 0x6A, 0x08, 0xCF, 0xE4, 0xFF, 0xE3, 0xA6, 0x82, 0x4A, 0x4E,
+    0x10, 0xB9, 0xA6, 0xF0, 0xDD, 0x92, 0x1F, 0x01, 0xA7, 0x0C, 0x4A, 0xFA,
+    0xAB, 0x73, 0x9D, 0x77, 0x00, 0xC2, 0x9F, 0x52, 0xC5, 0x7D, 0xB1, 0x7C,
+    0x62, 0x0A, 0x86, 0x52, 0xBE, 0x5E, 0x90, 0x01, 0xA8, 0xD6, 0x6A, 0xD7,
+    0xC1, 0x76, 0x69, 0x10, 0x19, 0x99, 0x02, 0x4A, 0xF4, 0xD0, 0x27, 0x27,
+    0x5A, 0xC1, 0x34, 0x8B, 0xB8, 0xA7, 0x62, 0xD0, 0x52, 0x1B, 0xC9, 0x8A,
+    0xE2, 0x47, 0x15, 0x04, 0x22, 0xEA, 0x1E, 0xD4, 0x09, 0x93, 0x9D, 0x54,
+    0xDA, 0x74, 0x60, 0xCD, 0xB5, 0xF6, 0xC6, 0xB2, 0x50, 0x71, 0x7C, 0xBE,
+    0xF1, 0x80, 0xEB, 0x34, 0x11, 0x8E, 0x98, 0xD1, 0x19, 0x52, 0x9A, 0x45,
+    0xD6, 0xF8, 0x34, 0x56, 0x6E, 0x30, 0x25, 0xE3, 0x16, 0xA3, 0x30, 0xEF,
+    0xBB, 0x77, 0xA8, 0x6F, 0x0C, 0x1A, 0xB1, 0x5B, 0x05, 0x1A, 0xE3, 0xD4,
+    0x28, 0xC8, 0xF8, 0xAC, 0xB7, 0x0A, 0x81, 0x37, 0x15, 0x0B, 0x8E, 0xEB,
+    0x10, 0xE1, 0x83, 0xED, 0xD1, 0x99, 0x63, 0xDD, 0xD9, 0xE2, 0x63, 0xE4,
+    0x77, 0x05, 0x89, 0xEF, 0x6A, 0xA2, 0x1E, 0x7F, 0x5F, 0x2F, 0xF3, 0x81,
+    0xB5, 0x39, 0xCC, 0xE3, 0x40, 0x9D, 0x13, 0xCD, 0x56, 0x6A, 0xFB, 0xB4,
+    0x8D, 0x6C, 0x01, 0x91, 0x81, 0xE1, 0xBC, 0xFE, 0x94, 0xB3, 0x02, 0x69,
+    0xED, 0xFE, 0x72, 0xFE, 0x9B, 0x6A, 0xA4, 0xBD, 0x7B, 0x5A, 0x0F, 0x1C,
+    0x71, 0xCF, 0xFF, 0x4C, 0x19, 0xC4, 0x18, 0xE1, 0xF6, 0xEC, 0x01, 0x79,
+    0x81, 0xBC, 0x08, 0x7F, 0x2A, 0x70, 0x65, 0xB3, 0x84, 0xB8, 0x90, 0xD3,
+    0x19, 0x1F, 0x2B, 0xFA
+};
+
+static const unsigned char rfc_5114_modp_2_q[] = {
+    0x80, 0x1C, 0x0D, 0x34, 0xC5, 0x8D, 0x93, 0xFE, 0x99, 0x71, 0x77, 0x10,
+    0x1F, 0x80, 0x53, 0x5A, 0x47, 0x38, 0xCE, 0xBC, 0xBF, 0x38, 0x9A, 0x99,
+    0xB3, 0x63, 0x71, 0xEB
+};
+
+static const unsigned char rfc_5114_modp_3_p[] = {
+    0x87, 0xA8, 0xE6, 0x1D, 0xB4, 0xB6, 0x66, 0x3C, 0xFF, 0xBB, 0xD1, 0x9C,
+    0x65, 0x19, 0x59, 0x99, 0x8C, 0xEE, 0xF6, 0x08, 0x66, 0x0D, 0xD0, 0xF2,
+    0x5D, 0x2C, 0xEE, 0xD4, 0x43, 0x5E, 0x3B, 0x00, 0xE0, 0x0D, 0xF8, 0xF1,
+    0xD6, 0x19, 0x57, 0xD4, 0xFA, 0xF7, 0xDF, 0x45, 0x61, 0xB2, 0xAA, 0x30,
+    0x16, 0xC3, 0xD9, 0x11, 0x34, 0x09, 0x6F, 0xAA, 0x3B, 0xF4, 0x29, 0x6D,
+    0x83, 0x0E, 0x9A, 0x7C, 0x20, 0x9E, 0x0C, 0x64, 0x97, 0x51, 0x7A, 0xBD,
+    0x5A, 0x8A, 0x9D, 0x30, 0x6B, 0xCF, 0x67, 0xED, 0x91, 0xF9, 0xE6, 0x72,
+    0x5B, 0x47, 0x58, 0xC0, 0x22, 0xE0, 0xB1, 0xEF, 0x42, 0x75, 0xBF, 0x7B,
+    0x6C, 0x5B, 0xFC, 0x11, 0xD4, 0x5F, 0x90, 0x88, 0xB9, 0x41, 0xF5, 0x4E,
+    0xB1, 0xE5, 0x9B, 0xB8, 0xBC, 0x39, 0xA0, 0xBF, 0x12, 0x30, 0x7F, 0x5C,
+    0x4F, 0xDB, 0x70, 0xC5, 0x81, 0xB2, 0x3F, 0x76, 0xB6, 0x3A, 0xCA, 0xE1,
+    0xCA, 0xA6, 0xB7, 0x90, 0x2D, 0x52, 0x52, 0x67, 0x35, 0x48, 0x8A, 0x0E,
+    0xF1, 0x3C, 0x6D, 0x9A, 0x51, 0xBF, 0xA4, 0xAB, 0x3A, 0xD8, 0x34, 0x77,
+    0x96, 0x52, 0x4D, 0x8E, 0xF6, 0xA1, 0x67, 0xB5, 0xA4, 0x18, 0x25, 0xD9,
+    0x67, 0xE1, 0x44, 0xE5, 0x14, 0x05, 0x64, 0x25, 0x1C, 0xCA, 0xCB, 0x83,
+    0xE6, 0xB4, 0x86, 0xF6, 0xB3, 0xCA, 0x3F, 0x79, 0x71, 0x50, 0x60, 0x26,
+    0xC0, 0xB8, 0x57, 0xF6, 0x89, 0x96, 0x28, 0x56, 0xDE, 0xD4, 0x01, 0x0A,
+    0xBD, 0x0B, 0xE6, 0x21, 0xC3, 0xA3, 0x96, 0x0A, 0x54, 0xE7, 0x10, 0xC3,
+    0x75, 0xF2, 0x63, 0x75, 0xD7, 0x01, 0x41, 0x03, 0xA4, 0xB5, 0x43, 0x30,
+    0xC1, 0x98, 0xAF, 0x12, 0x61, 0x16, 0xD2, 0x27, 0x6E, 0x11, 0x71, 0x5F,
+    0x69, 0x38, 0x77, 0xFA, 0xD7, 0xEF, 0x09, 0xCA, 0xDB, 0x09, 0x4A, 0xE9,
+    0x1E, 0x1A, 0x15, 0x97
+};
+
+static const unsigned char rfc_5114_modp_3_g[] = {
+    0x3F, 0xB3, 0x2C, 0x9B, 0x73, 0x13, 0x4D, 0x0B, 0x2E, 0x77, 0x50, 0x66,
+    0x60, 0xED, 0xBD, 0x48, 0x4C, 0xA7, 0xB1, 0x8F, 0x21, 0xEF, 0x20, 0x54,
+    0x07, 0xF4, 0x79, 0x3A, 0x1A, 0x0B, 0xA1, 0x25, 0x10, 0xDB, 0xC1, 0x50,
+    0x77, 0xBE, 0x46, 0x3F, 0xFF, 0x4F, 0xED, 0x4A, 0xAC, 0x0B, 0xB5, 0x55,
+    0xBE, 0x3A, 0x6C, 0x1B, 0x0C, 0x6B, 0x47, 0xB1, 0xBC, 0x37, 0x73, 0xBF,
+    0x7E, 0x8C, 0x6F, 0x62, 0x90, 0x12, 0x28, 0xF8, 0xC2, 0x8C, 0xBB, 0x18,
+    0xA5, 0x5A, 0xE3, 0x13, 0x41, 0x00, 0x0A, 0x65, 0x01, 0x96, 0xF9, 0x31,
+    0xC7, 0x7A, 0x57, 0xF2, 0xDD, 0xF4, 0x63, 0xE5, 0xE9, 0xEC, 0x14, 0x4B,
+    0x77, 0x7D, 0xE6, 0x2A, 0xAA, 0xB8, 0xA8, 0x62, 0x8A, 0xC3, 0x76, 0xD2,
+    0x82, 0xD6, 0xED, 0x38, 0x64, 0xE6, 0x79, 0x82, 0x42, 0x8E, 0xBC, 0x83,
+    0x1D, 0x14, 0x34, 0x8F, 0x6F, 0x2F, 0x91, 0x93, 0xB5, 0x04, 0x5A, 0xF2,
+    0x76, 0x71, 0x64, 0xE1, 0xDF, 0xC9, 0x67, 0xC1, 0xFB, 0x3F, 0x2E, 0x55,
+    0xA4, 0xBD, 0x1B, 0xFF, 0xE8, 0x3B, 0x9C, 0x80, 0xD0, 0x52, 0xB9, 0x85,
+    0xD1, 0x82, 0xEA, 0x0A, 0xDB, 0x2A, 0x3B, 0x73, 0x13, 0xD3, 0xFE, 0x14,
+    0xC8, 0x48, 0x4B, 0x1E, 0x05, 0x25, 0x88, 0xB9, 0xB7, 0xD2, 0xBB, 0xD2,
+    0xDF, 0x01, 0x61, 0x99, 0xEC, 0xD0, 0x6E, 0x15, 0x57, 0xCD, 0x09, 0x15,
+    0xB3, 0x35, 0x3B, 0xBB, 0x64, 0xE0, 0xEC, 0x37, 0x7F, 0xD0, 0x28, 0x37,
+    0x0D, 0xF9, 0x2B, 0x52, 0xC7, 0x89, 0x14, 0x28, 0xCD, 0xC6, 0x7E, 0xB6,
+    0x18, 0x4B, 0x52, 0x3D, 0x1D, 0xB2, 0x46, 0xC3, 0x2F, 0x63, 0x07, 0x84,
+    0x90, 0xF0, 0x0E, 0xF8, 0xD6, 0x47, 0xD1, 0x48, 0xD4, 0x79, 0x54, 0x51,
+    0x5E, 0x23, 0x27, 0xCF, 0xEF, 0x98, 0xC5, 0x82, 0x66, 0x4B, 0x4C, 0x0F,
+    0x6C, 0xC4, 0x16, 0x59
+};
+
+static const unsigned char rfc_5114_modp_3_q[] = {
+    0x8C, 0xF8, 0x36, 0x42, 0xA7, 0x09, 0xA0, 0x97, 0xB4, 0x47, 0x99, 0x76,
+    0x40, 0x12, 0x9D, 0xA2, 0x99, 0xB1, 0xA4, 0x7D, 0x1E, 0xB3, 0x75, 0x0B,
+    0xA3, 0x08, 0xB0, 0xFE, 0x64, 0xF5, 0xFB, 0xD3
+};
+
+/**
+ * @brief Create a DH structure using the parameters from one of the MODP groups
+ *         defined in RFC 5114.
+ *
+ * @param[in] num number of the group to be generated. The valid range is from
+ *         one to three
+ * @return new DH group or NULL in case of an error
+ */
+static DH *
+get_rfc5114_modp(int num);
+/**
+ * @brief Public key validation method described in RFC 2631.
+ *
+ * Verify that DH->pub_key lies within the interval [2,p-1]. If it does not,
+ * the key is invalid.
+ * If DH->q exists, compute y^q mod p. If the result == 1, the key is valid.
+ * Otherwise the key is invalid.
+ *
+ * @param[in] dh DH object to use
+ * @param[in] ctx BN_CTX object
+ * @param[out] ret Can contain these flags as result:
+ * DH_CHECK_PUBKEY_TOO_SMALL (smaller than 2)
+ * DH_CHECK_PUBKEY_TOO_LARGE (bigger than p-1)
+ * DH_CHECK_PUBKEY_INVALID (y^q mod p != 1)
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+static int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret);
+#define DH_CHECK_PUBKEY_INVALID        0x04
+
+int
+init_dh(DH ** dh, int standardizedDomainParameters)
+{
+    int i;
+    DH *tmp = NULL;
+
+    if (!dh) {
+        EACerr(EAC_F_INIT_DH, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (!*dh) {
+        tmp = get_rfc5114_modp(standardizedDomainParameters);
+        if (!tmp)
+            goto err;
+    } else {
+        /*Note: this could be something not matching standardizedDomainParameters */
+        tmp = *dh;
+    }
+
+    if (!DH_check(tmp, &i))
+        goto err;
+
+    /* RFC 5114 parameters do not use safe primes and OpenSSL does not know
+     * how to deal with generator other then 2 or 5. Therefore we have to
+     * ignore some of the checks */
+    i &= ~DH_CHECK_P_NOT_SAFE_PRIME;
+    i &= ~DH_UNABLE_TO_CHECK_GENERATOR;
+
+    if (i) {
+        EACerr(EAC_F_INIT_DH, EAC_R_BAD_DH_KEY);
+        goto err;
+    }
+
+    *dh = tmp;
+
+    return 1;
+
+err:
+    if (tmp && !*dh) {
+        DH_free(tmp);
+    }
+
+    return 0;
+}
+
+static int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret)
+{
+    BIGNUM *bn = NULL;
+    int ok = 0;
+
+    if (!dh || !ret) {
+        EACerr(EAC_F_DH_CHECK_PUB_KEY_RFC, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Verify that y lies within the interval [2,p-1]. */
+    if (!DH_check_pub_key(dh, dh->pub_key, ret))
+        goto err;
+
+    /* If the DH is conform to RFC 2631 it should have a non-NULL q.
+     * Others (like the DHs generated from OpenSSL) might have a problem with
+     * this check. */
+    if (dh->q) {
+        /* Compute y^q mod p. If the result == 1, the key is valid. */
+        bn = BN_new();
+        if (!bn || !BN_mod_exp(bn, dh->pub_key, dh->q, dh->p, ctx))
+            goto err;
+        if (!BN_is_one(bn))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
+    }
+    ok = 1;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+
+    return ok;
+}
+
+
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *q = NULL, *bn = NULL;
+    int i;
+
+    if (!dh) {
+        EACerr(EAC_F_DH_GET_Q, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (!dh->q) {
+        q = BN_new();
+        bn = BN_dup(dh->p);
+        /* DH primes should be strong, based on a Sophie Germain prime q
+         * p=(2*q)+1 or (p-1)/2=q */
+        if (!q || !bn ||
+                !BN_sub_word(bn, 1) ||
+                !BN_rshift1(q, bn)) {
+            goto err;
+        }
+    } else {
+        q = BN_dup(dh->q);
+    }
+
+    /* q should always be prime */
+    i = BN_is_prime(q, BN_prime_checks, NULL, ctx, NULL);
+    if (i <= 0) {
+        if (i == 0)
+            EACerr(EAC_F_DH_GET_Q, EAC_R_UNABLE_TO_GET_SG_PRIME);
+        goto err;
+    }
+
+    return q;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (q)
+        BN_clear_free(q);
+
+    return NULL;
+}
+
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *order = NULL, *bn = NULL;
+
+    if (!dh) {
+        EACerr(EAC_F_DH_GET_ORDER, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* suppose the order of g is q-1 */
+    order = DH_get_q(dh, ctx);
+    bn = BN_new();
+    if (!bn || !order || !BN_sub_word(order, 1) ||
+            !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+        goto err;
+
+    if (BN_cmp(bn, BN_value_one()) != 0) {
+        /* if bn != 1, then q-1 is not the order of g, but p-1 should be */
+        if (!BN_sub(order, dh->p, BN_value_one()) ||
+                !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+            goto err;
+        if (BN_cmp(bn, BN_value_one()) != 0) {
+            EACerr(EAC_F_DH_GET_ORDER, EAC_R_UNABLE_TO_GET_ORDER);
+            goto err;
+        }
+    }
+
+    BN_clear_free(bn);
+
+    return order;
+
+err:
+    if (order)
+        BN_clear_free(order);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
+
+BUF_MEM *
+dh_generate_key(EVP_PKEY *key, BN_CTX *bn_ctx)
+{
+    int suc;
+    DH *dh = NULL;
+    BUF_MEM *ret = NULL;
+
+
+    if (!key) {
+        EACerr(EAC_F_DH_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    dh = EVP_PKEY_get1_DH(key);
+    if (!dh)
+        goto err;
+
+    if (!DH_generate_key(dh) || !DH_check_pub_key_rfc(dh, bn_ctx, &suc))
+        goto err;
+
+    if (suc)
+        goto err;
+
+    ret = BN_bn2buf(dh->pub_key);
+
+err:
+    if (dh)
+        DH_free(dh);
+    return ret;
+}
+
+BUF_MEM *
+dh_compute_key(EVP_PKEY *key, const BUF_MEM * in, BN_CTX *bn_ctx)
+{
+    BUF_MEM * out = NULL;
+    BIGNUM * bn = NULL;
+    DH *dh = NULL;
+
+    if (!key || !in) {
+        EACerr(EAC_F_DH_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    dh = EVP_PKEY_get1_DH(key);
+    if (!dh)
+        return NULL;
+
+    /* decode public key */
+    bn = BN_bin2bn((unsigned char *) in->data, in->length, bn);
+    if (!bn)
+        goto err;
+
+    out = BUF_MEM_create(DH_size(dh));
+    if (!out)
+        goto err;
+
+    out->length = DH_compute_key((unsigned char *) out->data, bn, dh);
+    if ((int) out->length < 0)
+        goto err;
+
+    BN_clear_free(bn);
+    DH_free(dh);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (bn)
+        BN_clear_free(bn);
+    if (dh)
+        DH_free(dh);
+
+    return NULL;
+}
+
+static DH *
+get_rfc5114_modp(int num)
+{
+    DH *ret = NULL;
+    BIGNUM *p = NULL, *g = NULL, *q = NULL;
+    int check = 0;
+
+    ret = DH_new();
+    if (!ret)
+        goto err;
+
+    switch(num) {
+        case 0:
+            p = BN_bin2bn(rfc_5114_modp_1_p, sizeof(rfc_5114_modp_1_p), p);
+            g = BN_bin2bn(rfc_5114_modp_1_g, sizeof(rfc_5114_modp_1_g), g);
+            q = BN_bin2bn(rfc_5114_modp_1_q, sizeof(rfc_5114_modp_1_q), q);
+            break;
+        case 1:
+            p = BN_bin2bn(rfc_5114_modp_2_p, sizeof(rfc_5114_modp_2_p), p);
+            g = BN_bin2bn(rfc_5114_modp_2_g, sizeof(rfc_5114_modp_2_g), g);
+            q = BN_bin2bn(rfc_5114_modp_2_q, sizeof(rfc_5114_modp_2_q), q);
+            break;
+        case 2:
+            p = BN_bin2bn(rfc_5114_modp_3_p, sizeof(rfc_5114_modp_3_p), p);
+            g = BN_bin2bn(rfc_5114_modp_3_g, sizeof(rfc_5114_modp_3_g), g);
+            q = BN_bin2bn(rfc_5114_modp_3_q, sizeof(rfc_5114_modp_3_q), q);
+            break;
+        default:
+            EACerr(EAC_F_GET_RFC5114_MODP, EAC_R_INVALID_ARGUMENTS);
+            goto err;
+    }
+
+    if (!p || !g || !q)
+        goto err;
+
+    /* There are no setter functions for the DH structure. Therefore we must
+       set access the members directly */
+    ret->p = BN_dup(p);
+    ret->g = BN_dup(g);
+    ret->q = BN_dup(q);
+
+    if (!ret->p || !ret->g || !ret->q)
+        goto err;
+
+    /* Perform some checks. OpenSSL only knows generators 2 and 5, so the
+     * DH_UNABLE_TO_CHECK_GENERATOR will be set, but the prime should be safe
+     * nevertheless */
+    if (!DH_check(ret, &check)) goto err;
+    if (check & DH_CHECK_P_NOT_PRIME)
+        goto err;
+
+    BN_free(p);
+    BN_free(g);
+    BN_free(q);
+
+    return ret;
+
+err:
+    if (ret)
+        DH_free(ret);
+    if (p)
+        BN_free(p);
+    if (g)
+        BN_free(g);
+    if (q)
+        BN_free(q);
+    return NULL;
+}
+
+DH *
+DHparams_dup_with_q(DH *dh)
+{
+    DH *dup = DHparams_dup(dh);
+
+    if (dup && dh->q && !dup->q) {
+        dup->q = BN_dup(dh->q);
+        if (!dup->q) {
+            DH_free(dup);
+            return NULL;
+        }
+    }
+
+    return dup;
+}
Index: openssl/crypto/eac/eac_dh.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_dh.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,85 @@
+/**
+ * @file
+ * @brief Interface to Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_DH_H_
+#define PACE_DH_H_
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/dh.h>
+
+/**
+ * @brief initializes a DH key structure. If the structure is already initialized,
+ * nothing is done
+ *
+ * @param[in/out] dh DH object to use
+ * @param[in] standardizedDomainParameters specifies which parameters to use
+ * (see TR-03110, p. 52)
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_dh(DH ** dh, int standardizedDomainParameters);
+/**
+ * @brief Computes the prime on which the modulus is based.
+ *
+ * If DH->q does not exist, tries to guess a Sophie Germain prime matching the
+ * DH's modulus.
+ *
+ * @param[in] dh DH object to use
+ * @param[in] ctx BN_CTX object
+ *
+ * @return q or NULL if an error occurred
+ */
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Computes the order of the DH's generator.
+ *
+ * @param[in] dh DH object to use
+ * @param[in] ctx BN_CTX object (optional)
+ *
+ * @return order of g or NULL if an error occurred
+ *
+ * @note This calculation is for DHs using a safe prime, which will generate
+ * either an order-q or an order-2q group (see crypto/dh/dh_gen.c:151).
+ */
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Generates a DH key pair
+ *
+ * @param[in] key
+ * @param[in] bn_ctx BIGNUM context
+ *
+ * @return public key of the generated key pair or NULL if an error occurred
+ */
+BUF_MEM *
+dh_generate_key(EVP_PKEY *key, BN_CTX *bn_ctx);
+/**
+ * @brief Computes a DH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+dh_compute_key(EVP_PKEY *key, const BUF_MEM * in, BN_CTX *bn_ctx);
+
+/**
+ * @brief Duplicate Diffie-Hellman-Parameters including parameter q.
+ *
+ * DHparams_dup creates a duplicated object copying only p, g and optionally
+ * the length. This object is used to also copy the parameter q.
+ *
+ * @param dh Diffie-Hellman-Parameters
+ *
+ * @return Duplicate object or NULL in case of an error
+ */
+DH *
+DHparams_dup_with_q(DH *dh);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/eac/eac_ecdh.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_ecdh.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,163 @@
+/**
+ * @file
+ * @brief Elliptic curve Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_ecdh.h"
+#include <openssl/ecdh.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+
+int
+init_ecdh(EC_KEY ** ecdh, int standardizedDomainParameters)
+{
+    EC_KEY * tmp = NULL;
+
+    if (!ecdh) {
+        EACerr(EAC_F_INIT_ECDH, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    if (!*ecdh) {
+        switch(standardizedDomainParameters) {
+            case 8:
+                /* NOTE: prime192v1 is equivalent to secp192r1 */
+                tmp = EC_KEY_new_by_curve_name(NID_X9_62_prime192v1);
+                break;
+            case 9:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP192r1);
+                break;
+            case 10:
+                tmp = EC_KEY_new_by_curve_name(NID_secp224r1);
+                break;
+            case 11:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP224r1);
+                break;
+            case 12:
+                /* NOTE: prime256v1 is equivalent to secp256r1 */
+                tmp = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+                break;
+            case 13:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP256r1);
+                break;
+            case 14:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP512r1);
+                break;
+            case 15:
+                tmp = EC_KEY_new_by_curve_name(NID_secp384r1);
+                break;
+            case 16:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP384r1);
+                break;
+            case 17:
+                tmp = EC_KEY_new_by_curve_name(NID_brainpoolP512r1);
+                break;
+            case 18:
+                tmp = EC_KEY_new_by_curve_name(NID_secp521r1);
+                break;
+            default:
+                EACerr(EAC_F_INIT_ECDH, EAC_R_INVALID_ARGUMENTS);
+                goto err;
+        }
+        if (!tmp)
+            goto err;
+    }
+
+    if (!*ecdh)
+        *ecdh = tmp;
+    return 1;
+
+err:
+    if (!*ecdh && tmp)
+        EC_KEY_free(tmp);
+    return 0;
+}
+
+BUF_MEM *
+ecdh_generate_key(EVP_PKEY *key, BN_CTX *bn_ctx)
+{
+    EC_KEY *ec = NULL;
+    BUF_MEM *ret = NULL;
+
+    if (!key) {
+        EACerr(EAC_F_ECDH_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    ec = EVP_PKEY_get1_EC_KEY(key);
+    if (!ec)
+        goto err;
+
+    if (!EC_KEY_generate_key(ec)) {
+        goto err;
+    }
+
+    /* The key agreement algorithm ECKA prevents small subgroup attacks by
+     * using compatible cofactor multiplication. */
+    ret = EC_POINT_point2buf(ec, bn_ctx, EC_KEY_get0_public_key(ec));
+
+err:
+    if (ec)
+        EC_KEY_free(ec);
+    return ret;
+}
+
+BUF_MEM *
+ecdh_compute_key(EVP_PKEY *key, const BUF_MEM * in, BN_CTX *bn_ctx)
+{
+    BUF_MEM * out = NULL;
+    EC_POINT * ecp = NULL;
+    EC_KEY *ecdh = NULL;
+    const EC_GROUP *group = NULL;
+
+    if (!key || !in) {
+        EACerr(EAC_F_ECDH_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    ecdh = EVP_PKEY_get1_EC_KEY(key);
+    if (!ecdh)
+        return NULL;
+
+    /* decode public key */
+    group = EC_KEY_get0_group(ecdh);
+    if (!group)
+        goto err;
+    ecp = EC_POINT_new(group);
+    if (!ecp)
+        goto err;
+    if(!EC_POINT_oct2point(group, ecp, (unsigned char *) in->data, in->length,
+            bn_ctx))
+        goto err;
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(EC_POINT_point2oct(group, ecp, EC_KEY_get_conv_form(ecdh),
+            NULL, 0, bn_ctx));
+    if (!out)
+        goto err;
+
+    /* copy data and set length */
+    out->length = ECDH_compute_key(out->data, out->max, ecp, ecdh, NULL);
+    if ((int) out->length < 0)
+        goto err;
+
+    EC_POINT_free(ecp);
+    EC_KEY_free(ecdh);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (ecp)
+        EC_POINT_free(ecp);
+    if (ecdh)
+        EC_KEY_free(ecdh);
+
+    return NULL;
+}
Index: openssl/crypto/eac/eac_ecdh.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_ecdh.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,46 @@
+/**
+ * @file
+ * @brief Interface to elliptic curve Diffie Hellman helper functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_ECDH_H_
+#define PACE_ECDH_H_
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+/**
+ * @brief initializes a key for ECDH. If the object is already initialised,
+ * nothing is don
+ *
+ * @param[in/out] ecdh elliptic curve object to use
+ * @param[in] standardizedDomainParameters specifies which parameters to use
+ * (see TR-03110, p. 52)
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_ecdh(EC_KEY ** ecdh, int standardizedDomainParameters);
+/**
+ * @brief Generates an ECDH keypair
+ *
+ * @param[in] key
+ * @param[in] bn_ctx BIGNUM context
+ *
+ * @return public key of the generated keypair or NULL if an error occurred
+ */
+BUF_MEM *
+ecdh_generate_key(EVP_PKEY *key, BN_CTX *bn_ctx);
+/**
+ * @brief Computes an ECDH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+ecdh_compute_key(EVP_PKEY *key, const BUF_MEM * in, BN_CTX *bn_ctx);
+
+#endif /*PACE_ECDH_H_*/
Index: openssl/crypto/eac/eac_err.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_err.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,238 @@
+/* crypto/eac/eac_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/eac.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_EAC,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_EAC,0,reason)
+
+static ERR_STRING_DATA EAC_str_functs[]=
+	{
+{ERR_FUNC(EAC_F_ASN1_PUBKEY),	"ASN1_PUBKEY"},
+{ERR_FUNC(EAC_F_AUTHENTICATE),	"AUTHENTICATE"},
+{ERR_FUNC(EAC_F_CA_CTX_SET_PROTOCOL),	"CA_CTX_SET_PROTOCOL"},
+{ERR_FUNC(EAC_F_CA_STEP1_GET_PUBKEY),	"CA_STEP1_GET_PUBKEY"},
+{ERR_FUNC(EAC_F_CA_STEP2_GET_EPH_PUBKEY),	"CA_STEP2_GET_EPH_PUBKEY"},
+{ERR_FUNC(EAC_F_CA_STEP3_CHECK_PCD_PUBKEY),	"CA_STEP3_CHECK_PCD_PUBKEY"},
+{ERR_FUNC(EAC_F_CA_STEP4_COMPUTE_SHARED_SECRET),	"CA_STEP4_COMPUTE_SHARED_SECRET"},
+{ERR_FUNC(EAC_F_CA_STEP5_DERIVE_KEYS),	"CA_STEP5_DERIVE_KEYS"},
+{ERR_FUNC(EAC_F_CA_STEP6_DERIVE_KEYS),	"CA_STEP6_DERIVE_KEYS"},
+{ERR_FUNC(EAC_F_CERT_FROM_CAR),	"CERT_FROM_CAR"},
+{ERR_FUNC(EAC_F_CIPHER),	"CIPHER"},
+{ERR_FUNC(EAC_F_CIPHER_NO_PAD),	"CIPHER_NO_PAD"},
+{ERR_FUNC(EAC_F_CMAC),	"CMAC"},
+{ERR_FUNC(EAC_F_COMP),	"COMP"},
+{ERR_FUNC(EAC_F_COMPUTE_AUTHENTICATION_TOKEN),	"COMPUTE_AUTHENTICATION_TOKEN"},
+{ERR_FUNC(EAC_F_CONVERT_FROM_PLAIN_SIG),	"CONVERT_FROM_PLAIN_SIG"},
+{ERR_FUNC(EAC_F_CONVERT_TO_PLAIN_SIG),	"CONVERT_TO_PLAIN_SIG"},
+{ERR_FUNC(EAC_F_CVC_GET_EC_PUBKEY),	"CVC_GET_EC_PUBKEY"},
+{ERR_FUNC(EAC_F_CVC_GET_PUBKEY),	"CVC_GET_PUBKEY"},
+{ERR_FUNC(EAC_F_CVC_GET_RSA_PUBKEY),	"CVC_GET_RSA_PUBKEY"},
+{ERR_FUNC(EAC_F_CVC_GET_TERMINAL_TYPE),	"CVC_GET_TERMINAL_TYPE"},
+{ERR_FUNC(EAC_F_DH_CHECK_PUB_KEY_RFC),	"DH_CHECK_PUB_KEY_RFC"},
+{ERR_FUNC(EAC_F_DH_COMPUTE_KEY),	"DH_compute_key"},
+{ERR_FUNC(EAC_F_DH_GENERATE_KEY),	"DH_generate_key"},
+{ERR_FUNC(EAC_F_DH_GET_ORDER),	"DH_GET_ORDER"},
+{ERR_FUNC(EAC_F_DH_GET_Q),	"DH_GET_Q"},
+{ERR_FUNC(EAC_F_DH_GET_SG_PRIME),	"DH_GET_SG_PRIME"},
+{ERR_FUNC(EAC_F_DH_GM_COMPUTE_KEY),	"DH_GM_COMPUTE_KEY"},
+{ERR_FUNC(EAC_F_DH_GM_GENERATE_KEY),	"DH_GM_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_DH_IM_COMPUTE_KEY),	"DH_IM_COMPUTE_KEY"},
+{ERR_FUNC(EAC_F_DH_IM_GENERATE_KEY),	"DH_IM_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_EAC_ADD_ISO_PAD),	"EAC_add_iso_pad"},
+{ERR_FUNC(EAC_F_EAC_AUTHENTICATE),	"EAC_authenticate"},
+{ERR_FUNC(EAC_F_EAC_COMP),	"EAC_Comp"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_CA),	"EAC_CTX_init_ca"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_EF_CARDACCESS),	"EAC_CTX_init_ef_cardaccess"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_EF_CARD_ACCESS),	"EAC_CTX_INIT_EF_CARD_ACCESS"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_PACE),	"EAC_CTX_init_pace"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_RI),	"EAC_CTX_init_ri"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_TA),	"EAC_CTX_init_ta"},
+{ERR_FUNC(EAC_F_EAC_CTX_INIT_TA_COMPAT),	"EAC_CTX_init_ta_compat"},
+{ERR_FUNC(EAC_F_EAC_CTX_SET_ENCRYPTION_CTX),	"EAC_CTX_set_encryption_ctx"},
+{ERR_FUNC(EAC_F_EAC_DECRYPT),	"EAC_decrypt"},
+{ERR_FUNC(EAC_F_EAC_EC_KEY_FROM_ASN1),	"EAC_ec_key_from_asn1"},
+{ERR_FUNC(EAC_F_EAC_ENCRYPT),	"EAC_encrypt"},
+{ERR_FUNC(EAC_F_EAC_OID2MD),	"EAC_OID2MD"},
+{ERR_FUNC(EAC_F_EAC_SIGN),	"EAC_SIGN"},
+{ERR_FUNC(EAC_F_EAC_VERIFY),	"EAC_VERIFY"},
+{ERR_FUNC(EAC_F_ECDH_COMPUTE_KEY),	"ECDH_compute_key"},
+{ERR_FUNC(EAC_F_ECDH_GENERATE_KEY),	"ECDH_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_ECDH_GM_COMPUTE_KEY),	"ECDH_GM_COMPUTE_KEY"},
+{ERR_FUNC(EAC_F_ECDH_GM_GENERATE_KEY),	"ECDH_GM_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_ECDH_IM_COMPUTE_KEY),	"ECDH_IM_COMPUTE_KEY"},
+{ERR_FUNC(EAC_F_ECDH_IM_GENERATE_KEY),	"ECDH_IM_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_ECDH_INTEGRATED_MAPPING),	"ECDH_INTEGRATED_MAPPING"},
+{ERR_FUNC(EAC_F_EC_KEY_FROM_PACE_ECPARAMETERS),	"EC_KEY_FROM_PACE_ECPARAMETERS"},
+{ERR_FUNC(EAC_F_ENCODED_MRZ),	"ENCODED_MRZ"},
+{ERR_FUNC(EAC_F_ENCODED_SECRET),	"ENCODED_SECRET"},
+{ERR_FUNC(EAC_F_ENCODE_SSC),	"ENCODE_SSC"},
+{ERR_FUNC(EAC_F_EVP_PKEY_DUP),	"EVP_PKEY_DUP"},
+{ERR_FUNC(EAC_F_EVP_PKEY_FROM_PUBKEY),	"EVP_PKEY_FROM_PUBKEY"},
+{ERR_FUNC(EAC_F_EVP_PKEY_SET_KEYS),	"EVP_PKEY_SET_KEYS"},
+{ERR_FUNC(EAC_F_EVP_PKEY_SET_STD_DP),	"EVP_PKEY_SET_STD_DP"},
+{ERR_FUNC(EAC_F_GETLEN),	"GETLEN"},
+{ERR_FUNC(EAC_F_GET_AUTHENTICATION_TOKEN),	"GET_AUTHENTICATION_TOKEN"},
+{ERR_FUNC(EAC_F_GET_PUBKEY),	"GET_PUBKEY"},
+{ERR_FUNC(EAC_F_GET_RFC5114_MODP),	"GET_RFC5114_MODP"},
+{ERR_FUNC(EAC_F_GET_TA_SIGDATA),	"GET_TA_SIGDATA"},
+{ERR_FUNC(EAC_F_HASH),	"HASH"},
+{ERR_FUNC(EAC_F_INIT_DH),	"INIT_DH"},
+{ERR_FUNC(EAC_F_INIT_ECDH),	"INIT_ECDH"},
+{ERR_FUNC(EAC_F_IS_CHAR_STR),	"IS_CHAR_STR"},
+{ERR_FUNC(EAC_F_KA_CTX_COMPUTE_KEY),	"KA_CTX_compute_key"},
+{ERR_FUNC(EAC_F_KA_CTX_DERIVE_KEYS),	"KA_CTX_derive_keys"},
+{ERR_FUNC(EAC_F_KA_CTX_DUP),	"KA_CTX_dup"},
+{ERR_FUNC(EAC_F_KA_CTX_GENERATE_KEY),	"KA_CTX_generate_key"},
+{ERR_FUNC(EAC_F_KA_CTX_SET_PROTOCOL),	"KA_CTX_set_protocol"},
+{ERR_FUNC(EAC_F_KDF),	"KDF"},
+{ERR_FUNC(EAC_F_KDF_ENC),	"KDF_ENC"},
+{ERR_FUNC(EAC_F_KDF_MAC),	"KDF_MAC"},
+{ERR_FUNC(EAC_F_PACE_CTX_SET_PROTOCOL),	"PACE_CTX_set_protocol"},
+{ERR_FUNC(EAC_F_PACE_SEC_NEW),	"PACE_SEC_NEW"},
+{ERR_FUNC(EAC_F_PACE_STEP1_ENC_NONCE),	"PACE_STEP1_enc_nonce"},
+{ERR_FUNC(EAC_F_PACE_STEP2_DEC_NONCE),	"PACE_STEP2_dec_nonce"},
+{ERR_FUNC(EAC_F_PACE_STEP3A_GENERATE_MAPPING_DATA),	"PACE_STEP3A_generate_mapping_data"},
+{ERR_FUNC(EAC_F_PACE_STEP3A_MAP_DP),	"PACE_STEP3A_map_dp"},
+{ERR_FUNC(EAC_F_PACE_STEP3A_MAP_GENERATOR),	"PACE_STEP3A_MAP_GENERATOR"},
+{ERR_FUNC(EAC_F_PACE_STEP3B_COMPUTE_EPHEMERAL_KEY),	"PACE_STEP3B_compute_ephemeral_key"},
+{ERR_FUNC(EAC_F_PACE_STEP3B_COMPUTE_SHARED_SECRET),	"PACE_STEP3B_COMPUTE_SHARED_SECRET"},
+{ERR_FUNC(EAC_F_PACE_STEP3B_GENERATE_EPHEMERAL_KEY),	"PACE_STEP3B_generate_ephemeral_key"},
+{ERR_FUNC(EAC_F_PACE_STEP3B_PROCESS),	"PACE_STEP3B_PROCESS"},
+{ERR_FUNC(EAC_F_PACE_STEP3C_DERIVE_KEYS),	"PACE_STEP3C_derive_keys"},
+{ERR_FUNC(EAC_F_PACE_STEP3D_),	"PACE_STEP3D_"},
+{ERR_FUNC(EAC_F_PACE_STEP3D_COMPUTE_AUTHENTICATION_TOKEN),	"PACE_STEP3D_compute_authentication_token"},
+{ERR_FUNC(EAC_F_PACE_STEP3D_VERIFY_AUTHENTICATION_TOKEN),	"PACE_STEP3D_verify_authentication_token"},
+{ERR_FUNC(EAC_F_RETAIL_MAC_DES),	"RETAIL_MAC_DES"},
+{ERR_FUNC(EAC_F_RI_CTX_COMPUTE_KEY),	"RI_CTX_COMPUTE_KEY"},
+{ERR_FUNC(EAC_F_RI_CTX_GENERATE_KEY),	"RI_CTX_GENERATE_KEY"},
+{ERR_FUNC(EAC_F_RI_CTX_SET_PROTOCOL),	"RI_CTX_SET_PROTOCOL"},
+{ERR_FUNC(EAC_F_RI_STEP2_COMPUTE_IDENTIFIER),	"RI_STEP2_COMPUTE_IDENTIFIER"},
+{ERR_FUNC(EAC_F_TA_CTX_IMPORT_CERTIFICATE),	"TA_CTX_IMPORT_CERTIFICATE"},
+{ERR_FUNC(EAC_F_TA_CTX_INIT_COMPAT),	"TA_CTX_INIT_COMPAT"},
+{ERR_FUNC(EAC_F_TA_CTX_SET_MD),	"TA_CTX_SET_MD"},
+{ERR_FUNC(EAC_F_TA_SET_NONCE),	"TA_SET_NONCE"},
+{ERR_FUNC(EAC_F_TA_STEP2_IMPORT_CERTIFICATE),	"TA_STEP2_IMPORT_CERTIFICATE"},
+{ERR_FUNC(EAC_F_TA_STEP3_GENERATE_EPHEMERAL_KEY),	"TA_STEP3_GENERATE_EPHEMERAL_KEY"},
+{ERR_FUNC(EAC_F_TA_STEP4_GET_NONCE),	"TA_STEP4_GET_NONCE"},
+{ERR_FUNC(EAC_F_TA_STEP4_SET_NONCE),	"TA_STEP4_SET_NONCE"},
+{ERR_FUNC(EAC_F_TA_STEP5_SIGN),	"TA_STEP5_SIGN"},
+{ERR_FUNC(EAC_F_TA_STEP6_VERIFY),	"TA_STEP6_VERIFY"},
+{ERR_FUNC(EAC_F_UPDATE_IV),	"UPDATE_IV"},
+{ERR_FUNC(EAC_F_VERIFY_AUTHENTICATION_TOKEN),	"VERIFY_AUTHENTICATION_TOKEN"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA EAC_str_reasons[]=
+	{
+{ERR_REASON(EAC_R_BAD_DH_GENERATOR)      ,"bad dh generator"},
+{ERR_REASON(EAC_R_BAD_DH_KEY)            ,"bad dh key"},
+{ERR_REASON(EAC_R_BAD_DH_OR_ECKEY_OBJECT),"bad dh or eckey object"},
+{ERR_REASON(EAC_R_CONDITIONS_NOT_SATISFIED),"conditions not satisfied"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_CA_DP_INFO),"could not decode ca dp info"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_CA_INFO),"could not decode ca info"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_EC_KEY),"could not decode ec key"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_PACE_DP_INFO),"could not decode pace dp info"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_PACE_INFO),"could not decode pace info"},
+{ERR_REASON(EAC_R_COULD_NOT_DECODE_TA_INFO),"could not decode ta info"},
+{ERR_REASON(EAC_R_CURRENT_CAR_DOES_NOT_MATCH_NEXT_CHR),"current car does not match next chr"},
+{ERR_REASON(EAC_R_CURRENT_CHR_DOES_NOT_MATCH_NEXT_CAR),"current chr does not match next car"},
+{ERR_REASON(EAC_R_CURRENT_SIGNATURE_NOT_VERIFIED),"current signature not verified"},
+{ERR_REASON(EAC_R_DATA_IS_NOT_OF_BLOCKLENGTH),"data is not of blocklength"},
+{ERR_REASON(EAC_R_FAILED_TO_COPY)        ,"failed to copy"},
+{ERR_REASON(EAC_R_FAILED_TO_SET_PADDING) ,"failed to set padding"},
+{ERR_REASON(EAC_R_IM_ONLY_SUPPORTED_FOR_TR_201_AND_EARLIER),"im only supported for tr 201 and earlier"},
+{ERR_REASON(EAC_R_INCOMPLETE_DOMAIN_PARAMETERS),"incomplete domain parameters"},
+{ERR_REASON(EAC_R_INCORRECT_DOMAIN_PARAMETERS),"incorrect domain parameters"},
+{ERR_REASON(EAC_R_INVALID_ARGUMENTS)     ,"invalid arguments"},
+{ERR_REASON(EAC_R_INVALID_DATA)          ,"invalid data"},
+{ERR_REASON(EAC_R_INVALID_KEY_FORMAT)    ,"invalid key format"},
+{ERR_REASON(EAC_R_KEY_TOO_SHORT)         ,"key too short"},
+{ERR_REASON(EAC_R_MESSAGE_DIGEST_NOT_SUITABLE_FOR_CIPHER),"message digest not suitable for cipher"},
+{ERR_REASON(EAC_R_REALLOC_FAILED)        ,"realloc failed"},
+{ERR_REASON(EAC_R_UNABLE_TO_GET_ORDER)   ,"unable to get order"},
+{ERR_REASON(EAC_R_UNABLE_TO_GET_SG_PRIME),"unable to get sg prime"},
+{ERR_REASON(EAC_R_UNKNOWN_CIPHER)        ,"unknown cipher"},
+{ERR_REASON(EAC_R_UNKNOWN_PACE_PARAMETERS),"unknown pace parameters"},
+{ERR_REASON(EAC_R_UNKNOWN_PARAMETERS)    ,"unknown parameters"},
+{ERR_REASON(EAC_R_UNKNOWN_PROTOCOL)      ,"unknown protocol"},
+{ERR_REASON(EAC_R_UNSUITED_CURVE)        ,"unsuited curve"},
+{ERR_REASON(EAC_R_WRONG_PUBLIC_KEY)      ,"wrong public key"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_EAC_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(EAC_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,EAC_str_functs);
+		ERR_load_strings(0,EAC_str_reasons);
+		}
+#endif
+	}
Index: openssl/crypto/eac/eac_kdf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_kdf.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,122 @@
+/**
+ * @file
+ * @brief Key derivation functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+
+#include "eac_kdf.h"
+#include "eac_util.h"
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#define USE_SOCKETS
+#undef OPENSSL_USE_APPLINK
+#include "cryptlib.h"
+
+BUF_MEM *
+kdf(const BUF_MEM *key, const BUF_MEM *nonce, const uint32_t counter,
+        const KA_CTX *ka_ctx, EVP_MD_CTX *md_ctx)
+{
+    size_t inlen;
+    BUF_MEM *in = NULL, *digest = NULL, *out = NULL;
+
+    if (!key || !ka_ctx->md || !ka_ctx->cipher) {
+        EACerr(EAC_F_KDF, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+    if (ka_ctx->cipher->key_len > EVP_MD_size(ka_ctx->md)) {
+        EACerr(EAC_F_KDF, EAC_R_MESSAGE_DIGEST_NOT_SUITABLE_FOR_CIPHER);
+        goto err;
+    }
+
+    in = BUF_MEM_new();
+    if (!in)
+        goto err;
+
+    /* Concatenate secret || nonce || counter
+     * nonce is optional */
+    if (nonce) {
+        inlen = key->length + nonce->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        /* Flawfinder: ignore */
+        memcpy(in->data, key->data, key->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length, nonce->data, nonce->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length + nonce->length, &counter, sizeof counter);
+    } else {
+        inlen = key->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        /* Flawfinder: ignore */
+        memcpy(in->data, key->data, key->length);
+        /* Flawfinder: ignore */
+        memcpy(in->data + key->length, &counter, sizeof counter);
+    }
+
+    digest = hash(ka_ctx->md, md_ctx, ka_ctx->md_engine, in);
+    if (!digest)
+        goto err;
+
+    /* Truncate the hash to the length of the key */
+    out = BUF_MEM_create_init(digest->data, ka_ctx->cipher->key_len);
+
+    OPENSSL_cleanse(in->data, in->max);
+    BUF_MEM_free(in);
+    OPENSSL_cleanse(digest->data, digest->max);
+    BUF_MEM_free(digest);
+
+    return out;
+
+err:
+    if (in) {
+        OPENSSL_cleanse(in->data, in->max);
+        BUF_MEM_free(in);
+    }
+    if (out) {
+        OPENSSL_cleanse(out->data, out->max);
+        BUF_MEM_free(out);
+    }
+    if (digest) {
+        OPENSSL_cleanse(digest->data, digest->max);
+        BUF_MEM_free(digest);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+kdf_pi(const PACE_SEC *pi, const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx)
+{
+    BUF_MEM * out;
+
+    out = kdf(pi->encoded, nonce, htonl(KDF_PI_COUNTER), ctx, md_ctx);
+
+    return out;
+}
+
+BUF_MEM *
+kdf_enc(const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx)
+{
+    if (!ctx) {
+        EACerr(EAC_F_KDF_ENC, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return kdf(ctx->shared_secret, nonce, htonl(KDF_ENC_COUNTER), ctx, md_ctx);
+}
+
+BUF_MEM *
+kdf_mac(const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx)
+{
+    if (!ctx) {
+        EACerr(EAC_F_KDF_MAC, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return kdf(ctx->shared_secret, nonce, htonl(KDF_MAC_COUNTER), ctx, md_ctx);
+}
Index: openssl/crypto/eac/eac_kdf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_kdf.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,60 @@
+/**
+ * @file
+ * @brief Interface to key derivation functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_KDF_H_
+#define PACE_KDF_H_
+
+#include <openssl/buffer.h>
+#include <openssl/pace.h>
+#include <openssl/evp.h>
+#include <stdint.h>
+
+/**
+ * @defgroup kdf            Key Derivation Functions
+ * @{ ************************************************************************/
+
+/**
+ * @brief General key derivation function according to TR-3110 F.3.1
+ *
+ * @param[in] key Shared secret
+ * @param[in] nonce (optional)
+ * @param[in] counter Formatted in big endian
+ * @param[in] ctx
+ *
+ * @return derivated key or NULL if an error occurred
+ */
+BUF_MEM *
+kdf(const BUF_MEM *key, const BUF_MEM *nonce, const uint32_t counter,
+        const KA_CTX *ctx, EVP_MD_CTX *md_ctx);
+#define KDF_ENC_COUNTER 1
+#define KDF_MAC_COUNTER 2
+#define KDF_PI_COUNTER  3
+/**
+ * @brief Key derivation function to derive encryption key
+ *
+ * @see kdf()
+ */
+BUF_MEM *
+kdf_enc(const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx);
+/**
+ * @brief Key derivation function to derive authentication key
+ *
+ * @see kdf()
+ */
+BUF_MEM *
+kdf_mac(const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx);
+/**
+ * @brief Key derivation function from a password pi
+ *
+ * @see kdf()
+ */
+BUF_MEM *
+kdf_pi(const PACE_SEC *pi, const BUF_MEM *nonce, const KA_CTX *ctx, EVP_MD_CTX *md_ctx);
+/** @} ***********************************************************************/
+
+#endif /*PACE_KDF_H_*/
Index: openssl/crypto/eac/eac_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_lib.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,509 @@
+/**
+ * @file
+ * @brief Data management functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "ca_lib.h"
+#include "eac_dh.h"
+#include "eac_ecdh.h"
+#include "eac_lib.h"
+#include "eac_util.h"
+#include "pace_lib.h"
+#include "ta_lib.h"
+#include <openssl/buffer.h>
+#include <openssl/ca.h>
+#include <openssl/crypto.h>
+#include <openssl/cv_cert.h>
+#include <openssl/eac.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include <openssl/ri.h>
+#include <openssl/ta.h>
+#include <string.h>
+
+static unsigned char DECVCAeID00102[] = {
+    0x7f, 0x21, 0x82, 0x01, 0xb6, 0x7f, 0x4e, 0x82, 0x01, 0x6e, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, /*.!....N..n_)..B.*/
+    0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, /*DECVCAeID00102.I*/
+    0x82, 0x01, 0x1d, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x81, /*................*/
+    0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, /* ..W.....>f.....*/
+    0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, /*rn;.#.& ( .H..nS*/
+    0x77, 0x82, 0x20, 0x7d, 0x5a, 0x09, 0x75, 0xfc, 0x2c, 0x30, 0x57, 0xee, 0xf6, 0x75, 0x30, 0x41, /*w. }Z.u.,0W..u0A*/
+    0x7a, 0xff, 0xe7, 0xfb, 0x80, 0x55, 0xc1, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, /*z....U.&.\l.JKD.*/
+    0x30, 0xb5, 0xd9, 0x83, 0x20, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, 0x30, 0xb5, /*0... &.\l.JKD.0.*/
+    0xd9, 0xbb, 0xd7, 0x7c, 0xbf, 0x95, 0x84, 0x16, 0x29, 0x5c, 0xf7, 0xe1, 0xce, 0x6b, 0xcc, 0xdc, /*...|....)\...k..*/
+    0x18, 0xff, 0x8c, 0x07, 0xb6, 0x84, 0x41, 0x04, 0x8b, 0xd2, 0xae, 0xb9, 0xcb, 0x7e, 0x57, 0xcb, /*......A......~W.*/
+    0x2c, 0x4b, 0x48, 0x2f, 0xfc, 0x81, 0xb7, 0xaf, 0xb9, 0xde, 0x27, 0xe1, 0xe3, 0xbd, 0x23, 0xc2, /*,KH/......'...#.*/
+    0x3a, 0x44, 0x53, 0xbd, 0x9a, 0xce, 0x32, 0x62, 0x54, 0x7e, 0xf8, 0x35, 0xc3, 0xda, 0xc4, 0xfd, /*:DS...2bT~.5....*/
+    0x97, 0xf8, 0x46, 0x1a, 0x14, 0x61, 0x1d, 0xc9, 0xc2, 0x77, 0x45, 0x13, 0x2d, 0xed, 0x8e, 0x54, /*..F..a...wE.-..T*/
+    0x5c, 0x1d, 0x54, 0xc7, 0x2f, 0x04, 0x69, 0x97, 0x85, 0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, /*\.T./.i.. ..W...*/
+    0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71, 0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, /*..>f.....q.9z..a*/
+    0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7, 0x86, 0x41, 0x04, 0x33, 0x47, 0xec, /*.......HV..A.3G.*/
+    0xf9, 0x6f, 0xfb, 0x4b, 0xd9, 0xb8, 0x55, 0x4e, 0xfb, 0xcc, 0xfc, 0x7d, 0x0b, 0x24, 0x2f, 0x10, /*.o.K..UN...}.$/.*/
+    0x71, 0xe2, 0x9b, 0x4c, 0x9c, 0x62, 0x2c, 0x79, 0xe3, 0x39, 0xd8, 0x40, 0xaf, 0x67, 0xbe, 0xb9, /*q..L.b,y.9.@.g..*/
+    0xb9, 0x12, 0x69, 0x22, 0x65, 0xd9, 0xc1, 0x6c, 0x62, 0x57, 0x3f, 0x45, 0x79, 0xff, 0xd4, 0xde, /*..i"e..lbW?Ey...*/
+    0x2d, 0xe9, 0x2b, 0xab, 0x40, 0x9d, 0xd5, 0xc5, 0xd4, 0x82, 0x44, 0xa9, 0xf7, 0x87, 0x01, 0x01, /*-.+.@.....D.....*/
+    0x5f, 0x20, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, /*_ .DECVCAeID0010*/
+    0x32, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, /*2.L............S*/
+    0x05, 0xfe, 0x0f, 0x01, 0xff, 0xff, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x01, 0x00, 0x01, 0x08, 0x5f, /*......_%......._*/
+    0x24, 0x06, 0x01, 0x03, 0x01, 0x00, 0x01, 0x08, 0x5f, 0x37, 0x40, 0x50, 0x67, 0x14, 0x5c, 0x68, /*$......._7@Pg.\h*/
+    0xca, 0xe9, 0x52, 0x0f, 0x5b, 0xb3, 0x48, 0x17, 0xf1, 0xca, 0x9c, 0x43, 0x59, 0x3d, 0xb5, 0x64, /*..R.[.H....CY=.d*/
+    0x06, 0xc6, 0xa3, 0xb0, 0x06, 0xcb, 0xf3, 0xf3, 0x14, 0xe7, 0x34, 0x9a, 0xcf, 0x0c, 0xc6, 0xbf, /*..........4.....*/
+    0xeb, 0xcb, 0xde, 0xfd, 0x10, 0xb4, 0xdc, 0xf0, 0xf2, 0x31, 0xda, 0x56, 0x97, 0x7d, 0x88, 0xf9, /*.........1.V.}..*/
+    0xf9, 0x01, 0x82, 0xd1, 0x99, 0x07, 0x6a, 0x56, 0x50, 0x64, 0x51,                               /*......jVPdQ*/
+};
+static unsigned char DECVCAEPASS00102[] = {
+    0x7f, 0x21, 0x82, 0x01, 0xb6, 0x7f, 0x4e, 0x82, 0x01, 0x6e, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /*.!....N..n_)..B.*/
+    0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x45, 0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x30, 0x32, /*DECVCAEPASS00102*/
+    0x7f, 0x49, 0x82, 0x01, 0x1d, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, /*.I..............*/
+    0x03, 0x81, 0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, /*.., 0x..W.....>f...*/
+    0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, /*..rn;.#.&, 0x(, 0x.H..*/
+    0x6e, 0x53, 0x77, 0x82, 0x20, 0x7d, 0x5a, 0x09, 0x75, 0xfc, 0x2c, 0x30, 0x57, 0xee, 0xf6, 0x75, /*nSw., 0x}Z.u.,0W..u*/
+    0x30, 0x41, 0x7a, 0xff, 0xe7, 0xfb, 0x80, 0x55, 0xc1, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, /*0Az....U.&.\l.JK*/
+    0x44, 0xf3, 0x30, 0xb5, 0xd9, 0x83, 0x20, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, /*D.0..., 0x&.\l.JKD.*/
+    0x30, 0xb5, 0xd9, 0xbb, 0xd7, 0x7c, 0xbf, 0x95, 0x84, 0x16, 0x29, 0x5c, 0xf7, 0xe1, 0xce, 0x6b, /*0....|....)\...k*/
+    0xcc, 0xdc, 0x18, 0xff, 0x8c, 0x07, 0xb6, 0x84, 0x41, 0x04, 0x8b, 0xd2, 0xae, 0xb9, 0xcb, 0x7e, /*........A......~*/
+    0x57, 0xcb, 0x2c, 0x4b, 0x48, 0x2f, 0xfc, 0x81, 0xb7, 0xaf, 0xb9, 0xde, 0x27, 0xe1, 0xe3, 0xbd, /*W.,KH/......'...*/
+    0x23, 0xc2, 0x3a, 0x44, 0x53, 0xbd, 0x9a, 0xce, 0x32, 0x62, 0x54, 0x7e, 0xf8, 0x35, 0xc3, 0xda, /*#.:DS...2bT~.5..*/
+    0xc4, 0xfd, 0x97, 0xf8, 0x46, 0x1a, 0x14, 0x61, 0x1d, 0xc9, 0xc2, 0x77, 0x45, 0x13, 0x2d, 0xed, /*....F..a...wE.-.*/
+    0x8e, 0x54, 0x5c, 0x1d, 0x54, 0xc7, 0x2f, 0x04, 0x69, 0x97, 0x85, 0x20, 0xa9, 0xfb, 0x57, 0xdb, /*.T\.T./.i.., 0x..W.*/
+    0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71, 0x8c, 0x39, 0x7a, 0xa3, /*....>f.....q.9z.*/
+    0xb5, 0x61, 0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7, 0x86, 0x41, 0x04, 0x43, /*.a.......HV..A.C*/
+    0x3e, 0xdc, 0xc9, 0x3e, 0x73, 0xe8, 0xe2, 0x92, 0xf4, 0xd9, 0x41, 0xed, 0x06, 0x58, 0x0e, 0x56, /*>..>s.....A..X.V*/
+    0x8f, 0x7f, 0x09, 0xfc, 0x5e, 0xc3, 0x4e, 0x90, 0x6e, 0x5a, 0x61, 0xae, 0x83, 0x10, 0x8f, 0xa2, /*....^.N.nZa.....*/
+    0x76, 0x95, 0x2f, 0xbd, 0xa1, 0x4f, 0xfe, 0x47, 0xfd, 0x08, 0xec, 0x42, 0xa8, 0x20, 0xc7, 0x73, /*v./..O.G...B., 0x.s*/
+    0xb2, 0x27, 0x02, 0xfc, 0x47, 0xbf, 0xf1, 0xa1, 0xd3, 0x41, 0x60, 0xb6, 0x46, 0x23, 0xd7, 0x87, /*.'..G....A`.F#..*/
+    0x01, 0x01, 0x5f, 0x20, 0x10, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x45, 0x50, 0x41, 0x53, 0x53, /*.._, 0x.DECVCAEPASS*/
+    0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x4c, 0x0e, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, /*00102.L.........*/
+    0x01, 0x02, 0x01, 0x53, 0x01, 0xc1, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x01, 0x00, 0x01, 0x08, 0x5f, /*...S.._%......._*/
+    0x24, 0x06, 0x01, 0x03, 0x01, 0x00, 0x01, 0x08, 0x5f, 0x37, 0x40, 0x90, 0xd5, 0xe1, 0x71, 0xeb, /*$......._7@...q.*/
+    0xb2, 0xce, 0x74, 0x9f, 0xb3, 0x15, 0xb3, 0x13, 0x29, 0x9f, 0xa9, 0x04, 0x24, 0x1d, 0xde, 0x27, /*..t.....)...$..'*/
+    0x1b, 0xf5, 0xc6, 0x81, 0x9c, 0x8f, 0xcd, 0xe7, 0xbb, 0x4c, 0xb4, 0x77, 0x62, 0x3f, 0x1c, 0xcd, /*.........L.wb?..*/
+    0xd7, 0x1a, 0xd3, 0xda, 0x90, 0xfa, 0x4c, 0x48, 0xe5, 0x8a, 0x96, 0xc7, 0x4f, 0xea, 0xdc, 0xe3, /*......LH....O...*/
+    0x85, 0xe4, 0xa2, 0x77, 0x98, 0x22, 0xb4, 0x79, 0xfa, 0x4a, 0xe4,                               /*...w.".y.J.*/
+};
+struct certificates {
+    char *chr;
+    unsigned char *cert;
+    size_t cert_len;
+};
+static struct certificates certs[] = {
+    {"DECVCAeID00102", DECVCAeID00102, sizeof DECVCAeID00102},
+    {"DECVCAEPASS00102", DECVCAEPASS00102, sizeof DECVCAEPASS00102},
+};
+
+EAC_CTX *
+EAC_CTX_new(void)
+{
+    EAC_CTX *ctx = OPENSSL_malloc(sizeof(EAC_CTX));
+    if (!ctx)
+        return NULL;
+
+    ctx->bn_ctx = BN_CTX_new();
+    ctx->pace_ctx = PACE_CTX_new();
+    ctx->md_ctx = EVP_MD_CTX_create();
+    ctx->ta_ctx = TA_CTX_new();
+    ctx->ca_ctx = CA_CTX_new();
+    ctx->cipher_ctx = EVP_CIPHER_CTX_new();
+    ctx->ri_ctx = RI_CTX_new();
+
+    if (!ctx->bn_ctx || !ctx->md_ctx || !ctx->pace_ctx || !ctx->ta_ctx
+                       || !ctx->ca_ctx || !ctx->cipher_ctx || !ctx->ri_ctx)
+        goto err;
+
+    ctx->tr_version = EAC_TR_VERSION_2_02;
+    BN_CTX_init(ctx->bn_ctx);
+    EVP_CIPHER_CTX_init(ctx->cipher_ctx);
+    ctx->key_ctx = NULL;
+
+    return ctx;
+
+err:
+    EAC_CTX_clear_free(ctx);
+    return NULL;
+}
+
+int
+EAC_CTX_init_pace(EAC_CTX *ctx, int protocol, int curve)
+{
+    if (!ctx || !ctx->pace_ctx) {
+        EACerr(EAC_F_EAC_CTX_INIT_PACE, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    if (!PACE_CTX_set_protocol(ctx->pace_ctx, protocol, ctx->tr_version)
+                || !EVP_PKEY_set_std_dp(ctx->pace_ctx->static_key, curve))
+        return 0;
+
+    return 1;
+}
+
+CVC_CERT *
+cert_from_car(const unsigned char *car, size_t car_len)
+{
+    size_t i;
+    const unsigned char *p;
+
+    if (!car || !car_len) {
+        EACerr(EAC_F_CERT_FROM_CAR, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    for (i = 0; i < (sizeof certs)/sizeof *certs; i++) {
+        if (strlen(certs[i].chr) == car_len
+                && memcmp(certs[i].chr, car, car_len) == 0) {
+            p = certs[i].cert;
+            return CVC_d2i_CVC_CERT(NULL, &p, certs[i].cert_len);
+        }
+    }
+
+    return NULL;
+}
+
+int
+EAC_CTX_init_ta(const EAC_CTX *ctx,
+           const unsigned char *privkey, size_t privkey_len,
+           const unsigned char *cert, size_t cert_len,
+           const unsigned char *car, size_t car_len)
+{
+    CVC_CERT *ta_cert = NULL;
+    int r = 0;
+
+    if (!ctx) {
+        EACerr(EAC_F_EAC_CTX_INIT_TA, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (privkey && privkey_len) {
+        if (ctx->ta_ctx->priv_key)
+            EVP_PKEY_free(ctx->ta_ctx->priv_key);
+        ctx->ta_ctx->priv_key = d2i_AutoPrivateKey(&ctx->ta_ctx->priv_key,
+                &privkey, privkey_len);
+        if (!ctx->ta_ctx->priv_key)
+            goto err;
+    }
+
+    if (cert && cert_len) {
+        ta_cert = CVC_d2i_CVC_CERT(&ta_cert, &cert, cert_len);
+        if (car && car_len && ta_cert) {
+            if (!ta_cert->body || !ta_cert->body->certificate_holder_reference
+                    || ta_cert->body->certificate_holder_reference->length != car_len
+                    || memcmp(ta_cert->body->certificate_holder_reference->data, car, car_len) != 0)
+                goto err;
+        }
+    } else
+        ta_cert = cert_from_car(car, car_len);
+    r = TA_CTX_import_certificate(ctx->ta_ctx, ta_cert, ctx->bn_ctx);
+
+err:
+    if (ta_cert)
+        CVC_CERT_free(ta_cert);
+
+    return r;
+}
+
+int
+EAC_CTX_init_ca(const EAC_CTX *ctx, int protocol, int curve,
+                const unsigned char *priv, size_t priv_len,
+                const unsigned char *pub, size_t pub_len)
+{
+    if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx
+               || (!priv && pub)) {
+        EACerr(EAC_F_EAC_CTX_INIT_CA, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    if (!CA_CTX_set_protocol(ctx->ca_ctx, protocol)
+                || !EVP_PKEY_set_std_dp(ctx->ca_ctx->ka_ctx->key, curve))
+        return 0;
+
+    if (priv && !pub) {
+        if (!d2i_AutoPrivateKey(&ctx->ca_ctx->ka_ctx->key, &priv, priv_len))
+            return 0;
+    }
+
+    if (priv && pub)
+        return EVP_PKEY_set_keys(ctx->ca_ctx->ka_ctx->key, priv, priv_len,
+                   pub, pub_len, ctx->bn_ctx);
+
+    return 1;
+}
+
+int
+EAC_CTX_init_ri(EAC_CTX *ctx, int protocol, int stnd_dp)
+{
+
+    BUF_MEM *pubkey = NULL;
+
+    if (!ctx || !ctx->ri_ctx) {
+        EACerr(EAC_F_EAC_CTX_INIT_RI, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    if (!RI_CTX_set_protocol(ctx->ri_ctx, protocol)
+               || !EVP_PKEY_set_std_dp(ctx->ri_ctx->static_key, stnd_dp))
+            return 0;
+
+    if (!ctx->ri_ctx->generate_key)
+        return 0;
+
+    pubkey = ctx->ri_ctx->generate_key(ctx->ri_ctx->static_key, ctx->bn_ctx);
+    if (!pubkey)
+        return 0;
+    else /* We do not need the buffered public key and throw it away immediately */
+        BUF_MEM_clear_free(pubkey);
+
+    return 1;
+}
+
+void
+EAC_CTX_clear_free(EAC_CTX *ctx) {
+    if (ctx) {
+        if (ctx->bn_ctx)
+            BN_CTX_free(ctx->bn_ctx);
+        if (ctx->md_ctx)
+            EVP_MD_CTX_destroy(ctx->md_ctx);
+        if (ctx->cipher_ctx)
+            EVP_CIPHER_CTX_free(ctx->cipher_ctx);
+        if (ctx->pace_ctx)
+            PACE_CTX_clear_free(ctx->pace_ctx);
+        if (ctx->ta_ctx)
+            TA_CTX_clear_free(ctx->ta_ctx);
+        if (ctx->ca_ctx)
+            CA_CTX_clear_free(ctx->ca_ctx);
+        if (ctx->key_ctx)
+            KA_CTX_clear_free(ctx->key_ctx);
+        if (ctx->ri_ctx)
+            RI_CTX_clear_free(ctx->ri_ctx);
+        OPENSSL_free(ctx);
+    }
+}
+
+KA_CTX *
+KA_CTX_new(void)
+{
+    KA_CTX * out = OPENSSL_malloc(sizeof(KA_CTX));
+    if (!out)
+        goto err;
+
+    out->key = EVP_PKEY_new();
+    if (!out->key)
+        goto err;
+
+    out->md = NULL;
+    out->md_engine = NULL;
+    out->cmac_ctx = NULL;
+    out->cipher = NULL;
+    out->cipher_engine = NULL;
+    out->iv = NULL;
+    out->generate_key = NULL;
+    out->compute_key = NULL;
+    out->mac_keylen = 0;
+    out->enc_keylen = 0;
+    out->shared_secret = NULL;
+    out->k_enc = NULL;
+    out->k_mac = NULL;
+
+    return out;
+
+err:
+    if (out) {
+        if (out->key)
+            EVP_PKEY_free(out->key);
+        OPENSSL_free(out);
+    }
+    return NULL;
+}
+
+KA_CTX *
+KA_CTX_dup(const KA_CTX *ka_ctx)
+{
+    KA_CTX *out = NULL;
+
+    if (!ka_ctx) {
+        EACerr(EAC_F_KA_CTX_DUP, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    out = OPENSSL_malloc(sizeof(KA_CTX));
+    if (!out)
+        goto err;
+
+    out->key = EVP_PKEY_dup(ka_ctx->key);
+    if (!out->key && ka_ctx->key)
+        goto err;
+
+    out->md = ka_ctx->md;
+    out->md_engine = ka_ctx->md_engine;
+    out->cmac_ctx = NULL;
+    out->cipher = ka_ctx->cipher;
+    out->cipher_engine = ka_ctx->cipher_engine;
+    out->iv = NULL;
+    out->generate_key = ka_ctx->generate_key;
+    out->compute_key = ka_ctx->compute_key;
+    out->mac_keylen = ka_ctx->mac_keylen;
+    out->enc_keylen = ka_ctx->enc_keylen;
+    if (ka_ctx->k_enc) {
+        out->k_enc = BUF_MEM_create_init(ka_ctx->k_enc->data, ka_ctx->k_enc->length);
+        if (!out->k_enc)
+            goto err;
+    } else
+        out->k_enc = NULL;
+    if (ka_ctx->k_mac) {
+        out->k_mac = BUF_MEM_create_init(ka_ctx->k_mac->data, ka_ctx->k_mac->length);
+        if (!out->k_mac)
+            goto err;
+    } else
+        out->k_mac = NULL;
+    if (ka_ctx->shared_secret) {
+        out->shared_secret = BUF_MEM_create_init(ka_ctx->shared_secret->data, ka_ctx->shared_secret->length);
+        if (!out->shared_secret)
+            goto err;
+    } else
+        out->shared_secret = NULL;
+
+    return out;
+
+err:
+    KA_CTX_clear_free(out);
+
+    return NULL;
+}
+
+void
+KA_CTX_clear_free(KA_CTX *ctx)
+{
+    if (ctx) {
+        if (ctx->cmac_ctx) /* FIXME: Segfaults if CMAC_Init has not been called */
+            CMAC_CTX_free(ctx->cmac_ctx);
+        if (ctx->key)
+            EVP_PKEY_free(ctx->key);
+        if (ctx->shared_secret) {
+            OPENSSL_cleanse(ctx->shared_secret->data, ctx->shared_secret->max);
+            BUF_MEM_free(ctx->shared_secret);
+        }
+        if (ctx->k_mac) {
+            OPENSSL_cleanse(ctx->k_mac->data, ctx->k_mac->max);
+            BUF_MEM_free(ctx->k_mac);
+        }
+        if (ctx->k_enc) {
+            OPENSSL_cleanse(ctx->k_enc->data, ctx->k_enc->max);
+            BUF_MEM_free(ctx->k_enc);
+        }
+        free(ctx->iv);
+        OPENSSL_free(ctx);
+    }
+}
+
+int
+KA_CTX_set_protocol(KA_CTX *ctx, int protocol)
+{
+    if (!ctx) {
+        EACerr(EAC_F_KA_CTX_SET_PROTOCOL, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    switch (protocol) {
+        case NID_id_CA_DH_3DES_CBC_CBC:
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+            ctx->generate_key = dh_generate_key;
+            ctx->compute_key = dh_compute_key;
+            ctx->mac_keylen = 16;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_DH_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+            ctx->generate_key = dh_generate_key;
+            ctx->compute_key = dh_compute_key;
+            ctx->mac_keylen = 16;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_DH_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+            ctx->generate_key = dh_generate_key;
+            ctx->compute_key = dh_compute_key;
+            ctx->mac_keylen = 24;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_DH_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            ctx->generate_key = dh_generate_key;
+            ctx->compute_key = dh_compute_key;
+            ctx->mac_keylen = 32;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_ECDH_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            ctx->generate_key = ecdh_generate_key;
+            ctx->compute_key = ecdh_compute_key;
+            ctx->mac_keylen = 16;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_ECDH_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            ctx->generate_key = ecdh_generate_key;
+            ctx->compute_key = ecdh_compute_key;
+            ctx->mac_keylen = 16;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_ECDH_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            ctx->generate_key = ecdh_generate_key;
+            ctx->compute_key = ecdh_compute_key;
+            ctx->mac_keylen = 24;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        case NID_id_CA_ECDH_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            ctx->generate_key = ecdh_generate_key;
+            ctx->compute_key = ecdh_compute_key;
+            ctx->mac_keylen = 32;
+            ctx->cmac_ctx = NULL; /* We don't set cmac_ctx, because of potential segfaults */
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            ctx->enc_keylen = ctx->cipher->key_len;
+            break;
+
+        default:
+            EACerr(EAC_F_KA_CTX_SET_PROTOCOL, EAC_R_UNKNOWN_PROTOCOL);
+            return 0;
+    }
+
+    return 1;
+}
Index: openssl/crypto/eac/eac_lib.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_lib.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,35 @@
+/**
+ * @file
+ * @brief Interface for EAC library functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef EAC_LIB_H_
+#define EAC_LIB_H_
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/eac.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+BUF_MEM *
+KA_CTX_generate_key(const KA_CTX *ctx, BN_CTX *bn_ctx);
+int
+KA_CTX_compute_key(KA_CTX *ctx, const BUF_MEM *in, BN_CTX *bn_ctx);
+int
+KA_CTX_derive_keys(KA_CTX *ka_ctx, const BUF_MEM *nonce, EVP_MD_CTX *md_ctx);
+
+void KA_CTX_clear_free(KA_CTX *ctx);
+KA_CTX *KA_CTX_new(void);
+KA_CTX *KA_CTX_dup(const KA_CTX *ka_ctx);
+int KA_CTX_set_protocol(KA_CTX *ctx, int protocol);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/eac_print.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_print.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,235 @@
+/**
+ * @file
+ * @brief Implementation of printing functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/eac.h>
+
+int
+BUF_MEM_print(BIO *out, const BUF_MEM *buf, int indent)
+{
+    if (buf) {
+        if (!BIO_dump_indent(out, buf->data, buf->length, indent))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
+
+static int
+KA_CTX_print_private(BIO *out, const KA_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Key Agreement Parameters:\n"))
+            return 0;
+        if (ctx->key)
+            if (ctx->shared_secret) {
+                /* If we have a shared secret, we also must have a private key
+                 * which we can print. This is a bit clumsy but unfortunately
+                 * OpenSSL doesn't offer a function to check whether or not an
+                 * EVP_PKEY contains a private key. */
+                if (!EVP_PKEY_print_private(out, ctx->key, indent+4, NULL))
+                    return 0;
+            } else {
+                if (!EVP_PKEY_print_params(out, ctx->key, indent+4, NULL))
+                    return 0;
+            }
+            else {
+                if (!BIO_indent(out, indent+4, 80)
+                        || !BIO_printf(out, "<ABSENT>\n"))
+                    return 0;
+            }
+        if (!BIO_indent(out, indent, 80))
+            return 0;
+        if (ctx->cipher) {
+            if (!BIO_printf(out, "Cipher: %s\n", EVP_CIPHER_name(ctx->cipher)))
+                return 0;
+        } else if (!BIO_printf(out, "Cipher: %s\n", "<ABSENT>"))
+            return 0;
+        if (!BIO_indent(out, indent, 80))
+            return 0;
+        if (ctx->md) {
+            if (!BIO_printf(out, "Message Digest: %s\n", EVP_MD_name(ctx->md)))
+                return 0;
+        } else if (!BIO_printf(out, "Message Digest: %s\n", "<ABSENT>"))
+                    return 0;
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Shared Secret:\n")
+                || !BUF_MEM_print(out, ctx->shared_secret, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "K_enc:\n")
+                || !BUF_MEM_print(out, ctx->k_enc, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "K_mac:\n")
+                || !BUF_MEM_print(out, ctx->k_mac, indent+4))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
+
+static int
+TA_CTX_print_private(BIO *out, const TA_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "OID: %s\n", OBJ_nid2sn(ctx->protocol))
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Version: %d\n", ctx->version))
+            return 0;
+
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "PCD's Static Domain Parameters:\n"))
+            return 0;
+        if (ctx->priv_key) {
+            if (!EVP_PKEY_print_private(out, ctx->priv_key, indent+4, NULL))
+                return 0;
+        } else {
+            if (!BIO_indent(out, indent+4, 80)
+                    || !BIO_printf(out, "<ABSENT>\n"))
+                return 0;
+        }
+        if (ctx->pub_key) {
+            if (!EVP_PKEY_print_params(out, ctx->pub_key, indent+4, NULL))
+                return 0;
+        } else {
+            if (!BIO_indent(out, indent+4, 80)
+                    || !BIO_printf(out, "<ABSENT>\n"))
+                return 0;
+        }
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Nonce:\n")
+                || !BUF_MEM_print(out, ctx->nonce, indent+4))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
+
+static int
+CA_CTX_print_private(BIO *out, const CA_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "OID: %s\n", OBJ_nid2sn(ctx->protocol))
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Version: %d\n", ctx->version)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "PICC's Static Domain Parameters:\n")
+                || !KA_CTX_print_private(out, ctx->ka_ctx, indent+4))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
+
+static int
+RI_CTX_print_private(BIO *out, const RI_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "OID: %s\n", OBJ_nid2sn(ctx->protocol)))
+            return 0;
+
+        if (ctx->md) {
+            if (!BIO_indent(out, indent, 80)
+                    || !BIO_printf(out, "Message Digest: %s\n", EVP_MD_name(ctx->md)))
+                return 0;
+        } else if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Message Digest: %s\n", "<ABSENT>"))
+            return 0;
+
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "PICC's static domain parameters:\n"))
+            return 0;
+        if (ctx->static_key) {
+            if (!EVP_PKEY_print_params(out, ctx->static_key, indent+4, NULL))
+                return 0;
+        } else {
+            if (!BIO_printf(out, "<ABSENT>\n"))
+                return 0;
+        }
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+
+    return 1;
+}
+
+static int
+PACE_CTX_print_private(BIO *out, const PACE_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "OID: %s\n", OBJ_nid2sn(ctx->protocol))
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Version: %d\n", ctx->version)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "PICC's Static Domain Parameters:\n"))
+            return 0;
+        if (ctx->static_key) {
+            if (!EVP_PKEY_print_params(out, ctx->static_key, indent+4, NULL))
+                return 0;
+            else {
+                if (!BIO_indent(out, indent+4, 80)
+                        || !BIO_printf(out, "<ABSENT>\n"))
+                    return 0;
+            }
+        }
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Nonce:\n")
+                || !BUF_MEM_print(out, ctx->nonce, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Ephemeral Domain Parameters:\n")
+                || !KA_CTX_print_private(out, ctx->ka_ctx, indent+4))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
+
+int
+EAC_CTX_print_private(BIO *out, const EAC_CTX *ctx, int indent)
+{
+    if (ctx) {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Context for PACE\n")
+                || !PACE_CTX_print_private(out, ctx->pace_ctx, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Context for TA\n")
+                || !TA_CTX_print_private(out, ctx->ta_ctx, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Context for CA\n")
+                || !CA_CTX_print_private(out, ctx->ca_ctx, indent+4)
+                || !BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "Context for RI\n")
+                || !RI_CTX_print_private(out, ctx->ri_ctx, indent+4))
+            return 0;
+    } else {
+        if (!BIO_indent(out, indent, 80)
+                || !BIO_printf(out, "<ABSENT>\n"))
+            return 0;
+    }
+    return 1;
+}
Index: openssl/crypto/eac/eac_util.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_util.c	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,1310 @@
+/**
+ * @file
+ * @brief Utility functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_asn1.h"
+#include "eac_dh.h"
+#include "eac_ecdh.h"
+#include "eac_util.h"
+#include <openssl/bio.h>
+#include <openssl/err.h>
+#include <openssl/dh.h>
+#include <openssl/eac.h>
+#include <openssl/ec.h>
+#include <openssl/rsa.h>
+#include <openssl/ecdsa.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+#include <string.h>
+
+/**
+ * @brief Wrapper to the OpenSSL encryption functions.
+ *
+ * @param ctx (optional)
+ * @param type
+ * @param impl (optional)
+ * @param key
+ * @param iv (optional)
+ * @param enc
+ * @param in
+ *
+ * @return cipher of in or NULL if an error occurred
+ */
+static BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        const unsigned char *key, const unsigned char *iv, int enc, const BUF_MEM * in);
+static EVP_PKEY *
+EVP_PKEY_from_pubkey(EVP_PKEY *key, const BUF_MEM *pub, BN_CTX *bn_ctx);
+/**
+ * @brief Computes the authentication token over the other parties public key
+ * using the MAC key derived during PACE
+ *
+ */
+static BUF_MEM *
+compute_authentication_token(int protocol, const KA_CTX *ka_ctx, EVP_PKEY *opp_key,
+        BN_CTX *bn_ctx, enum eac_tr_version tr_version);
+/**
+ * @brief Convert an ECDSA signature from plain format to X9.62 format
+ *
+ * @param[in] plain_sig signature in plain format
+ *
+ * @return signature in X9.62 format or NULL in case of an error */
+static BUF_MEM *
+convert_from_plain_sig(const BUF_MEM *plain_sig);
+/**
+ * @brief OpenSSL uses the X9.62 signature format, we have to convert it to the
+ * plain format format specified in BSI TR 03111
+ *
+ * @param x962_sig X9.62 formatted signature
+ *
+ * @return plain format signature or NULL in case of an error
+ */
+static BUF_MEM *
+convert_to_plain_sig(const BUF_MEM *x962_sig);
+
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EVP_MD_CTX * tmp_ctx = NULL;
+    unsigned int tmp_len;
+
+    if (!md || !in) {
+        EACerr(EAC_F_HASH, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_MD_CTX_create();
+        if (!tmp_ctx)
+            goto err;
+    }
+
+    tmp_len = EVP_MD_size(md);
+    out = BUF_MEM_create(tmp_len);
+    if (!out || !EVP_DigestInit_ex(tmp_ctx, md, impl) ||
+            !EVP_DigestUpdate(tmp_ctx, in->data, in->length) ||
+            !EVP_DigestFinal_ex(tmp_ctx, (unsigned char *) out->data,
+                &tmp_len))
+        goto err;
+    out->length = tmp_len;
+
+    if (!ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (tmp_ctx && !ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return NULL;
+}
+
+static BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        const unsigned char *key, const unsigned char *iv, int enc, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EVP_CIPHER_CTX * tmp_ctx = NULL;
+    int i;
+
+    if (!in) {
+        EACerr(EAC_F_CIPHER, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_CIPHER_CTX_new();
+        if (!tmp_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(tmp_ctx);
+        if (!EVP_CipherInit_ex(tmp_ctx, type, impl, key, iv, enc))
+            goto err;
+    }
+
+    if (tmp_ctx->flags & EVP_CIPH_NO_PADDING) {
+        i = in->length;
+        if (in->length % EVP_CIPHER_block_size(type) != 0) {
+            EACerr(EAC_F_CIPHER, EAC_R_DATA_IS_NOT_OF_BLOCKLENGTH);
+            goto err;
+        }
+    } else
+        i = in->length + EVP_CIPHER_block_size(type);
+
+    out = BUF_MEM_create(i);
+    if (!out)
+        goto err;
+
+    if (!EVP_CipherUpdate(tmp_ctx, (unsigned char *) out->data, &i,
+            (unsigned char *) in->data, in->length))
+        goto err;
+    out->length = i;
+
+    if (!EVP_CipherFinal_ex(tmp_ctx, (unsigned char *) (out->data + out->length),
+            &i))
+            goto err;
+
+    if (!(tmp_ctx->flags & EVP_CIPH_NO_PADDING))
+        out->length += i;
+
+    if (!ctx)
+        EVP_CIPHER_CTX_free(tmp_ctx);
+
+    return out;
+
+err:
+
+    if (out)
+        BUF_MEM_free(out);
+    if (!ctx && tmp_ctx)
+        EVP_CIPHER_CTX_free(tmp_ctx);
+
+    return NULL;
+}
+
+BUF_MEM *
+cipher_no_pad(KA_CTX *ctx, EVP_CIPHER_CTX *cipher_ctx, const BUF_MEM *key_enc, const BUF_MEM *data, int enc)
+{
+    BUF_MEM *out = NULL;
+    EVP_CIPHER_CTX *tmp_ctx = NULL;
+
+    if (!ctx) {
+        EACerr(EAC_F_CIPHER_NO_PAD, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (cipher_ctx)
+        tmp_ctx = cipher_ctx;
+    else {
+        tmp_ctx = EVP_CIPHER_CTX_new();
+        if (!tmp_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(tmp_ctx);
+    }
+
+    if (!EVP_CipherInit_ex(tmp_ctx, ctx->cipher, ctx->cipher_engine,
+                (unsigned char *)key_enc->data, ctx->iv, enc)
+            || !EVP_CIPHER_CTX_set_padding(tmp_ctx, 0))
+        goto err;
+
+    out = cipher(tmp_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *)key_enc->data, ctx->iv, enc, data);
+
+err:
+    if (!cipher_ctx && tmp_ctx)
+        EVP_CIPHER_CTX_free(tmp_ctx);
+
+    return out;
+}
+
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, size_t maclen)
+{
+    CMAC_CTX * cmac_ctx = NULL;
+    BUF_MEM * out = NULL, * tmp = NULL;
+    size_t cmac_len = 0;
+
+    if (!key || !in || !type) {
+        EACerr(EAC_F_CMAC, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+    if (key->length < (size_t) EVP_CIPHER_key_length(type)) {
+        EACerr(EAC_F_CMAC, EAC_R_KEY_TOO_SHORT);
+        goto err;
+    }
+
+    if (ctx)
+        cmac_ctx = ctx;
+    else {
+        cmac_ctx = CMAC_CTX_new();
+    }
+
+    /* Initialize the CMAC context, feed in the data, and get the required
+     * output buffer size */
+    if (!cmac_ctx ||
+            !CMAC_Init(cmac_ctx, key->data, EVP_CIPHER_key_length(type),
+                type, NULL) ||
+            !CMAC_Update(cmac_ctx, in->data, in->length) ||
+            !CMAC_Final(cmac_ctx, NULL, &cmac_len))
+        goto err;
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(cmac_len);
+    if (!out)
+        goto err;
+
+    /* get the actual CMAC */
+    if (!CMAC_Final(cmac_ctx, (unsigned char*) out->data, &out->length))
+        goto err;
+
+    /* Truncate the CMAC if necessary */
+    if (cmac_len > maclen) {
+        tmp = BUF_MEM_create_init(out->data, maclen);
+        BUF_MEM_free(out);
+        out = tmp;
+    }
+
+    if (!ctx)
+        CMAC_CTX_free(cmac_ctx);
+
+    return out;
+
+err:
+    if (cmac_ctx && !ctx) {
+        CMAC_CTX_free(cmac_ctx);
+    }
+    if (out) {
+        BUF_MEM_free(out);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+randb(int numbytes)
+{
+    BUF_MEM * r = BUF_MEM_new();
+    if (!r || !BUF_MEM_grow(r, numbytes) ||
+            !RAND_bytes((unsigned char *) r->data, numbytes))
+        goto err;
+
+    return r;
+
+err:
+    if (r)
+        BUF_MEM_free(r);
+
+    return NULL;
+}
+
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in)
+{
+    /* ISO 9797-1 algorithm 3 retail mac without any padding */
+    BUF_MEM * c_tmp = NULL, *d_tmp = NULL, *mac = NULL, *block = NULL;
+    EVP_CIPHER_CTX * ctx = NULL;
+    size_t len;
+
+    if (!key) {
+        EACerr(EAC_F_RETAIL_MAC_DES, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Flawfinder: ignore */
+    len = EVP_CIPHER_block_size(EVP_des_cbc());
+    if ( key->length < 2*len ) {
+        EACerr(EAC_F_RETAIL_MAC_DES, EAC_R_KEY_TOO_SHORT);
+        goto err;
+    }
+
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx)
+        goto err;
+    EVP_CIPHER_CTX_init(ctx);
+    /* Flawfinder: ignore */
+    if (!EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data, NULL, 1) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+
+    /* get last block of des_cbc encrypted input */
+    /* Flawfinder: ignore */
+    c_tmp = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 1, in);
+    if (!c_tmp)
+        goto err;
+    block = BUF_MEM_create_init(c_tmp->data + c_tmp->length - len, len);
+
+    /* decrypt last block with the rest of the key */
+    /* IV is always NULL */
+    /* Flawfinder: ignore */
+    if (!block || !EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data + len, NULL, 0) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+    /* Flawfinder: ignore */
+    d_tmp = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 0, block);
+
+    /* encrypt last block with the first key */
+    /* IV is always NULL */
+    /* Flawfinder: ignore */
+    if (!d_tmp || !EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data, NULL, 1) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+    /* Flawfinder: ignore */
+    mac = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 1, d_tmp);
+
+    BUF_MEM_free(block);
+    BUF_MEM_free(c_tmp);
+    BUF_MEM_free(d_tmp);
+    EVP_CIPHER_CTX_free(ctx);
+
+    return mac;
+
+err:
+    if (block)
+        BUF_MEM_free(block);
+    if (c_tmp)
+        BUF_MEM_free(c_tmp);
+    if (d_tmp)
+        BUF_MEM_free(d_tmp);
+    if (ctx)
+        EVP_CIPHER_CTX_free(ctx);
+
+    return NULL;
+}
+
+int encode_ssc(const BIGNUM *ssc, const KA_CTX *ctx, unsigned char **encoded)
+{
+    unsigned char *p;
+    size_t en_len, bn_len;
+
+    if (!ctx || !encoded) {
+        EACerr(EAC_F_ENCODE_SSC, EAC_R_INVALID_ARGUMENTS);
+        return -1;
+    }
+
+    en_len = EVP_CIPHER_block_size(ctx->cipher);
+    p = OPENSSL_realloc(*encoded, en_len);
+    if (!p) {
+        EACerr(EAC_F_ENCODE_SSC, EAC_R_REALLOC_FAILED);
+        return -1;
+    }
+    *encoded = p;
+
+    bn_len = BN_num_bytes(ssc);
+
+    if (bn_len <= en_len) {
+        memset(*encoded, 0, en_len - bn_len);
+        BN_bn2bin(ssc, *encoded + en_len - bn_len);
+    } else {
+        p = OPENSSL_malloc(bn_len);
+        if (!p)
+            return -1;
+        BN_bn2bin(ssc, p);
+        /* Flawfinder: ignore */
+        memcpy(*encoded, p + bn_len - en_len, en_len);
+        OPENSSL_free(p);
+    }
+
+    return en_len;
+}
+
+int update_iv(KA_CTX *ctx, EVP_CIPHER_CTX *cipher_ctx, const BIGNUM *ssc)
+{
+    BUF_MEM *sscbuf = NULL, *ivbuf = NULL;
+    const EVP_CIPHER *ivcipher = NULL, *oldcipher;
+    unsigned char *ssc_buf = NULL;
+    unsigned char *p;
+    int r = 0;
+
+    if (!ctx) {
+        EACerr(EAC_F_UPDATE_IV, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    switch (EVP_CIPHER_nid(ctx->cipher)) {
+        case NID_aes_128_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_128_ecb();
+            /* fall through */
+        case NID_aes_192_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_192_ecb();
+            /* fall through */
+        case NID_aes_256_cbc:
+            if (!ivcipher)
+                ivcipher = EVP_aes_256_ecb();
+
+            /* For AES decryption the IV is not needed,
+             * so we always set it to the encryption IV=E(K_Enc, SSC) */
+            r = encode_ssc(ssc, ctx, &ssc_buf);
+            if (r < 0)
+                goto err;
+            sscbuf = BUF_MEM_create_init(ssc_buf, r);
+            if (!sscbuf)
+                goto err;
+            oldcipher = ctx->cipher;
+            ctx->cipher = ivcipher;
+            ivbuf = cipher_no_pad(ctx, cipher_ctx, ctx->k_enc, sscbuf, 1);
+            ctx->cipher = oldcipher;
+            if (!ivbuf)
+                goto err;
+            p = OPENSSL_realloc(ctx->iv, ivbuf->length);
+            if (!p)
+                goto err;
+            ctx->iv = p;
+            /* Flawfinder: ignore */
+            memcpy(ctx->iv, ivbuf->data, ivbuf->length);
+            break;
+        case NID_des_ede_cbc:
+            /* For 3DES encryption or decryption the IV is always NULL */
+            if (ctx->iv)
+                free(ctx->iv);
+            ctx->iv = NULL;
+            break;
+        default:
+            EACerr(EAC_F_UPDATE_IV, EAC_R_UNKNOWN_CIPHER);
+            goto err;
+    }
+
+    r = 1;
+
+err:
+    if (ssc_buf)
+        free(ssc_buf);
+    if (sscbuf)
+        BUF_MEM_free(sscbuf);
+    if (ivbuf)
+        BUF_MEM_free(ivbuf);
+
+    return r;
+}
+
+int
+is_char_str(const BUF_MEM * str)
+{
+    const unsigned char *s = NULL;
+    size_t i = 0;
+
+    if (!str)
+        return 0;
+
+    s = (unsigned char *) str->data;
+    i = str->length;
+
+    while (i) {
+        if (*s <= 0x1f || (0x7f <= *s && *s <= 0x9f)) {
+            EACerr(EAC_F_IS_CHAR_STR, EAC_R_INVALID_DATA);
+            return 0;
+        }
+        s++;
+        i--;
+    }
+
+    return 1;
+}
+
+int
+is_bcd(const unsigned char *data, size_t length)
+{
+    size_t i;
+
+    if (!data)
+        return 0;
+
+    for(i = 0; i < length; i++) {
+        if (data[i] > 0x9)
+            return 0;
+    }
+    return 1;
+}
+
+BUF_MEM *
+authenticate(const KA_CTX *ctx, const BUF_MEM *data)
+{
+    switch (EVP_CIPHER_nid(ctx->cipher)) {
+        case NID_des_ede_cbc:
+            return retail_mac_des(ctx->k_mac, data);
+        case NID_aes_128_cbc:
+        case NID_aes_192_cbc:
+        case NID_aes_256_cbc:
+            return cmac(ctx->cmac_ctx, ctx->cipher, ctx->k_mac, data,
+                    EAC_AES_MAC_LENGTH);
+        default:
+            EACerr(EAC_F_AUTHENTICATE, EAC_R_UNKNOWN_CIPHER);
+            return NULL;
+    }
+}
+
+EVP_PKEY *
+EVP_PKEY_dup(EVP_PKEY *key)
+{
+    EVP_PKEY *out = NULL;
+    DH *dh_in = NULL, *dh_out = NULL;
+    EC_KEY *ec_in = NULL, *ec_out = NULL;
+    RSA *rsa_in = NULL, *rsa_out = NULL;
+
+    if (!key) {
+        EACerr(EAC_F_EVP_PKEY_DUP, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    out = EVP_PKEY_new();
+
+    if (!out)
+        goto err;
+
+    switch (EVP_PKEY_type(key->type)) {
+        case EVP_PKEY_DH:
+            dh_in = EVP_PKEY_get1_DH(key);
+            if (!dh_in)
+                goto err;
+
+            dh_out = DHparams_dup_with_q(dh_in);
+            if (!dh_out)
+                goto err;
+
+            EVP_PKEY_set1_DH(out, dh_out);
+            DH_free(dh_out);
+            DH_free(dh_in);
+            break;
+
+        case EVP_PKEY_EC:
+            ec_in = EVP_PKEY_get1_EC_KEY(key);
+            if (!ec_in)
+                goto err;
+
+            ec_out = EC_KEY_dup(ec_in);
+            if (!ec_out)
+                goto err;
+
+            EVP_PKEY_set1_EC_KEY(out, ec_out);
+            EC_KEY_free(ec_out);
+            EC_KEY_free(ec_in);
+            break;
+
+        case EVP_PKEY_RSA:
+            rsa_in = EVP_PKEY_get1_RSA(key);
+            if (!rsa_in)
+                goto err;
+
+            rsa_out = RSAPrivateKey_dup(rsa_in);
+            if (!rsa_out)
+                goto err;
+
+            EVP_PKEY_set1_RSA(out, rsa_out);
+            RSA_free(rsa_out);
+            RSA_free(rsa_in);
+            break;
+
+        default:
+            EACerr(EAC_F_EVP_PKEY_DUP, EAC_R_UNKNOWN_PROTOCOL);
+            goto err;
+    }
+
+    return out;
+
+err:
+    if (dh_in)
+        DH_free(dh_in);
+    if (dh_out)
+        DH_free(dh_out);
+    if (ec_in)
+        EC_KEY_free(ec_in);
+    if (ec_out)
+        EC_KEY_free(ec_out);
+    if (rsa_out)
+        RSA_free(rsa_out);
+    if (rsa_in)
+        RSA_free(rsa_in);
+    if (out)
+        EVP_PKEY_free(out);
+    return NULL;
+}
+
+static EVP_PKEY *
+EVP_PKEY_from_pubkey(EVP_PKEY *key, const BUF_MEM *pub, BN_CTX *bn_ctx)
+{
+    EVP_PKEY *out = NULL;
+    DH *dh = NULL;
+    EC_KEY *ec = NULL;
+    EC_POINT *ecp = NULL;
+
+    out = EVP_PKEY_dup(key);
+
+    if (!out) {
+        EACerr(EAC_F_EVP_PKEY_FROM_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    switch (EVP_PKEY_type(out->type)) {
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(out);
+            if (!dh)
+                goto err;
+
+            dh->pub_key = BN_bin2bn((unsigned char *) pub->data, pub->length,
+                    dh->pub_key);
+            if (!dh->pub_key)
+                goto err;
+            EVP_PKEY_set1_DH(out, dh);
+            DH_free(dh);
+            break;
+        case EVP_PKEY_EC:
+            ec = EVP_PKEY_get1_EC_KEY(out);
+            if (!ec)
+                goto err;
+
+            ecp = EC_POINT_new(EC_KEY_get0_group(ec));
+            if (!ecp || !EC_POINT_oct2point(EC_KEY_get0_group(ec), ecp,
+                    (unsigned char *) pub->data, pub->length, bn_ctx)
+                     || !EC_KEY_set_public_key(ec, ecp))
+                goto err;
+            EVP_PKEY_set1_EC_KEY(out, ec);
+            EC_POINT_free(ecp);
+            EC_KEY_free(ec);
+            break;
+        default:
+            EACerr(EAC_F_EVP_PKEY_FROM_PUBKEY, EAC_R_UNKNOWN_PROTOCOL);
+            goto err;
+    }
+
+    return out;
+
+err:
+    if (dh)
+        DH_free(dh);
+    if (ec)
+        EC_KEY_free(ec);
+    if (ecp)
+        EC_POINT_free(ecp);
+    if (out)
+        EVP_PKEY_free(out);
+    return NULL;
+}
+
+BUF_MEM *
+get_authentication_token(int protocol, const KA_CTX *ka_ctx, BN_CTX *bn_ctx,
+                   enum eac_tr_version tr_version, const BUF_MEM *pub_opp)
+{
+    BUF_MEM *out = NULL;
+    EVP_PKEY *opp_key = NULL;
+
+    if (!ka_ctx) {
+        EACerr(EAC_F_GET_AUTHENTICATION_TOKEN, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    opp_key = EVP_PKEY_from_pubkey(ka_ctx->key, pub_opp,
+            bn_ctx);
+    if (!opp_key)
+        goto err;
+
+
+    out = compute_authentication_token(protocol, ka_ctx, opp_key,
+            bn_ctx, tr_version);
+
+err:
+    EVP_PKEY_free(opp_key);
+
+    return out;
+}
+
+BUF_MEM *
+compute_authentication_token(int protocol, const KA_CTX *ka_ctx, EVP_PKEY *opp_key,
+        BN_CTX *bn_ctx, enum eac_tr_version tr_version)
+{
+    BUF_MEM *asn1 = NULL, *out = NULL, *pad =NULL;
+
+    if (!ka_ctx) {
+        EACerr(EAC_F_COMPUTE_AUTHENTICATION_TOKEN, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    asn1 = asn1_pubkey(protocol, opp_key, bn_ctx, tr_version);
+
+    /* ISO 9797-1 algorithm 3 retail MAC now needs extra padding (padding method 2) */
+    if (EVP_CIPHER_nid(ka_ctx->cipher) == NID_des_ede_cbc) {
+        pad = EAC_add_iso_pad(asn1, EVP_CIPHER_block_size(ka_ctx->cipher));
+        if (!pad)
+            goto err;
+        out = authenticate(ka_ctx, pad);
+    } else {
+        out = authenticate(ka_ctx, asn1);
+    }
+
+err:
+    if (asn1)
+        BUF_MEM_free(asn1);
+    if (pad)
+        BUF_MEM_free(pad);
+
+    return out;
+}
+
+int
+verify_authentication_token(int protocol, const KA_CTX *ka_ctx, BN_CTX *bn_ctx,
+                   enum eac_tr_version tr_version, const BUF_MEM *token)
+{
+    int rv;
+    BUF_MEM *token_verify = NULL;
+
+    if (!ka_ctx || !token) {
+        EACerr(EAC_F_VERIFY_AUTHENTICATION_TOKEN, EAC_R_INVALID_ARGUMENTS);
+        return -1;
+    }
+
+    token_verify = compute_authentication_token(protocol, ka_ctx, ka_ctx->key,
+                    bn_ctx, tr_version);
+    if (!token_verify)
+        return -1;
+
+    if (token_verify->length != token->length
+                       || memcmp(token_verify->data, token->data, token->length) != 0)
+        rv = 0;
+    else
+        rv = 1;
+
+    BUF_MEM_free(token_verify);
+
+    return rv;
+}
+
+BUF_MEM *
+Comp(EVP_PKEY *key, const BUF_MEM *pub, BN_CTX *bn_ctx, EVP_MD_CTX *md_ctx)
+{
+    BUF_MEM *out = NULL;
+    const EC_GROUP *group;
+    EC_POINT *ecp = NULL;
+    EC_KEY *ec = NULL;
+    BIGNUM *x = NULL, *y = NULL;
+
+    if (!key || !pub) {
+        EACerr(EAC_F_COMP, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    switch (EVP_PKEY_type(key->type)) {
+        case EVP_PKEY_DH:
+            out = hash(EVP_sha1(), md_ctx, NULL, pub);
+            break;
+        case EVP_PKEY_EC:
+            ec = EVP_PKEY_get1_EC_KEY(key);
+            if (!ec)
+                goto err;
+
+            group = EC_KEY_get0_group(ec);
+            ecp = EC_POINT_new(group);
+            x = BN_CTX_get(bn_ctx);
+            y = BN_CTX_get(bn_ctx);
+
+            if(!ecp || !x || !y
+                    || !EC_POINT_oct2point(group, ecp,
+                        (unsigned char *) pub->data, pub->length, bn_ctx)
+                    || !EC_POINT_get_affine_coordinates_GF2m(group, ecp, x, y, bn_ctx))
+                goto err;
+
+            out = BUF_MEM_create(BN_num_bytes(x));
+            if(!out || !BN_bn2bin(x, (unsigned char *) out->data))
+                goto err;
+            break;
+        default:
+            EACerr(EAC_F_COMP, EAC_R_UNKNOWN_PROTOCOL);
+            goto err;
+    }
+
+err:
+    if (ecp)
+        EC_POINT_free(ecp);
+    /* Decrease the reference count, the key is still available in the EVP_PKEY
+     * structure */
+    if (ec)
+        EC_KEY_free(ec);
+    if (x)
+        BN_free(x);
+    if (y)
+        BN_free(y);
+
+    return out;
+}
+
+int EVP_PKEY_set_std_dp(EVP_PKEY *key, int stnd_dp) {
+
+    DH *dh = NULL;
+    EC_KEY *ec = NULL;
+
+    if (!key) {
+        EACerr(EAC_F_EVP_PKEY_SET_STD_DP, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    /* Generate key from standardized domain parameters */
+    switch(stnd_dp) {
+        case 0:
+        case 1:
+        case 2:
+            if (!init_dh(&dh, stnd_dp))
+                return 0;
+            EVP_PKEY_set1_DH(key, dh);
+            /* Decrement reference count */
+            DH_free(dh);
+            break;
+        case 8:
+        case 9:
+        case 10:
+        case 11:
+        case 12:
+        case 13:
+        case 14:
+        case 15:
+        case 16:
+        case 17:
+        case 18:
+            if (!init_ecdh(&ec, stnd_dp))
+                return 0;
+            EVP_PKEY_set1_EC_KEY(key, ec);
+            /* Decrement reference count */
+            EC_KEY_free(ec);
+            break;
+        default:
+            EACerr(EAC_F_EVP_PKEY_SET_STD_DP, EAC_R_INVALID_ARGUMENTS);
+            return 0;
+    }
+
+    return 1;
+}
+
+void
+BUF_MEM_clear_free(BUF_MEM *b)
+{
+    if (b) {
+        OPENSSL_cleanse(b->data, b->max);
+        BUF_MEM_free(b);
+    }
+}
+
+int
+EVP_PKEY_set_keys(EVP_PKEY *evp_pkey,
+        const unsigned char *privkey, size_t privkey_len,
+           const unsigned char *pubkey, size_t pubkey_len,
+           BN_CTX *bn_ctx)
+{
+    EC_KEY *ec_key = NULL;
+    DH *dh = NULL;
+    EC_POINT *ec_point = NULL;
+    BIGNUM *bn = NULL;
+    int ok = 0;
+    const EC_GROUP *group;
+
+    if (!evp_pkey) {
+        EACerr(EAC_F_EVP_PKEY_SET_KEYS, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    switch (EVP_PKEY_type(evp_pkey->type)) {
+        case EVP_PKEY_EC:
+            ec_key = EVP_PKEY_get1_EC_KEY(evp_pkey);
+            group = EC_KEY_get0_group(ec_key);
+            ec_point = EC_POINT_new(group);
+            bn = BN_bin2bn(privkey, privkey_len, bn);
+            if (!ec_key || !ec_point || !bn
+                    || !EC_POINT_oct2point(group, ec_point, pubkey, pubkey_len,
+                        bn_ctx)
+                    || !EC_KEY_set_public_key(ec_key, ec_point)
+                    || !EC_KEY_set_private_key(ec_key, bn)
+                    || !EVP_PKEY_set1_EC_KEY(evp_pkey, ec_key))
+                goto err;
+            break;
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(evp_pkey);
+            dh->priv_key = BN_bin2bn(privkey, privkey_len, dh->priv_key);
+            dh->pub_key = BN_bin2bn(pubkey, pubkey_len, dh->pub_key);
+            if (!dh->priv_key || !dh->pub_key
+                    || !EVP_PKEY_set1_DH(evp_pkey, dh))
+                goto err;
+            break;
+        default:
+            EACerr(EAC_F_EVP_PKEY_SET_KEYS, EAC_R_UNKNOWN_PROTOCOL);
+            goto err;
+            break;
+    }
+
+    ok = 1;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (ec_key)
+        EC_KEY_free(ec_key);
+    if (dh)
+        DH_free(dh);
+    if (ec_point)
+        EC_POINT_clear_free(ec_point);
+
+    return ok;
+}
+
+BUF_MEM *
+get_pubkey(EVP_PKEY *key, BN_CTX *bn_ctx)
+{
+    BUF_MEM *out;
+    DH *dh;
+    EC_KEY *ec;
+    const EC_POINT *ec_pub;
+
+    if (!key) {
+        EACerr(EAC_F_GET_PUBKEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    switch (EVP_PKEY_type(key->type)) {
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(key);
+            if (!dh)
+                return NULL;
+
+            out = BN_bn2buf(dh->pub_key);
+
+            DH_free(dh);
+            break;
+
+        case EVP_PKEY_EC:
+            ec = EVP_PKEY_get1_EC_KEY(key);
+            if (!ec)
+                return NULL;
+
+            ec_pub = EC_KEY_get0_public_key(ec);
+            if (!ec_pub)
+                return NULL;
+
+            out = EC_POINT_point2buf(ec, bn_ctx, ec_pub);
+
+            EC_KEY_free(ec);
+            break;
+
+        default:
+            return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+convert_from_plain_sig(const BUF_MEM *plain_sig)
+{
+    ECDSA_SIG *ecdsa_sig = NULL;
+    BUF_MEM *x962_sig = NULL;
+    int l;
+    unsigned char *p = NULL;
+
+    if (!plain_sig) {
+        EACerr(EAC_F_CONVERT_FROM_PLAIN_SIG, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+    if (plain_sig->length%2 != 0) {
+        EACerr(EAC_F_CONVERT_FROM_PLAIN_SIG, EAC_R_INVALID_DATA);
+        goto err;
+    }
+
+    ecdsa_sig = ECDSA_SIG_new();
+    if (!ecdsa_sig)
+        goto err;
+
+    /* The first l/2 bytes of the plain signature contain the number r, the second
+     * l/2 bytes contain the number s. */
+    ecdsa_sig->r = BN_bin2bn((unsigned char *) plain_sig->data,
+            plain_sig->length/2, ecdsa_sig->r);
+    ecdsa_sig->s = BN_bin2bn((unsigned char *) plain_sig->data +
+            plain_sig->length/2, plain_sig->length/2, ecdsa_sig->s);
+
+    /* ASN.1 encode the signature*/
+    l = i2d_ECDSA_SIG(ecdsa_sig, &p);
+    if (l < 0)
+        goto err;
+    x962_sig = BUF_MEM_create_init(p, l);
+
+err:
+    if (p)
+        free(p);
+    if (ecdsa_sig)
+        ECDSA_SIG_free(ecdsa_sig);
+
+    return x962_sig;
+}
+
+BUF_MEM *
+convert_to_plain_sig(const BUF_MEM *x962_sig)
+{
+    size_t r_len, s_len, rs_max;
+    BUF_MEM *plain_sig_buf = NULL;
+    ECDSA_SIG *tmp_sig = NULL;
+    const unsigned char *tmp;
+    unsigned char *r = NULL, *s = NULL;
+
+    if (!x962_sig) {
+        EACerr(EAC_F_CONVERT_TO_PLAIN_SIG, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    /* Convert the ASN.1 data to a C structure*/
+    tmp = (unsigned char*) x962_sig->data;
+    tmp_sig = ECDSA_SIG_new();
+    if (!tmp_sig)
+        goto err;
+    tmp_sig = d2i_ECDSA_SIG(&tmp_sig, &tmp, x962_sig->length);
+    if (!tmp_sig)
+        goto err;
+
+    /* Extract the parameters r and s*/
+    r_len = BN_num_bytes(tmp_sig->r);
+    s_len = BN_num_bytes(tmp_sig->s);
+    rs_max = r_len > s_len ? r_len : s_len;
+    r = OPENSSL_malloc(rs_max);
+    s = OPENSSL_malloc(rs_max);
+    if (!r || !s)
+        goto err;
+
+    /* Convert r and s to a binary representation */
+    if (!BN_bn2bin(tmp_sig->r, r + rs_max - r_len))
+        goto err;
+    if (!BN_bn2bin(tmp_sig->s, s + rs_max - s_len))
+        goto err;
+    /* r and s must be padded with leading zero bytes to ensure they have the
+     * same length */
+    memset(r, 0, rs_max - r_len);
+    memset(s, 0, rs_max - s_len);
+
+    /* concatenate r and s to get the plain signature format */
+    plain_sig_buf = BUF_MEM_create(rs_max + rs_max);
+    if (!plain_sig_buf)
+        goto err;
+    memcpy(plain_sig_buf->data, r, rs_max);
+    memcpy(plain_sig_buf->data + rs_max, s, rs_max);
+
+    OPENSSL_free(r);
+    OPENSSL_free(s);
+    ECDSA_SIG_free(tmp_sig);
+
+    return plain_sig_buf;
+
+err:
+    if (r)
+        OPENSSL_free(r);
+    if (s)
+        OPENSSL_free(s);
+    if (tmp_sig)
+        ECDSA_SIG_free(tmp_sig);
+    return NULL;
+}
+
+const EVP_MD *
+eac_oid2md(int protocol)
+{
+    switch(protocol) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_1:
+            return EVP_sha1();
+        case NID_id_TA_ECDSA_SHA_224:
+            return EVP_sha224();
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_256:
+            return EVP_sha256();
+        case NID_id_TA_ECDSA_SHA_384:
+            return EVP_sha384();
+        case NID_id_TA_ECDSA_SHA_512:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            return EVP_sha512();
+        default:
+            EACerr(EAC_F_EAC_OID2MD, EAC_R_UNKNOWN_PROTOCOL);
+            return NULL;
+    }
+}
+
+int
+EAC_verify(int protocol, EVP_PKEY *key,    const BUF_MEM *signature,
+        const BUF_MEM *data)
+{
+    BUF_MEM *verification_data = NULL, *signature_to_verify = NULL;
+    EVP_PKEY_CTX *tmp_key_ctx = NULL;
+    int ret = -1;
+    const EVP_MD *md = eac_oid2md(protocol);
+
+    if (!key || !signature) {
+        EACerr(EAC_F_EAC_VERIFY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+
+    tmp_key_ctx = EVP_PKEY_CTX_new(key, NULL);
+    if (!tmp_key_ctx || !md
+               || EVP_PKEY_verify_init(tmp_key_ctx) <= 0
+            || EVP_PKEY_CTX_set_signature_md(tmp_key_ctx, md) <= 0)
+        goto err;
+
+
+    switch (protocol) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_EC))
+                goto err;
+
+            /* EAC signatures are always in plain signature format for EC curves but
+             * OpenSSL only creates X.509 format. Therefore we need to convert between
+             * these formats. */
+            signature_to_verify = convert_from_plain_sig(signature);
+            if (!signature_to_verify)
+                goto err;
+            break;
+
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_RSA))
+                goto err;
+
+            signature_to_verify = BUF_MEM_create_init(signature->data,
+                    signature->length);
+            if (!EVP_PKEY_CTX_set_rsa_padding(tmp_key_ctx, RSA_PKCS1_PADDING)
+                    || !signature_to_verify)
+                goto err;
+            break;
+
+        case NID_id_TA_RSA_PSS_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_RSA))
+                goto err;
+
+            signature_to_verify = BUF_MEM_create_init(signature->data, signature->length);
+            if (!EVP_PKEY_CTX_set_rsa_padding(tmp_key_ctx, RSA_PKCS1_PSS_PADDING)
+                    || !signature_to_verify)
+                goto err;
+            break;
+
+        default:
+            goto err;
+    }
+
+    /* EVP_PKEY_sign doesn't perform hashing (despite EVP_PKEY_CTX_set_signature_md).
+     * Therefore we need to compute the hash ourself. */
+    verification_data = hash(md, NULL, NULL, data);
+    if (!verification_data)
+        goto err;
+
+    /* Actual signature verification */
+    ret = EVP_PKEY_verify(tmp_key_ctx, (unsigned char*) signature_to_verify->data,
+            signature_to_verify->length, (unsigned char*) verification_data->data,
+            verification_data->length);
+
+err:
+    if (verification_data)
+        BUF_MEM_free(verification_data);
+    if (signature_to_verify)
+        BUF_MEM_free(signature_to_verify);
+    if (tmp_key_ctx)
+        EVP_PKEY_CTX_free(tmp_key_ctx);
+
+    return ret;
+}
+
+BUF_MEM *
+EAC_sign(int protocol, EVP_PKEY *key, const BUF_MEM *data)
+{
+    BUF_MEM *signature = NULL, *signature_data = NULL, *plain_sig = NULL;
+    EVP_PKEY_CTX *tmp_key_ctx = NULL;
+    size_t len;
+    const EVP_MD *md = eac_oid2md(protocol);
+
+    if (!key || !data) {
+        EACerr(EAC_F_EAC_SIGN, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+
+    tmp_key_ctx = EVP_PKEY_CTX_new(key, NULL);
+    if (!tmp_key_ctx || !md
+               || EVP_PKEY_sign_init(tmp_key_ctx) <= 0
+            || EVP_PKEY_CTX_set_signature_md(tmp_key_ctx, md) <= 0)
+        goto err;
+
+
+    switch (protocol) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_EC))
+                goto err;
+
+            break;
+
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_RSA))
+                goto err;
+
+            if (!EVP_PKEY_CTX_set_rsa_padding(tmp_key_ctx, RSA_PKCS1_PADDING))
+                goto err;
+            break;
+
+        case NID_id_TA_RSA_PSS_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_512:
+            if (!(EVP_PKEY_type(key->type) == EVP_PKEY_RSA))
+                goto err;
+
+            if (!EVP_PKEY_CTX_set_rsa_padding(tmp_key_ctx, RSA_PKCS1_PSS_PADDING))
+                goto err;
+            break;
+
+        default:
+            goto err;
+    }
+
+    /* EVP_PKEY_sign doesn't perform hashing (despite EVP_PKEY_CTX_set_signature_md).
+     * Therefore we need to compute the hash ourself. */
+    signature_data = hash(md, NULL, NULL, data);
+    if (!signature_data)
+        goto err;
+
+
+    /* Actual signature creation */
+    if (EVP_PKEY_sign(tmp_key_ctx, NULL, &len,
+               (unsigned char*) signature_data->data,
+               signature_data->length) <= 0)
+        goto err;
+    signature = BUF_MEM_create(len);
+    if (!signature)
+        goto err;
+    if (EVP_PKEY_sign(tmp_key_ctx,
+                   (unsigned char *) signature->data,
+                &signature->length,
+                   (unsigned char*) signature_data->data,
+                   signature_data->length) <= 0)
+        goto err;
+
+
+    /* EAC signatures are always in plain signature format for EC curves but
+     * OpenSSL only creates X.509 format. Therefore we need to convert between
+     * these formats. */
+    switch (protocol) {
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            plain_sig = convert_to_plain_sig(signature);
+            BUF_MEM_free(signature);
+            signature = plain_sig;
+            break;
+    }
+
+err:
+    if (tmp_key_ctx)
+        EVP_PKEY_CTX_free(tmp_key_ctx);
+    if (signature_data)
+        BUF_MEM_free(signature_data);
+
+    return signature;
+}
Index: openssl/crypto/eac/eac_util.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eac_util.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,214 @@
+/**
+ * @file
+ * @brief Interface to utility functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_UTIL_H_
+#define PACE_UTIL_H_
+
+#include <openssl/buffer.h>
+#include <openssl/cmac.h>
+#include <openssl/eac.h>
+#include <openssl/evp.h>
+
+/**
+ * @defgroup wrapper               Wrapper functions
+ * @{ ************************************************************************/
+/**
+ * @brief Wrapper for the OpenSSL hash functions.
+ *
+ * @param[in] md specifies the hash function to use
+ * @param[in] ctx (optional)
+ * @param[in] impl (optional)
+ * @param[in] in data to be hashed
+ *
+ * @return message digest or NULL if an error occurred
+ */
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in);
+/**
+ * @brief Wrapper to the OpenSSL encryption functions.
+ * Automatic padding is disabled.
+ *
+ * @param[in] ctx PACE context containing the cipher to use
+ * @param[in] key_enc the key used for en-/decryption
+ * @param[in] data the data to en-/decrypt
+ * @param[in] enc specifies wether to encrypt (1) or decrypt (0)
+ *
+ * @return encrypted/decrypted data or NULL if an error occurred
+ */
+BUF_MEM *
+cipher_no_pad(KA_CTX *ctx, EVP_CIPHER_CTX *cipher_ctx, const BUF_MEM *key_enc, const BUF_MEM *data, int enc);
+/**
+ * @brief Wrapper to the OpenSSL pseudo-random number generator.
+ *
+ * @param[in] numbytes number of bytes to randomize
+ *
+ * @return a buffer of randomized bytes or NULL if an error occurred
+ */
+BUF_MEM *
+randb(int numbytes);
+/**
+ * @brief Computes message authentication code in retail-mode according to
+ * ISO/IEC 9797-1 MAC algorithm 3 / padding method 2 with block cipher DES and
+ * IV=0.
+ *
+ * @param[in] key authentication key
+ * @param[in] in buffer to authenticate
+ *
+ * @return message authentication code or NULL if an error occurred
+ */
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in);
+/**
+ * @brief Compute a CMAC of the input buffer using the encryption algorithm
+ *           specified in the PACE context structure
+ *
+ * @param[in] ctx EVP_CIPHER_CTX object (optional)
+ * @param[in] type contains the encryption algorithm to use
+ * @param[in] key the symmetric key used for the computation. The key must have
+ *           the correct length for the encryption algorithm used
+ * @param[in] in buffer that contains the data to for CMAC computation
+ * @param[in] maclen length in number of bytes of the MAC
+ *
+ * @return buffer containing the CMAC or NULL in case of error
+ */
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, size_t maclen);
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup encoding               Encoding
+ * @{ ************************************************************************/
+
+/**
+ * @brief Encodes a send sequence counter according to TR-3110 F.3
+ *
+ * @param[in] ssc Send sequence counter to encode
+ * @param[in] ctx PACE_CTX object
+ * @param[out] encoded where to store the encoded SSC
+ *
+ * @return length of encoded SSC or -1 if an error occurred
+ */
+int
+encode_ssc(const BIGNUM *ssc, const KA_CTX *ctx, unsigned char **encoded);
+
+/**
+ * @brief Computes the new initialisation vector according to the SSC and the
+ * algorithm
+ *
+ * @param[in,out] ctx contains the parameters needed for the generation of the IV
+ * and the IV itself
+ * @param[in] ssc the send sequence counter
+ *
+ * @return 1 if everything worked, 0 in case of an error
+ */
+int
+update_iv(KA_CTX *ctx, EVP_CIPHER_CTX *cipher_ctx, const BIGNUM *ssc);
+
+/**
+ * @brief Checks if str is a character string according to TR-3110 D.2.1.4
+ *
+ * @param[in] str BUF_MEM object with the string to check
+ *
+ * @return 1 if str is a character string or 0 if it is not
+ */
+int
+is_char_str(const BUF_MEM * str);
+/**
+ * @brief Checks if \c is BCD encoded
+ *
+ * @param[in] data buffer to check
+ * @param[in] length of \a data
+ *
+ * @return 1 if data is BCD encoded or 0 if it is not
+ */
+int
+is_bcd(const unsigned char *data, size_t length);
+/** @} ***********************************************************************/
+
+/**
+ * @brief Authenticate data
+ *
+ * @param[in] ctx contains the information on how to authenticate the data
+ * @param[data] the data that should be authenticated
+ *
+ * @return the authenticated data or NULL in case of an error
+ * @note the data has to be padded correctly for this function
+ */
+BUF_MEM *
+authenticate(const KA_CTX *ctx, const BUF_MEM *data);
+int
+verify_authentication_token(int protocol, const KA_CTX *ka_ctx, BN_CTX *bn_ctx,
+                   enum eac_tr_version tr_version, const BUF_MEM *token);
+BUF_MEM *
+get_authentication_token(int protocol, const KA_CTX *ka_ctx, BN_CTX *bn_ctx,
+                   enum eac_tr_version tr_version, const BUF_MEM *pub_opp);
+
+BUF_MEM *
+Comp(EVP_PKEY *key, const BUF_MEM *pub, BN_CTX *bn_ctx, EVP_MD_CTX *md_ctx);
+
+/**
+ * @brief Initializes a \c EVP_PKEY object using the standardized domain
+ * parameters. This parameter can be found in the PACEInfo part of an
+ * EF.CardAccess.
+ *
+ * @param[in,out] key The key object to initialize
+ * @param[in] stnd_dp Identifier of the standardized domain parameters
+ *
+ * @return 1 in case of success, 0 otherwise
+ */
+int
+EVP_PKEY_set_std_dp(EVP_PKEY *key, int stnd_dp);
+
+/**
+ * @brief Verifies an signature created with a Terminal for EAC.
+ *
+ * Handles plain signatures as well as X.509 signatures. In order to perform
+ * ECDSA verification the data is hashed before calling \c EVP_PKEY_verify()
+ * (see \c ECDSA_verify()).
+ *
+ * @param [in] protocol     The protocol identifier used for TA
+ * @param [in] key         The terminal's parameters for signing
+ * @param [in] signature The terminal's signature
+ * @param [in] data         The data that was signed
+ *
+ * @return 1 if the signature has been verified, 0 if not or -1 in case of an error
+ */
+int
+EAC_verify(int protocol, EVP_PKEY *key,
+           const BUF_MEM *signature, const BUF_MEM *data);
+
+/**
+ * @brief Signs data for a Terminal for EAC.
+ *
+ * Creates plain signatures as well as X.509 signatures. In order to perform
+ * ECDSA signing the data is hashed before calling \c EVP_PKEY_sign()
+ * (see \c ECDSA_sign()).
+ *
+ * @param [in] protocol     The protocol identifier used for TA
+ * @param [in] key         The terminal's parameters for signing
+ * @param [in] data         The data to sign
+ *
+ * @return Signature or NULL in case of an error
+ */
+BUF_MEM *
+EAC_sign(int protocol, EVP_PKEY *key, const BUF_MEM *data);
+
+EVP_PKEY *
+EVP_PKEY_dup(EVP_PKEY *key);
+void
+BUF_MEM_clear_free(BUF_MEM *b);
+int
+EVP_PKEY_set_keys(EVP_PKEY *evp_pkey,
+           const unsigned char *pubkey, size_t pubkey_len,
+        const unsigned char *privkey, size_t privkey_len,
+           BN_CTX *bn_ctx);
+BUF_MEM *
+get_pubkey(EVP_PKEY *key, BN_CTX *bn_ctx);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/eac/eactest.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/eactest.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,3236 @@
+#include <openssl/opensslconf.h>    /* for OPENSSL_NO_PACE */
+#include <stdio.h>
+#ifdef OPENSSL_NO_PACE
+int
+main(int argc, char *argv[])
+{
+    printf("No PACE support\n");
+    return (0);
+}
+#else
+#include <openssl/asn1.h>
+#include <openssl/bio.h>
+#include <openssl/buffer.h>
+#include <openssl/ca.h>
+#include <openssl/conf.h>
+#include <openssl/crypto.h>
+#include <openssl/cv_cert.h>
+#include <openssl/dh.h>
+#include <openssl/eac.h>
+#include <openssl/ec.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include <openssl/ri.h>
+#include <openssl/ta.h>
+#include <openssl/x509.h>
+#include <string.h>
+
+#define CHECK(reportverbose, test, message) { \
+    if (test) { \
+        if (!verbose) \
+            printf("."); \
+        else if (debug || (verbose && reportverbose)) { \
+            printf("    %-65s [  OK ]\n", message); \
+        } \
+    } else { \
+        if (verbose) { \
+            printf("    %-65s [ ERR ]\n", message); \
+        } else { \
+            printf("\n"); \
+        } \
+        printf("    Error in %s:%d:%s\n", __FILE__, __LINE__, __FUNCTION__); \
+        if (debug) { \
+            ERR_load_crypto_strings(); ERR_print_errors_fp(stdout); ERR_free_strings(); \
+        } \
+        goto err; \
+    } \
+}
+#define OK { if (!verbose) printf(" ok\n"); }
+#define TESTEND { if (!verbose && !failed) printf(" ok\n"); }
+#define END { TESTEND return failed; }
+
+static char verbose=0;
+static char debug=0;
+
+/******************************* Test data ************************************/
+
+struct encryption_decryption {
+    unsigned int ssc;
+    BUF_MEM data;
+    BUF_MEM cipher;
+};
+
+struct authenticate {
+    unsigned int ssc;
+    BUF_MEM data;
+    BUF_MEM mac;
+};
+
+struct eac_worked_example {
+    const BUF_MEM ef_cardaccess;
+    const int pace_info_oid;
+    const int pace_version;
+    const int pace_curve;
+    const char *password;
+    const enum s_type password_type;
+    const BUF_MEM pace_nonce;
+    const BUF_MEM pace_enc_nonce;
+    const BUF_MEM pace_static_pcd_priv_key;
+    const BUF_MEM pace_static_pcd_pub_key;
+    const BUF_MEM pace_static_picc_priv_key;
+    const BUF_MEM pace_static_picc_pub_key;
+    const BUF_MEM pace_shared_secret_h;
+    const BUF_MEM pace_eph_generator;
+    const BUF_MEM pace_eph_pcd_priv_key;
+    const BUF_MEM pace_eph_pcd_pub_key;
+    const BUF_MEM pace_eph_picc_priv_key;
+    const BUF_MEM pace_eph_picc_pub_key;
+    const BUF_MEM pace_shared_secret_k;
+    const BUF_MEM pace_k_mac;
+    const BUF_MEM pace_k_enc;
+    const BUF_MEM pace_authentication_token_picc;
+    const BUF_MEM pace_authentication_token_pcd;
+    const struct encryption_decryption *pace_encrypt_decrypt;
+    const size_t pace_encrypt_decrypt_len;
+    const struct authenticate *pace_authenticate;
+    const size_t pace_authenticate_len;
+    const int ca_curve;
+    const int ca_version;
+    const int ca_info_oid;
+    const BUF_MEM ca_picc_priv_key;
+    const BUF_MEM ca_picc_pub_key;
+    const BUF_MEM ca_pcd_priv_key;
+    const BUF_MEM ca_pcd_pub_key;
+    const BUF_MEM ca_nonce;
+    const BUF_MEM ca_picc_token;
+    const BUF_MEM ca_shared_secret_k;
+    const BUF_MEM ca_k_mac;
+    const BUF_MEM ca_k_enc;
+    const int ta_curve;
+    const BUF_MEM ta_pcd_key;
+    const BUF_MEM ta_nonce;
+    const BUF_MEM ta_auxdata;
+    const BUF_MEM ta_pcd_signature;
+    const BUF_MEM ta_cert;
+    const BUF_MEM ta_cvca;
+    const BUF_MEM ta_dv_cert;
+};
+
+
+static char tc_ecdh_ef_cardaccess[] = {
+    0x31, 0x81, 0xC6, 0x30, 0x0D, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02,  /* 1..0............ */
+    0x01, 0x02, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x02,  /* ..0............. */
+    0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02,  /* ......0......... */
+    0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x30, 0x1C, 0x06, 0x09, 0x04, 0x00,  /* ..........0..... */
+    0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00, 0x07,  /* .......0........ */
+    0x01, 0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x30, 0x2F, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00,  /* ........0/...... */
+    0x07, 0x02, 0x02, 0x06, 0x16, 0x23, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77,  /* .....#https://ww */
+    0x77, 0x2E, 0x68, 0x6A, 0x70, 0x2D, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6C, 0x74, 0x69, 0x6E, 0x67,  /* w.hjp-consulting */
+    0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x6F, 0x6D, 0x65, 0x30, 0x3E, 0x06, 0x08, 0x04, 0x00, 0x7F,  /* .com/home0>..... */
+    0x00, 0x07, 0x02, 0x02, 0x08, 0x31, 0x32, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07,  /* .....120........ */
+    0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x1C, 0x06, 0x09, 0x04,  /* ...........0.... */
+    0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00,  /* ........0....... */
+    0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x02,                                            /* ......... */
+};
+static char tc_ecdh_nonce_enc[] = {
+    0xCE, 0x83, 0x4C, 0xDE, 0x69, 0xFF, 0xBB, 0x1D, 0x1E, 0xB2, 0x15, 0x85, 0xCD, 0x70, 0x9F, 0x18,
+};
+static char tc_ecdh_nonce[] = {
+    0x7D, 0x98, 0xC0, 0x0F, 0xC6, 0xC9, 0xE9, 0x54, 0x3B, 0xBF, 0x94, 0xA8, 0x70, 0x73, 0xA1, 0x23,
+};
+static char tc_ecdh_map_pcd_priv_key[] = {
+    0x75, 0x22, 0x87, 0xF5, 0xB0, 0x2D, 0xE3, 0xC4, 0xBC, 0x3E, 0x17, 0x94, 0x51, 0x18, 0xC5, 0x1B,  /* u"...-...>..Q... */
+    0x23, 0xC9, 0x72, 0x78, 0xE4, 0xCD, 0x74, 0x80, 0x48, 0xAC, 0x56, 0xBA, 0x5B, 0xDC, 0x3D, 0x46,  /* #.rx..t.H.V.[.=F */
+};
+static char tc_ecdh_map_pcd_pub_key[] = {
+    0x04, 0x3D, 0xD2, 0x9B, 0xBE, 0x59, 0x07, 0xFD, 0x21, 0xA1, 0x52, 0xAD, 0xA4, 0x89, 0x5F, 0xAA,  /* .=...Y..!.R..._. */
+    0xE7, 0xAC, 0xC5, 0x5F, 0x5E, 0x50, 0xEF, 0xBF, 0xDE, 0x5A, 0xB0, 0xC6, 0xEB, 0x54, 0xF1, 0x98,  /* ..._^P...Z...T.. */
+    0xD6, 0x15, 0x91, 0x36, 0x35, 0xF0, 0xFD, 0xF5, 0xBE, 0xB3, 0x83, 0xE0, 0x03, 0x55, 0xF8, 0x2D,  /* ...65........U.- */
+    0x3C, 0x41, 0xED, 0x0D, 0xF2, 0xE2, 0x83, 0x63, 0x43, 0x3D, 0xFB, 0x73, 0x85, 0x6A, 0x15, 0xDC,  /* <A.....cC=.s.j.. */
+    0x9F,                                                                                            /* . */
+};
+static char tc_ecdh_map_picc_priv_key[] = {
+    0x19, 0xC4, 0x28, 0x71, 0x56, 0x63, 0xDE, 0x74, 0x5D, 0x18, 0x24, 0xB8, 0x55, 0xD2, 0xB9, 0x67,  /* ..(qVc.t].$.U..g */
+    0x89, 0x0C, 0x99, 0xD6, 0x8E, 0xD5, 0xFE, 0xEE, 0x9D, 0xCD, 0xF8, 0xD7, 0xBB, 0xA2, 0x89, 0xD2,  /* ................ */
+};
+static char tc_ecdh_map_picc_pub_key[] = {
+    0x04, 0x9C, 0xFC, 0xF7, 0x58, 0x2A, 0xC9, 0x86, 0xD0, 0xDD, 0x52, 0xFA, 0x53, 0x12, 0x34, 0x14,  /* ....X*....R.S.4. */
+    0xC3, 0xE1, 0xB9, 0x6B, 0x4D, 0x00, 0xAB, 0xA8, 0xE5, 0x74, 0x67, 0x9B, 0x70, 0xEF, 0xB5, 0xBC,  /* ...kM....tg.p... */
+    0x3B, 0x45, 0xD2, 0xF1, 0x37, 0x29, 0xCC, 0x2A, 0xE1, 0x78, 0xE7, 0xE2, 0x41, 0xB4, 0x43, 0x21,  /* ;E..7).*.x..A.C! */
+    0x35, 0x33, 0xB7, 0x7D, 0xBB, 0x44, 0x64, 0x9A, 0x81, 0x5D, 0xDC, 0x4A, 0x23, 0x84, 0xBA, 0x42,  /* 53.}.Dd..].J#..B */
+    0x2A,                                                                                            /* * */
+    };
+static char tc_ecdh_map_shared_secret_h[] = {
+    0x04, 0x71, 0x85, 0x0C, 0xFD, 0x80, 0xFB, 0x47, 0x59, 0x47, 0xE5, 0xB1, 0xAF, 0x10, 0xFE, 0x8E,  /* .q.....GYG...... */
+    0x66, 0x63, 0x96, 0x7C, 0x2D, 0x26, 0x49, 0x35, 0xB3, 0x19, 0x51, 0xF7, 0x63, 0xA4, 0xB0, 0x3A,  /* fc.|-&I5..Q.c..: */
+    0x57, 0x49, 0x16, 0x73, 0x88, 0xF8, 0x8F, 0x52, 0xA1, 0x09, 0x16, 0x7E, 0x3E, 0x65, 0x92, 0xCA,  /* WI.s...R...~>e.. */
+    0x08, 0x20, 0x46, 0x8D, 0x11, 0x57, 0xA8, 0xE7, 0x81, 0xD2, 0xF7, 0x04, 0x91, 0x79, 0xB1, 0xD1,  /* . F..W.......y.. */
+    0x14,                                                                                            /* . */
+};
+static char tc_ecdh_map_generator[] = {
+    0x04, 0x39, 0x29, 0xD2, 0x8B, 0xA1, 0xE5, 0x33, 0x9D, 0x6C, 0x5D, 0xAD, 0xE5, 0xE3, 0x3B, 0xD3,  /* .9)....3.l]...;. */
+    0xC2, 0xF0, 0xBD, 0x14, 0xDD, 0x77, 0xC7, 0x52, 0x15, 0x32, 0x26, 0x16, 0x59, 0xC9, 0x18, 0xFA,  /* .....w.R.2&.Y... */
+    0x60, 0x14, 0xDD, 0x48, 0xFA, 0x84, 0xE6, 0x2B, 0xDE, 0x43, 0x8E, 0xDB, 0x4C, 0x97, 0x71, 0xD0,  /* `..H...+.C..L.q. */
+    0x42, 0xCD, 0xB2, 0x4B, 0x77, 0x88, 0xBD, 0xBA, 0xB2, 0x03, 0x1C, 0x45, 0x75, 0x1E, 0x77, 0x7F,  /* B..Kw......Eu.w. */
+    0x66,                                                                                            /* f */
+};
+static char tc_ecdh_pcd_priv_key[] = {
+    0x00, 0x9D, 0x9A, 0x32, 0xDF, 0x93, 0xA5, 0x7C, 0xCE, 0x33, 0xCA, 0x3C, 0xDD, 0x34, 0x57, 0xE3,  /* ...2...|.3.<.4W. */
+    0x3A, 0x97, 0x6F, 0x29, 0x35, 0x46, 0xC7, 0x35, 0x50, 0xF3, 0x97, 0x25, 0x9C, 0x93, 0xBE, 0x01,  /* :.o)5F.5P..%.... */
+    0x20,
+};
+static char tc_ecdh_pcd_pub_key[] = {
+    0x04, 0x51, 0x8B, 0xC4, 0xE5, 0x32, 0xAD, 0x2A, 0x9B, 0xD6, 0x52, 0x78, 0x04, 0xD5, 0xD6, 0x65,  /* .Q...2.*..Rx...e */
+    0xAB, 0xD5, 0x10, 0x41, 0x03, 0x7A, 0x0C, 0xC8, 0xAA, 0x92, 0x28, 0x04, 0xEB, 0x50, 0x1C, 0x22,  /* ...A.z....(..P." */
+    0x2B, 0x34, 0x27, 0x38, 0x85, 0x99, 0xAF, 0xAA, 0xE9, 0xFB, 0xAC, 0xE2, 0xDF, 0x93, 0xE1, 0x3C,  /* +4'8...........< */
+    0x3C, 0x49, 0x79, 0xCD, 0x12, 0xF0, 0xAE, 0x3E, 0x3C, 0x01, 0x26, 0x02, 0x83, 0x91, 0x55, 0x45,  /* <Iy....><.&...UE */
+    0x82,                                                                                            /* . */
+};
+static char tc_ecdh_picc_priv_key[] = {
+    0x15, 0x87, 0x2C, 0x56, 0x90, 0x8C, 0x14, 0x40, 0x02, 0x17, 0x79, 0x94, 0xCF, 0xAA, 0xED, 0xD5,  /* ..,V...@..y..... */
+    0x46, 0x7C, 0xE1, 0x50, 0x85, 0x3C, 0x44, 0x53, 0x50, 0x51, 0xFF, 0x24, 0x18, 0x30, 0x39, 0xD8,  /* F|.P.<DSPQ.$.09. */
+};
+static char tc_ecdh_picc_pub_key[] = {
+    0x04, 0x28, 0x2C, 0xF3, 0x80, 0x73, 0x03, 0x6A, 0xFA, 0xC2, 0x16, 0xAF, 0x13, 0x5B, 0xD9, 0x94,  /* .(,..s.j.....[.. */
+    0xDA, 0x0C, 0x35, 0x7F, 0x10, 0xBD, 0x4C, 0x34, 0xAF, 0xEA, 0x10, 0x42, 0xB2, 0xEB, 0x0F, 0xD6,  /* ..5...L4...B.... */
+    0x80, 0x4D, 0xF3, 0x65, 0x8B, 0x83, 0x5A, 0xC2, 0xE7, 0x13, 0x3F, 0x13, 0x69, 0x11, 0x84, 0x54,  /* .M.e..Z...?.i..T */
+    0x2B, 0xB5, 0x0B, 0x10, 0x99, 0x63, 0xA4, 0x66, 0x2A, 0xBD, 0xC0, 0x8B, 0x97, 0x63, 0xAF, 0x4B,  /* +....c.f*....c.K */
+    0x5B,                                                                                            /* [ */
+};
+static char tc_ecdh_shared_secret_k[] = {
+    0x6E, 0x7D, 0x07, 0x7C, 0xCD, 0x36, 0x7C, 0x2E, 0xAA, 0x68, 0x3F, 0x1E, 0x8E, 0xC5, 0x34, 0x30,  /* n}.|.6|..h?...40 */
+    0x2E, 0x2D, 0x00, 0xB6, 0xAD, 0xAF, 0x8A, 0x87, 0xA6, 0xED, 0xA7, 0x87, 0x40, 0xF1, 0x76, 0x06,  /* .-..........@.v. */
+};
+/* Note that  Worked Example for Extended Access Control (EAC) Version 1.0
+ * contains a wrong key. The Log however contains a dump of the correct value
+ */
+static char tc_ecdh_k_mac[] = {
+    0x73, 0xFF, 0x26, 0x87, 0x84, 0xF7, 0x2A, 0xF8, 0x33, 0xFD, 0xC9, 0x46, 0x40, 0x49, 0xAF, 0xC9,  /* s.&...*.3..F@I.. */
+};
+/* Note that  Worked Example for Extended Access Control (EAC) Version 1.0
+ * contains a wrong key. The Log however contains a dump of the correct value
+ */
+static char tc_ecdh_k_enc[] = {
+    0x68, 0x40, 0x6B, 0x41, 0x62, 0x10, 0x05, 0x63, 0xD9, 0xC9, 0x01, 0xA6, 0x15, 0x4D, 0x29, 0x01,  /* h@kAb..c.....M). */
+};
+static char tc_ecdh_authentication_token_pcd[] = {
+    0xA2, 0x7A, 0xE7, 0xB3, 0x65, 0x73, 0xC1, 0xD9,                          /* .z..es.. */
+};
+static char tc_ecdh_authentication_token_picc[] = {
+    0xA2, 0x65, 0x8C, 0x2F, 0x38, 0x60, 0x0B, 0x0F,                          /* .e./8`.. */
+};
+static char tc_ecdh_d1[] = {
+    0x83, 0x0D, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x41, 0x54, 0x30, 0x30,
+    0x30, 0x30, 0x31,
+};
+static char tc_ecdh_e1[] = {
+    0xbe, 0x90, 0x23, 0x7e, 0xeb, 0x4b, 0xa0, 0xff, 0x25, 0x3e, 0xa2, 0x46,
+    0xae, 0x31, 0xc8, 0xb8,
+};
+static const struct encryption_decryption tc_ecdh_enc_dec[] = {
+    {
+        1,
+        { sizeof tc_ecdh_d1, tc_ecdh_d1, sizeof tc_ecdh_d1, },
+        { sizeof tc_ecdh_e1, tc_ecdh_e1, sizeof tc_ecdh_e1, },
+    },
+};
+static char tc_ecdh_ad1[] = {
+    0x99, 0x02, 0x90, 0x00,
+};
+static char tc_ecdh_a1[] = {
+    0xA8, 0x95, 0x70, 0xA6, 0x86, 0x64, 0xA7, 0xD6,
+};
+static const struct authenticate tc_ecdh_pace_authenticate[] = {
+    {
+        2,
+        { sizeof tc_ecdh_ad1, tc_ecdh_ad1, sizeof tc_ecdh_ad1, },
+        { sizeof tc_ecdh_a1, tc_ecdh_a1, sizeof tc_ecdh_a1, },
+    },
+};
+static char tc_ecdh_ca_picc_priv_key[] = {
+    0x79, 0x84, 0x67, 0x4C, 0xF3, 0xB3, 0xA5, 0x24, 0xBF, 0x92, 0x9C, 0xE8, 0xA6, 0x7F, 0xCF, 0x22,  /* y.gL...$......." */
+    0x17, 0x3D, 0xA0, 0xBA, 0xD5, 0x95, 0xEE, 0xD6, 0xDE, 0xB7, 0x2D, 0x22, 0xC5, 0x42, 0xFA, 0x9D,  /* .=........-".B.. */
+};
+static char tc_ecdh_ca_picc_pub_key[] = {
+    0x04, 0xA4, 0x4E, 0xBE, 0x54, 0x51, 0xDF, 0x7A, 0xAD, 0xB0, 0x1E, 0x45, 0x9B, 0x8C, 0x92, 0x8A,  /* ..N.TQ.z...E.... */
+    0x87, 0x74, 0x6A, 0x57, 0x92, 0x7C, 0x8C, 0x28, 0xA6, 0x77, 0x5C, 0x97, 0xA7, 0xE1, 0xFE, 0x8D,  /* .tjW.|.(.w\..... */
+    0x9A, 0x46, 0xFF, 0x4A, 0x1C, 0xC7, 0xE4, 0xD1, 0x38, 0x9A, 0xEA, 0x19, 0x75, 0x8E, 0x4F, 0x75,  /* .F.J....8...u.Ou */
+    0xC2, 0x8C, 0x59, 0x8F, 0xD7, 0x34, 0xAE, 0xBE, 0xB1, 0x35, 0x33, 0x7C, 0xF9, 0x5B, 0xE1, 0x2E,  /* ..Y..4...53|.[.. */
+    0x94,                                               /* . */
+};
+static char tc_ecdh_ca_pcd_priv_key[] = {
+    0x00, 0xA6, 0xA4, 0xD2, 0x55, 0xC5, 0xBF, 0x7A, 0x77, 0xEC, 0x3D, 0x05, 0x53, 0xDB, 0x74, 0xF6,  /* ....U..zw.=.S.t. */
+    0x93, 0xCF, 0x04, 0x4E, 0x18, 0xC9, 0x83, 0x64, 0xD4, 0x97, 0x7A, 0x29, 0x61, 0x08, 0xAF, 0x19,  /* ...N...d..z)a... */
+    0xBD,                                                                                            /* . */
+};
+static char tc_ecdh_ca_pcd_pub_key[] = {
+    0x04, 0x5A, 0x7A, 0x37, 0x7F, 0xC9, 0xCA, 0xFC, 0x03, 0xAC, 0x7F, 0xF4, 0x54, 0x41, 0xA8, 0xB2,  /* .Zz7........TA.. */
+    0x90, 0x9D, 0x88, 0xEA, 0xB8, 0xE6, 0xB0, 0x17, 0x38, 0x47, 0xAB, 0x49, 0xB9, 0x49, 0xDF, 0x37,  /* ........8G.I.I.7 */
+    0x99, 0xA3, 0x4E, 0xE5, 0x7E, 0xC5, 0x52, 0x68, 0xCF, 0x8B, 0x1C, 0x3E, 0xC4, 0x89, 0xF8, 0xBF,  /* /..N.~.Rh...>.... */
+    0x4C, 0xF4, 0xC6, 0x8D, 0x3F, 0xD9, 0x67, 0x0E, 0x89, 0xC0, 0xD5, 0xD3, 0xFF, 0xF1, 0xAA, 0xF8,  /* L...?.g......... */
+    0x9F,                                                                                            /* . */
+};
+static char tc_ecdh_ca_nonce[] = {
+    0x42, 0x87, 0xB3, 0x07, 0x2A, 0x3E, 0xDC, 0x60,                          /* B...*>.` */
+};
+static char tc_ecdh_ca_picc_token[] = {
+    0xFF, 0x01, 0x17, 0xD6, 0x8D, 0xEE, 0x8E, 0x72,                          /* .......r */
+};
+static char tc_ecdh_ca_shared_secret_k[] = {
+    0x79, 0x1D, 0xA0, 0x42, 0x73, 0xCC, 0xFE, 0x86, 0x2E, 0x52, 0xDF, 0x60, 0x34, 0x7E, 0x25, 0x57,  /* y..Bs....R.`4~%W */
+    0x19, 0x2E, 0x1F, 0x8D, 0x75, 0x17, 0x82, 0x2C, 0xE3, 0xD3, 0x06, 0x05, 0x6C, 0x1C, 0xDE, 0xB4,  /* ....u..,....l... */
+};
+static char tc_ecdh_ca_k_mac[] = {
+    0x78, 0xB5, 0x70, 0x9E, 0x7A, 0xBE, 0xDB, 0x18, 0x5B, 0x42, 0x4D, 0x0E, 0xE3, 0xA8, 0x24, 0x99,  /* x.p.z...[BM...$. */
+};
+static char tc_ecdh_ca_k_enc[] = {
+    0x94, 0xAB, 0xCD, 0x27, 0x1A, 0xB7, 0xD9, 0xA5, 0x59, 0x0B, 0xA5, 0x2C, 0xB5, 0x18, 0xB8, 0x31,  /* ...'....Y..,...1 */
+};
+static char tc_ecdh_ta_pcd_key[] = {
+    0x30, 0x82, 0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x82, 0x01, 0xaf, 0x06, 0x07, 0x2a, 0x86, 0x48,  /* 0......0.....*.H*/
+    0xce, 0x3d, 0x02, 0x01, 0x30, 0x82, 0x01, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x4c, 0x06, 0x07, 0x2a,  /* .=..0......0L..**/
+    0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x41, 0x00, 0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4,  /* .H.=...A........*/
+    0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07, 0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2,  /* .?...3....0.....*/
+    0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x71, 0x7d, 0x4d, 0x9b, 0x00, 0x9b, 0xc6, 0x68,  /* ..c..p3.q}M....h*/
+    0x42, 0xae, 0xcd, 0xa1, 0x2a, 0xe6, 0xa3, 0x80, 0xe6, 0x28, 0x81, 0xff, 0x2f, 0x2d, 0x82, 0xc6,  /* B...*....(../-..*/
+    0x85, 0x28, 0xaa, 0x60, 0x56, 0x58, 0x3a, 0x48, 0xf3, 0x30, 0x81, 0x84, 0x04, 0x40, 0x78, 0x30,  /* .(.`VX:H.0...@x0*/
+    0xa3, 0x31, 0x8b, 0x60, 0x3b, 0x89, 0xe2, 0x32, 0x71, 0x45, 0xac, 0x23, 0x4c, 0xc5, 0x94, 0xcb,  /* .1.`;..2qE.#L...*/
+    0xdd, 0x8d, 0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98, 0x63, 0xbc, 0x2d, 0xed,  /* ..=....4A...c.-.*/
+    0x5d, 0x5a, 0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a, 0xc8, 0xb5, 0x7f, 0x11,  /* ]Z.%:...........*/
+    0x17, 0xa7, 0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc, 0x94, 0xca, 0x04, 0x40,  /* ..+......Mw....@*/
+    0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98, 0x63, 0xbc, 0x2d, 0xed, 0x5d, 0x5a,  /* =....4A...c.-.]Z*/
+    0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a, 0xc8, 0xb5, 0x7f, 0x11, 0x17, 0xa7,  /* .%:.............*/
+    0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc, 0x94, 0xca, 0xdc, 0x08, 0x3e, 0x67,  /* +......Mw.....>g*/
+    0x98, 0x40, 0x50, 0xb7, 0x5e, 0xba, 0xe5, 0xdd, 0x28, 0x09, 0xbd, 0x63, 0x80, 0x16, 0xf7, 0x23,  /* .@P.^...(..c...#*/
+    0x04, 0x81, 0x81, 0x04, 0x81, 0xae, 0xe4, 0xbd, 0xd8, 0x2e, 0xd9, 0x64, 0x5a, 0x21, 0x32, 0x2e,  /* ...........dZ!2.*/
+    0x9c, 0x4c, 0x6a, 0x93, 0x85, 0xed, 0x9f, 0x70, 0xb5, 0xd9, 0x16, 0xc1, 0xb4, 0x3b, 0x62, 0xee,  /* .Lj....p.....;b.*/
+    0xf4, 0xd0, 0x09, 0x8e, 0xff, 0x3b, 0x1f, 0x78, 0xe2, 0xd0, 0xd4, 0x8d, 0x50, 0xd1, 0x68, 0x7b,  /* .....;.x....P.h{*/
+    0x93, 0xb9, 0x7d, 0x5f, 0x7c, 0x6d, 0x50, 0x47, 0x40, 0x6a, 0x5e, 0x68, 0x8b, 0x35, 0x22, 0x09,  /* ..}_|mPG@j^h.5".*/
+    0xbc, 0xb9, 0xf8, 0x22, 0x7d, 0xde, 0x38, 0x5d, 0x56, 0x63, 0x32, 0xec, 0xc0, 0xea, 0xbf, 0xa9,  /* ..."}.8]Vc2.....*/
+    0xcf, 0x78, 0x22, 0xfd, 0xf2, 0x09, 0xf7, 0x00, 0x24, 0xa5, 0x7b, 0x1a, 0xa0, 0x00, 0xc5, 0x5b,  /* .x".....$.{....[*/
+    0x88, 0x1f, 0x81, 0x11, 0xb2, 0xdc, 0xde, 0x49, 0x4a, 0x5f, 0x48, 0x5e, 0x5b, 0xca, 0x4b, 0xd8,  /* .......IJ_H^[.K.*/
+    0x8a, 0x27, 0x63, 0xae, 0xd1, 0xca, 0x2b, 0x2f, 0xa8, 0xf0, 0x54, 0x06, 0x78, 0xcd, 0x1e, 0x0f,  /* .'c...+/..T.x...*/
+    0x3a, 0xd8, 0x08, 0x92, 0x02, 0x41, 0x00, 0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f,  /* :....A.........?*/
+    0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07, 0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6,  /* ...3....0.......*/
+    0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x70, 0x55, 0x3e, 0x5c, 0x41, 0x4c, 0xa9, 0x26, 0x19, 0x41,  /* c..p3.pU>\AL.&.A*/
+    0x86, 0x61, 0x19, 0x7f, 0xac, 0x10, 0x47, 0x1d, 0xb1, 0xd3, 0x81, 0x08, 0x5d, 0xda, 0xdd, 0xb5,  /* .a....G.....]...*/
+    0x87, 0x96, 0x82, 0x9c, 0xa9, 0x00, 0x69, 0x02, 0x01, 0x01, 0x04, 0x47, 0x30, 0x45, 0x02, 0x01,  /* ......i....G0E..*/
+    0x01, 0x04, 0x40, 0x8a, 0xa2, 0x32, 0x7f, 0x9d, 0x38, 0x70, 0xab, 0x1e, 0xbb, 0x62, 0x85, 0x0f,  /* ..@..2..8p...b..*/
+    0x85, 0x97, 0x5e, 0xf7, 0xa0, 0x42, 0xdb, 0x92, 0x0b, 0x60, 0x4b, 0x68, 0x8d, 0xc1, 0xda, 0x27,  /* ..^..B...`Kh...'*/
+    0xa6, 0x1c, 0x3f, 0x8f, 0xa5, 0xdf, 0xdf, 0x1f, 0x91, 0xd2, 0x26, 0x62, 0x1f, 0xf1, 0xf9, 0x02,  /* ..?.......&b....*/
+    0xf1, 0x4d, 0x8c, 0x90, 0x38, 0x26, 0x42, 0x5a, 0xc4, 0x64, 0x10, 0xd8, 0x7f, 0x3d, 0xda, 0xd7,  /* .M..8&BZ.d...=..*/
+    0x2b, 0x0d, 0xbe,                                                                                /* +..*/
+};
+static char tc_ecdh_ta_nonce[] = {
+    0x54, 0x7E, 0x4E, 0xAB, 0x03, 0xB2, 0x35, 0xD2,                          /*  T~N...5. */
+};
+static char tc_ecdh_ta_pcd_signature[] = {
+    0x81, 0xA2, 0xD9, 0xE5, 0x89, 0x1B, 0x86, 0xA0, 0xF0, 0x1A, 0xDD, 0x03, 0x41, 0xC8, 0x9D, 0x6E,  /* ............A..n */
+    0x9E, 0xF3, 0xE2, 0x0C, 0x22, 0x38, 0x84, 0xF2, 0x7B, 0x2F, 0x20, 0x40, 0xE9, 0x72, 0x1C, 0x46,  /* ...."8..{/ @.r.F */
+    0xC9, 0xC3, 0xCF, 0x7C, 0x0E, 0xE0, 0xA4, 0x22, 0x26, 0x3B, 0xA6, 0xF1, 0xEA, 0xFC, 0x69, 0x3B,  /* ...|..."&;....i; */
+    0xD8, 0x73, 0x8F, 0x34, 0x76, 0x0B, 0x59, 0x98, 0x58, 0x4F, 0x58, 0xDD, 0x25, 0xB8, 0xD6, 0x0D,  /* .s.4v.Y.XOX.%... */
+    0x99, 0xD7, 0xC4, 0x59, 0x57, 0xC2, 0xE2, 0xF1, 0x0C, 0x0E, 0x5F, 0x91, 0xA8, 0xDC, 0x88, 0xBD,  /* ...YW....._..... */
+    0x7C, 0xFA, 0x33, 0xCB, 0xF7, 0x84, 0xA9, 0xDA, 0x83, 0xC8, 0x00, 0x32, 0x41, 0x65, 0x17, 0x9D,  /* |.3........2Ae.. */
+    0xBE, 0x71, 0xC6, 0x9B, 0x2C, 0x0F, 0xD8, 0x11, 0x27, 0x0E, 0x43, 0x6C, 0x43, 0x27, 0x81, 0x84,  /* .q..,...'.ClC'.. */
+    0xDD, 0xB5, 0x42, 0x14, 0x23, 0x42, 0xDB, 0xF1, 0x56, 0xE8, 0x2D, 0x2A, 0x1B, 0xC1, 0x90, 0x85,  /* ..B.#B..V.-*.... */
+};
+static char tc_ecdh_ta_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x66, 0x7f, 0x4e, 0x81, 0xde, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0d, 0x44,  /* .!..f.N.._)..B.D */
+    0x45, 0x54, 0x45, 0x53, 0x54, 0x44, 0x56, 0x44, 0x45, 0x30, 0x31, 0x39, 0x7f, 0x49, 0x81, 0x90,  /* ETESTDVDE019.I.. */
+    0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x05, 0x86, 0x81, 0x81, 0x04,  /* ................ */
+    0x33, 0x85, 0xb4, 0x84, 0xe8, 0xe9, 0x94, 0xc9, 0x3f, 0x55, 0xad, 0xf4, 0xa9, 0xc9, 0x2d, 0xa3,  /* 3.......?U....-. */
+    0xc0, 0x63, 0xac, 0x7d, 0x74, 0x4e, 0x85, 0xd3, 0x8e, 0xe0, 0x70, 0xbf, 0x6f, 0xf8, 0xd7, 0xab,  /* .c.}tN....p.o... */
+    0xa2, 0xde, 0x68, 0x87, 0x24, 0xb2, 0x7d, 0x6b, 0xae, 0x2b, 0x1c, 0x8a, 0xe0, 0x74, 0xc0, 0x9b,  /* ..h.$.}k.+...t.. */
+    0xb8, 0x80, 0x8c, 0xc8, 0x30, 0x36, 0xb0, 0x69, 0x28, 0x98, 0x71, 0x1d, 0x3f, 0x6f, 0xc3, 0x21,  /* ....06.i(.q.?o.! */
+    0x38, 0x46, 0xe1, 0x4b, 0x31, 0x54, 0x84, 0x50, 0x84, 0xdf, 0xbc, 0x0e, 0xb7, 0x0a, 0xe2, 0xbd,  /* 8F.K1T.P........ */
+    0xea, 0x8e, 0xeb, 0xd6, 0x79, 0x6a, 0xcf, 0xa4, 0xc5, 0x6f, 0x57, 0x03, 0xce, 0x5a, 0x6e, 0xfe,  /* ....yj...oW..Zn. */
+    0x0a, 0x26, 0x6e, 0x43, 0xc3, 0xf7, 0x1a, 0x1b, 0x7e, 0xec, 0x60, 0xe5, 0xc6, 0xf0, 0x85, 0x0d,  /* .&nC....~.`..... */
+    0xc4, 0xd3, 0x45, 0x5f, 0x53, 0x28, 0x2c, 0x9f, 0xbc, 0xa8, 0x5d, 0xc9, 0x47, 0xd1, 0x3b, 0xee,  /* ..E_S(,...].G.;. */
+    0x5f, 0x20, 0x0d, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x41, 0x54, 0x44, 0x45, 0x30, 0x31, 0x39,  /* _ .DETESTATDE00x19, */
+    0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05,  /* .L............S. */
+    0x00, 0x00, 0x00, 0x01, 0x10, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x09, 0x03, 0x00, 0x5f, 0x24,  /* ....._%......._$ */
+    0x06, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x5f, 0x37, 0x81, 0x80, 0x34, 0xbb, 0x8c, 0x28, 0x0a,  /* ......._7..4..(. */
+    0x7a, 0x59, 0x3c, 0xf7, 0xc7, 0xe9, 0xf3, 0x75, 0xff, 0xff, 0xbf, 0xd9, 0x2c, 0x4e, 0x3f, 0x61,  /* zY<....u....,N?a */
+    0x88, 0xa4, 0x48, 0x24, 0x21, 0x5e, 0x11, 0xef, 0x47, 0xd0, 0x34, 0x28, 0xcf, 0xc9, 0x19, 0x36,  /* ..H$!^..G.4(...6 */
+    0xa2, 0x60, 0x9c, 0x74, 0x2e, 0xf9, 0x2c, 0x59, 0x68, 0xbc, 0xe6, 0x5b, 0xa4, 0x2a, 0xed, 0x7a,  /* .`.t..,Yh..[.*.z */
+    0xad, 0x70, 0xb7, 0xb2, 0xa3, 0x12, 0x01, 0xdc, 0x15, 0x2c, 0xec, 0x93, 0x0d, 0x7d, 0x79, 0x54,  /* .p.......,...}yT */
+    0xbf, 0xbe, 0x00, 0x21, 0xad, 0x1f, 0xd2, 0xac, 0xaa, 0x6c, 0x34, 0x9a, 0x6c, 0x2f, 0xb8, 0x65,  /* ...!.....l4.l/.e */
+    0x14, 0xb9, 0xf0, 0x3d, 0xfa, 0xb9, 0x98, 0x71, 0xfb, 0xd9, 0x90, 0xdd, 0x84, 0x16, 0xd3, 0xed,  /* ...=...q........ */
+    0xa2, 0x88, 0x3e, 0xbd, 0x0b, 0x94, 0x40, 0x1a, 0x7d, 0xbf, 0xe1, 0x6e, 0x5a, 0x1d, 0xb6, 0x43,  /* ..>...@.}..nZ..C */
+    0xee, 0x7c, 0x2f, 0xc0, 0xd5, 0xd7, 0x7b, 0xae, 0x36, 0x66, 0xaf,                                /* .|/...{.6f. */
+};
+
+static char tc_ecdh_cvca_cert[] = {
+    0x7f, 0x21, 0x82, 0x02, 0xf3, 0x7f, 0x4e, 0x82, 0x02, 0x6a, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0d,  /* .!....N..j_)..B. */
+    0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x41, 0x54, 0x30, 0x30, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x82,  /* DECVCAAT00001.I. */
+    0x02, 0x1f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x05, 0x81, 0x40,  /* ...............@ */
+    0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9, 0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07,  /* ........?...3... */
+    0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9, 0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x71,  /* .0.......c..p3.q */
+    0x7d, 0x4d, 0x9b, 0x00, 0x9b, 0xc6, 0x68, 0x42, 0xae, 0xcd, 0xa1, 0x2a, 0xe6, 0xa3, 0x80, 0xe6,  /* }M....hB...*.... */
+    0x28, 0x81, 0xff, 0x2f, 0x2d, 0x82, 0xc6, 0x85, 0x28, 0xaa, 0x60, 0x56, 0x58, 0x3a, 0x48, 0xf3,  /* (../-...(.`VX:H. */
+    0x82, 0x40, 0x78, 0x30, 0xa3, 0x31, 0x8b, 0x60, 0x3b, 0x89, 0xe2, 0x32, 0x71, 0x45, 0xac, 0x23,  /* .@x0.1.`;..2qE.# */
+    0x4c, 0xc5, 0x94, 0xcb, 0xdd, 0x8d, 0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98,  /* L.....=....4A... */
+    0x63, 0xbc, 0x2d, 0xed, 0x5d, 0x5a, 0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a,  /* c.-.]Z.%:....... */
+    0xc8, 0xb5, 0x7f, 0x11, 0x17, 0xa7, 0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc,  /* ......+......Mw. */
+    0x94, 0xca, 0x83, 0x40, 0x3d, 0xf9, 0x16, 0x10, 0xa8, 0x34, 0x41, 0xca, 0xea, 0x98, 0x63, 0xbc,  /* ...@=....4A...c. */
+    0x2d, 0xed, 0x5d, 0x5a, 0xa8, 0x25, 0x3a, 0xa1, 0x0a, 0x2e, 0xf1, 0xc9, 0x8b, 0x9a, 0xc8, 0xb5,  /* -.]Z.%:......... */
+    0x7f, 0x11, 0x17, 0xa7, 0x2b, 0xf2, 0xc7, 0xb9, 0xe7, 0xc1, 0xac, 0x4d, 0x77, 0xfc, 0x94, 0xca,  /* ....+......Mw... */
+    0xdc, 0x08, 0x3e, 0x67, 0x98, 0x40, 0x50, 0xb7, 0x5e, 0xba, 0xe5, 0xdd, 0x28, 0x09, 0xbd, 0x63,  /* ..>g.@P.^...(..c */
+    0x80, 0x16, 0xf7, 0x23, 0x84, 0x81, 0x81, 0x04, 0x81, 0xae, 0xe4, 0xbd, 0xd8, 0x2e, 0xd9, 0x64,  /* ...#...........d */
+    0x5a, 0x21, 0x32, 0x2e, 0x9c, 0x4c, 0x6a, 0x93, 0x85, 0xed, 0x9f, 0x70, 0xb5, 0xd9, 0x16, 0xc1,  /* Z!2..Lj....p.... */
+    0xb4, 0x3b, 0x62, 0xee, 0xf4, 0xd0, 0x09, 0x8e, 0xff, 0x3b, 0x1f, 0x78, 0xe2, 0xd0, 0xd4, 0x8d,  /* .;b......;.x.... */
+    0x50, 0xd1, 0x68, 0x7b, 0x93, 0xb9, 0x7d, 0x5f, 0x7c, 0x6d, 0x50, 0x47, 0x40, 0x6a, 0x5e, 0x68,  /* P.h{..}_|mPG@j^h */
+    0x8b, 0x35, 0x22, 0x09, 0xbc, 0xb9, 0xf8, 0x22, 0x7d, 0xde, 0x38, 0x5d, 0x56, 0x63, 0x32, 0xec,  /* .5"...."}.8]Vc2. */
+    0xc0, 0xea, 0xbf, 0xa9, 0xcf, 0x78, 0x22, 0xfd, 0xf2, 0x09, 0xf7, 0x00, 0x24, 0xa5, 0x7b, 0x1a,  /* .....x".....$.{. */
+    0xa0, 0x00, 0xc5, 0x5b, 0x88, 0x1f, 0x81, 0x11, 0xb2, 0xdc, 0xde, 0x49, 0x4a, 0x5f, 0x48, 0x5e,  /* ...[.......IJ_H^ */
+    0x5b, 0xca, 0x4b, 0xd8, 0x8a, 0x27, 0x63, 0xae, 0xd1, 0xca, 0x2b, 0x2f, 0xa8, 0xf0, 0x54, 0x06,  /* [.K..'c...+/..T. */
+    0x78, 0xcd, 0x1e, 0x0f, 0x3a, 0xd8, 0x08, 0x92, 0x85, 0x40, 0xaa, 0xdd, 0x9d, 0xb8, 0xdb, 0xe9,  /* x...:....@...... */
+    0xc4, 0x8b, 0x3f, 0xd4, 0xe6, 0xae, 0x33, 0xc9, 0xfc, 0x07, 0xcb, 0x30, 0x8d, 0xb3, 0xb3, 0xc9,  /* ..?...3....0.... */
+    0xd2, 0x0e, 0xd6, 0x63, 0x9c, 0xca, 0x70, 0x33, 0x08, 0x70, 0x55, 0x3e, 0x5c, 0x41, 0x4c, 0xa9,  /* ...c..p3.pU>\AL. */
+    0x26, 0x19, 0x41, 0x86, 0x61, 0x19, 0x7f, 0xac, 0x10, 0x47, 0x1d, 0xb1, 0xd3, 0x81, 0x08, 0x5d,  /* &.A.a....G.....] */
+    0xda, 0xdd, 0xb5, 0x87, 0x96, 0x82, 0x9c, 0xa9, 0x00, 0x69, 0x86, 0x81, 0x81, 0x04, 0x64, 0xf0,  /* .........i....d. */
+    0x9c, 0x61, 0x7c, 0x0d, 0x5a, 0x4e, 0x2e, 0x88, 0xb2, 0x59, 0x8a, 0xf0, 0x68, 0x60, 0x44, 0x0c,  /* .a|.ZN...Y..h`D. */
+    0x07, 0xc5, 0xed, 0x35, 0x3a, 0x18, 0xa1, 0x4e, 0x93, 0x8a, 0x6c, 0xbc, 0xe3, 0x05, 0x94, 0xd9,  /* ...5:..N..l..... */
+    0x40, 0x79, 0x59, 0x4c, 0xcf, 0xae, 0xfe, 0x28, 0xd9, 0xaa, 0xc9, 0xac, 0x1b, 0xd3, 0x7c, 0x89,  /* @yYL...(......|. */
+    0xb6, 0xcc, 0xbd, 0x10, 0xb1, 0x4f, 0xc3, 0xaa, 0x19, 0xde, 0xb1, 0xfd, 0x03, 0xea, 0x15, 0x1a,  /* .....O.......... */
+    0x42, 0xb8, 0x92, 0x54, 0x7a, 0x33, 0x96, 0x18, 0xc4, 0xc9, 0xf2, 0x6f, 0xa9, 0x83, 0x85, 0x5d,  /* B..Tz3.....o...] */
+    0x89, 0x3f, 0x81, 0x41, 0x3c, 0xd3, 0x20, 0xea, 0x42, 0x30, 0xd3, 0x41, 0x5e, 0xbc, 0xcd, 0xb5,  /* .?.A<. .B0.A^... */
+    0x90, 0x8d, 0x91, 0xdc, 0x23, 0xc6, 0x56, 0x6f, 0x47, 0xb8, 0xa0, 0xe0, 0xa1, 0x9c, 0x17, 0x5b,  /* ....#.VoG......[ */
+    0xdc, 0x77, 0x5d, 0x88, 0x24, 0x67, 0x6a, 0xac, 0xfa, 0xed, 0xea, 0x0c, 0x16, 0x0e, 0x87, 0x01,  /* .w].$gj......... */
+    0x01, 0x5f, 0x20, 0x0d, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x41, 0x54, 0x30, 0x30, 0x30, 0x30,  /* ._ .DECVCAAT0000 */
+    0x31, 0x7f, 0x4c, 0x0e, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x01, 0x53,  /* 1.L............S */
+    0x01, 0xc3, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x09, 0x03, 0x00, 0x5f, 0x24, 0x06, 0x01, 0x01,  /* .._%......._$... */
+    0x00, 0x09, 0x02, 0x05, 0x5f, 0x37, 0x81, 0x80, 0xa5, 0xe7, 0x22, 0x44, 0xd0, 0xac, 0x9c, 0xd3,  /* ...._7...."D.... */
+    0xe8, 0xfe, 0x9b, 0x87, 0x8e, 0xa3, 0x2a, 0x24, 0xf4, 0xaa, 0x06, 0x0f, 0xd1, 0x7c, 0x2a, 0x82,  /* ......*$.....|*. */
+    0x91, 0xd9, 0x79, 0x7e, 0x8a, 0x60, 0xf2, 0x8a, 0x29, 0x78, 0xe3, 0xf4, 0xea, 0xe8, 0x40, 0xe9,  /* ..y~.`..)x....@. */
+    0x5b, 0x6a, 0x64, 0xfd, 0xa4, 0x4d, 0x8d, 0x39, 0xa6, 0x99, 0x52, 0x1c, 0xd5, 0x38, 0x22, 0x03,  /* [jd..M.9..R..8". */
+    0x96, 0x49, 0x45, 0x15, 0x0a, 0x6c, 0xc4, 0xa5, 0x0c, 0x49, 0xee, 0x23, 0x4a, 0xb3, 0x6d, 0xf6,  /* .IE..l...I.#J.m. */
+    0x75, 0xe4, 0x4c, 0x11, 0x49, 0x90, 0x80, 0x67, 0x6d, 0xd5, 0xb3, 0xac, 0x18, 0x59, 0xd9, 0x8b,  /* u.L.I..gm....Y.. */
+    0x30, 0x2c, 0xa9, 0x60, 0x5c, 0xd9, 0x4a, 0x51, 0xd7, 0xda, 0x57, 0x38, 0xbe, 0xaa, 0x49, 0x84,  /* 0,.`\.JQ..W8..I. */
+    0x8b, 0xca, 0x77, 0x77, 0xb7, 0xdc, 0x9a, 0xcc, 0xda, 0xa1, 0xd0, 0xb6, 0x44, 0x32, 0xb2, 0xc1,  /* ..ww........D2.. */
+    0x38, 0x89, 0xa4, 0x85, 0x4c, 0x9f, 0xf3, 0x46,                                                  /* 8...L..F */
+};
+static char tc_ecdh_dv_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x66, 0x7f, 0x4e, 0x81, 0xde, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0d, 0x44,  /*.!..f.N.._)..B.D */
+    0x45, 0x43, 0x56, 0x43, 0x41, 0x41, 0x54, 0x30, 0x30, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x81, 0x90,  /*ECVCAAT00001.I.. */
+    0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x05, 0x86, 0x81, 0x81, 0x04,  /*................ */
+    0x0a, 0x74, 0x97, 0x2e, 0x84, 0xb7, 0xd2, 0xc4, 0x28, 0xfb, 0xe4, 0x6d, 0x40, 0xc9, 0x2d, 0x6c,  /*.t......(..m@.-l */
+    0xb5, 0x6a, 0xe6, 0xa4, 0xb0, 0xaf, 0x5b, 0x8b, 0xc0, 0x92, 0x7e, 0x5e, 0xf6, 0xf7, 0x32, 0x20,  /*.j....[...~^..2  */
+    0x77, 0x6d, 0x31, 0x69, 0x3e, 0x36, 0xd6, 0x85, 0xdf, 0x6c, 0xf3, 0x76, 0x3e, 0x41, 0x72, 0x8d,  /*wm1i>6...l.v>Ar. */
+    0x96, 0x7d, 0xc1, 0x96, 0x3f, 0x7c, 0xa7, 0x0f, 0x0e, 0xa7, 0xad, 0xb5, 0xea, 0x85, 0x6d, 0x8a,  /*.}..?|........m. */
+    0x13, 0x3b, 0x86, 0x7b, 0x8e, 0xf4, 0x13, 0x2e, 0x7f, 0xfa, 0x3e, 0x8f, 0x32, 0xcd, 0x03, 0x21,  /*.;.{......>.2..! */
+    0xfc, 0x22, 0x19, 0x9b, 0x93, 0x23, 0x37, 0x6e, 0x59, 0xd8, 0x4a, 0x06, 0x24, 0x91, 0x94, 0x81,  /*."...#7nY.J.$... */
+    0x17, 0x17, 0x8b, 0xf4, 0xdb, 0x6c, 0x0e, 0xe7, 0xa2, 0x35, 0xbf, 0xc3, 0xd4, 0x45, 0x91, 0x83,  /*.....l...5...E.. */
+    0xd4, 0x08, 0x23, 0x2a, 0xc7, 0x81, 0xc7, 0x8c, 0xf5, 0xc5, 0x4e, 0x2f, 0xf3, 0x5b, 0xa5, 0x16,  /*..#*......N/.[.. */
+    0x5f, 0x20, 0x0d, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x44, 0x56, 0x44, 0x45, 0x30, 0x31, 0x39,  /*_ .DETESTDVDE00x19, */
+    0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05,  /*.L............S. */
+    0x80, 0x1f, 0xff, 0xff, 0x10, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x09, 0x03, 0x00, 0x5f, 0x24,  /*....._%......._$ */
+    0x06, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x5f, 0x37, 0x81, 0x80, 0x98, 0xc6, 0x37, 0xbe, 0xfa,  /*......._7....7.. */
+    0x63, 0x05, 0x89, 0x21, 0x90, 0x28, 0x96, 0xa6, 0x05, 0x20, 0x6d, 0x5b, 0xe3, 0xbf, 0xf2, 0xf7,  /*c..!.(... m[.... */
+    0xe2, 0x58, 0xeb, 0x0b, 0xb0, 0x6e, 0xa7, 0xe8, 0x4d, 0xfb, 0xc9, 0x8e, 0x35, 0x27, 0x61, 0x10,  /*.X...n..M...5'a. */
+    0xc6, 0x84, 0xbb, 0x23, 0xd2, 0x77, 0x35, 0x0e, 0x38, 0x62, 0xe6, 0xa3, 0x05, 0x20, 0x80, 0x8f,  /*...#.w5.8b... .. */
+    0x41, 0x7b, 0x89, 0x11, 0x98, 0x58, 0x80, 0xa5, 0x56, 0xe1, 0x75, 0x8c, 0x7f, 0xe6, 0x54, 0x5b,  /*A{...X..V.u...T[ */
+    0x3d, 0xa0, 0x33, 0x83, 0xbd, 0x7b, 0x5b, 0x51, 0xde, 0xc0, 0x07, 0x13, 0x9c, 0xbc, 0x44, 0xff,  /*=.3..{[Q......D. */
+    0x32, 0x0f, 0x84, 0xf2, 0xb6, 0xad, 0x44, 0xc7, 0xb2, 0x8f, 0xca, 0xeb, 0x2b, 0x7b, 0x98, 0xe3,  /*2.....D.....+{.. */
+    0xa2, 0xba, 0xe8, 0x32, 0x2b, 0x11, 0x5a, 0x8f, 0x10, 0xd4, 0x83, 0x49, 0x28, 0x1b, 0x4f, 0x46,  /*...2+.Z....I(.OF */
+    0x45, 0xc9, 0xaa, 0xe3, 0x07, 0xcf, 0xae, 0x9a, 0xd6, 0xb1, 0x94,                                /*E.......... */
+};
+
+static char tc_dh_ef_cardaccess[] = {
+    0x31, 0x81, 0xC6, 0x30, 0x0D, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02,  /* 1..0............ */
+    0x01, 0x02, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x01, 0x02,  /* ..0............. */
+    0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02,  /* ......0......... */
+    0x02, 0x04, 0x01, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x30, 0x1C, 0x06, 0x09, 0x04, 0x00,  /* ..........0..... */
+    0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x01, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00, 0x07,  /* .......0........ */
+    0x01, 0x02, 0x02, 0x01, 0x00, 0x02, 0x01, 0x01, 0x30, 0x2F, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00,  /* ........0/...... */
+    0x07, 0x02, 0x02, 0x06, 0x16, 0x23, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77,  /* .....#https://ww */
+    0x77, 0x2E, 0x68, 0x6A, 0x70, 0x2D, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6C, 0x74, 0x69, 0x6E, 0x67,  /* w.hjp-consulting */
+    0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x68, 0x6F, 0x6D, 0x65, 0x30, 0x3E, 0x06, 0x08, 0x04, 0x00, 0x7F,  /* .com/home0>..... */
+    0x00, 0x07, 0x02, 0x02, 0x08, 0x31, 0x32, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07,  /* .....120........ */
+    0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x1C, 0x06, 0x09, 0x04,  /* ...........0.... */
+    0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x01, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00,  /* ........0....... */
+    0x07, 0x01, 0x02, 0x02, 0x01, 0x00, 0x02, 0x01, 0x02,                                            /* ......... */
+};
+static char tc_dh_nonce_enc[] = {
+    0x9A, 0xBB, 0x88, 0x64, 0xCA, 0x0F, 0xF1, 0x55, 0x1E, 0x62, 0x0D, 0x1E, 0xF4, 0xE1, 0x35, 0x10,  /* ...d...U.b....5. */
+};
+static char tc_dh_nonce[] = {
+    0xFA, 0x5B, 0x7E, 0x3E, 0x49, 0x75, 0x3A, 0x0D, 0xB9, 0x17, 0x8B, 0x7B, 0x9B, 0xD8, 0x98, 0xC8,  /* .[~>Iu:....{.... */
+};
+static char tc_dh_map_pcd_priv_key[] = {
+    0x24, 0xC3, 0xC0, 0xE0, 0xA3, 0x28, 0x0E, 0xCB, 0x94, 0x33, 0x45, 0xD9, 0xDC, 0x2A, 0x7B, 0x72,  /* $....(...3E..*{r */
+    0x53, 0x9F, 0xDA, 0x6F, 0xFD, 0xF9, 0x9A, 0xB7, 0xB6, 0xCD, 0xDD, 0xD1, 0xBE, 0x42, 0x5A, 0xF3,  /* S..o.........BZ. */
+    0xD0, 0x2C, 0x4E, 0xD0, 0xCD, 0xD7, 0x3E, 0xBB, 0x4B, 0x2E, 0xDF, 0x8C, 0x07, 0xFB, 0x3A, 0x35,  /* .,N...>.K.....:5 */
+    0x90, 0x3F, 0x72, 0xB8, 0x4F, 0x37, 0x71, 0xF4, 0xEB, 0xFB, 0x49, 0x52, 0x0D, 0x61, 0xA8, 0xF7,  /* .?r.O7q...IR.a.. */
+    0xC7, 0xFB, 0x8C, 0x9E, 0x2A, 0xBC, 0x24, 0xBF, 0x4F, 0xF9, 0xD8, 0xDD, 0xF3, 0x81, 0xA1, 0x93,  /* ....*.$.O....... */
+    0x80, 0xC8, 0x5B, 0x62, 0x3A, 0xB0, 0x2A, 0xCB, 0xF6, 0xD2, 0x20, 0xF5, 0x12, 0xBF, 0x40, 0x65,  /* ..[b:.*... ...@e */
+    0x83, 0x22, 0xAD, 0x20, 0x9A, 0xC0, 0xBF, 0x9E, 0x6F, 0x8D, 0xB6, 0x02, 0xD5, 0x19, 0x7D, 0x25,  /* .". ....o.....}% */
+    0x2B, 0xF6, 0xD1, 0x48, 0x51, 0x0C, 0xA1, 0xB7, 0x40, 0xAF, 0x0F, 0x99, 0xF3, 0x3C, 0xA5, 0xF1,  /* +..HQ...@....<.. */
+};
+static char tc_dh_map_pcd_pub_key[] = {
+    0x23, 0xFB, 0x37, 0x49, 0xEA, 0x03, 0x0D, 0x2A, 0x25, 0xB2, 0x78, 0xD2, 0xA5, 0x62, 0x04, 0x7A,  /* #.7I...*%.x..b.z */
+    0xDE, 0x3F, 0x01, 0xB7, 0x4F, 0x17, 0xA1, 0x54, 0x02, 0xCB, 0x73, 0x52, 0xCA, 0x7D, 0x2B, 0x3E,  /* .?..O..T..sR.}+> */
+    0xB7, 0x1C, 0x34, 0x3D, 0xB1, 0x3D, 0x1D, 0xEB, 0xCE, 0x9A, 0x36, 0x66, 0xDB, 0xCF, 0xC9, 0x20,  /* ..4=.=....6f...  */
+    0xB4, 0x91, 0x74, 0xA6, 0x02, 0xCB, 0x47, 0x96, 0x5C, 0xAA, 0x73, 0xDC, 0x70, 0x24, 0x89, 0xA4,  /* ..t...G.\.s.p$.. */
+    0x4D, 0x41, 0xDB, 0x91, 0x4D, 0xE9, 0x61, 0x3D, 0xC5, 0xE9, 0x8C, 0x94, 0x16, 0x05, 0x51, 0xC0,  /* MA..M.a=......Q. */
+    0xDF, 0x86, 0x27, 0x4B, 0x93, 0x59, 0xBC, 0x04, 0x90, 0xD0, 0x1B, 0x03, 0xAD, 0x54, 0x02, 0x2D,  /* ..'K.Y.......T.- */
+    0xCB, 0x4F, 0x57, 0xFA, 0xD6, 0x32, 0x24, 0x97, 0xD7, 0xA1, 0xE2, 0x8D, 0x46, 0x71, 0x0F, 0x46,  /* .OW..2$.....Fq.F */
+    0x1A, 0xFE, 0x71, 0x0F, 0xBB, 0xBC, 0x5F, 0x8B, 0xA1, 0x66, 0xF4, 0x31, 0x19, 0x75, 0xEC, 0x6C,  /* ..q..._..f.1.u.l */
+    };
+static char tc_dh_map_picc_priv_key[] = {
+    0x4E, 0xC0, 0x25, 0xE4, 0x0C, 0x6D, 0x10, 0xB2, 0xAA, 0xF6, 0xFC, 0xAC, 0x98, 0xC4, 0x24, 0x4F,  /* N.%..m........$O */
+    0x57, 0x48, 0x1A, 0x49, 0x61, 0xF3, 0xAD, 0xC3, 0x72, 0xA9, 0x5E, 0x40, 0xE0, 0xCC, 0x35, 0x55,  /* WH.Ia...r.^@..5U */
+    0xF7, 0x3C, 0xCF, 0xC6, 0x5E, 0x9D, 0xB9, 0x56, 0xDD, 0x61, 0xB1, 0x43, 0xE0, 0xC7, 0xDC, 0x51,  /* .<..^..V.a.C...Q */
+    0x9E, 0x7D, 0xD8, 0xED, 0xD8, 0xE3, 0xE4, 0x6A, 0x09, 0x4C, 0xF2, 0x26, 0x4F, 0xD1, 0x93, 0xD0,  /* .}.....j.L.&O... */
+    0xBC, 0x4B, 0xC0, 0x5C, 0xDE, 0x6C, 0xA4, 0x43, 0x19, 0xC2, 0x43, 0x9F, 0xD0, 0x4A, 0x46, 0x44,  /* .K.\.l.C..C..JFD */
+    0x3C, 0x8D, 0x04, 0x94, 0x48, 0x7F, 0x6F, 0x2F, 0xE9, 0xAC, 0x8B, 0xE9, 0xB9, 0xEE, 0x16, 0xA3,  /* <...H.o/........ */
+    0xD2, 0x42, 0x66, 0x8C, 0xBA, 0x4F, 0xFD, 0x42, 0xEE, 0xAC, 0x36, 0x50, 0x9E, 0x16, 0xB4, 0xD1,  /* .Bf..O.B..6P.... */
+    0xE6, 0xE8, 0xEE, 0x00, 0x25, 0xFF, 0x82, 0x44, 0xB1, 0x90, 0xF5, 0x7D, 0x44, 0x1E, 0xC3, 0x28,  /* ....%..D...}D..( */
+    };
+static char tc_dh_map_picc_pub_key[] = {
+    0x78, 0x87, 0x9F, 0x57, 0x22, 0x5A, 0xA8, 0x08, 0x0D, 0x52, 0xED, 0x0F, 0xC8, 0x90, 0xA4, 0xB2,  /* x..W"Z...R...... */
+    0x53, 0x36, 0xF6, 0x99, 0xAA, 0x89, 0xA2, 0xD3, 0xA1, 0x89, 0x65, 0x4A, 0xF7, 0x07, 0x29, 0xE6,  /* S6........eJ..). */
+    0x23, 0xEA, 0x57, 0x38, 0xB2, 0x63, 0x81, 0xE4, 0xDA, 0x19, 0xE0, 0x04, 0x70, 0x6F, 0xAC, 0xE7,  /* #.W8.c......po.. */
+    0xB2, 0x35, 0xC2, 0xDB, 0xF2, 0xF3, 0x87, 0x48, 0x31, 0x2F, 0x3C, 0x98, 0xC2, 0xDD, 0x48, 0x82,  /* .5.....H1/<...H. */
+    0xA4, 0x19, 0x47, 0xB3, 0x24, 0xAA, 0x12, 0x59, 0xAC, 0x22, 0x57, 0x9D, 0xB9, 0x3F, 0x70, 0x85,  /* ..G.$..Y."W..?p. */
+    0x65, 0x5A, 0xF3, 0x08, 0x89, 0xDB, 0xB8, 0x45, 0xD9, 0xE6, 0x78, 0x3F, 0xE4, 0x2C, 0x9F, 0x24,  /* eZ.....E..x?.,.$ */
+    0x49, 0x40, 0x03, 0x06, 0x25, 0x4C, 0x8A, 0xE8, 0xEE, 0x9D, 0xD8, 0x12, 0xA8, 0x04, 0xC0, 0xB6,  /* I@..%L.......... */
+    0x6E, 0x8C, 0xAF, 0xC1, 0x4F, 0x84, 0xD8, 0x25, 0x89, 0x50, 0xA9, 0x1B, 0x44, 0x12, 0x6E, 0xE6,  /* n...O..%.P..D.n. */
+};
+static char tc_dh_map_shared_secret_h[] = {
+    0x5B, 0xAB, 0xEB, 0xEF, 0x5B, 0x74, 0xE5, 0xBA, 0x94, 0xB5, 0xC0, 0x63, 0xFD, 0xA1, 0x5F, 0x1F,  /* [...[t.....c.._. */
+    0x1C, 0xDE, 0x94, 0x87, 0x3E, 0xE0, 0xA5, 0xD3, 0xA2, 0xFC, 0xAB, 0x49, 0xF2, 0x58, 0xD0, 0x7F,  /* ....>......I.X.. */
+    0x54, 0x4F, 0x13, 0xCB, 0x66, 0x65, 0x8C, 0x3A, 0xFE, 0xE9, 0xE7, 0x27, 0x38, 0x9B, 0xE3, 0xF6,  /* TO..fe.:...'8... */
+    0xCB, 0xBB, 0xD3, 0x21, 0x28, 0xA8, 0xC2, 0x1D, 0xD6, 0xEE, 0xA3, 0xCF, 0x70, 0x91, 0xCD, 0xDF,  /* ...!(.......p... */
+    0xB0, 0x8B, 0x8D, 0x00, 0x7D, 0x40, 0x31, 0x8D, 0xCC, 0xA4, 0xFF, 0xBF, 0x51, 0x20, 0x87, 0x90,  /* ....}@1.....Q .. */
+    0xFB, 0x4B, 0xD1, 0x11, 0xE5, 0xA9, 0x68, 0xED, 0x6B, 0x6F, 0x08, 0xB2, 0x6C, 0xA8, 0x7C, 0x41,  /* .K....h.ko..l.|A */
+    0x0B, 0x3C, 0xE0, 0xC3, 0x10, 0xCE, 0x10, 0x4E, 0xAB, 0xD1, 0x66, 0x29, 0xAA, 0x48, 0x62, 0x0C,  /* .<.....N..f).Hb. */
+    0x12, 0x79, 0x27, 0x0C, 0xB0, 0x75, 0x0C, 0x0D, 0x37, 0xC5, 0x7F, 0xFF, 0xE3, 0x02, 0xAE, 0x7F,  /* .y'..u..7....... */
+    };
+static char tc_dh_map_generator[] = {
+    0x7C, 0x9C, 0xBF, 0xE9, 0x8F, 0x9F, 0xBD, 0xDA, 0x8D, 0x14, 0x35, 0x06, 0xFA, 0x7D, 0x93, 0x06,  /* |.........5..}.. */
+    0xF4, 0xCB, 0x17, 0xE3, 0xC7, 0x17, 0x07, 0xAF, 0xF5, 0xE1, 0xC1, 0xA1, 0x23, 0x70, 0x24, 0x96,  /* ............#p$. */
+    0x84, 0xD6, 0x4E, 0xE3, 0x7A, 0xF4, 0x4B, 0x8D, 0xBD, 0x9D, 0x45, 0xBF, 0x60, 0x23, 0x91, 0x9C,  /* ..N.z.K...E.`#.. */
+    0xBA, 0xA0, 0x27, 0xAB, 0x97, 0xAC, 0xC7, 0x71, 0x66, 0x6C, 0x8E, 0x98, 0xFF, 0x48, 0x33, 0x01,  /* ..'....qfl...H3. */
+    0xBF, 0xA4, 0x87, 0x2D, 0xED, 0xE9, 0x03, 0x4E, 0xDF, 0xAC, 0xB7, 0x08, 0x14, 0x16, 0x6B, 0x7F,  /* ...-...N......k. */
+    0x36, 0x06, 0x76, 0x82, 0x9B, 0x82, 0x6B, 0xEA, 0x57, 0x29, 0x1B, 0x5A, 0xD6, 0x9F, 0xBC, 0x84,  /* 6.v...k.W).Z.... */
+    0xEF, 0x1E, 0x77, 0x90, 0x32, 0xA3, 0x05, 0x80, 0x3F, 0x74, 0x34, 0x17, 0x93, 0xE8, 0x69, 0x74,  /* ..w.2...?t4...it */
+    0x2D, 0x40, 0x13, 0x25, 0xB3, 0x7E, 0xE8, 0x56, 0x5F, 0xFC, 0xDE, 0xE6, 0x18, 0x34, 0x2D, 0xC5,  /* -@.%.~.V_....4-. */
+    };
+static char tc_dh_pcd_priv_key[] = {
+    0x4B, 0xD0, 0xE5, 0x47, 0x40, 0xF9, 0xA0, 0x28, 0xE6, 0xA5, 0x15, 0xBF, 0xDA, 0xF9, 0x67, 0x84,  /* K..G@..(......g. */
+    0x8C, 0x4F, 0x5F, 0x5F, 0xFF, 0x65, 0xAA, 0x09, 0x15, 0x94, 0x7F, 0xFD, 0x1A, 0x0D, 0xF2, 0xFA,  /* .O__.e.......... */
+    0x69, 0x81, 0x27, 0x1B, 0xC9, 0x05, 0xF3, 0x55, 0x14, 0x57, 0xB7, 0xE0, 0x3A, 0xC3, 0xB8, 0x06,  /* i.'....U.W..:... */
+    0x6D, 0xE4, 0xAA, 0x40, 0x6C, 0x11, 0x71, 0xFB, 0x43, 0xDD, 0x93, 0x9C, 0x4B, 0xA1, 0x61, 0x75,  /* m..@l.q.C...K.au */
+    0x10, 0x3B, 0xA3, 0xDE, 0xE1, 0x64, 0x19, 0xAA, 0x24, 0x81, 0x18, 0xF9, 0x0C, 0xC3, 0x6A, 0x3D,  /* .;...d..$.....j= */
+    0x6F, 0x4C, 0x37, 0x36, 0x52, 0xE0, 0xC3, 0xCC, 0xE7, 0xF0, 0xF1, 0xD0, 0xC5, 0x42, 0x5B, 0x36,  /* oL76R........B[6 */
+    0x00, 0xF0, 0xF0, 0xD6, 0xA6, 0x7F, 0x00, 0x4C, 0x8B, 0xBA, 0x33, 0xF2, 0xB4, 0x73, 0x3C, 0x72,  /* .......L..3..s<r */
+    0x52, 0x44, 0x5C, 0x1D, 0xFC, 0x4F, 0x11, 0x07, 0x20, 0x3F, 0x71, 0xD2, 0xEF, 0xB2, 0x81, 0x61,  /* RD\..O.. ?q....a */
+};
+static char tc_dh_pcd_pub_key[] = {
+    0x00, 0x90, 0x7D, 0x89, 0xE2, 0xD4, 0x25, 0xA1, 0x78, 0xAA, 0x81, 0xAF, 0x4A, 0x77, 0x74, 0xEC,  /* ..}...%.x...Jwt. */
+    0x8E, 0x38, 0x8C, 0x11, 0x5C, 0xAE, 0x67, 0x03, 0x1E, 0x85, 0xEE, 0xCE, 0x52, 0x0B, 0xD9, 0x11,  /* .8..\.g.....R... */
+    0x55, 0x1B, 0x9A, 0xE4, 0xD0, 0x43, 0x69, 0xF2, 0x9A, 0x02, 0x62, 0x6C, 0x86, 0xFB, 0xC6, 0x74,  /* U....Ci...bl...t */
+    0x7C, 0xC7, 0xBC, 0x35, 0x26, 0x45, 0xB6, 0x16, 0x1A, 0x2A, 0x42, 0xD4, 0x4E, 0xDA, 0x80, 0xA0,  /* |..5&E...*B.N... */
+    0x8F, 0xA8, 0xD6, 0x1B, 0x76, 0xD3, 0xA1, 0x54, 0xAD, 0x8A, 0x5A, 0x51, 0x78, 0x6B, 0x0B, 0xC0,  /* ....v..T..ZQxk.. */
+    0x71, 0x47, 0x05, 0x78, 0x71, 0xA9, 0x22, 0x21, 0x2C, 0x5F, 0x67, 0xF4, 0x31, 0x73, 0x17, 0x22,  /* qG.xq."!,_g.1s." */
+    0x36, 0xB7, 0x74, 0x7D, 0x16, 0x71, 0xE6, 0xD6, 0x92, 0xA3, 0xC7, 0xD4, 0x0A, 0x0C, 0x3C, 0x5C,  /* 6.t}.q........<\ */
+    0xE3, 0x97, 0x54, 0x5D, 0x01, 0x5C, 0x17, 0x5E, 0xB5, 0x13, 0x05, 0x51, 0xED, 0xBC, 0x2E, 0xE5,  /* ..T].\.^...Q.... */
+    0xD4,                                                                                            /* . */
+};
+/* Note that  Worked Example for Extended Access Control (EAC) Version 1.0
+ * contains a wrong key. The Log however contains a dump of the correct value
+ */
+static char tc_dh_picc_priv_key[] = {
+    0x02, 0x0F, 0x01, 0x8C, 0x72, 0x84, 0xB0, 0x47, 0xFA, 0x77, 0x21, 0xA3, 0x37, 0xEF, 0xB7, 0xAC,  /* ....r..G.w!.7... */
+    0xB1, 0x44, 0x0B, 0xB3, 0x0C, 0x52, 0x52, 0xBD, 0x41, 0xC9, 0x7C, 0x30, 0xC9, 0x94, 0xBB, 0x78,  /* .D...RR.A.|0...x */
+    0xE9, 0xF0, 0xC5, 0xB3, 0x27, 0x44, 0xD8, 0x40, 0x17, 0xD2, 0x1F, 0xFA, 0x68, 0x78, 0x39, 0x6A,  /* ....'D.@....hx9j */
+    0x64, 0x69, 0xCA, 0x28, 0x3E, 0xF5, 0xC0, 0x00, 0xDA, 0xF7, 0xD2, 0x61, 0xA3, 0x9A, 0xB8, 0x86,  /* di.(>......a.... */
+    0x0E, 0xD4, 0x61, 0x0A, 0xB5, 0x34, 0x33, 0x90, 0x89, 0x7A, 0xAB, 0x5A, 0x77, 0x87, 0xE4, 0xFA,  /* ..a..43..z.Zw... */
+    0xEF, 0xA0, 0x64, 0x9C, 0x6A, 0x94, 0xFD, 0xF8, 0x2D, 0x99, 0x1E, 0x8E, 0x3F, 0xC3, 0x32, 0xF5,  /* ..d.j...-...?.2. */
+    0x14, 0x27, 0x29, 0xE7, 0x04, 0x0A, 0x3F, 0x7D, 0x5A, 0x4D, 0x3C, 0xD7, 0x5C, 0xBE, 0xE1, 0xF0,  /* .')...?}ZM<.\... */
+    0x43, 0xC1, 0xCA, 0xD2, 0xDD, 0x48, 0x4F, 0xEB, 0x4E, 0xD2, 0x2B, 0x59, 0x7D, 0x36, 0x68, 0x8E,  /* C....HO.N.+Y}6h. */
+};
+/* Note that  Worked Example for Extended Access Control (EAC) Version 1.0
+ * contains a wrong key. The Log however contains a dump of the correct value
+ */
+static char tc_dh_picc_pub_key[] = {
+    0x07, 0x56, 0x93, 0xD9, 0xAE, 0x94, 0x18, 0x77, 0x57, 0x3E, 0x63, 0x4B, 0x6E, 0x64, 0x4F, 0x8E,  /* .V.....wW>cKndO. */
+    0x60, 0xAF, 0x17, 0xA0, 0x07, 0x6B, 0x8B, 0x12, 0x3D, 0x92, 0x01, 0x07, 0x4D, 0x36, 0x15, 0x2B,  /* `....k..=...M6.+ */
+    0xD8, 0xB3, 0xA2, 0x13, 0xF5, 0x38, 0x20, 0xC4, 0x2A, 0xDC, 0x79, 0xAB, 0x5D, 0x0A, 0xEE, 0xC3,  /* .....8 .*.y.]... */
+    0xAE, 0xFB, 0x91, 0x39, 0x4D, 0xA4, 0x76, 0xBD, 0x97, 0xB9, 0xB1, 0x4D, 0x0A, 0x65, 0xC1, 0xFC,  /* ...9M.v....M.e.. */
+    0x71, 0xA0, 0xE0, 0x19, 0xCB, 0x08, 0xAF, 0x55, 0xE1, 0xF7, 0x29, 0x00, 0x5F, 0xBA, 0x7E, 0x3F,  /* q......U..)._.~? */
+    0xA5, 0xDC, 0x41, 0x89, 0x92, 0x38, 0xA2, 0x50, 0x76, 0x7A, 0x6D, 0x46, 0xDB, 0x97, 0x40, 0x64,  /* ..A..8.PvzmF..@d */
+    0x38, 0x6C, 0xD4, 0x56, 0x74, 0x35, 0x85, 0xF8, 0xE5, 0xD9, 0x0C, 0xC8, 0xB4, 0x00, 0x4B, 0x1F,  /* 8l.Vt5........K. */
+    0x6D, 0x86, 0x6C, 0x79, 0xCE, 0x05, 0x84, 0xE4, 0x96, 0x87, 0xFF, 0x61, 0xBC, 0x29, 0xAE, 0xA1,  /* m.ly.......a.).. */
+};
+/* Note that  Worked Example for Extended Access Control (EAC) Version 1.0
+ * contains a wrong key. The Log however contains a dump of the correct value
+ */
+static char tc_dh_shared_secret_k[] = {
+    0x6B, 0xAB, 0xC7, 0xB3, 0xA7, 0x2B, 0xCD, 0x7E, 0xA3, 0x85, 0xE4, 0xC6, 0x2D, 0xB2, 0x62, 0x5B,  /* k....+.~....-.b[ */
+    0xD8, 0x61, 0x3B, 0x24, 0x14, 0x9E, 0x14, 0x6A, 0x62, 0x93, 0x11, 0xC4, 0xCA, 0x66, 0x98, 0xE3,  /* .a;$...jb....f.. */
+    0x8B, 0x83, 0x4B, 0x6A, 0x9E, 0x9C, 0xD7, 0x18, 0x4B, 0xA8, 0x83, 0x4A, 0xFF, 0x50, 0x43, 0xD4,  /* ..Kj....K..J.PC. */
+    0x36, 0x95, 0x0C, 0x4C, 0x1E, 0x78, 0x32, 0x36, 0x7C, 0x10, 0xCB, 0x8C, 0x31, 0x4D, 0x40, 0xE5,  /* 6..L.x26|...1M@. */
+    0x99, 0x0B, 0x0D, 0xF7, 0x01, 0x3E, 0x64, 0xB4, 0x54, 0x9E, 0x22, 0x70, 0x92, 0x3D, 0x06, 0xF0,  /* .....>d.T."p.=.. */
+    0x8C, 0xFF, 0x6B, 0xD3, 0xE9, 0x77, 0xDD, 0xE6, 0xAB, 0xE4, 0xC3, 0x1D, 0x55, 0xC0, 0xFA, 0x2E,  /* ..k..w......U... */
+    0x46, 0x5E, 0x55, 0x3E, 0x77, 0xBD, 0xF7, 0x5E, 0x31, 0x93, 0xD3, 0x83, 0x4F, 0xC2, 0x6E, 0x8E,  /* F^U>w..^1...O.n. */
+    0xB1, 0xEE, 0x2F, 0xA1, 0xE4, 0xFC, 0x97, 0xC1, 0x8C, 0x3F, 0x6C, 0xFF, 0xFE, 0x26, 0x07, 0xFD,  /* ../......?l..&.. */
+};
+static char tc_dh_k_mac[] = {
+    0x80, 0x5A, 0x1D, 0x27, 0xD4, 0x5A, 0x51, 0x16, 0xF7, 0x3C, 0x54, 0x46, 0x94, 0x62, 0xB7, 0xD8,  /* .Z.'.ZQ..<TF.b.. */
+};
+static char tc_dh_k_enc[] = {
+    0x2F, 0x7F, 0x46, 0xAD, 0xCC, 0x9E, 0x7E, 0x52, 0x1B, 0x45, 0xD1, 0x92, 0xFA, 0xFA, 0x91, 0x26,  /* /.F...~R.E.....& */
+};
+static char tc_dh_authentication_token_picc[] = {
+    0x91, 0x7F, 0x37, 0xB5, 0xC0, 0xE6, 0xD8, 0xD1,                          /* ..7..... */
+};
+static char tc_dh_authentication_token_pcd[] = {
+    0xB4, 0x6D, 0xD9, 0xBD, 0x4D, 0x98, 0x38, 0x1F,                          /* .m..M.8. */
+};
+static char tc_dh_d1[] = {
+    0x83, 0x0F, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x43, 0x56, 0x43, 0x41,
+    0x30, 0x30, 0x30, 0x30, 0x33,
+};
+static char tc_dh_e1[] = {
+    0xB3, 0x7B, 0xB5, 0x7D, 0xA1, 0xDB, 0x37, 0xD1, 0xC4, 0x96, 0x04, 0x91,
+    0x7B, 0xD6, 0x99, 0xE6, 0x1D, 0x6A, 0x30, 0x74, 0xE6, 0x9E, 0x40, 0x67,
+    0xA1, 0xB3, 0x99, 0x03, 0x88, 0x23, 0x36, 0x33,
+};
+static const struct encryption_decryption tc_dh_enc_dec[] = {
+    {
+        1,
+        { sizeof tc_dh_d1, tc_dh_d1, sizeof tc_dh_d1, },
+        { sizeof tc_dh_e1, tc_dh_e1, sizeof tc_dh_e1, },
+    },
+};
+static char tc_dh_ad1[] = {
+    0x99, 0x02, 0x90, 0x00,
+};
+static char tc_dh_a1[] = {
+    0xEB, 0xFF, 0x08, 0xD3, 0xB2, 0x0A, 0x04, 0x14,
+};
+static const struct authenticate tc_dh_pace_authenticate[] = {
+    {
+        2,
+        { sizeof tc_dh_ad1, tc_dh_ad1, sizeof tc_dh_ad1, },
+        { sizeof tc_dh_a1, tc_dh_a1, sizeof tc_dh_a1, },
+    },
+};
+static char tc_dh_ca_picc_priv_key[] = {
+    0x00, 0xD0, 0xE5, 0xA9, 0x5E, 0xCA, 0x54, 0x1D, 0xEF, 0x4F, 0xE9, 0x2B, 0x9F, 0xF9, 0x92, 0x0D,  /* ....^.T..O.+.... */
+    0x49, 0xA4, 0x54, 0xC2, 0x97,                                                                    /* I.T.. */
+};
+static char tc_dh_ca_picc_pub_key[] = {
+    0x1B, 0x33, 0x45, 0xF8, 0xDC, 0x04, 0x34, 0x1B, 0xF8, 0xB2, 0xC9, 0x7F, 0x65, 0x2F, 0xA6, 0x80,  /* .3E...4.....e/.. */
+    0xE5, 0xD4, 0xFA, 0x4C, 0x14, 0x6A, 0xE4, 0xB8, 0x39, 0x43, 0x1A, 0x64, 0x4A, 0x79, 0xBC, 0x36,  /* ...L.j..9C.dJy.6 */
+    0x8C, 0x48, 0x22, 0xC8, 0x9C, 0xD0, 0x18, 0xA5, 0x7F, 0x95, 0x36, 0x44, 0xBE, 0xDA, 0x67, 0x9C,  /* .H".......6D..g. */
+    0x5B, 0x53, 0x29, 0x02, 0x32, 0x0E, 0x83, 0xE1, 0x3B, 0x80, 0xDE, 0xEF, 0x8C, 0x18, 0xAF, 0x3E,  /* [S).2...;......> */
+    0x7D, 0x49, 0x3A, 0xE3, 0xF8, 0x81, 0x96, 0x10, 0x1B, 0x9F, 0x78, 0xEA, 0xFE, 0x4B, 0x30, 0x25,  /* }I:.......x..K0% */
+    0xEF, 0x8B, 0xFF, 0x91, 0x6B, 0x2F, 0xC0, 0x2D, 0x76, 0x2D, 0x08, 0x38, 0xDE, 0xA2, 0x9C, 0x09,  /* ....k/.-v-.8.... */
+    0xB4, 0x85, 0x59, 0x1C, 0x2F, 0x47, 0xF8, 0x7C, 0x71, 0xF5, 0x30, 0xBB, 0x35, 0x8F, 0x56, 0xAF,  /* ..Y./G.|q.0.5.V. */
+    0x64, 0x59, 0xD8, 0x6D, 0xBF, 0x85, 0xEA, 0xF9, 0xED, 0xBD, 0x96, 0x2C, 0xD3, 0x64, 0xF7, 0xB8,  /* dY.m.......,.d.. */
+};
+static char tc_dh_ca_pcd_priv_key[] = {
+    0x00, 0xA2, 0xCF, 0xFD, 0x06, 0xC3, 0x4A, 0xFD, 0x62, 0x2E, 0xEE, 0x0F, 0xC3, 0x1F, 0x09, 0x3F,  /* ......J.b......? */
+    0xDF, 0xDA, 0x60, 0x9C, 0x67, 0x12, 0x1C, 0xAC, 0xF0, 0xA8, 0xF5, 0x22, 0x91, 0xDE, 0x68, 0x53,  /* ..`.g......"..hS */
+    0xBB, 0x5C, 0x93, 0xCF, 0x76, 0x70, 0x57, 0x75, 0xEC, 0xF4, 0x08, 0xA7, 0x43, 0x02, 0x61, 0x3B,  /* .\..vpWu....C.a; */
+    0xEE, 0xCB, 0x38, 0x14, 0x47, 0xD3, 0x64, 0x94, 0xC9, 0xE1, 0x89, 0x51, 0xEC, 0x17, 0x25, 0x2D,  /* ..8.G.d....Q..%- */
+    0xD2, 0xA8, 0x07, 0xAA, 0xE0, 0x9F, 0xA4, 0xDC, 0x30, 0x18, 0x33, 0x39, 0x01, 0x3D, 0x9C, 0x91,  /* ........0.39.=.. */
+    0x91, 0x30, 0x3C, 0xAC, 0xEE, 0x3C, 0x91, 0xE9, 0x26, 0xA3, 0x6D, 0x01, 0x4A, 0x5C, 0xFA, 0x94,  /* .0<..<..&.m.J\.. */
+    0x95, 0x0C, 0xAD, 0xB3, 0x7B, 0x53, 0x4F, 0x32, 0xA9, 0xBF, 0x76, 0xB3, 0x79, 0x80, 0x97, 0x93,  /* ....{SO2..v.y... */
+    0x04, 0xC5, 0x66, 0x38, 0x71, 0xBD, 0x74, 0x6E, 0xB9, 0xE9, 0x5A, 0x47, 0xCA, 0x47, 0x1B, 0x4E,  /* ..f8q.tn..ZG.G.N */
+    0xDE,                                                                                            /* . */
+};
+static char tc_dh_ca_pcd_pub_key[] = {
+    0xA2, 0x83, 0x09, 0x47, 0xA6, 0xFC, 0xAA, 0xCD, 0xE2, 0xFC, 0xB8, 0x8B, 0x29, 0xAB, 0x38, 0xE0,  /* ...G........).8. */
+    0x7C, 0x34, 0x53, 0xAB, 0xC4, 0xBC, 0xB4, 0x66, 0x08, 0x7E, 0x11, 0xC7, 0x9F, 0x32, 0xA1, 0x9E,  /* |4S....f.~...2.. */
+    0x6E, 0xF2, 0x2B, 0xE1, 0x08, 0xF8, 0xDD, 0x18, 0xFE, 0x82, 0x49, 0xC9, 0x60, 0x95, 0x15, 0x11,  /* n.+.......I.`... */
+    0x20, 0x0D, 0xC9, 0x85, 0xAA, 0x3E, 0xC0, 0xCC, 0xAD, 0x59, 0xA5, 0xF9, 0xBB, 0xCC, 0x33, 0xEE,  /* ....>...Y....3. */
+    0x5F, 0x15, 0x77, 0xE2, 0x03, 0x30, 0xB4, 0xDD, 0x10, 0xEB, 0x06, 0xB7, 0x40, 0x27, 0x7C, 0x97,  /* _.w..0......@'|. */
+    0xA1, 0x89, 0x18, 0x0E, 0xDE, 0x52, 0xBE, 0xE9, 0xD4, 0x29, 0xF1, 0x0F, 0xB7, 0x7F, 0x18, 0x0F,  /* .....R...)...... */
+    0x05, 0xD6, 0xA9, 0x9C, 0x49, 0x9C, 0xB5, 0xE1, 0xEC, 0xEE, 0xB8, 0xE9, 0x22, 0x84, 0xF6, 0x6E,  /* ....I......."..n */
+    0xA9, 0x84, 0x79, 0x67, 0x4C, 0xE7, 0x3F, 0x53, 0xC5, 0x67, 0xA0, 0x3B, 0x0D, 0x29, 0x78, 0x33,  /* ..ygL.?S.g.;.)x3 */
+};
+static char tc_dh_ca_nonce[] = {
+    0x1A, 0x1A, 0xC1, 0xAB, 0x04, 0xD9, 0x69, 0x65,                          /* ......ie */
+};
+static char tc_dh_ca_picc_token[] = {
+    0x75, 0x68, 0x91, 0x58, 0x0F, 0x70, 0x16, 0x4D,                          /* uh.X.p.M */
+};
+static char tc_dh_ca_shared_secret_k[] = {
+    0x2A, 0x4F, 0xC2, 0xD1, 0x14, 0x90, 0xDF, 0x47, 0x73, 0xDD, 0xFA, 0x6F, 0xF7, 0x05, 0x55, 0x7C,  /* *O.....Gs..o..U| */
+    0x51, 0xF4, 0xAD, 0x45, 0x33, 0xE8, 0xD8, 0xA6, 0x6A, 0x30, 0x01, 0xBF, 0xDD, 0x27, 0x1D, 0xB8,  /* Q..E3...j0...'.. */
+    0x7B, 0xE3, 0xC1, 0xCA, 0xC2, 0x2A, 0x05, 0xE8, 0xAF, 0x1A, 0x06, 0x6D, 0xD0, 0x29, 0x8E, 0x75,  /* {....*.....m.).u */
+    0xDB, 0x92, 0x8A, 0xAF, 0xDF, 0x00, 0xEB, 0x4B, 0xFB, 0x1B, 0xD1, 0x2F, 0x37, 0x23, 0x13, 0xC1,  /* .......K.../7#.. */
+    0xCA, 0x64, 0x90, 0x56, 0x51, 0x73, 0x05, 0x63, 0x85, 0x15, 0xD5, 0xA4, 0xFB, 0xE0, 0xAC, 0x59,  /* .d.VQs.c.......Y */
+    0xBD, 0xC8, 0x0E, 0x8C, 0x5A, 0x5F, 0x46, 0x25, 0x4D, 0x23, 0x19, 0x16, 0xEA, 0x77, 0xF8, 0x0A,  /* ....Z_F%M#...w.. */
+    0xC5, 0x8E, 0x6B, 0x63, 0xA2, 0x61, 0x98, 0xEE, 0x43, 0x87, 0xF1, 0x09, 0x81, 0xE8, 0xE4, 0x6F,  /* ..kc.a..C......o */
+    0xFB, 0xA2, 0x37, 0x90, 0xC8, 0x1E, 0x67, 0x93, 0x63, 0xC5, 0x89, 0x58, 0x7D, 0x30, 0xBB, 0xB3,  /* ..7...g.c..X}0.. */
+};
+static char tc_dh_ca_k_mac[] = {
+    0x06, 0x67, 0x21, 0xF3, 0xEB, 0xEA, 0x78, 0x7B, 0x4F, 0x1C, 0x6D, 0xCA, 0x43, 0x1E, 0xC2, 0x29,  /* .g!...x{O.m.C..) */
+};
+static char tc_dh_ca_k_enc[] = {
+    0xE8, 0x13, 0xD0, 0x9D, 0xF6, 0x9F, 0xFC, 0xC6, 0x37, 0x63, 0xC5, 0x37, 0xF8, 0x28, 0x98, 0x5C,  /* ........7c.7.(.\ */
+};
+static char tc_dh_ta_pcd_key[] = {
+    0x30, 0x82, 0x02, 0x76, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,  /* 0..v...0...*.H.. */
+    0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x02, 0x60, 0x30, 0x82, 0x02, 0x5c, 0x02, 0x01,  /* .........`0..\.. */
+    0x00, 0x02, 0x81, 0x81, 0x00, 0x9f, 0x7e, 0xf6, 0x8e, 0x15, 0x3d, 0xb4, 0xfd, 0x10, 0x84, 0xdd,  /* ......~...=..... */
+    0xed, 0xbe, 0xae, 0x84, 0x2c, 0x55, 0x6d, 0x41, 0x9f, 0xcb, 0x5e, 0xf6, 0x21, 0xaa, 0x37, 0x51,  /* ....,UmA..^.!.7Q */
+    0xf0, 0xfc, 0x0c, 0xfd, 0x71, 0x4f, 0xc0, 0xe7, 0x68, 0x86, 0x6b, 0x3f, 0x44, 0xe2, 0x72, 0x5a,  /* ....qO..h.k?D.rZ */
+    0xf0, 0x35, 0x1a, 0x97, 0xed, 0xb1, 0xba, 0x88, 0xdf, 0xdd, 0x9b, 0x4d, 0x81, 0xd4, 0x08, 0xfe,  /* .5.........M.... */
+    0x07, 0x63, 0x34, 0x6a, 0x77, 0x2c, 0xf6, 0x46, 0x16, 0x46, 0x5c, 0x8f, 0xd9, 0x71, 0xb7, 0x75,  /* .c4jw,.F.F\..q.u */
+    0xd2, 0xe1, 0x34, 0x26, 0xc5, 0xbc, 0x11, 0x89, 0x47, 0x95, 0xc5, 0xad, 0x2c, 0x3e, 0x42, 0x68,  /* ..4&....G...,>Bh */
+    0x37, 0xf3, 0xa1, 0x01, 0x9f, 0xe9, 0x51, 0x24, 0xea, 0x5d, 0x43, 0x3e, 0x90, 0x6d, 0x79, 0x93,  /* 7.....Q$.]C>.my. */
+    0x49, 0x63, 0x21, 0xef, 0xcb, 0xdb, 0xc3, 0x2d, 0x93, 0xc0, 0x68, 0x0b, 0x45, 0xf3, 0xb8, 0xf6,  /* Ic!....-..h.E... */
+    0x4a, 0x5d, 0xaf, 0xcf, 0xb9, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x81, 0x81, 0x00, 0x80, 0xcf,  /* J].............. */
+    0xe8, 0x4e, 0x4d, 0xe7, 0x5d, 0x41, 0xb8, 0xd2, 0xa5, 0xed, 0xf9, 0xbf, 0x36, 0x2e, 0x1b, 0xfc,  /* .NM.]A......6... */
+    0x36, 0x30, 0xd8, 0xed, 0xe3, 0xb8, 0xc2, 0xa1, 0x15, 0x03, 0x9c, 0x7c, 0xdd, 0x3f, 0x63, 0x5a,  /* 60.........|.?cZ */
+    0xf7, 0x49, 0x9a, 0xae, 0x09, 0x16, 0x18, 0x10, 0xa5, 0x53, 0x34, 0x80, 0x3a, 0xcd, 0x94, 0x69,  /* .I.......S4.:..i */
+    0x83, 0x5b, 0xd1, 0xbd, 0x38, 0xb6, 0xae, 0xc9, 0x68, 0x68, 0x0c, 0xfd, 0xeb, 0x30, 0xf8, 0x39,  /* .[..8...hh...0.9 */
+    0x3a, 0xc3, 0x9f, 0x3a, 0x98, 0xf5, 0x47, 0x80, 0xff, 0x15, 0x11, 0x93, 0xf6, 0x39, 0x80, 0xd3,  /* :..:..G......9.. */
+    0xef, 0x60, 0x6a, 0xb5, 0x98, 0x11, 0x0e, 0x7a, 0x44, 0xe9, 0xf0, 0x71, 0x71, 0xc7, 0xc5, 0xf1,  /* .`j....zD..qq... */
+    0x95, 0xfc, 0xc1, 0x84, 0xf5, 0x34, 0x5d, 0x0c, 0x2d, 0x09, 0xc9, 0x2f, 0x05, 0xbc, 0xc1, 0x1c,  /* .....4].-../.... */
+    0xa7, 0x09, 0x6e, 0x76, 0x52, 0x24, 0xc1, 0xfd, 0x3a, 0x4d, 0xd5, 0xc4, 0xc8, 0x25, 0x02, 0x41,  /* ..nvR$..:M...%.A */
+    0x00, 0xd1, 0xa6, 0x33, 0x59, 0xe8, 0x74, 0x23, 0xbb, 0xe5, 0x6e, 0x9b, 0x6b, 0xc9, 0x9a, 0x7d,  /* ...3Y.t#..n.k..} */
+    0x42, 0x73, 0xd3, 0xb1, 0xee, 0xd2, 0xba, 0x8e, 0x1a, 0xaa, 0xb2, 0xe1, 0x0f, 0x31, 0x93, 0xc3,  /* Bs...........1.. */
+    0xfc, 0x48, 0xa0, 0x6f, 0xfe, 0xfc, 0x4e, 0x48, 0x21, 0x90, 0xa2, 0xda, 0xc2, 0x10, 0xe4, 0x69,  /* .H.o..NH!......i */
+    0x19, 0xc5, 0x9b, 0x7c, 0xc1, 0xbe, 0xa4, 0xad, 0x05, 0xbd, 0xcd, 0xc5, 0x28, 0xe4, 0x95, 0xb4,  /* ...|........(... */
+    0x03, 0x02, 0x41, 0x00, 0xc2, 0xc2, 0x2b, 0x95, 0x1e, 0x07, 0x6a, 0x2f, 0xa9, 0xf6, 0x06, 0xf6,  /* ..A...+...j/.... */
+    0x6d, 0xb1, 0x5a, 0x65, 0xae, 0x78, 0xdb, 0x73, 0x8c, 0x04, 0x41, 0x1e, 0xd8, 0x78, 0xd0, 0x25,  /* m.Ze.x.s..A..x.% */
+    0xfa, 0xe3, 0xf0, 0x7b, 0xcc, 0x8f, 0xdb, 0x3d, 0x1c, 0x73, 0xa2, 0xe4, 0x7f, 0xb6, 0x00, 0x16,  /* ...{...=.s...... */
+    0x58, 0x64, 0xbc, 0xc6, 0x88, 0x28, 0x7e, 0x2c, 0xd8, 0xc6, 0x0a, 0x37, 0xda, 0x2a, 0xcd, 0x67,  /* Xd...(~,...7.*.g */
+    0x37, 0xab, 0x26, 0x93, 0x02, 0x40, 0x2f, 0x08, 0xb9, 0x76, 0x8f, 0x47, 0x17, 0x09, 0x3d, 0x84,  /* 7.&..@/..v.G..=. */
+    0xde, 0x0b, 0x85, 0x94, 0x4a, 0x4b, 0xd1, 0x4e, 0x8a, 0x19, 0xc9, 0x5f, 0x1f, 0x28, 0x6e, 0x69,  /* ....JK.N..._.(ni */
+    0x69, 0x42, 0x8e, 0x5d, 0xd7, 0x57, 0x4f, 0x37, 0xe7, 0x48, 0x6e, 0x74, 0x65, 0x8c, 0x5a, 0x35,  /* iB.].WO7.Hnte.Z5 */
+    0x9f, 0x1c, 0x70, 0xcb, 0xbd, 0xa4, 0x91, 0x87, 0xbb, 0xaa, 0x7f, 0xc9, 0xd4, 0x23, 0x78, 0x9c,  /* ..p..........#x. */
+    0xa4, 0x81, 0xf3, 0x1e, 0x7e, 0xdf, 0x02, 0x40, 0x46, 0x86, 0x71, 0xa9, 0xc9, 0xf9, 0xfd, 0x65,  /* ....~..@F.q....e */
+    0xcd, 0x32, 0x1e, 0x4b, 0x56, 0x65, 0x86, 0xca, 0x93, 0x67, 0x88, 0x70, 0x4b, 0x1f, 0xaf, 0x45,  /* .2.KVe...g.pK..E */
+    0x30, 0x36, 0x6f, 0x89, 0x91, 0x54, 0xc1, 0x5c, 0xd3, 0x32, 0xb4, 0xbd, 0x68, 0x74, 0x27, 0x64,  /* 06o..T.\.2..ht'd */
+    0x7f, 0x2a, 0xb4, 0xd5, 0x62, 0xa4, 0xf8, 0x07, 0x1c, 0x7f, 0x2d, 0x51, 0xa8, 0x1d, 0xee, 0xcd,  /* .*..b.....-Q.... */
+    0x52, 0xdf, 0x75, 0x0a, 0x0f, 0x8a, 0x96, 0xa9, 0x02, 0x40, 0x06, 0x3b, 0x7a, 0x95, 0x47, 0x78,  /* R.u......@.;z.Gx */
+    0x5a, 0x8c, 0x0b, 0x31, 0x89, 0x30, 0xd3, 0x6b, 0x81, 0xa4, 0xca, 0x86, 0x2c, 0xbb, 0x14, 0x7a,  /* Z..1.0.k....,..z */
+    0xfb, 0x36, 0x78, 0x02, 0xb7, 0xca, 0x6f, 0xf2, 0x89, 0xf3, 0xc9, 0x2b, 0x9e, 0xce, 0x05, 0x4c,  /* .6x...o....+...L */
+    0xa5, 0xa7, 0x78, 0x54, 0x2a, 0x06, 0xc9, 0xc2, 0x5b, 0xd4, 0xa8, 0xe3, 0x77, 0xdc, 0xb2, 0xab,  /* ..xT*...[...w... */
+    0xe5, 0xf4, 0x23, 0x7c, 0x4e, 0xe8, 0x03, 0x25, 0xa6, 0xf3,                                      /* ..#|N..%.. */
+};
+static char tc_dh_ta_nonce[] = {
+    0xFC, 0x21, 0x0C, 0x17, 0x4A, 0x80, 0x1D, 0x46,                          /* .!..J..F */
+};
+static char tc_dh_ta_pcd_signature[] = {
+    0x37, 0xC7, 0x36, 0x0C, 0x55, 0x57, 0x9D, 0xE2, 0x8A, 0x41, 0xDF, 0x8A, 0x1D, 0x17, 0x03, 0x2C,  /* 7.6.UW...A....., */
+    0x4B, 0x9F, 0x90, 0xDF, 0x7F, 0x64, 0x6D, 0xF3, 0x3F, 0x77, 0xEF, 0x97, 0x6A, 0xE4, 0xC4, 0x5C,  /* K....dm.?w..j..\ */
+    0xDB, 0xA3, 0x77, 0x63, 0x99, 0x64, 0x8C, 0x75, 0x50, 0x43, 0x79, 0x0F, 0x0F, 0x19, 0xBF, 0xC1,  /* ..wc.d.uPCy..... */
+    0x46, 0xD0, 0x53, 0xB7, 0x70, 0x36, 0xCA, 0x9B, 0x24, 0xBF, 0xB4, 0xB7, 0x93, 0x4F, 0xAC, 0x04,  /* F.S.p6..$....O.. */
+    0x26, 0x71, 0xE2, 0x3B, 0xE6, 0xE3, 0xCA, 0x2B, 0x24, 0x6C, 0xE2, 0x06, 0x6C, 0x1F, 0x05, 0x50,  /* &q.;...+$l..l..P */
+    0x38, 0x34, 0x18, 0x19, 0x2F, 0x06, 0xD6, 0xAD, 0x6C, 0x0A, 0xCB, 0x1E, 0x70, 0xBD, 0xEA, 0xD6,  /* 84../...l...p... */
+    0x0E, 0xA1, 0x0B, 0x31, 0xE0, 0x74, 0xF4, 0x9E, 0x5E, 0x8A, 0xEB, 0x54, 0xE6, 0xF4, 0xF8, 0x3C,  /* ...1.t..^..T...< */
+    0xE9, 0x98, 0x95, 0x79, 0x53, 0xF9, 0x7F, 0x87, 0x00, 0x58, 0x01, 0x3D, 0x0E, 0x74, 0x5D, 0x0A,  /* ...yS....X.=.t]. */
+};
+static char tc_dh_ta_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x6a, 0x7f, 0x4e, 0x81, 0xe2, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0d, 0x44,  /* .!..j.N.._)..B.D */
+    0x45, 0x54, 0x45, 0x53, 0x54, 0x44, 0x56, 0x44, 0x45, 0x30, 0x31, 0x39, 0x7f, 0x49, 0x81, 0x94,  /* ETESTDVDE019.I.. */
+    0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x01, 0x01, 0x81, 0x81, 0x80, 0x9f,  /* ................ */
+    0x7e, 0xf6, 0x8e, 0x15, 0x3d, 0xb4, 0xfd, 0x10, 0x84, 0xdd, 0xed, 0xbe, 0xae, 0x84, 0x2c, 0x55,  /* ~...=.........,U */
+    0x6d, 0x41, 0x9f, 0xcb, 0x5e, 0xf6, 0x21, 0xaa, 0x37, 0x51, 0xf0, 0xfc, 0x0c, 0xfd, 0x71, 0x4f,  /* mA..^.!.7Q....qO */
+    0xc0, 0xe7, 0x68, 0x86, 0x6b, 0x3f, 0x44, 0xe2, 0x72, 0x5a, 0xf0, 0x35, 0x1a, 0x97, 0xed, 0xb1,  /* ..h.k?D.rZ.5.... */
+    0xba, 0x88, 0xdf, 0xdd, 0x9b, 0x4d, 0x81, 0xd4, 0x08, 0xfe, 0x07, 0x63, 0x34, 0x6a, 0x77, 0x2c,  /* .....M.....c4jw, */
+    0xf6, 0x46, 0x16, 0x46, 0x5c, 0x8f, 0xd9, 0x71, 0xb7, 0x75, 0xd2, 0xe1, 0x34, 0x26, 0xc5, 0xbc,  /* .F.F\..q.u..4&.. */
+    0x11, 0x89, 0x47, 0x95, 0xc5, 0xad, 0x2c, 0x3e, 0x42, 0x68, 0x37, 0xf3, 0xa1, 0x01, 0x9f, 0xe9,  /* ..G...,>Bh7..... */
+    0x51, 0x24, 0xea, 0x5d, 0x43, 0x3e, 0x90, 0x6d, 0x79, 0x93, 0x49, 0x63, 0x21, 0xef, 0xcb, 0xdb,  /* Q$.]C>.my.Ic!... */
+    0xc3, 0x2d, 0x93, 0xc0, 0x68, 0x0b, 0x45, 0xf3, 0xb8, 0xf6, 0x4a, 0x5d, 0xaf, 0xcf, 0xb9, 0x82,  /* .-..h.E...J].... */
+    0x03, 0x01, 0x00, 0x01, 0x5f, 0x20, 0x0d, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x41, 0x54, 0x44,  /* ...._ .DETESTATD */
+    0x45, 0x30, 0x31, 0x39, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01,  /* E019.L.......... */
+    0x02, 0x02, 0x53, 0x05, 0x00, 0x00, 0x00, 0x01, 0x10, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x03,  /* ..S......_%..... */
+    0x02, 0x04, 0x5f, 0x24, 0x06, 0x01, 0x00, 0x00, 0x04, 0x02, 0x04, 0x5f, 0x37, 0x81, 0x80, 0x8c,  /* .._$......._7... */
+    0xb1, 0x61, 0x26, 0xa1, 0xfd, 0xbb, 0x82, 0x48, 0xc8, 0x8b, 0xdb, 0x1f, 0xb1, 0x19, 0x9c, 0x3f,  /* .a&....H.......? */
+    0x25, 0x38, 0x56, 0xfe, 0x10, 0x83, 0x5f, 0x7b, 0xff, 0x62, 0xa3, 0x0b, 0xd2, 0x81, 0xb8, 0xa1,  /* %8V..._{.b...... */
+    0xf0, 0xfe, 0x03, 0x81, 0xa5, 0xb0, 0xa4, 0x26, 0x51, 0xf7, 0x7d, 0xf7, 0x21, 0x52, 0x21, 0xf0,  /* .......&Q.}.!R!. */
+    0xed, 0xe4, 0x88, 0xe6, 0x89, 0xea, 0x45, 0xce, 0xe2, 0x0b, 0x19, 0xc7, 0xb1, 0xd1, 0xed, 0xb6,  /* ......E......... */
+    0xac, 0x21, 0xf3, 0x40, 0x88, 0x81, 0x9f, 0x6f, 0xd5, 0xdc, 0x33, 0x31, 0x09, 0xe1, 0x5a, 0x15,  /* .!.@...o..31..Z. */
+    0xdf, 0xf6, 0x85, 0xa2, 0xb6, 0x9d, 0x17, 0xd5, 0xe2, 0x3d, 0xaf, 0xe3, 0x63, 0xa8, 0xe7, 0x63,  /* .........=..c..c */
+    0x31, 0xcc, 0x25, 0xb9, 0x13, 0xfb, 0x6e, 0xd8, 0x30, 0xeb, 0x45, 0x7a, 0xd0, 0xa6, 0x73, 0x96,  /* 1.%...n.0.Ez..s. */
+    0xa1, 0x90, 0xca, 0xe3, 0x9c, 0xc6, 0xc2, 0xe4, 0x67, 0x1e, 0x60, 0x52, 0xd3, 0xc2, 0x2d,        /* ........g.`R..- */
+};
+static char tc_dh_cvca[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x6a, 0x7f, 0x4e, 0x81, 0xe2, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0f, 0x44,  /* .!..j.N.._)..B.D */
+    0x45, 0x54, 0x45, 0x53, 0x54, 0x43, 0x56, 0x43, 0x41, 0x30, 0x30, 0x30, 0x30, 0x33, 0x7f, 0x49,  /* ETESTCVCA00003.I */
+    0x81, 0x94, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x01, 0x01, 0x81, 0x81,  /* ................ */
+    0x80, 0xb5, 0xad, 0xa4, 0x40, 0xf2, 0x64, 0x80, 0x3d, 0xbe, 0xec, 0x57, 0xab, 0x1f, 0xfb, 0xd1,  /* ....@.d.=..W.... */
+    0x2b, 0x42, 0x68, 0x74, 0x23, 0xec, 0x29, 0x9d, 0xd5, 0x2a, 0x6b, 0xb0, 0x34, 0x51, 0x93, 0xd1,  /* +Bht#.)..*k.4Q.. */
+    0xe2, 0xa5, 0xbb, 0xc1, 0x19, 0x55, 0x90, 0x8a, 0x08, 0x76, 0x0f, 0x40, 0x0f, 0xa0, 0x3d, 0x56,  /* .....U...v.@..=V */
+    0x09, 0x7b, 0x5f, 0x21, 0x65, 0x64, 0x8d, 0x85, 0x07, 0x1a, 0x80, 0xa1, 0xb6, 0x6f, 0xfa, 0x93,  /* .{_!ed.......o.. */
+    0x21, 0x52, 0x6d, 0xda, 0x41, 0xe1, 0x46, 0xd5, 0x32, 0x99, 0x1c, 0xa0, 0xc1, 0xdc, 0xfc, 0x8d,  /* !Rm.A.F.2....... */
+    0x0b, 0xbe, 0x29, 0x8c, 0x1f, 0x0e, 0xdb, 0x57, 0x40, 0x0f, 0xae, 0xd6, 0x7e, 0x13, 0x5d, 0x54,  /* ..)....W@...~.]T */
+    0x24, 0x71, 0xc8, 0x2e, 0x35, 0x1b, 0x06, 0xd4, 0x3c, 0x94, 0x66, 0x04, 0xfc, 0xbd, 0x50, 0x45,  /* $q..5...<.f...PE */
+    0x05, 0x6c, 0x4b, 0x8a, 0x7b, 0x98, 0xec, 0x38, 0x72, 0xe4, 0x1b, 0xb3, 0xd7, 0xa5, 0x91, 0xcc,  /* .lK.{..8r....... */
+    0xad, 0x82, 0x03, 0x01, 0x00, 0x01, 0x5f, 0x20, 0x0f, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x43,  /* ......_ .DETESTC */
+    0x56, 0x43, 0x41, 0x30, 0x30, 0x30, 0x30, 0x33, 0x7f, 0x4c, 0x0e, 0x06, 0x09, 0x04, 0x00, 0x7f,  /* VCA00003.L...... */
+    0x00, 0x07, 0x03, 0x01, 0x02, 0x01, 0x53, 0x01, 0xc3, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x03,  /* ......S.._%..... */
+    0x02, 0x04, 0x5f, 0x24, 0x06, 0x01, 0x01, 0x00, 0x03, 0x01, 0x09, 0x5f, 0x37, 0x81, 0x80, 0xa2,  /* .._$......._7... */
+    0x7e, 0xd8, 0x30, 0xe9, 0x90, 0x82, 0xe5, 0x81, 0x30, 0x68, 0xb9, 0xb2, 0x16, 0x62, 0x44, 0x4e,  /* ~.0.....0h...bDN */
+    0xd1, 0xc8, 0x71, 0x3a, 0xba, 0x71, 0x98, 0x5b, 0x52, 0x88, 0xf3, 0x76, 0x42, 0x36, 0x08, 0xb8,  /* ..q:.q.[R..vB6.. */
+    0xee, 0xc8, 0x25, 0x17, 0x38, 0x62, 0xf8, 0xdf, 0x9f, 0x25, 0x9b, 0xcd, 0x61, 0x1c, 0x96, 0xa2,  /* ..%.8b...%..a... */
+    0xdb, 0xa8, 0x6a, 0xc6, 0xc4, 0x8a, 0x33, 0x10, 0xcf, 0xd6, 0xfa, 0xde, 0x9b, 0x4b, 0xd0, 0x2b,  /* ..j...3......K.+ */
+    0xb5, 0x20, 0x36, 0x7a, 0xd9, 0x0b, 0x37, 0x9f, 0x6d, 0x35, 0xad, 0x01, 0xd4, 0x06, 0xf8, 0xcb,  /* . 6z..7.m5...... */
+    0x1d, 0x94, 0xd0, 0x25, 0x73, 0x0a, 0x98, 0xd7, 0xdf, 0xbe, 0x3b, 0x0f, 0x74, 0x18, 0x35, 0x31,  /* ...%s.....;.t.51 */
+    0xde, 0x6e, 0x69, 0x9d, 0x23, 0x65, 0x2c, 0xe3, 0x90, 0x67, 0x63, 0x5a, 0x8d, 0x17, 0x6c, 0x66,  /* .ni.#e,..gcZ..lf */
+    0x06, 0x4b, 0x79, 0xb7, 0x27, 0x1a, 0x0e, 0xe6, 0x00, 0xba, 0xc9, 0x4a, 0xd5, 0x1e, 0x4f,        /* .Ky.'......J..O */
+};
+static char tc_dh_dv_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x6c, 0x7f, 0x4e, 0x81, 0xe4, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0f, 0x44,  /* .!..l.N.._)..B.D */
+    0x45, 0x54, 0x45, 0x53, 0x54, 0x43, 0x56, 0x43, 0x41, 0x30, 0x30, 0x30, 0x30, 0x33, 0x7f, 0x49,  /* ETESTCVCA00003.I */
+    0x81, 0x94, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x01, 0x01, 0x81, 0x81,  /* ................ */
+    0x80, 0xa0, 0x8c, 0x4d, 0x11, 0xd6, 0x99, 0xf4, 0x25, 0xb0, 0xe7, 0x43, 0xbb, 0xa4, 0xf2, 0x19,  /* ...M....%..C.... */
+    0x6e, 0x05, 0xbc, 0x9e, 0xf2, 0x4f, 0x53, 0xa6, 0x74, 0x42, 0x90, 0xe6, 0x55, 0x6e, 0x83, 0xe9,  /* n....OS.tB..Un.. */
+    0x05, 0x77, 0xa9, 0x30, 0xec, 0x31, 0x4a, 0x4f, 0x9f, 0x03, 0x33, 0xa0, 0xa0, 0x19, 0x93, 0x11,  /* .w.0.1JO..3..... */
+    0x0e, 0xc6, 0x34, 0x86, 0xdf, 0x60, 0x7f, 0xd7, 0xb3, 0x04, 0x74, 0x79, 0xb0, 0xec, 0x09, 0x04,  /* ..4..`....ty.... */
+    0xac, 0xf8, 0xb6, 0x26, 0x5c, 0xd0, 0xab, 0xc3, 0x53, 0x8f, 0x4d, 0x72, 0x39, 0x5d, 0xd5, 0xf1,  /* ...&\...S.Mr9].. */
+    0xe7, 0xa1, 0x08, 0x18, 0xa7, 0xfa, 0xa0, 0x1d, 0x25, 0xff, 0x25, 0xbc, 0x6b, 0xf1, 0x9c, 0xe8,  /* ........%.%.k... */
+    0x6a, 0x20, 0x82, 0x33, 0xc5, 0x43, 0x7f, 0xf9, 0x90, 0xfe, 0x94, 0xd1, 0xc2, 0x5d, 0x59, 0xbe,  /* j .3.C.......]Y. */
+    0xdb, 0x6a, 0xe7, 0x9e, 0x4a, 0x76, 0xde, 0x22, 0x79, 0xfc, 0xd6, 0xa5, 0xa3, 0xd6, 0x6f, 0xf5,  /* .j..Jv."y.....o. */
+    0xf9, 0x82, 0x03, 0x01, 0x00, 0x01, 0x5f, 0x20, 0x0d, 0x44, 0x45, 0x54, 0x45, 0x53, 0x54, 0x44,  /* ......_ .DETESTD */
+    0x56, 0x44, 0x45, 0x30, 0x31, 0x39, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07,  /* VDE019.L........ */
+    0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x80, 0x1f, 0xff, 0xff, 0x10, 0x5f, 0x25, 0x06, 0x01, 0x00,  /* ....S......_%... */
+    0x00, 0x03, 0x02, 0x04, 0x5f, 0x24, 0x06, 0x01, 0x00, 0x00, 0x04, 0x02, 0x04, 0x5f, 0x37, 0x81,  /* ...._$......._7. */
+    0x80, 0x6b, 0x95, 0x0f, 0x1f, 0xa8, 0xfe, 0xf8, 0x61, 0xee, 0xa7, 0x57, 0x65, 0xc2, 0x80, 0x5d,  /* .k......a..We..] */
+    0x79, 0xbb, 0x5d, 0x0d, 0x60, 0x87, 0x8e, 0x93, 0x0a, 0x8c, 0x17, 0xd3, 0xf9, 0x2d, 0xcc, 0x2b,  /* y.].`........-.+ */
+    0xe9, 0x54, 0x7d, 0x31, 0xe4, 0x12, 0x6b, 0x75, 0x10, 0xc3, 0x59, 0x27, 0xe8, 0x24, 0xbd, 0x0c,  /* .T}1..ku..Y'.$.. */
+    0x64, 0xdc, 0x33, 0x96, 0xf5, 0x39, 0x2a, 0xac, 0xf6, 0xf6, 0x49, 0x9f, 0x1d, 0x88, 0xca, 0xfa,  /* d.3..9*...I..... */
+    0xd9, 0x4c, 0xa6, 0x16, 0x24, 0xb6, 0x63, 0x7c, 0x75, 0x1b, 0xd0, 0x35, 0xfc, 0x08, 0x4b, 0xb8,  /* .L..$.c|u..5..K. */
+    0x9f, 0x50, 0xa9, 0x00, 0xec, 0xc1, 0x80, 0x71, 0x25, 0x8b, 0x31, 0x6b, 0xdf, 0x3a, 0xf9, 0xd6,  /* .P.....q%.1k.:.. */
+    0x10, 0x92, 0xa1, 0x50, 0x05, 0x64, 0x29, 0xe0, 0x2d, 0x1a, 0x70, 0xdf, 0xc1, 0x1e, 0x77, 0xd0,  /* ...P.d).-.p...w. */
+    0xfb, 0xba, 0x00, 0xcb, 0x70, 0x0a, 0x63, 0x20, 0x98, 0x05, 0x96, 0x8d, 0xbd, 0x17, 0xd3, 0x6e,  /* ....p.c .......n */
+    0x75,                                                                                            /* u */
+};
+
+static struct eac_worked_example eac_examples[] = {
+    {   /* EAC worked example - ECDH */
+        /* ef_cardaccess */
+        { sizeof tc_ecdh_ef_cardaccess, tc_ecdh_ef_cardaccess, sizeof tc_ecdh_ef_cardaccess, },
+        /* pace_info_oid */
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128,
+        /* pace_version */
+        2,
+        /* pace_curve */
+        0x0D,
+        /* password */
+        "123456",
+        /* password_type */
+        PACE_PIN,
+        /* pace_nonce */
+        { sizeof tc_ecdh_nonce, tc_ecdh_nonce, sizeof tc_ecdh_nonce, },
+        /* pace_enc_nonce */
+        { sizeof tc_ecdh_nonce_enc, tc_ecdh_nonce_enc, sizeof tc_ecdh_nonce_enc, },
+        /* pace_static_pcd_priv_key */
+        { sizeof tc_ecdh_map_pcd_priv_key, tc_ecdh_map_pcd_priv_key, sizeof tc_ecdh_map_pcd_priv_key, },
+        /* pace_static_pcd_pub_key */
+        { sizeof tc_ecdh_map_pcd_pub_key, tc_ecdh_map_pcd_pub_key, sizeof tc_ecdh_map_pcd_pub_key, },
+        /* pace_static_picc_priv_key */
+        { sizeof tc_ecdh_map_picc_priv_key, tc_ecdh_map_picc_priv_key, sizeof tc_ecdh_map_picc_priv_key, },
+        /* pace_static_picc_pub_key */
+        { sizeof tc_ecdh_map_picc_pub_key, tc_ecdh_map_picc_pub_key, sizeof tc_ecdh_map_picc_pub_key, },
+        /* pace_shared_secret_h */
+        { sizeof tc_ecdh_map_shared_secret_h, tc_ecdh_map_shared_secret_h, sizeof tc_ecdh_map_shared_secret_h, },
+        /* pace_eph_generator */
+        { sizeof tc_ecdh_map_generator, tc_ecdh_map_generator, sizeof tc_ecdh_map_generator, },
+        /* pace_eph_pcd_priv_key */
+        { sizeof tc_ecdh_pcd_priv_key, tc_ecdh_pcd_priv_key, sizeof tc_ecdh_pcd_priv_key, },
+        /* pace_eph_pcd_pub_key */
+        { sizeof tc_ecdh_pcd_pub_key, tc_ecdh_pcd_pub_key, sizeof tc_ecdh_pcd_pub_key, },
+        /* pace_eph_picc_priv_key */
+        { sizeof tc_ecdh_picc_priv_key, tc_ecdh_picc_priv_key, sizeof tc_ecdh_picc_priv_key, },
+        /* pace_eph_picc_pub_key */
+        { sizeof tc_ecdh_picc_pub_key, tc_ecdh_picc_pub_key, sizeof tc_ecdh_picc_pub_key, },
+        /* pace_shared_secret_k */
+        { sizeof tc_ecdh_shared_secret_k, tc_ecdh_shared_secret_k, sizeof tc_ecdh_shared_secret_k, },
+        /* pace_k_mac */
+        { sizeof tc_ecdh_k_mac, tc_ecdh_k_mac, sizeof tc_ecdh_k_mac, },
+        /* pace_k_enc */
+        { sizeof tc_ecdh_k_enc, tc_ecdh_k_enc, sizeof tc_ecdh_k_enc, },
+        /* pace_authentication_token_picc */
+        { sizeof tc_ecdh_authentication_token_picc, tc_ecdh_authentication_token_picc, sizeof tc_ecdh_authentication_token_picc, },
+        /* pace_authentication_token_pcd */
+        { sizeof tc_ecdh_authentication_token_pcd, tc_ecdh_authentication_token_pcd, sizeof tc_ecdh_authentication_token_pcd, },
+        /* pace_encrypt_decrypt */
+        tc_ecdh_enc_dec,
+        /* pace_encrypt_decrypt_len */
+        (sizeof tc_ecdh_enc_dec)/sizeof *tc_ecdh_enc_dec,
+        /* pace_authenticate */
+        tc_ecdh_pace_authenticate,
+        /* pace_authenticate_len */
+        (sizeof tc_ecdh_pace_authenticate)/sizeof *tc_ecdh_pace_authenticate,
+        /* ca_curve */
+        0x0D,
+        /* ca_version */
+        2,
+        /* ca_info_oid */
+        NID_id_CA_ECDH_AES_CBC_CMAC_128,
+        /* ca_picc_priv_key */
+        { sizeof tc_ecdh_ca_picc_priv_key, tc_ecdh_ca_picc_priv_key, sizeof tc_ecdh_ca_picc_priv_key, },
+        /* ca_picc_pub_key */
+        { sizeof tc_ecdh_ca_picc_pub_key, tc_ecdh_ca_picc_pub_key, sizeof tc_ecdh_ca_picc_pub_key, },
+        /* ca_pcd_priv_key */
+        { sizeof tc_ecdh_ca_pcd_priv_key, tc_ecdh_ca_pcd_priv_key, sizeof tc_ecdh_ca_pcd_priv_key, },
+        /* ca_pcd_pub_key */
+        { sizeof tc_ecdh_ca_pcd_pub_key, tc_ecdh_ca_pcd_pub_key, sizeof tc_ecdh_ca_pcd_pub_key, },
+        /* ca_nonce */
+        { sizeof tc_ecdh_ca_nonce, tc_ecdh_ca_nonce, sizeof tc_ecdh_ca_nonce, },
+        /* ca_picc_token */
+        { sizeof tc_ecdh_ca_picc_token, tc_ecdh_ca_picc_token, sizeof tc_ecdh_ca_picc_token, },
+        /* ca_shared_secret_k */
+        { sizeof tc_ecdh_ca_shared_secret_k, tc_ecdh_ca_shared_secret_k, sizeof tc_ecdh_ca_shared_secret_k, },
+        /* ca_k_mac */
+        { sizeof tc_ecdh_ca_k_mac, tc_ecdh_ca_k_mac, sizeof tc_ecdh_ca_k_mac, },
+        /* ca_k_enc */
+        { sizeof tc_ecdh_ca_k_enc, tc_ecdh_ca_k_enc, sizeof tc_ecdh_ca_k_enc, },
+        /* ta_curve */
+        13,
+        /* ta_pcd_key */
+        { sizeof tc_ecdh_ta_pcd_key, tc_ecdh_ta_pcd_key, sizeof tc_ecdh_ta_pcd_key, },
+        /* ta_nonce */
+        { sizeof tc_ecdh_ta_nonce, tc_ecdh_ta_nonce, sizeof tc_ecdh_ta_nonce, },
+        /* ta_auxdata */
+        { 0, NULL, 0, },
+        /* ta_pcd_signature */
+        { sizeof tc_ecdh_ta_pcd_signature, tc_ecdh_ta_pcd_signature, sizeof tc_ecdh_ta_pcd_signature, },
+        /* ta_cert */
+        { sizeof tc_ecdh_ta_cert, tc_ecdh_ta_cert, sizeof tc_ecdh_ta_cert, },
+        /* ta_cvca */
+        { sizeof tc_ecdh_cvca_cert, tc_ecdh_cvca_cert, sizeof tc_ecdh_cvca_cert, },
+        /* ta_dv_cert */
+        { sizeof tc_ecdh_dv_cert, tc_ecdh_dv_cert, sizeof tc_ecdh_dv_cert, },
+    },
+    {   /* EAC worked example - DH */
+        /* ef_cardaccess */
+        { sizeof tc_dh_ef_cardaccess, tc_dh_ef_cardaccess, sizeof tc_dh_ef_cardaccess, },
+        /* pace_info_oid */
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_128,
+        /* pace_version */
+        2,
+        /* pace_curve */
+        0x00,
+        /* password */
+        "123456",
+        /* password_type */
+        PACE_PIN,
+        /* pace_nonce */
+        { sizeof tc_dh_nonce, tc_dh_nonce, sizeof tc_dh_nonce, },
+        /* pace_enc_nonce */
+        { sizeof tc_dh_nonce_enc, tc_dh_nonce_enc, sizeof tc_dh_nonce_enc, },
+        /* pace_static_pcd_priv_key */
+        { sizeof tc_dh_map_pcd_priv_key, tc_dh_map_pcd_priv_key, sizeof tc_dh_map_pcd_priv_key, },
+        /* pace_static_pcd_pub_key */
+        { sizeof tc_dh_map_pcd_pub_key, tc_dh_map_pcd_pub_key, sizeof tc_dh_map_pcd_pub_key, },
+        /* pace_static_picc_priv_key */
+        { sizeof tc_dh_map_picc_priv_key, tc_dh_map_picc_priv_key, sizeof tc_dh_map_picc_priv_key, },
+        /* pace_static_picc_pub_key */
+        { sizeof tc_dh_map_picc_pub_key, tc_dh_map_picc_pub_key, sizeof tc_dh_map_picc_pub_key, },
+        /* pace_shared_secret_h */
+        { sizeof tc_dh_map_shared_secret_h, tc_dh_map_shared_secret_h, sizeof tc_dh_map_shared_secret_h, },
+        /* pace_eph_generator */
+        { sizeof tc_dh_map_generator, tc_dh_map_generator, sizeof tc_dh_map_generator, },
+        /* pace_eph_pcd_priv_key */
+        { sizeof tc_dh_pcd_priv_key, tc_dh_pcd_priv_key, sizeof tc_dh_pcd_priv_key, },
+        /* pace_eph_pcd_pub_key */
+        { sizeof tc_dh_pcd_pub_key, tc_dh_pcd_pub_key, sizeof tc_dh_pcd_pub_key, },
+        /* pace_eph_picc_priv_key */
+        { sizeof tc_dh_picc_priv_key, tc_dh_picc_priv_key, sizeof tc_dh_picc_priv_key, },
+        /* pace_eph_picc_pub_key */
+        { sizeof tc_dh_picc_pub_key, tc_dh_picc_pub_key, sizeof tc_dh_picc_pub_key, },
+        /* pace_shared_secret_k */
+        { sizeof tc_dh_shared_secret_k, tc_dh_shared_secret_k, sizeof tc_dh_shared_secret_k, },
+        /* pace_k_mac */
+        { sizeof tc_dh_k_mac, tc_dh_k_mac, sizeof tc_dh_k_mac, },
+        /* pace_k_enc */
+        { sizeof tc_dh_k_enc, tc_dh_k_enc, sizeof tc_dh_k_enc, },
+        /* pace_authentication_token_picc */
+        { sizeof tc_dh_authentication_token_picc, tc_dh_authentication_token_picc, sizeof tc_dh_authentication_token_picc, },
+        /* pace_authentication_token_pcd */
+        { sizeof tc_dh_authentication_token_pcd, tc_dh_authentication_token_pcd, sizeof tc_dh_authentication_token_pcd, },
+        /* pace_encrypt_decrypt */
+        tc_dh_enc_dec,
+        /* pace_encrypt_decrypt_len */
+        (sizeof tc_dh_enc_dec)/sizeof *tc_dh_enc_dec,
+        /* pace_authenticate */
+        tc_dh_pace_authenticate,
+        /* pace_authenticate_len */
+        (sizeof tc_dh_pace_authenticate)/sizeof *tc_dh_pace_authenticate,
+        /* ca_curve */
+        0x00,
+        /* ca_version */
+        2,
+        /* ca_info_oid */
+        NID_id_CA_DH_AES_CBC_CMAC_128,
+        /* ca_picc_priv_key */
+        { sizeof tc_dh_ca_picc_priv_key, tc_dh_ca_picc_priv_key, sizeof tc_dh_ca_picc_priv_key, },
+        /* ca_picc_pub_key */
+        { sizeof tc_dh_ca_picc_pub_key, tc_dh_ca_picc_pub_key, sizeof tc_dh_ca_picc_pub_key, },
+        /* ca_pcd_priv_key */
+        { sizeof tc_dh_ca_pcd_priv_key, tc_dh_ca_pcd_priv_key, sizeof tc_dh_ca_pcd_priv_key, },
+        /* ca_pcd_pub_key */
+        { sizeof tc_dh_ca_pcd_pub_key, tc_dh_ca_pcd_pub_key, sizeof tc_dh_ca_pcd_pub_key, },
+        /* ca_nonce */
+        { sizeof tc_dh_ca_nonce, tc_dh_ca_nonce, sizeof tc_dh_ca_nonce, },
+        /* ca_picc_token */
+        { sizeof tc_dh_ca_picc_token, tc_dh_ca_picc_token, sizeof tc_dh_ca_picc_token, },
+        /* ca_shared_secret_k */
+        { sizeof tc_dh_ca_shared_secret_k, tc_dh_ca_shared_secret_k, sizeof tc_dh_ca_shared_secret_k, },
+        /* ca_k_mac */
+        { sizeof tc_dh_ca_k_mac, tc_dh_ca_k_mac, sizeof tc_dh_ca_k_mac, },
+        /* ca_k_enc */
+        { sizeof tc_dh_ca_k_enc, tc_dh_ca_k_enc, sizeof tc_dh_ca_k_enc, },
+        /* ta_curve */
+        0,
+        /* ta_pcd_key */
+        { sizeof tc_dh_ta_pcd_key, tc_dh_ta_pcd_key, sizeof tc_dh_ta_pcd_key, },
+        /* ta_nonce */
+        { sizeof tc_dh_ta_nonce, tc_dh_ta_nonce, sizeof tc_dh_ta_nonce, },
+        /* ta_auxdata */
+        { 0, NULL, 0, },
+        /* ta_pcd_signature */
+        { sizeof tc_dh_ta_pcd_signature, tc_dh_ta_pcd_signature, sizeof tc_dh_ta_pcd_signature, },
+        /* ta_cert */
+        { sizeof tc_dh_ta_cert, tc_dh_ta_cert, sizeof tc_dh_ta_cert, },
+        /* ta_cvca */
+        { sizeof tc_dh_cvca, tc_dh_cvca, sizeof tc_dh_cvca, },
+        /* ta_dv_cert */
+        { sizeof tc_dh_dv_cert, tc_dh_dv_cert, sizeof tc_dh_dv_cert, },
+    },
+};
+
+static const unsigned char ef_cardaccess_old_testcard[] = {
+    0x31, 0x82, 0x02, 0x64, 0x30, 0x0d, 0x06, 0x08, 0x04, 0x00, 0x7f,
+    0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0f, 0x06,
+    0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x02,
+    0x02, 0x01, 0x02, 0x30, 0x0f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00,
+    0x07, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x30, 0x2f,
+    0x06, 0x08, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x06, 0x16,
+    0x23, 0x41, 0x77, 0x54, 0x20, 0x65, 0x50, 0x41, 0x20, 0x2d, 0x20,
+    0x42, 0x44, 0x72, 0x20, 0x47, 0x6d, 0x62, 0x48, 0x20, 0x2d, 0x20,
+    0x54, 0x65, 0x73, 0x74, 0x6b, 0x61, 0x72, 0x74, 0x65, 0x20, 0x76,
+    0x31, 0x2e, 0x30, 0x30, 0x81, 0xfe, 0x06, 0x09, 0x04, 0x00, 0x7f,
+    0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x81, 0xf0, 0x06, 0x0b,
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x01, 0x01, 0x05, 0x02, 0x02, 0x02,
+    0x30, 0x81, 0xe0, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a,
+    0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xa9, 0xfb,
+    0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d,
+    0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28,
+    0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x77, 0x30, 0x44, 0x04,
+    0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66,
+    0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23, 0xd5,
+    0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x74,
+    0x04, 0x20, 0x66, 0x2c, 0x61, 0xc4, 0x30, 0xd8, 0x4e, 0xa4, 0xfe,
+    0x66, 0xa7, 0x73, 0x3d, 0x0b, 0x76, 0xb7, 0xbf, 0x93, 0xeb, 0xc4,
+    0xaf, 0x2f, 0x49, 0x25, 0x6a, 0xe5, 0x81, 0x01, 0xfe, 0xe9, 0x2b,
+    0x04, 0x04, 0x41, 0x04, 0xa3, 0xe8, 0xeb, 0x3c, 0xc1, 0xcf, 0xe7,
+    0xb7, 0x73, 0x22, 0x13, 0xb2, 0x3a, 0x65, 0x61, 0x49, 0xaf, 0xa1,
+    0x42, 0xc4, 0x7a, 0xaf, 0xbc, 0x2b, 0x79, 0xa1, 0x91, 0x56, 0x2e,
+    0x13, 0x05, 0xf4, 0x2d, 0x99, 0x6c, 0x82, 0x34, 0x39, 0xc5, 0x6d,
+    0x7f, 0x7b, 0x22, 0xe1, 0x46, 0x44, 0x41, 0x7e, 0x69, 0xbc, 0xb6,
+    0xde, 0x39, 0xd0, 0x27, 0x00, 0x1d, 0xab, 0xe8, 0xf3, 0x5b, 0x25,
+    0xc9, 0xbe, 0x02, 0x21, 0x00, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee,
+    0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71, 0x8c,
+    0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7, 0x90, 0x1e, 0x0e, 0x82,
+    0x97, 0x48, 0x56, 0xa7, 0x02, 0x01, 0x01, 0x30, 0x81, 0xfe, 0x06,
+    0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x04, 0x02, 0x30,
+    0x81, 0xf0, 0x06, 0x0b, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x01, 0x01,
+    0x05, 0x02, 0x02, 0x02, 0x30, 0x81, 0xe0, 0x02, 0x01, 0x01, 0x30,
+    0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02,
+    0x21, 0x00, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e,
+    0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e, 0x3b, 0xf6, 0x23,
+    0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53,
+    0x77, 0x30, 0x44, 0x04, 0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee,
+    0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72, 0x6e,
+    0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d,
+    0x1f, 0x6e, 0x53, 0x74, 0x04, 0x20, 0x66, 0x2c, 0x61, 0xc4, 0x30,
+    0xd8, 0x4e, 0xa4, 0xfe, 0x66, 0xa7, 0x73, 0x3d, 0x0b, 0x76, 0xb7,
+    0xbf, 0x93, 0xeb, 0xc4, 0xaf, 0x2f, 0x49, 0x25, 0x6a, 0xe5, 0x81,
+    0x01, 0xfe, 0xe9, 0x2b, 0x04, 0x04, 0x41, 0x04, 0xa3, 0xe8, 0xeb,
+    0x3c, 0xc1, 0xcf, 0xe7, 0xb7, 0x73, 0x22, 0x13, 0xb2, 0x3a, 0x65,
+    0x61, 0x49, 0xaf, 0xa1, 0x42, 0xc4, 0x7a, 0xaf, 0xbc, 0x2b, 0x79,
+    0xa1, 0x91, 0x56, 0x2e, 0x13, 0x05, 0xf4, 0x2d, 0x99, 0x6c, 0x82,
+    0x34, 0x39, 0xc5, 0x6d, 0x7f, 0x7b, 0x22, 0xe1, 0x46, 0x44, 0x41,
+    0x7e, 0x69, 0xbc, 0xb6, 0xde, 0x39, 0xd0, 0x27, 0x00, 0x1d, 0xab,
+    0xe8, 0xf3, 0x5b, 0x25, 0xc9, 0xbe, 0x02, 0x21, 0x00, 0xa9, 0xfb,
+    0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d,
+    0x83, 0x8d, 0x71, 0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6, 0xf7,
+    0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7, 0x02, 0x01, 0x01
+};
+static const unsigned char ef_cardaccess_new_testcard[] = {
+    0x31, 0x81, 0x82, 0x30, 0x0D, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00,
+    0x07, 0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x30, 0x12, 0x06, 0x0A,
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x02, 0x02,
+    0x01, 0x02, 0x02, 0x01, 0x41, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00,
+    0x7F, 0x00, 0x07, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x02,
+    0x02, 0x01, 0x0D, 0x30, 0x1C, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00,
+    0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00,
+    0x7F, 0x00, 0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x41,
+    0x30, 0x2B, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02,
+    0x06, 0x16, 0x1F, 0x65, 0x50, 0x41, 0x20, 0x2D, 0x20, 0x42, 0x44,
+    0x72, 0x20, 0x47, 0x6D, 0x62, 0x48, 0x20, 0x2D, 0x20, 0x54, 0x65,
+    0x73, 0x74, 0x6B, 0x61, 0x72, 0x74, 0x65, 0x20, 0x76, 0x32, 0x2E,
+    0x30, 0x04, 0x49, 0x17, 0x15, 0x41, 0x19, 0x28, 0x80, 0x0A, 0x01,
+    0xB4, 0x21, 0xFA, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x20, 0x10, 0x10, 0x29, 0x10, 0x10
+    /*Note: The new test cards contain garbage at the end of their EF.CardAccess
+     * (the last 38 Bytes), which we ignore */
+};
+static const unsigned char ef_cardaccess_dan[] = {
+    0x31, 0x81, 0xB3, 0x30, 0x0D, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, /*1..0............*/
+    0x01, 0x02, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x02, /*..0.............*/
+    0x02, 0x01, 0x02, 0x02, 0x01, 0x41, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, /*.....A0.........*/
+    0x02, 0x03, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x45, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, /*.........E0.....*/
+    0x7F, 0x00, 0x07, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x30, 0x1C, /*..............0.*/
+    0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, /*...........0....*/
+    0x00, 0x7F, 0x00, 0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x41, 0x30, 0x1C, 0x06, 0x09, /*...........A0...*/
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, /*.........0......*/
+    0x00, 0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x45, 0x30, 0x2A, 0x06, 0x08, 0x04, 0x00, /*.........E0*....*/
+    0x7F, 0x00, 0x07, 0x02, 0x02, 0x06, 0x16, 0x1E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x62, /*........http://b*/
+    0x73, 0x69, 0x2E, 0x62, 0x75, 0x6E, 0x64, 0x2E, 0x64, 0x65, 0x2F, 0x63, 0x69, 0x66, 0x2F, 0x6E, /*si.bund.de/cif/n*/
+    0x70, 0x61, 0x2E, 0x78, 0x6D, 0x6C,                                                             /*pa.xml*/
+};
+static const unsigned char ef_cardsecurity_wolf[] = {
+    0x30, 0x82, 0x05, 0xA0, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, /*0.....*.H.......*/
+    0x82, 0x05, 0x91, 0x30, 0x82, 0x05, 0x8D, 0x02, 0x01, 0x03, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x09, /*...0......1.0...*/
+    0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x30, 0x82, 0x01, 0x48, 0x06, /*`.H.e......0..H.*/
+    0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x02, 0x01, 0xA0, 0x82, 0x01, 0x3A, 0x04, 0x82, 0x01, /*............:...*/
+    0x36, 0x31, 0x82, 0x01, 0x32, 0x30, 0x0D, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, /*61..20..........*/
+    0x02, 0x02, 0x01, 0x02, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x03, /*....0...........*/
+    0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x41, 0x30, 0x12, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, /*.......A0.......*/
+    0x07, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x30, 0x17, 0x06, 0x0A, /*............0...*/
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x05, 0x02, 0x03, 0x30, 0x09, 0x02, 0x01, 0x01, 0x02, /*..........0.....*/
+    0x01, 0x43, 0x01, 0x01, 0xFF, 0x30, 0x17, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, /*.C...0..........*/
+    0x05, 0x02, 0x03, 0x30, 0x09, 0x02, 0x01, 0x01, 0x02, 0x01, 0x44, 0x01, 0x01, 0x00, 0x30, 0x19, /*...0......D...0.*/
+    0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x05, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, /*...........0....*/
+    0x00, 0x7F, 0x00, 0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, 0x30, 0x1C, 0x06, 0x09, 0x04, 0x00, 0x7F, /*.........0......*/
+    0x00, 0x07, 0x02, 0x02, 0x03, 0x02, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x01, /*......0.........*/
+    0x02, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x41, 0x30, 0x2A, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, /*......A0*.......*/
+    0x02, 0x02, 0x06, 0x16, 0x1E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x62, 0x73, 0x69, 0x2E, /*.....http://bsi.*/
+    0x62, 0x75, 0x6E, 0x64, 0x2E, 0x64, 0x65, 0x2F, 0x63, 0x69, 0x66, 0x2F, 0x6E, 0x70, 0x61, 0x2E, /*bund.de/cif/npa.*/
+    0x78, 0x6D, 0x6C, 0x30, 0x62, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x01, 0x02, /*xml0b...........*/
+    0x30, 0x52, 0x30, 0x0C, 0x06, 0x07, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x01, 0x02, 0x02, 0x01, 0x0D, /*0R0.............*/
+    0x03, 0x42, 0x00, 0x04, 0x92, 0x5D, 0xB4, 0xE1, 0x7A, 0xDE, 0x58, 0x20, 0x9F, 0x96, 0xFA, 0xA0, /*.B...]..z.X ....*/
+    0x7F, 0x1F, 0x8A, 0x22, 0x3F, 0x82, 0x3F, 0x96, 0xCC, 0x5D, 0x78, 0xCB, 0xEF, 0x5D, 0x17, 0x42, /*..."?.?..]x..].B*/
+    0x20, 0x88, 0xFD, 0xD5, 0x8E, 0x56, 0xBC, 0x42, 0x50, 0xDE, 0x33, 0x46, 0xB3, 0xC8, 0x32, 0xCA, /* ....V.BP.3F..2.*/
+    0xE4, 0x86, 0x35, 0xFB, 0x6C, 0x43, 0x78, 0x9D, 0xE8, 0xB3, 0x10, 0x2F, 0x43, 0x93, 0xB4, 0x18, /*..5.lCx..../C...*/
+    0xE2, 0x4A, 0x13, 0xD9, 0x02, 0x01, 0x41, 0xA0, 0x82, 0x03, 0x1C, 0x30, 0x82, 0x03, 0x18, 0x30, /*.J....A....0...0*/
+    0x82, 0x02, 0xBC, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x01, 0x5C, 0x30, 0x0C, 0x06, 0x08, /*...........\0...*/
+    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x30, 0x4F, 0x31, 0x0B, 0x30, 0x09, /**.H.=.....0O1.0.*/
+    0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x44, 0x45, 0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, /*..U....DE1.0...U*/
+    0x04, 0x0A, 0x0C, 0x04, 0x62, 0x75, 0x6E, 0x64, 0x31, 0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, 0x04, /*....bund1.0...U.*/
+    0x0B, 0x0C, 0x03, 0x62, 0x73, 0x69, 0x31, 0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, 0x04, 0x05, 0x13, /*...bsi1.0...U...*/
+    0x03, 0x30, 0x31, 0x33, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x0C, 0x63, /*.0131.0...U....c*/
+    0x73, 0x63, 0x61, 0x2D, 0x67, 0x65, 0x72, 0x6D, 0x61, 0x6E, 0x79, 0x30, 0x1E, 0x17, 0x0D, 0x31, /*sca-germany0...1*/
+    0x30, 0x31, 0x30, 0x30, 0x35, 0x31, 0x31, 0x30, 0x37, 0x35, 0x32, 0x5A, 0x17, 0x0D, 0x32, 0x31, /*01005110752Z..21*/
+    0x30, 0x34, 0x30, 0x35, 0x30, 0x38, 0x33, 0x39, 0x34, 0x37, 0x5A, 0x30, 0x47, 0x31, 0x0B, 0x30, /*0405083947Z0G1.0*/
+    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x44, 0x45, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, /*...U....DE1.0...*/
+    0x55, 0x04, 0x0A, 0x0C, 0x14, 0x42, 0x75, 0x6E, 0x64, 0x65, 0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, /*U....Bundesdruck*/
+    0x65, 0x72, 0x65, 0x69, 0x20, 0x47, 0x6D, 0x62, 0x48, 0x31, 0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, /*erei GmbH1.0...U*/
+    0x04, 0x05, 0x13, 0x03, 0x30, 0x37, 0x34, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x03, /*....0741.0...U..*/
+    0x0C, 0x02, 0x44, 0x53, 0x30, 0x82, 0x01, 0x13, 0x30, 0x81, 0xD4, 0x06, 0x07, 0x2A, 0x86, 0x48, /*..DS0...0....*.H*/
+    0xCE, 0x3D, 0x02, 0x01, 0x30, 0x81, 0xC8, 0x02, 0x01, 0x01, 0x30, 0x28, 0x06, 0x07, 0x2A, 0x86, /*.=..0.....0(..*.*/
+    0x48, 0xCE, 0x3D, 0x01, 0x01, 0x02, 0x1D, 0x00, 0xD7, 0xC1, 0x34, 0xAA, 0x26, 0x43, 0x66, 0x86, /*H.=.......4.&Cf.*/
+    0x2A, 0x18, 0x30, 0x25, 0x75, 0xD1, 0xD7, 0x87, 0xB0, 0x9F, 0x07, 0x57, 0x97, 0xDA, 0x89, 0xF5, /**.0%u......W....*/
+    0x7E, 0xC8, 0xC0, 0xFF, 0x30, 0x3C, 0x04, 0x1C, 0x68, 0xA5, 0xE6, 0x2C, 0xA9, 0xCE, 0x6C, 0x1C, /*~...0<..h..,..l.*/
+    0x29, 0x98, 0x03, 0xA6, 0xC1, 0x53, 0x0B, 0x51, 0x4E, 0x18, 0x2A, 0xD8, 0xB0, 0x04, 0x2A, 0x59, /*)....S.QN.*...*Y*/
+    0xCA, 0xD2, 0x9F, 0x43, 0x04, 0x1C, 0x25, 0x80, 0xF6, 0x3C, 0xCF, 0xE4, 0x41, 0x38, 0x87, 0x07, /*...C..%..<..A8..*/
+    0x13, 0xB1, 0xA9, 0x23, 0x69, 0xE3, 0x3E, 0x21, 0x35, 0xD2, 0x66, 0xDB, 0xB3, 0x72, 0x38, 0x6C, /*...#i.>!5.f..r8l*/
+    0x40, 0x0B, 0x04, 0x39, 0x04, 0x0D, 0x90, 0x29, 0xAD, 0x2C, 0x7E, 0x5C, 0xF4, 0x34, 0x08, 0x23, /*@..9...).,~\.4.#*/
+    0xB2, 0xA8, 0x7D, 0xC6, 0x8C, 0x9E, 0x4C, 0xE3, 0x17, 0x4C, 0x1E, 0x6E, 0xFD, 0xEE, 0x12, 0xC0, /*..}...L..L.n....*/
+    0x7D, 0x58, 0xAA, 0x56, 0xF7, 0x72, 0xC0, 0x72, 0x6F, 0x24, 0xC6, 0xB8, 0x9E, 0x4E, 0xCD, 0xAC, /*}X.V.r.ro$...N..*/
+    0x24, 0x35, 0x4B, 0x9E, 0x99, 0xCA, 0xA3, 0xF6, 0xD3, 0x76, 0x14, 0x02, 0xCD, 0x02, 0x1D, 0x00, /*$5K......v......*/
+    0xD7, 0xC1, 0x34, 0xAA, 0x26, 0x43, 0x66, 0x86, 0x2A, 0x18, 0x30, 0x25, 0x75, 0xD0, 0xFB, 0x98, /*..4.&Cf.*.0%u...*/
+    0xD1, 0x16, 0xBC, 0x4B, 0x6D, 0xDE, 0xBC, 0xA3, 0xA5, 0xA7, 0x93, 0x9F, 0x02, 0x01, 0x01, 0x03, /*...Km...........*/
+    0x3A, 0x00, 0x04, 0x3D, 0x6A, 0x7C, 0x2A, 0x6F, 0x20, 0x5F, 0x83, 0x9B, 0x04, 0x14, 0xEC, 0x58, /*:..=j|*o _.....X*/
+    0xC6, 0xC7, 0x1B, 0x75, 0xF5, 0x15, 0xDE, 0xC3, 0xAE, 0x73, 0x3B, 0x5F, 0x47, 0x88, 0xDD, 0xC8, /*...u.....s;_G...*/
+    0x15, 0xF0, 0x5B, 0xC1, 0xF6, 0x53, 0x8F, 0xD9, 0x69, 0x54, 0xE1, 0xF8, 0x40, 0xA2, 0xE2, 0x18, /*..[..S..iT..@...*/
+    0x99, 0x62, 0xCC, 0xAA, 0x14, 0x90, 0x08, 0x24, 0xC7, 0xDD, 0xB9, 0xA3, 0x81, 0xD1, 0x30, 0x81, /*.b.....$......0.*/
+    0xCE, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, /*.0...U..........*/
+    0x80, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x60, 0x44, /*.0...U.#..0...`D*/
+    0xF2, 0x45, 0xF2, 0xE0, 0x71, 0xD4, 0xD5, 0x64, 0xF4, 0xE5, 0x77, 0xD6, 0x36, 0x69, 0xDB, 0xEB, /*.E..q..d..w.6i..*/
+    0x18, 0x59, 0x30, 0x41, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3A, 0x30, 0x38, 0x30, 0x36, 0x06, /*.Y0A..U. .:0806.*/
+    0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01, 0x01, 0x01, 0x30, 0x29, 0x30, 0x27, 0x06, 0x08, /*..........0)0'..*/
+    0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, /*+.........http:/*/
+    0x2F, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x73, 0x69, 0x2E, 0x62, 0x75, 0x6E, 0x64, 0x2E, 0x64, 0x65, /*/www.bsi.bund.de*/
+    0x2F, 0x63, 0x73, 0x63, 0x61, 0x30, 0x2B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, /*/csca0+..*.H....*/
+    0x09, 0x15, 0x04, 0x1E, 0x04, 0x1C, 0x31, 0x2E, 0x32, 0x2E, 0x32, 0x37, 0x36, 0x2E, 0x30, 0x2E, /*......1.2.276.0.*/
+    0x38, 0x30, 0x2E, 0x31, 0x2E, 0x31, 0x32, 0x2E, 0x30, 0x2E, 0x32, 0x30, 0x2E, 0x35, 0x2E, 0x31, /*80.1.12.0.20.5.1*/
+    0x2E, 0x30, 0x30, 0x2B, 0x06, 0x03, 0x55, 0x1D, 0x10, 0x04, 0x24, 0x30, 0x22, 0x80, 0x0F, 0x32, /*.00+..U...$0"..2*/
+    0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x35, 0x31, 0x31, 0x30, 0x37, 0x35, 0x32, 0x5A, 0x81, 0x0F, /*0101005110752Z..*/
+    0x32, 0x30, 0x31, 0x31, 0x30, 0x32, 0x30, 0x35, 0x30, 0x39, 0x33, 0x39, 0x34, 0x37, 0x5A, 0x30, /*20110205093947Z0*/
+    0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x03, 0x48, 0x00, /*...*.H.=......H.*/
+    0x30, 0x45, 0x02, 0x20, 0x13, 0xE9, 0xE1, 0x7A, 0x9E, 0xFE, 0x8B, 0xD7, 0xD7, 0x27, 0x62, 0x92, /*0E. ...z.....'b.*/
+    0x30, 0x5B, 0xCC, 0xC3, 0x2B, 0x70, 0xC2, 0xB7, 0x60, 0x40, 0xF4, 0x88, 0x30, 0x66, 0x62, 0x26, /*0[..+p..`@..0fb&*/
+    0xCD, 0x6A, 0x4B, 0xF4, 0x02, 0x21, 0x00, 0x87, 0xF4, 0x71, 0xE2, 0x44, 0x35, 0xB4, 0xC3, 0x4A, /*.jK..!...q.D5..J*/
+    0xF3, 0x57, 0x30, 0x94, 0xFB, 0x1F, 0x1C, 0x2A, 0x48, 0xB1, 0x3E, 0xE5, 0xED, 0x67, 0xF1, 0x72, /*.W0....*H.>..g.r*/
+    0x6D, 0xCF, 0x56, 0xE3, 0x84, 0xE3, 0x6F, 0x31, 0x82, 0x01, 0x09, 0x30, 0x82, 0x01, 0x05, 0x02, /*m.V...o1...0....*/
+    0x01, 0x01, 0x30, 0x55, 0x30, 0x4F, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, /*..0U0O1.0...U...*/
+    0x02, 0x44, 0x45, 0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x04, 0x62, 0x75, /*.DE1.0...U....bu*/
+    0x6E, 0x64, 0x31, 0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x03, 0x62, 0x73, 0x69, /*nd1.0...U....bsi*/
+    0x31, 0x0C, 0x30, 0x0A, 0x06, 0x03, 0x55, 0x04, 0x05, 0x13, 0x03, 0x30, 0x31, 0x33, 0x31, 0x15, /*1.0...U....0131.*/
+    0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x0C, 0x63, 0x73, 0x63, 0x61, 0x2D, 0x67, 0x65, /*0...U....csca-ge*/
+    0x72, 0x6D, 0x61, 0x6E, 0x79, 0x02, 0x02, 0x01, 0x5C, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, /*rmany...\0...`.H*/
+    0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0xA0, 0x4A, 0x30, 0x17, 0x06, 0x09, 0x2A, 0x86, /*.e.......J0...*.*/
+    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31, 0x0A, 0x06, 0x08, 0x04, 0x00, 0x7F, 0x00, 0x07, /*H......1........*/
+    0x03, 0x02, 0x01, 0x30, 0x2F, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, /*...0/..*.H......*/
+    0x31, 0x22, 0x04, 0x20, 0xEF, 0x0F, 0xDA, 0x94, 0x2E, 0x5A, 0x0F, 0x6F, 0xC9, 0xC5, 0x46, 0xEE, /*1". .....Z.o..F.*/
+    0x01, 0xF9, 0x10, 0x31, 0x43, 0x64, 0x30, 0xF7, 0x5E, 0x9D, 0x36, 0x54, 0xD3, 0x69, 0x30, 0x9E, /*...1Cd0.^.6T.i0.*/
+    0x8B, 0xE7, 0x17, 0x48, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, /*...H0...*.H.=...*/
+    0x05, 0x00, 0x04, 0x40, 0x30, 0x3E, 0x02, 0x1D, 0x00, 0x89, 0x75, 0x92, 0x5B, 0xE1, 0x31, 0xB7, /*...@0>....u.[.1.*/
+    0x7C, 0x95, 0x8C, 0x3E, 0xCB, 0x2A, 0x5C, 0x67, 0xFC, 0x5C, 0xE3, 0x1C, 0xBD, 0x01, 0x41, 0xE3, /*|..>.*\g.\....A.*/
+    0x4B, 0xC7, 0xF0, 0xA4, 0x47, 0x02, 0x1D, 0x00, 0xCC, 0x65, 0xE6, 0x2D, 0xDC, 0xF2, 0x93, 0x96, /*K...G....e.-....*/
+    0x4B, 0x22, 0xD7, 0xB5, 0x10, 0xD7, 0x81, 0x88, 0x07, 0xC8, 0x95, 0x96, 0xBD, 0x34, 0xD8, 0xF9, /*K"...........4..*/
+    0xBB, 0x4C, 0x05, 0x27,                                                                         /*.L.'*/
+};
+
+struct ef_cardaccess {
+    const unsigned char *ef_cardaccess;
+    const size_t ef_cardaccess_len;
+};
+
+static const struct ef_cardaccess ef_cardaccess_files[] = {
+    {
+        ef_cardaccess_new_testcard,
+        sizeof ef_cardaccess_new_testcard,
+    },
+    {
+        ef_cardaccess_old_testcard,
+        sizeof ef_cardaccess_old_testcard,
+    },
+    {
+        ef_cardaccess_dan,
+        sizeof ef_cardaccess_dan,
+    },
+};
+
+static const unsigned char cvc1[] = {
+    0x7F, 0x21, 0x82, 0x01, 0x41, 0x7F, 0x4E, 0x81, 0xFA, 0x5F, 0x29,
+    0x01, 0x00, 0x42, 0x0D, 0x5A, 0x5A, 0x44, 0x56, 0x43, 0x41, 0x41,
+    0x54, 0x41, 0x30, 0x30, 0x30, 0x33, 0x7F, 0x49, 0x4F, 0x06, 0x0A,
+    0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+    0x41, 0x04, 0x19, 0xD1, 0x75, 0x45, 0xD3, 0xFE, 0x0B, 0x34, 0x3E,
+    0x7E, 0xE2, 0xAE, 0x4E, 0x2B, 0xC9, 0x2D, 0x51, 0x35, 0x1C, 0xC1,
+    0x17, 0xA4, 0x7F, 0xA9, 0x51, 0x9A, 0xDB, 0x1E, 0x40, 0x5E, 0xE6,
+    0xB8, 0x12, 0x12, 0x80, 0xBC, 0xC2, 0xFF, 0xF0, 0x35, 0x7A, 0x19,
+    0x7D, 0xE7, 0x39, 0xA7, 0xFD, 0x2E, 0xF0, 0x22, 0x10, 0xEF, 0x34,
+    0x3C, 0xDB, 0xE7, 0x9E, 0xF9, 0x4B, 0x8E, 0x28, 0x59, 0x1B, 0xB9,
+    0x5F, 0x20, 0x0B, 0x5A, 0x5A, 0x44, 0x4B, 0x42, 0x32, 0x30, 0x30,
+    0x30, 0x30, 0x52, 0x7F, 0x4C, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7F,
+    0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x00, 0x03, 0x01,
+    0xDF, 0x04, 0x5F, 0x25, 0x06, 0x01, 0x00, 0x00, 0x02, 0x01, 0x07,
+    0x5F, 0x24, 0x06, 0x01, 0x00, 0x00, 0x03, 0x03, 0x01, 0x65, 0x5E,
+    0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01,
+    0x03, 0x01, 0x80, 0x20, 0x75, 0xE0, 0xC4, 0xAC, 0x36, 0xC2, 0x5A,
+    0x33, 0xAC, 0x0E, 0x9A, 0x75, 0xEB, 0x79, 0x2A, 0x72, 0xF3, 0x31,
+    0xA5, 0x1E, 0x28, 0x63, 0x4E, 0xCC, 0x2E, 0xD6, 0x2E, 0x54, 0xF3,
+    0xC6, 0x93, 0xDA, 0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00,
+    0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x18, 0x12, 0x65, 0x74,
+    0x49, 0xFC, 0xF1, 0xD3, 0xDA, 0xD8, 0x3D, 0x13, 0x14, 0x29, 0x17,
+    0x5C, 0x61, 0x8B, 0x21, 0xBA, 0xF0, 0xAF, 0x44, 0xAC, 0xE3, 0x8C,
+    0xB2, 0xC1, 0x2C, 0xEB, 0x2A, 0x56, 0x5F, 0x37, 0x40, 0x54, 0x0F,
+    0x85, 0x09, 0x12, 0xAB, 0xD3, 0x51, 0xF8, 0xF5, 0x56, 0x9B, 0x53,
+    0x4A, 0x5C, 0x8F, 0x64, 0x54, 0x5B, 0x51, 0xA7, 0x34, 0x70, 0xBE,
+    0x5A, 0xD2, 0x89, 0xC1, 0x9A, 0x5E, 0x13, 0x52, 0x53, 0xD3, 0xBB,
+    0x15, 0x52, 0x26, 0x21, 0x7B, 0x41, 0xE7, 0xF0, 0x68, 0xB3, 0x52,
+    0x3F, 0x3A, 0x63, 0x92, 0x22, 0xAF, 0x2B, 0x62, 0x8C, 0x39, 0x7D,
+    0x4F, 0xD4, 0x02, 0x1E, 0xDE, 0x00, 0xDC
+};
+static const unsigned char cvc1_desc[] = {
+    0x30, 0x82, 0x01, 0x90, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03,
+    0x01, 0x03, 0x01, 0x01, 0xA1, 0x16, 0x0C, 0x14, 0x42, 0x75, 0x6E, 0x64,
+    0x65, 0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x20,
+    0x47, 0x6D, 0x62, 0x48, 0xA2, 0x24, 0x13, 0x22, 0x68, 0x74, 0x74, 0x70,
+    0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x75, 0x6E, 0x64, 0x65,
+    0x73, 0x64, 0x72, 0x75, 0x63, 0x6B, 0x65, 0x72, 0x65, 0x69, 0x2E, 0x64,
+    0x65, 0x2F, 0x64, 0x76, 0x63, 0x61, 0xA3, 0x18, 0x0C, 0x16, 0x44, 0x65,
+    0x75, 0x74, 0x73, 0x63, 0x68, 0x65, 0x20, 0x4B, 0x72, 0x65, 0x64, 0x69,
+    0x74, 0x62, 0x61, 0x6E, 0x6B, 0x20, 0x41, 0x47, 0xA4, 0x13, 0x13, 0x11,
+    0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64,
+    0x6B, 0x62, 0x2E, 0x64, 0x65, 0xA5, 0x82, 0x01, 0x13, 0x0C, 0x82, 0x01,
+    0x0F, 0x54, 0x61, 0x75, 0x62, 0x65, 0x6E, 0x73, 0x74, 0x72, 0x2E, 0x20,
+    0x37, 0x2D, 0x39, 0x0D, 0x0A, 0x31, 0x30, 0x31, 0x31, 0x37, 0x20, 0x42,
+    0x65, 0x72, 0x6C, 0x69, 0x6E, 0x0D, 0x0A, 0x69, 0x6E, 0x66, 0x6F, 0x40,
+    0x64, 0x6B, 0x62, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6,
+    0x66, 0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73,
+    0x20, 0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A, 0x42, 0x65, 0x72,
+    0x6C, 0x69, 0x6E, 0x65, 0x72, 0x20, 0x42, 0x65, 0x61, 0x75, 0x66, 0x74,
+    0x72, 0x61, 0x67, 0x74, 0x65, 0x72, 0x20, 0x66, 0xC3, 0xBC, 0x72, 0x20,
+    0x44, 0x61, 0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x20,
+    0x75, 0x6E, 0x64, 0x20, 0x49, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74,
+    0x69, 0x6F, 0x6E, 0x73, 0x66, 0x72, 0x65, 0x69, 0x68, 0x65, 0x69, 0x74,
+    0x2C, 0x20, 0x41, 0x6E, 0x20, 0x64, 0x65, 0x72, 0x20, 0x55, 0x72, 0x61,
+    0x6E, 0x69, 0x61, 0x20, 0x34, 0x2D, 0x31, 0x30, 0x2C, 0x20, 0x31, 0x30,
+    0x37, 0x38, 0x37, 0x20, 0x42, 0x65, 0x72, 0x6C, 0x69, 0x6E, 0x2C, 0x20,
+    0x30, 0x33, 0x30, 0x2F, 0x31, 0x33, 0x20, 0x38, 0x38, 0x39, 0x2D, 0x30,
+    0x2C, 0x20, 0x6D, 0x61, 0x69, 0x6C, 0x62, 0x6F, 0x78, 0x40, 0x64, 0x61,
+    0x74, 0x65, 0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65,
+    0x72, 0x6C, 0x69, 0x6E, 0x2E, 0x64, 0x65, 0x2C, 0x20, 0x68, 0x74, 0x74,
+    0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x64, 0x61, 0x74, 0x65,
+    0x6E, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7A, 0x2D, 0x62, 0x65, 0x72, 0x6C,
+    0x69, 0x6E, 0x2E, 0x64, 0x65, 0x0D, 0x0A, 0x45, 0x72, 0xC3, 0xB6, 0x66,
+    0x66, 0x6E, 0x75, 0x6E, 0x67, 0x20, 0x65, 0x69, 0x6E, 0x65, 0x73, 0x20,
+    0x4B, 0x6F, 0x6E, 0x74, 0x6F, 0x73, 0x0D, 0x0A
+};
+/* http://www.internet-sicherheit.de/forschung/aktuelle-forschungsprojekte/elektronischer-personalausweis/berechtigungszertifikat/ */
+static unsigned const char cvc2[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x89, 0x7f, 0x4e, 0x82, 0x01, 0x49, 0x5f,
+    0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41,
+    0x45, 0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x81,
+    0xfd, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02,
+    0x02, 0x02, 0x81, 0x1c, 0xd7, 0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66,
+    0x86, 0x2a, 0x18, 0x30, 0x25, 0x75, 0xd1, 0xd7, 0x87, 0xb0, 0x9f,
+    0x07, 0x57, 0x97, 0xda, 0x89, 0xf5, 0x7e, 0xc8, 0xc0, 0xff, 0x82,
+    0x1c, 0x68, 0xa5, 0xe6, 0x2c, 0xa9, 0xce, 0x6c, 0x1c, 0x29, 0x98,
+    0x03, 0xa6, 0xc1, 0x53, 0x0b, 0x51, 0x4e, 0x18, 0x2a, 0xd8, 0xb0,
+    0x04, 0x2a, 0x59, 0xca, 0xd2, 0x9f, 0x43, 0x83, 0x1c, 0x25, 0x80,
+    0xf6, 0x3c, 0xcf, 0xe4, 0x41, 0x38, 0x87, 0x07, 0x13, 0xb1, 0xa9,
+    0x23, 0x69, 0xe3, 0x3e, 0x21, 0x35, 0xd2, 0x66, 0xdb, 0xb3, 0x72,
+    0x38, 0x6c, 0x40, 0x0b, 0x84, 0x39, 0x04, 0x0d, 0x90, 0x29, 0xad,
+    0x2c, 0x7e, 0x5c, 0xf4, 0x34, 0x08, 0x23, 0xb2, 0xa8, 0x7d, 0xc6,
+    0x8c, 0x9e, 0x4c, 0xe3, 0x17, 0x4c, 0x1e, 0x6e, 0xfd, 0xee, 0x12,
+    0xc0, 0x7d, 0x58, 0xaa, 0x56, 0xf7, 0x72, 0xc0, 0x72, 0x6f, 0x24,
+    0xc6, 0xb8, 0x9e, 0x4e, 0xcd, 0xac, 0x24, 0x35, 0x4b, 0x9e, 0x99,
+    0xca, 0xa3, 0xf6, 0xd3, 0x76, 0x14, 0x02, 0xcd, 0x85, 0x1c, 0xd7,
+    0xc1, 0x34, 0xaa, 0x26, 0x43, 0x66, 0x86, 0x2a, 0x18, 0x30, 0x25,
+    0x75, 0xd0, 0xfb, 0x98, 0xd1, 0x16, 0xbc, 0x4b, 0x6d, 0xde, 0xbc,
+    0xa3, 0xa5, 0xa7, 0x93, 0x9f, 0x86, 0x39, 0x04, 0x39, 0x3e, 0xe8,
+    0xe0, 0x6d, 0xb6, 0xc7, 0xf5, 0x28, 0xf8, 0xb4, 0x26, 0x0b, 0x49,
+    0xaa, 0x93, 0x30, 0x98, 0x24, 0xd9, 0x2c, 0xdb, 0x18, 0x07, 0xe5,
+    0x43, 0x7e, 0xe2, 0xe2, 0x6e, 0x29, 0xb7, 0x3a, 0x71, 0x11, 0x53,
+    0x0f, 0xa8, 0x6b, 0x35, 0x00, 0x37, 0xcb, 0x94, 0x15, 0xe1, 0x53,
+    0x70, 0x43, 0x94, 0x46, 0x37, 0x97, 0x13, 0x9e, 0x14, 0x87, 0x01,
+    0x01, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x45,
+    0x50, 0x41, 0x53, 0x53, 0x30, 0x30, 0x31, 0x7f, 0x4c, 0x0e, 0x06,
+    0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x01, 0x53,
+    0x01, 0xc1, 0x5f, 0x25, 0x06, 0x00, 0x07, 0x00, 0x04, 0x00, 0x01,
+    0x5f, 0x24, 0x06, 0x00, 0x09, 0x00, 0x04, 0x00, 0x01, 0x5f, 0x37,
+    0x38, 0x4c, 0xcf, 0x25, 0xc5, 0x9f, 0x36, 0x12, 0xee, 0xe1, 0x88,
+    0x75, 0xf6, 0xc5, 0xf2, 0xe2, 0xd2, 0x1f, 0x03, 0x95, 0x68, 0x3b,
+    0x53, 0x2a, 0x26, 0xe4, 0xc1, 0x89, 0xb7, 0x1e, 0xfe, 0x65, 0x9c,
+    0x3f, 0x26, 0xe0, 0xeb, 0x9a, 0xea, 0xe9, 0x98, 0x63, 0x10, 0x7f,
+    0x9b, 0x0d, 0xad, 0xa1, 0x64, 0x14, 0xff, 0xa2, 0x04, 0x51, 0x6a,
+    0xee, 0x2b
+};
+
+static unsigned char wrong_tc_ecdh_cvca[] = {
+    0x7f, 0x21, 0x82, 0x01, 0xb4, 0x7f, 0x4e, 0x82, 0x01, 0x6c, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0d,  /*.!....N..l_)..B. */
+    0x44, 0x45, 0x41, 0x54, 0x43, 0x56, 0x43, 0x41, 0x30, 0x30, 0x30, 0x30, 0x31, 0x7f, 0x49, 0x82,  /*DEATCVCA00001.I. */
+    0x01, 0x1d, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x81, 0x20,  /*...............  */
+    0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9, 0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x72,  /*..W.....>f.....r */
+    0x6e, 0x3b, 0xf6, 0x23, 0xd5, 0x26, 0x20, 0x28, 0x20, 0x13, 0x48, 0x1d, 0x1f, 0x6e, 0x53, 0x77,  /*n;.#.& ( .H..nSw */
+    0x82, 0x20, 0x7d, 0x5a, 0x09, 0x75, 0xfc, 0x2c, 0x30, 0x57, 0xee, 0xf6, 0x75, 0x30, 0x41, 0x7a,  /*. }Z.u.,0W..u0Az */
+    0xff, 0xe7, 0xfb, 0x80, 0x55, 0xc1, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, 0x30,  /*....U.&.\l.JKD.0 */
+    0xb5, 0xd9, 0x83, 0x20, 0x26, 0xdc, 0x5c, 0x6c, 0xe9, 0x4a, 0x4b, 0x44, 0xf3, 0x30, 0xb5, 0xd9,  /*... &.\l.JKD.0.. */
+    0xbb, 0xd7, 0x7c, 0xbf, 0x95, 0x84, 0x16, 0x29, 0x5c, 0xf7, 0xe1, 0xce, 0x6b, 0xcc, 0xdc, 0x18,  /*..|....)\...k... */
+    0xff, 0x8c, 0x07, 0xb6, 0x84, 0x41, 0x04, 0x8b, 0xd2, 0xae, 0xb9, 0xcb, 0x7e, 0x57, 0xcb, 0x2c,  /*.....A......~W., */
+    0x4b, 0x48, 0x2f, 0xfc, 0x81, 0xb7, 0xaf, 0xb9, 0xde, 0x27, 0xe1, 0xe3, 0xbd, 0x23, 0xc2, 0x3a,  /*KH/......'...#.: */
+    0x44, 0x53, 0xbd, 0x9a, 0xce, 0x32, 0x62, 0x54, 0x7e, 0xf8, 0x35, 0xc3, 0xda, 0xc4, 0xfd, 0x97,  /*DS...2bT~.5..... */
+    0xf8, 0x46, 0x1a, 0x14, 0x61, 0x1d, 0xc9, 0xc2, 0x77, 0x45, 0x13, 0x2d, 0xed, 0x8e, 0x54, 0x5c,  /*.F..a...wE.-..T\ */
+    0x1d, 0x54, 0xc7, 0x2f, 0x04, 0x69, 0x97, 0x85, 0x20, 0xa9, 0xfb, 0x57, 0xdb, 0xa1, 0xee, 0xa9,  /*.T./.i.. ..W.... */
+    0xbc, 0x3e, 0x66, 0x0a, 0x90, 0x9d, 0x83, 0x8d, 0x71, 0x8c, 0x39, 0x7a, 0xa3, 0xb5, 0x61, 0xa6,  /*.>f.....q.9z..a. */
+    0xf7, 0x90, 0x1e, 0x0e, 0x82, 0x97, 0x48, 0x56, 0xa7, 0x86, 0x41, 0x04, 0x31, 0xa3, 0x8e, 0xe4,  /*......HV..A.1... */
+    0x3b, 0xf1, 0xa9, 0xf0, 0x3b, 0x13, 0x6b, 0x67, 0x30, 0x12, 0x92, 0x38, 0xe4, 0x12, 0xd2, 0x4c,  /*;...;.kg0..8...L */
+    0x6e, 0x36, 0xdd, 0xf2, 0xe6, 0x26, 0x20, 0x84, 0xd0, 0x5f, 0xaf, 0x3d, 0x9d, 0xed, 0x1c, 0xe1,  /*n6...& .._.=.... */
+    0x2e, 0x26, 0x4c, 0xcc, 0xb5, 0xb0, 0xda, 0xd2, 0x1f, 0x22, 0x2a, 0xd2, 0x81, 0xe3, 0x9d, 0x97,  /*.&L......"*..... */
+    0x29, 0x5e, 0xb0, 0x4d, 0x18, 0xfc, 0x72, 0x1f, 0x46, 0x9f, 0x7b, 0xd8, 0x87, 0x01, 0x01, 0x5f,  /*)^.M..r.F.{...._ */
+    0x20, 0x0d, 0x44, 0x45, 0x41, 0x54, 0x43, 0x56, 0x43, 0x41, 0x30, 0x30, 0x30, 0x30, 0x31, 0x7f,  /* .DEATCVCA00001. */
+    0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0xfe,  /*L............S.. */
+    0x1f, 0xff, 0xff, 0xff, 0x5f, 0x25, 0x06, 0x01, 0x00, 0x00, 0x03, 0x02, 0x04, 0x5f, 0x24, 0x06,  /*...._%......._$. */
+    0x01, 0x01, 0x00, 0x03, 0x02, 0x04, 0x5f, 0x37, 0x40, 0x13, 0x48, 0xec, 0xf2, 0xce, 0x5e, 0x0c,  /*......_7@.H...^. */
+    0x23, 0x3f, 0xd2, 0xb7, 0x78, 0x42, 0x10, 0x4f, 0x76, 0xfc, 0xe6, 0x02, 0x19, 0x28, 0x8d, 0x2f,  /*#?..xB.Ov....(./ */
+    0x67, 0x36, 0x0c, 0xbc, 0xf8, 0x80, 0xc7, 0x92, 0x5d, 0x4f, 0x2f, 0x80, 0x6f, 0x8b, 0xac, 0xa8,  /*g6......]O/.o... */
+    0x60, 0x83, 0xbd, 0xc7, 0x6a, 0xb9, 0xdd, 0xa4, 0x2b, 0xc5, 0xe8, 0x26, 0x20, 0xd6, 0x11, 0xf4,  /*`...j...+..& ... */
+    0x64, 0x97, 0x4f, 0x6c, 0x28, 0x21, 0x4e, 0x1e, 0xc2,                                            /*d.Ol(!N.. */
+};
+
+/* https://www.kba-online.de/vzronline/ */
+static unsigned char kba_dvca_cert[] = {
+    0x7f, 0x21, 0x82, 0x00, 0xe7, 0x7F,
+    0x4E, 0x81, 0xA0, 0x5F, 0x29, 0x01, 0x00, 0x42, 0x0E, 0x44, 0x45, 0x43, 0x56, 0x43, 0x41, 0x65, /*N.._)..B.DECVCAe*/
+    0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7F, 0x49, 0x4F, 0x06, 0x0A, 0x04, 0x00, 0x7F, 0x00, /*ID00102.IO......*/
+    0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0xA0, 0x1E, 0x1B, 0x0D, 0x37, 0x50, 0x51, /*.......A.....7PQ*/
+    0xAD, 0xCA, 0x23, 0x00, 0x33, 0xA8, 0x9F, 0x20, 0xC2, 0x87, 0x06, 0x52, 0x98, 0xD1, 0x4D, 0x2F, /*..#.3.. ...R..M/*/
+    0xF9, 0xD0, 0x2A, 0xFF, 0x43, 0xFA, 0x14, 0xE2, 0x44, 0x24, 0xEA, 0x7B, 0xCD, 0x8B, 0xA8, 0x66, /*..*.C...D$.{...f*/
+    0xBF, 0xF2, 0x36, 0x1E, 0x94, 0x2C, 0x76, 0x52, 0xA0, 0xF5, 0x22, 0xB4, 0x90, 0xCA, 0xDC, 0x25, /*..6..,vR.."....%*/
+    0x97, 0x2E, 0x01, 0xA2, 0x2F, 0xA5, 0x21, 0xB3, 0x28, 0x5F, 0x20, 0x10, 0x44, 0x45, 0x44, 0x56, /*..../.!.(_ .DEDV*/
+    0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x32, 0x30, 0x31, 0x7F, 0x4C, 0x12, 0x06, /*eIDDTR101201.L..*/
+    0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x40, 0x05, 0x01, 0xFF, /*..........S.@...*/
+    0x87, 0x5F, 0x25, 0x06, 0x01, 0x01, 0x00, 0x06, 0x02, 0x04, 0x5F, 0x24, 0x06, 0x01, 0x01, 0x00, /*._%......._$....*/
+    0x09, 0x02, 0x04, 0x5F, 0x37, 0x40, 0x5F, 0x22, 0x30, 0xC2, 0x1F, 0xC3, 0x86, 0x28, 0x90, 0x22, /*..._7@_"0....(."*/
+    0xF2, 0x7F, 0x0D, 0x54, 0x0E, 0xAB, 0x07, 0x74, 0xFE, 0x85, 0xB6, 0x57, 0x34, 0xE0, 0x23, 0x90, /*...T...t...W4.#.*/
+    0x8C, 0x83, 0x3E, 0xCE, 0x2F, 0x93, 0x96, 0xD4, 0xEE, 0x5C, 0x8E, 0x9F, 0xDC, 0x33, 0x3D, 0x9E, /*..>./....\...3=.*/
+    0xD9, 0x71, 0xA9, 0x70, 0xEF, 0xF5, 0x78, 0xD4, 0x00, 0x3D, 0x48, 0x62, 0x62, 0x9F, 0x3B, 0xD8, /*.q.p..x..=Hbb.;.*/
+    0xFA, 0xCD, 0xED, 0x10, 0xBC, 0x51,
+};
+static unsigned char kba_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48,
+          0x7F, 0x4E, 0x82, 0x01, 0x00, 0x5F, 0x29, 0x01, 0x00, 0x42, 0x10, 0x44, 0x45, 0x44, 0x56,  /*.N..._)..B.DEDV*/
+    0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x32, 0x30, 0x31, 0x7F, 0x49, 0x4F, 0x06, /*eIDDTR101201.IO.*/
+    0x0A, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x6E, 0x43, /*............A.nC*/
+    0x02, 0xE9, 0x70, 0xC8, 0x1F, 0x35, 0x60, 0x28, 0xB1, 0x75, 0x7C, 0xB4, 0xC7, 0x14, 0xE0, 0xD8, /*..p..5`(.u|.....*/
+    0x75, 0xEB, 0xA6, 0x94, 0xAB, 0xA9, 0xE6, 0x43, 0xF8, 0x3F, 0x72, 0x8A, 0x45, 0xCF, 0x83, 0xDE, /*u......C.?r.E...*/
+    0x2E, 0xB1, 0x05, 0x5E, 0x02, 0xC5, 0x2C, 0xDE, 0x74, 0xA2, 0x4B, 0x1D, 0xF9, 0xBB, 0xA3, 0xE8, /*...^..,.t.K.....*/
+    0xB1, 0x7B, 0x40, 0x35, 0x56, 0xE5, 0x26, 0x1F, 0x03, 0x12, 0x8E, 0x55, 0x84, 0x3C, 0x5F, 0x20, /*.{@5V.&....U.<_ */
+    0x0E, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x30, 0x33, 0x47, 0x33, 0x7F, /*.DE0000071003G3.*/
+    0x4C, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, 0x05, 0x00, /*L............S..*/
+    0x01, 0x01, 0x98, 0x04, 0x5F, 0x25, 0x06, 0x01, 0x01, 0x00, 0x09, 0x02, 0x01, 0x5F, 0x24, 0x06, /*...._%......._$.*/
+    0x01, 0x01, 0x00, 0x09, 0x02, 0x03, 0x65, 0x5E, 0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, /*......e^s-......*/
+    0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x98, 0x71, 0xAC, 0xEA, 0x94, 0x79, 0xF5, 0xF3, 0x36, /*...... .q...y..6*/
+    0xB1, 0x24, 0xB8, 0x71, 0xB7, 0xB1, 0xFB, 0x4D, 0xF4, 0x06, 0x46, 0xB8, 0x69, 0x35, 0x7C, 0xBA, /*.$.q...M..F.i5|.*/
+    0x77, 0x4D, 0x3C, 0x10, 0x83, 0x41, 0x97, 0x73, 0x2D, 0x06, 0x09, 0x04, 0x00, 0x7F, 0x00, 0x07, /*wM<..A.s-.......*/
+    0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x8E, 0x2F, 0xCF, 0x13, 0x70, 0xEE, 0x5E, 0x7D, 0xBC, 0xCA, /*..... ./..p.^}..*/
+    0x6F, 0xBF, 0xE0, 0x04, 0x41, 0x43, 0xB4, 0x97, 0xF4, 0x27, 0xA5, 0xD9, 0xAF, 0xAF, 0x5E, 0x40, /*o...AC...'....^@*/
+    0x33, 0xB2, 0xB1, 0xC3, 0x22, 0x06, 0x5F, 0x37, 0x40, 0x88, 0x49, 0x47, 0xD1, 0x07, 0x23, 0xD4, /*3..."._7@.IG..#.*/
+    0xB1, 0xE8, 0x7B, 0x4F, 0x74, 0x2E, 0x1B, 0xEC, 0x1A, 0x56, 0x2F, 0x8E, 0xCE, 0x62, 0xB1, 0x2C, /*..{Ot....V/..b.,*/
+    0xEB, 0xE5, 0x8B, 0xF2, 0x70, 0xB2, 0x67, 0xCD, 0x31, 0x95, 0x0C, 0x8B, 0x03, 0xA5, 0xD8, 0x9F, /*....p.g.1.......*/
+    0x1A, 0xEB, 0x06, 0x8C, 0x7B, 0x75, 0x18, 0x66, 0xCD, 0xA8, 0xE8, 0xC1, 0xCF, 0x21, 0x0C, 0xF9, /*....{u.f.....!..*/
+    0xA5, 0x24, 0x31, 0x04, 0x7C, 0x5C, 0x72, 0x31, 0xA4,                                           /*.$1.|\r1.*/
+};
+static unsigned char kba_cert_desc[] = {
+    0x30, 0x82, 0x02, 0x58, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x01,
+    0xa1, 0x0e, 0x0c, 0x0c, 0x44, 0x2d, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x47, 0x6d, 0x62, 0x48,
+    0xa2, 0x18, 0x13, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64,
+    0x2d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x6e, 0x65, 0x74, 0xa3, 0x16, 0x0c, 0x14, 0x4b, 0x72,
+    0x61, 0x66, 0x74, 0x66, 0x61, 0x68, 0x72, 0x74, 0x2d, 0x42, 0x75, 0x6e, 0x64, 0x65, 0x73, 0x61,
+    0x6d, 0x74, 0xa4, 0x25, 0x13, 0x23, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77,
+    0x77, 0x2e, 0x6b, 0x62, 0x61, 0x2d, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x2e, 0x64, 0x65, 0x2f,
+    0x76, 0x7a, 0x72, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0xa5, 0x82, 0x01, 0x97, 0x0c, 0x82, 0x01,
+    0x93, 0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x41, 0x6e, 0x73, 0x63, 0x68, 0x72, 0x69, 0x66, 0x74,
+    0x20, 0x75, 0x6e, 0x64, 0x20, 0x45, 0x2d, 0x4d, 0x61, 0x69, 0x6c, 0x2d, 0x41, 0x64, 0x72, 0x65,
+    0x73, 0x73, 0x65, 0x20, 0x64, 0x65, 0x73, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73, 0x74, 0x61, 0x6e,
+    0x62, 0x69, 0x65, 0x74, 0x65, 0x72, 0x73, 0x3a, 0x0d, 0x0a, 0x4b, 0x72, 0x61, 0x66, 0x74, 0x66,
+    0x61, 0x68, 0x72, 0x74, 0x2d, 0x42, 0x75, 0x6e, 0x64, 0x65, 0x73, 0x61, 0x6d, 0x74, 0x0d, 0x0a,
+    0x46, 0xc3, 0xb6, 0x72, 0x64, 0x65, 0x73, 0x74, 0x72, 0x61, 0x73, 0x73, 0x65, 0x20, 0x31, 0x36,
+    0x0d, 0x0a, 0x32, 0x34, 0x39, 0x34, 0x34, 0x20, 0x46, 0x6c, 0x65, 0x6e, 0x73, 0x62, 0x75, 0x72,
+    0x67, 0x0d, 0x0a, 0x56, 0x5a, 0x52, 0x2d, 0x48, 0x69, 0x6c, 0x66, 0x65, 0x40, 0x6b, 0x62, 0x61,
+    0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x0d, 0x0a, 0x47, 0x65, 0x73, 0x63, 0x68, 0xc3, 0xa4, 0x66, 0x74,
+    0x73, 0x7a, 0x77, 0x65, 0x63, 0x6b, 0x3a, 0x0d, 0x0a, 0x2d, 0x20, 0x41, 0x75, 0x73, 0x6b, 0x75,
+    0x6e, 0x66, 0x74, 0x20, 0x61, 0x75, 0x73, 0x20, 0x64, 0x65, 0x6d, 0x20, 0x56, 0x65, 0x72, 0x6b,
+    0x65, 0x68, 0x72, 0x73, 0x7a, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x72, 0x65, 0x67, 0x69, 0x73,
+    0x74, 0x65, 0x72, 0x20, 0x2d, 0x0d, 0x0a, 0x0d, 0x0a, 0x5a, 0x75, 0x73, 0x74, 0xc3, 0xa4, 0x6e,
+    0x64, 0x69, 0x67, 0x65, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a,
+    0x62, 0x65, 0x68, 0xc3, 0xb6, 0x72, 0x64, 0x65, 0x3a, 0x0d, 0x0a, 0x44, 0x65, 0x72, 0x20, 0x42,
+    0x75, 0x6e, 0x64, 0x65, 0x73, 0x62, 0x65, 0x61, 0x75, 0x66, 0x74, 0x72, 0x61, 0x67, 0x74, 0x65,
+    0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20, 0x64, 0x65, 0x6e, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73,
+    0x63, 0x68, 0x75, 0x74, 0x7a, 0x20, 0x75, 0x6e, 0x64, 0x20, 0x64, 0x69, 0x65, 0x20, 0x49, 0x6e,
+    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x66, 0x72, 0x65, 0x69, 0x68, 0x65,
+    0x69, 0x74, 0x0d, 0x0a, 0x48, 0x75, 0x73, 0x61, 0x72, 0x65, 0x6e, 0x73, 0x74, 0x72, 0x61, 0xc3,
+    0x9f, 0x65, 0x20, 0x33, 0x30, 0x0d, 0x0a, 0x35, 0x33, 0x31, 0x31, 0x37, 0x20, 0x42, 0x6f, 0x6e,
+    0x6e, 0x0d, 0x0a, 0x30, 0x32, 0x32, 0x38, 0x2d, 0x39, 0x39, 0x37, 0x37, 0x39, 0x39, 0x2d, 0x30,
+    0x0d, 0x0a, 0x70, 0x6f, 0x73, 0x74, 0x73, 0x74, 0x65, 0x6c, 0x6c, 0x65, 0x40, 0x62, 0x66, 0x64,
+    0x69, 0x2e, 0x62, 0x75, 0x6e, 0x64, 0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x68, 0x74, 0x74, 0x70, 0x3a,
+    0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x62, 0x66, 0x64, 0x69, 0x2e, 0x62, 0x75, 0x6e, 0x64, 0x2e,
+    0x64, 0x65, 0x0d, 0x0a, 0xa7, 0x46, 0x31, 0x44, 0x04, 0x20, 0x80, 0x5a, 0xd7, 0x54, 0x56, 0x8e,
+    0x47, 0x2c, 0x47, 0x61, 0xd5, 0x2d, 0x41, 0x0f, 0xb9, 0x91, 0x28, 0xab, 0x4c, 0xe2, 0xd7, 0x50,
+    0xfd, 0xa3, 0xa8, 0xda, 0x8f, 0xba, 0x67, 0xbb, 0x14, 0xeb, 0x04, 0x20, 0xf4, 0x31, 0x0a, 0x18,
+    0x1e, 0x71, 0x06, 0x4c, 0x36, 0xac, 0x95, 0xa0, 0x66, 0x68, 0xf0, 0xb7, 0x7a, 0x30, 0xd5, 0x99,
+    0x58, 0x67, 0x71, 0x3a, 0x73, 0xe5, 0xf1, 0x28, 0x6e, 0xd9, 0x90, 0x73,
+};
+static unsigned char kba_cert_3[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x82, 0x82, 0x88, 0xe4, 0x86, 0x71, 0xb1, 0xad, 0x46, 0x58, 0x9a, 0x50, 0x73, 0x20, /* A......q..FX.Ps  */
+    0xa1, 0x66, 0x98, 0xf4, 0x95, 0x65, 0x4a, 0x20, 0x07, 0xbe, 0x7b, 0x54, 0x9d, 0x79, 0x71, 0x5b, /* .f...eJ ..{T.yq[ */
+    0x59, 0xc8, 0x61, 0xb6, 0x45, 0x73, 0xe7, 0x5e, 0xf3, 0x7a, 0x74, 0x58, 0xb8, 0x11, 0x5c, 0x78, /* Y.a.Es.^.ztX..\x */
+    0x27, 0xa3, 0xee, 0xda, 0xc7, 0xee, 0x47, 0xe1, 0x86, 0x88, 0x08, 0x7e, 0x4b, 0x66, 0x01, 0x7e, /* '.....G....~Kf.~ */
+    0x0c, 0x05, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x30, /* .._ .DE000007100 */
+    0x35, 0x4a, 0x32, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 5J2.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x01, 0x98, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+    0x07, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, 0x08, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x98, 0x71, 0xac, 0xea, 0x94, /* .......... .q... */
+    0x79, 0xf5, 0xf3, 0x36, 0xb1, 0x24, 0xb8, 0x71, 0xb7, 0xb1, 0xfb, 0x4d, 0xf4, 0x06, 0x46, 0xb8, /* y..6.$.q...M..F. */
+    0x69, 0x35, 0x7c, 0xba, 0x77, 0x4d, 0x3c, 0x10, 0x83, 0x41, 0x97, 0x73, 0x2d, 0x06, 0x09, 0x04, /* i5|.wM<..A.s-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x36, 0x46, 0xb9, 0x42, 0xb1, 0xb1, /* ......... 6F.B.. */
+    0x0e, 0x87, 0x7d, 0x25, 0x67, 0xec, 0x2f, 0xf5, 0x57, 0x7c, 0xd9, 0xa5, 0x95, 0x6d, 0x29, 0x44, /* ..}%g./.W|...m)D */
+    0x4b, 0xad, 0x45, 0xdc, 0x7c, 0x21, 0x9f, 0xce, 0x6a, 0x71, 0x5f, 0x37, 0x40, 0x92, 0x3e, 0x51, /* K.E.|!..jq_7@.>Q */
+    0x82, 0xcc, 0x64, 0x20, 0x77, 0x9b, 0x21, 0xdc, 0xa2, 0x1d, 0x85, 0x57, 0x45, 0xa7, 0x18, 0x5e, /* ..d w.!....WE..^ */
+    0x68, 0x1d, 0xf4, 0x23, 0xa0, 0xb5, 0x5b, 0xd6, 0xc5, 0xee, 0xc5, 0x27, 0x8a, 0x84, 0xa6, 0x2c, /* h..#..[....'..., */
+    0x76, 0x9c, 0x51, 0xe2, 0xf1, 0xa5, 0x3f, 0x9d, 0xab, 0x09, 0x0c, 0xa9, 0x08, 0xbb, 0xfe, 0x84, /* v.Q...?......... */
+    0x41, 0x9d, 0x08, 0xf3, 0xd2, 0x09, 0xd3, 0xc8, 0xa0, 0x73, 0x28, 0xdd, 0x1e,                   /* A........s(.. */
+};
+static unsigned char kba_cert_2[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x06, 0x84, 0x9e, 0xb7, 0x1d, 0x58, 0x39, 0xae, 0x64, 0xa0, 0xcf, 0x53, 0xbc, 0xa3, /* A......X9.d..S.. */
+    0x00, 0xce, 0x90, 0x89, 0xfc, 0x06, 0x00, 0xbd, 0x9b, 0x1b, 0x67, 0x29, 0xb9, 0x37, 0x36, 0xcb, /* ..........g).76. */
+    0xa2, 0x96, 0x2f, 0x70, 0xd6, 0x38, 0xde, 0x95, 0x28, 0x6c, 0x90, 0x0d, 0x9f, 0x4e, 0xd3, 0x08, /* ../p.8..(l...N.. */
+    0x33, 0xa8, 0xce, 0xf1, 0xda, 0x4d, 0xa3, 0x65, 0x7a, 0x84, 0x6a, 0x96, 0xfc, 0xd4, 0x85, 0xa0, /* 3....M.ez.j..... */
+    0x81, 0xcd, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x30, /* .._ .DE000007100 */
+    0x35, 0x47, 0x4d, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 5GM.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x01, 0x98, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+    0x03, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, 0x04, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x98, 0x71, 0xac, 0xea, 0x94, /* .......... .q... */
+    0x79, 0xf5, 0xf3, 0x36, 0xb1, 0x24, 0xb8, 0x71, 0xb7, 0xb1, 0xfb, 0x4d, 0xf4, 0x06, 0x46, 0xb8, /* y..6.$.q...M..F. */
+    0x69, 0x35, 0x7c, 0xba, 0x77, 0x4d, 0x3c, 0x10, 0x83, 0x41, 0x97, 0x73, 0x2d, 0x06, 0x09, 0x04, /* i5|.wM<..A.s-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x36, 0x46, 0xb9, 0x42, 0xb1, 0xb1, /* ......... 6F.B.. */
+    0x0e, 0x87, 0x7d, 0x25, 0x67, 0xec, 0x2f, 0xf5, 0x57, 0x7c, 0xd9, 0xa5, 0x95, 0x6d, 0x29, 0x44, /* ..}%g./.W|...m)D */
+    0x4b, 0xad, 0x45, 0xdc, 0x7c, 0x21, 0x9f, 0xce, 0x6a, 0x71, 0x5f, 0x37, 0x40, 0x5e, 0xb7, 0x6b, /* K.E.|!..jq_7@^.k */
+    0x7a, 0xcc, 0x56, 0x59, 0xfb, 0x97, 0xc2, 0x7a, 0x94, 0xeb, 0xf3, 0xfb, 0x32, 0x74, 0x28, 0x1c, /* z.VY...z....2t(. */
+    0x63, 0xd4, 0x8e, 0x95, 0x9f, 0x6f, 0xf1, 0xb4, 0x37, 0x18, 0x04, 0x86, 0x3d, 0x68, 0x98, 0xf2, /* c....o..7...=h.. */
+    0xcc, 0x62, 0xf2, 0x5d, 0x1c, 0xc0, 0x71, 0x87, 0x26, 0xf7, 0xa6, 0xc2, 0x59, 0xdd, 0x77, 0x54, /* .b.]..q.&...Y.wT */
+    0xe0, 0x04, 0x54, 0xab, 0x6d, 0x2e, 0x13, 0x4d, 0x9f, 0xa3, 0x2b, 0x11, 0x67                    /* ..T.m..M..+.g */
+    };
+static unsigned char kba_dvca_cert_2[] = {
+    0x7f, 0x21, 0x81, 0xe7, 0x7f, 0x4e, 0x81, 0xa0, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45, /* .!...N.._)..B.DE */
+    0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, 0x4f, 0x06, /* CVCAeID00102.IO. */
+    0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x46, 0x5f, /* ............A.F_ */
+    0x4b, 0x87, 0x11, 0xde, 0x56, 0xa2, 0x4a, 0x03, 0x1a, 0xec, 0xc3, 0x74, 0x8c, 0x0a, 0x13, 0xa6, /* K...V.J....t.... */
+    0x3f, 0x56, 0x67, 0x5c, 0x8d, 0xfc, 0x76, 0x8e, 0x1f, 0xfe, 0x69, 0xf9, 0x92, 0x19, 0x2d, 0xab, /* ?Vg\..v...i...-. */
+    0x1a, 0x41, 0xec, 0x37, 0xc3, 0xae, 0x23, 0xe1, 0x53, 0x90, 0x65, 0x44, 0xab, 0x9b, 0x84, 0xb4, /* .A.7..#.S.eD.... */
+    0x50, 0xc0, 0xbf, 0x2e, 0xe4, 0x62, 0x57, 0x6a, 0x33, 0xf4, 0xa5, 0x0a, 0x17, 0x07, 0x5f, 0x20, /* P....bWj3....._  */
+    0x10, 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, /* .DEDVeIDDTR10140 */
+    0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, /* 1.L............S */
+    0x05, 0x40, 0x05, 0x01, 0xff, 0x87, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x5f, /* .@...._%......._ */
+    0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x07, 0x5f, 0x37, 0x40, 0x1b, 0x93, 0x4a, 0x7e, 0xc4, /* $......._7@..J~. */
+    0xd2, 0x01, 0xe8, 0xae, 0xb0, 0xe3, 0xbe, 0xda, 0x06, 0x60, 0x6b, 0x7b, 0x47, 0x10, 0xaf, 0xd3, /* .........`k{G... */
+    0x9a, 0x13, 0x14, 0x7d, 0x63, 0x2c, 0xf6, 0x72, 0xd6, 0x4b, 0x2f, 0x94, 0xd9, 0x93, 0x55, 0xad, /* ...}c,.r.K/...U. */
+    0x4a, 0x3b, 0x16, 0x07, 0x04, 0x86, 0x14, 0x9e, 0xd3, 0x53, 0xe0, 0xdc, 0x9d, 0x8c, 0xa7, 0x6b, /* J;.......S.....k */
+    0x28, 0xf7, 0x94, 0x33, 0x07, 0x3b, 0x43, 0x40, 0xb3, 0x8e, 0x97                                /* (..3.;C@... */
+};
+static unsigned char kba_cert_desc_2[] = {
+    0x30, 0x82, 0x02, 0x7a, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x01,
+    0xa1, 0x0e, 0x0c, 0x0c, 0x44, 0x2d, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x47, 0x6d, 0x62, 0x48,
+    0xa2, 0x18, 0x13, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64,
+    0x2d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x6e, 0x65, 0x74, 0xa3, 0x16, 0x0c, 0x14, 0x4b, 0x72,
+    0x61, 0x66, 0x74, 0x66, 0x61, 0x68, 0x72, 0x74, 0x2d, 0x42, 0x75, 0x6e, 0x64, 0x65, 0x73, 0x61,
+    0x6d, 0x74, 0xa4, 0x25, 0x13, 0x23, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77,
+    0x77, 0x2e, 0x6b, 0x62, 0x61, 0x2d, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x2e, 0x64, 0x65, 0x2f,
+    0x76, 0x7a, 0x72, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0xa5, 0x82, 0x01, 0x97, 0x0c, 0x82, 0x01,
+    0x93, 0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x41, 0x6e, 0x73, 0x63, 0x68, 0x72, 0x69, 0x66, 0x74,
+    0x20, 0x75, 0x6e, 0x64, 0x20, 0x45, 0x2d, 0x4d, 0x61, 0x69, 0x6c, 0x2d, 0x41, 0x64, 0x72, 0x65,
+    0x73, 0x73, 0x65, 0x20, 0x64, 0x65, 0x73, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73, 0x74, 0x61, 0x6e,
+    0x62, 0x69, 0x65, 0x74, 0x65, 0x72, 0x73, 0x3a, 0x0d, 0x0a, 0x4b, 0x72, 0x61, 0x66, 0x74, 0x66,
+    0x61, 0x68, 0x72, 0x74, 0x2d, 0x42, 0x75, 0x6e, 0x64, 0x65, 0x73, 0x61, 0x6d, 0x74, 0x0d, 0x0a,
+    0x46, 0xc3, 0xb6, 0x72, 0x64, 0x65, 0x73, 0x74, 0x72, 0x61, 0x73, 0x73, 0x65, 0x20, 0x31, 0x36,
+    0x0d, 0x0a, 0x32, 0x34, 0x39, 0x34, 0x34, 0x20, 0x46, 0x6c, 0x65, 0x6e, 0x73, 0x62, 0x75, 0x72,
+    0x67, 0x0d, 0x0a, 0x56, 0x5a, 0x52, 0x2d, 0x48, 0x69, 0x6c, 0x66, 0x65, 0x40, 0x6b, 0x62, 0x61,
+    0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x0d, 0x0a, 0x47, 0x65, 0x73, 0x63, 0x68, 0xc3, 0xa4, 0x66, 0x74,
+    0x73, 0x7a, 0x77, 0x65, 0x63, 0x6b, 0x3a, 0x0d, 0x0a, 0x2d, 0x20, 0x41, 0x75, 0x73, 0x6b, 0x75,
+    0x6e, 0x66, 0x74, 0x20, 0x61, 0x75, 0x73, 0x20, 0x64, 0x65, 0x6d, 0x20, 0x56, 0x65, 0x72, 0x6b,
+    0x65, 0x68, 0x72, 0x73, 0x7a, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x72, 0x65, 0x67, 0x69, 0x73,
+    0x74, 0x65, 0x72, 0x20, 0x2d, 0x0d, 0x0a, 0x0d, 0x0a, 0x5a, 0x75, 0x73, 0x74, 0xc3, 0xa4, 0x6e,
+    0x64, 0x69, 0x67, 0x65, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a,
+    0x62, 0x65, 0x68, 0xc3, 0xb6, 0x72, 0x64, 0x65, 0x3a, 0x0d, 0x0a, 0x44, 0x65, 0x72, 0x20, 0x42,
+    0x75, 0x6e, 0x64, 0x65, 0x73, 0x62, 0x65, 0x61, 0x75, 0x66, 0x74, 0x72, 0x61, 0x67, 0x74, 0x65,
+    0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20, 0x64, 0x65, 0x6e, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73,
+    0x63, 0x68, 0x75, 0x74, 0x7a, 0x20, 0x75, 0x6e, 0x64, 0x20, 0x64, 0x69, 0x65, 0x20, 0x49, 0x6e,
+    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x66, 0x72, 0x65, 0x69, 0x68, 0x65,
+    0x69, 0x74, 0x0d, 0x0a, 0x48, 0x75, 0x73, 0x61, 0x72, 0x65, 0x6e, 0x73, 0x74, 0x72, 0x61, 0xc3,
+    0x9f, 0x65, 0x20, 0x33, 0x30, 0x0d, 0x0a, 0x35, 0x33, 0x31, 0x31, 0x37, 0x20, 0x42, 0x6f, 0x6e,
+    0x6e, 0x0d, 0x0a, 0x30, 0x32, 0x32, 0x38, 0x2d, 0x39, 0x39, 0x37, 0x37, 0x39, 0x39, 0x2d, 0x30,
+    0x0d, 0x0a, 0x70, 0x6f, 0x73, 0x74, 0x73, 0x74, 0x65, 0x6c, 0x6c, 0x65, 0x40, 0x62, 0x66, 0x64,
+    0x69, 0x2e, 0x62, 0x75, 0x6e, 0x64, 0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x68, 0x74, 0x74, 0x70, 0x3a,
+    0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x62, 0x66, 0x64, 0x69, 0x2e, 0x62, 0x75, 0x6e, 0x64, 0x2e,
+    0x64, 0x65, 0x0d, 0x0a, 0xa7, 0x68, 0x31, 0x66, 0x04, 0x20, 0x2e, 0x15, 0x78, 0x88, 0x58, 0xe5,
+    0x6a, 0x91, 0xa4, 0x59, 0xbb, 0x70, 0x86, 0x94, 0x3a, 0x5a, 0x3a, 0xb8, 0x79, 0xf8, 0x8f, 0x72,
+    0xee, 0xe7, 0x2d, 0x5b, 0x82, 0x02, 0xb0, 0x35, 0x94, 0x3d, 0x04, 0x20, 0x80, 0x5a, 0xd7, 0x54,
+    0x56, 0x8e, 0x47, 0x2c, 0x47, 0x61, 0xd5, 0x2d, 0x41, 0x0f, 0xb9, 0x91, 0x28, 0xab, 0x4c, 0xe2,
+    0xd7, 0x50, 0xfd, 0xa3, 0xa8, 0xda, 0x8f, 0xba, 0x67, 0xbb, 0x14, 0xeb, 0x04, 0x20, 0xf4, 0x31,
+    0x0a, 0x18, 0x1e, 0x71, 0x06, 0x4c, 0x36, 0xac, 0x95, 0xa0, 0x66, 0x68, 0xf0, 0xb7, 0x7a, 0x30,
+    0xd5, 0x99, 0x58, 0x67, 0x71, 0x3a, 0x73, 0xe5, 0xf1, 0x28, 0x6e, 0xd9, 0x90, 0x73,
+};
+static unsigned char kba_cert_4[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x4f, 0x27, 0x73, 0x2a, 0x5a, 0x78, 0x79, 0x3e, 0xe6, 0x6d, 0x2c, 0x33, 0x8b, 0x43, /* A.O's*Zxy>.m,3.C */
+    0x7c, 0x1f, 0x38, 0x58, 0x0b, 0x1b, 0xa0, 0x68, 0x92, 0xc3, 0xc7, 0x18, 0x48, 0x1f, 0xc4, 0x7e, /* |.8X...h....H..~ */
+    0x16, 0xdf, 0x14, 0x1d, 0xf3, 0x81, 0xcd, 0xd1, 0xee, 0x45, 0xf9, 0xeb, 0x60, 0x54, 0x8d, 0x2b, /* .........E..`T.+ */
+    0x97, 0x2b, 0x74, 0x65, 0xc2, 0x9a, 0xbb, 0x03, 0x14, 0x1d, 0x7e, 0xe0, 0x38, 0x26, 0xe5, 0x04, /* .+te......~.8&.. */
+    0x41, 0xc5, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x37, 0x31, 0x30, 0x30, /* A._ .DE000007100 */
+    0x35, 0x4b, 0x41, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 5KA.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x01, 0x98, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+    0x09, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x00, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x98, 0x71, 0xac, 0xea, 0x94, /* .......... .q... */
+    0x79, 0xf5, 0xf3, 0x36, 0xb1, 0x24, 0xb8, 0x71, 0xb7, 0xb1, 0xfb, 0x4d, 0xf4, 0x06, 0x46, 0xb8, /* y..6.$.q...M..F. */
+    0x69, 0x35, 0x7c, 0xba, 0x77, 0x4d, 0x3c, 0x10, 0x83, 0x41, 0x97, 0x73, 0x2d, 0x06, 0x09, 0x04, /* i5|.wM<..A.s-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x36, 0x46, 0xb9, 0x42, 0xb1, 0xb1, /* ......... 6F.B.. */
+    0x0e, 0x87, 0x7d, 0x25, 0x67, 0xec, 0x2f, 0xf5, 0x57, 0x7c, 0xd9, 0xa5, 0x95, 0x6d, 0x29, 0x44, /* ..}%g./.W|...m)D */
+    0x4b, 0xad, 0x45, 0xdc, 0x7c, 0x21, 0x9f, 0xce, 0x6a, 0x71, 0x5f, 0x37, 0x40, 0x11, 0xb8, 0x53, /* K.E.|!..jq_7@..S */
+    0xd8, 0x71, 0x95, 0xb3, 0x40, 0xfd, 0x78, 0xa3, 0x97, 0x01, 0xfe, 0xf3, 0xab, 0xdb, 0x94, 0x12, /* .q..@.x......... */
+    0x1e, 0xb5, 0x9c, 0xc5, 0xfd, 0x50, 0x35, 0xdc, 0xfc, 0xa3, 0xd6, 0x52, 0xa0, 0x85, 0x67, 0xaf, /* .....P5....R..g. */
+    0x8c, 0x13, 0xc1, 0x3b, 0x02, 0x23, 0x84, 0xc9, 0xc4, 0x76, 0x6c, 0x6c, 0x41, 0x99, 0xa4, 0xa1, /* ...;.#...vllA... */
+    0x13, 0x26, 0x6e, 0xbf, 0x5f, 0xe5, 0xd8, 0x73, 0x8e, 0x65, 0x51, 0xb0, 0x14,                   /* .&n._..s.eQ.. */
+    };
+
+/* https://www.meineschufa.de/index.php */
+static unsigned char schufa_cert[] = {
+   0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10,
+   0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31,
+   0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+   0x41, 0x04, 0x30, 0x56, 0xd3, 0xf8, 0x41, 0x9d, 0xc5, 0x2f, 0x8c, 0xcb, 0xfc, 0x26, 0xe5, 0x83,
+   0x70, 0x86, 0x63, 0xaa, 0x4b, 0x4a, 0xc6, 0xd9, 0x90, 0x43, 0xa5, 0x9a, 0x0e, 0x08, 0xa1, 0x69,
+   0x44, 0x59, 0x2d, 0xbc, 0x38, 0x7d, 0xe0, 0x1a, 0x10, 0x1e, 0x50, 0x35, 0xdb, 0x63, 0x2e, 0x17,
+   0xaf, 0x39, 0x12, 0x66, 0x2d, 0x31, 0xce, 0x31, 0x73, 0x56, 0x9e, 0xc9, 0x98, 0xe9, 0xf6, 0x18,
+   0xdc, 0x3f, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x35, 0x30, 0x30,
+   0x34, 0x46, 0x46, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02,
+   0x02, 0x53, 0x05, 0x00, 0x01, 0x01, 0xd8, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x02, 0x00,
+   0x09, 0x5f, 0x24, 0x06, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09,
+   0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x8d, 0xd1, 0x91, 0xb4, 0x1b,
+   0x37, 0x63, 0x0e, 0x7e, 0x75, 0x9b, 0xb2, 0xe1, 0x0f, 0xb5, 0x0a, 0x7c, 0x59, 0x84, 0xdb, 0x09,
+   0x6a, 0x77, 0x14, 0xbe, 0x17, 0xbe, 0x54, 0x0c, 0x7c, 0x2d, 0x9d, 0x73, 0x2d, 0x06, 0x09, 0x04,
+   0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x17, 0xf5, 0x83, 0xb9, 0xdb, 0x3f,
+   0x79, 0x01, 0xa6, 0x05, 0xc3, 0x4e, 0xe1, 0x81, 0x02, 0x28, 0xa9, 0xd2, 0x03, 0x98, 0x57, 0x92,
+   0xc8, 0x2f, 0xb6, 0x37, 0x28, 0x24, 0x98, 0x5a, 0x66, 0x1d, 0x5f, 0x37, 0x40, 0x5c, 0xb1, 0x30,
+   0x87, 0xba, 0x2e, 0xd6, 0xf9, 0x66, 0x47, 0xae, 0x0f, 0xca, 0x6a, 0x7c, 0x51, 0xfa, 0xdb, 0xd9,
+   0x1e, 0x20, 0x78, 0xdd, 0x70, 0x68, 0x56, 0xd5, 0x27, 0xa8, 0x34, 0xf9, 0xdc, 0x88, 0x1c, 0x2a,
+   0x7b, 0x4c, 0x1d, 0xd8, 0x52, 0xf5, 0x8c, 0xe4, 0x1f, 0xfb, 0xd2, 0x79, 0x21, 0x71, 0x3d, 0xa6,
+   0x3a, 0x59, 0xf6, 0xae, 0xe2, 0xed, 0xbe, 0xe0, 0x9c, 0xc2, 0x3c, 0x9f, 0x26,
+};
+static unsigned char schufa_dvcert[] = {
+   0x7f, 0x21, 0x81, 0xe7, 0x7f, 0x4e, 0x81, 0xa0, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45,
+   0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, 0x4f, 0x06,
+   0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x46, 0x5f,
+   0x4b, 0x87, 0x11, 0xde, 0x56, 0xa2, 0x4a, 0x03, 0x1a, 0xec, 0xc3, 0x74, 0x8c, 0x0a, 0x13, 0xa6,
+   0x3f, 0x56, 0x67, 0x5c, 0x8d, 0xfc, 0x76, 0x8e, 0x1f, 0xfe, 0x69, 0xf9, 0x92, 0x19, 0x2d, 0xab,
+   0x1a, 0x41, 0xec, 0x37, 0xc3, 0xae, 0x23, 0xe1, 0x53, 0x90, 0x65, 0x44, 0xab, 0x9b, 0x84, 0xb4,
+   0x50, 0xc0, 0xbf, 0x2e, 0xe4, 0x62, 0x57, 0x6a, 0x33, 0xf4, 0xa5, 0x0a, 0x17, 0x07, 0x5f, 0x20,
+   0x10, 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30,
+   0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53,
+   0x05, 0x40, 0x05, 0x01, 0xff, 0x87, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x5f,
+   0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x07, 0x5f, 0x37, 0x40, 0x1b, 0x93, 0x4a, 0x7e, 0xc4,
+   0xd2, 0x01, 0xe8, 0xae, 0xb0, 0xe3, 0xbe, 0xda, 0x06, 0x60, 0x6b, 0x7b, 0x47, 0x10, 0xaf, 0xd3,
+   0x9a, 0x13, 0x14, 0x7d, 0x63, 0x2c, 0xf6, 0x72, 0xd6, 0x4b, 0x2f, 0x94, 0xd9, 0x93, 0x55, 0xad,
+   0x4a, 0x3b, 0x16, 0x07, 0x04, 0x86, 0x14, 0x9e, 0xd3, 0x53, 0xe0, 0xdc, 0x9d, 0x8c, 0xa7, 0x6b,
+   0x28, 0xf7, 0x94, 0x33, 0x07, 0x3b, 0x43, 0x40, 0xb3, 0x8e, 0x97
+};
+static unsigned char schufa_desc[] = {
+   0x30, 0x82, 0x03, 0x1b, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x01,
+   0xa1, 0x0e, 0x0c, 0x0c, 0x44, 0x2d, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x47, 0x6d, 0x62, 0x48,
+   0xa2, 0x18, 0x13, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64,
+   0x2d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x6e, 0x65, 0x74, 0xa3, 0x13, 0x0c, 0x11, 0x53, 0x43,
+   0x48, 0x55, 0x46, 0x41, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x41, 0x47, 0xa4,
+   0x1b, 0x13, 0x19, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6d, 0x65,
+   0x69, 0x6e, 0x65, 0x53, 0x43, 0x48, 0x55, 0x46, 0x41, 0x2e, 0x64, 0x65, 0xa5, 0x82, 0x02, 0x21,
+   0x0c, 0x82, 0x02, 0x1d, 0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x41, 0x6e, 0x73, 0x63, 0x68, 0x72,
+   0x69, 0x66, 0x74, 0x20, 0x75, 0x6e, 0x64, 0x20, 0x45, 0x2d, 0x4d, 0x61, 0x69, 0x6c, 0x2d, 0x41,
+   0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x20, 0x64, 0x65, 0x73, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73,
+   0x74, 0x65, 0x61, 0x6e, 0x62, 0x69, 0x65, 0x74, 0x65, 0x72, 0x73, 0x3a, 0x0d, 0x0a, 0x53, 0x43,
+   0x48, 0x55, 0x46, 0x41, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x41, 0x47, 0x0d,
+   0x0a, 0x4b, 0x6f, 0x72, 0x6d, 0x6f, 0x72, 0x61, 0x6e, 0x77, 0x65, 0x67, 0x20, 0x35, 0x0d, 0x0a,
+   0x36, 0x35, 0x32, 0x30, 0x31, 0x20, 0x57, 0x69, 0x65, 0x73, 0x62, 0x61, 0x64, 0x65, 0x6e, 0x0d,
+   0x0a, 0x65, 0x70, 0x61, 0x40, 0x73, 0x63, 0x68, 0x75, 0x66, 0x61, 0x2e, 0x64, 0x65, 0x0d, 0x0a,
+   0x0d, 0x0a, 0x47, 0x65, 0x73, 0x63, 0x68, 0xc3, 0xa4, 0x66, 0x74, 0x73, 0x7a, 0x77, 0x65, 0x63,
+   0x6b, 0x3a, 0x0d, 0x0a, 0x2d, 0x20, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x69, 0x65, 0x72,
+   0x75, 0x6e, 0x67, 0x20, 0x75, 0x6e, 0x64, 0x20, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x20, 0x61, 0x6d,
+   0x20, 0x50, 0x6f, 0x72, 0x74, 0x61, 0x6c, 0x20, 0x22, 0x4d, 0x65, 0x69, 0x6e, 0x65, 0x20, 0x53,
+   0x43, 0x48, 0x55, 0x46, 0x41, 0x2d, 0x41, 0x75, 0x73, 0x6b, 0x75, 0x6e, 0x66, 0x74, 0x20, 0x4f,
+   0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x22, 0x2d, 0x0d, 0x0a, 0x0d, 0x0a, 0x48, 0x69, 0x6e, 0x77, 0x65,
+   0x69, 0x73, 0x20, 0x61, 0x75, 0x66, 0x20, 0x64, 0x69, 0x65, 0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20,
+   0x64, 0x65, 0x6e, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x6e, 0x62, 0x69, 0x65,
+   0x74, 0x65, 0x72, 0x20, 0x7a, 0x75, 0x73, 0x74, 0xc3, 0xa4, 0x6e, 0x64, 0x69, 0x67, 0x65, 0x6e,
+   0x20, 0x53, 0x74, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x2c, 0x20, 0x64, 0x69, 0x65, 0x20, 0x64, 0x69,
+   0x65, 0x20, 0x45, 0x69, 0x6e, 0x68, 0x61, 0x6c, 0x74, 0x75, 0x6e, 0x67, 0x20, 0x64, 0x65, 0x72,
+   0x20, 0x56, 0x6f, 0x72, 0x73, 0x63, 0x68, 0x72, 0x69, 0x66, 0x74, 0x65, 0x6e, 0x20, 0x7a, 0x75,
+   0x6d, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x20, 0x6b, 0x6f,
+   0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x65, 0x6e, 0x3a, 0x0d, 0x0a, 0x44, 0x65,
+   0x72, 0x20, 0x48, 0x65, 0x73, 0x73, 0x69, 0x73, 0x63, 0x68, 0x65, 0x20, 0x44, 0x61, 0x74, 0x65,
+   0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x62, 0x65, 0x61, 0x75, 0x66, 0x74, 0x72, 0x61, 0x67,
+   0x74, 0x65, 0x0d, 0x0a, 0x4c, 0x75, 0x69, 0x73, 0x65, 0x6e, 0x70, 0x6c, 0x61, 0x74, 0x7a, 0x20,
+   0x32, 0x0d, 0x0a, 0x36, 0x34, 0x32, 0x38, 0x33, 0x20, 0x44, 0x61, 0x72, 0x6d, 0x73, 0x74, 0x61,
+   0x64, 0x74, 0x0d, 0x0a, 0x30, 0x36, 0x31, 0x35, 0x31, 0x2f, 0x31, 0x32, 0x2d, 0x30, 0x0d, 0x0a,
+   0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x40, 0x72, 0x70, 0x64, 0x61,
+   0x2e, 0x68, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x68, 0x74, 0x74, 0x70,
+   0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x72, 0x70, 0x2d, 0x64, 0x61, 0x72, 0x6d, 0x73, 0x74,
+   0x61, 0x64, 0x74, 0x2e, 0x68, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x2e, 0x64, 0x65, 0x2f, 0x0d, 0x0a,
+   0x41, 0x6e, 0x73, 0x70, 0x72, 0x65, 0x63, 0x68, 0x70, 0x61, 0x72, 0x74, 0x6e, 0x65, 0x72, 0x3a,
+   0x20, 0x50, 0x72, 0x6f, 0x66, 0x2e, 0x20, 0x44, 0x72, 0x2e, 0x20, 0x4d, 0x69, 0x63, 0x68, 0x61,
+   0x65, 0x6c, 0x20, 0x52, 0x6f, 0x6e, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x66, 0x69, 0x74, 0x73, 0x63,
+   0x68, 0xa7, 0x81, 0x8b, 0x31, 0x81, 0x88, 0x04, 0x20, 0x2e, 0x15, 0x78, 0x88, 0x58, 0xe5, 0x6a,
+   0x91, 0xa4, 0x59, 0xbb, 0x70, 0x86, 0x94, 0x3a, 0x5a, 0x3a, 0xb8, 0x79, 0xf8, 0x8f, 0x72, 0xee,
+   0xe7, 0x2d, 0x5b, 0x82, 0x02, 0xb0, 0x35, 0x94, 0x3d, 0x04, 0x20, 0x80, 0x5a, 0xd7, 0x54, 0x56,
+   0x8e, 0x47, 0x2c, 0x47, 0x61, 0xd5, 0x2d, 0x41, 0x0f, 0xb9, 0x91, 0x28, 0xab, 0x4c, 0xe2, 0xd7,
+   0x50, 0xfd, 0xa3, 0xa8, 0xda, 0x8f, 0xba, 0x67, 0xbb, 0x14, 0xeb, 0x04, 0x20, 0xab, 0xf4, 0x75,
+   0xcb, 0xa2, 0xf2, 0xc1, 0x10, 0xaf, 0x75, 0x49, 0x38, 0xe6, 0x2d, 0x58, 0xd1, 0xa9, 0x2f, 0x6e,
+   0x05, 0x10, 0x1e, 0x98, 0x48, 0xc2, 0x8c, 0x45, 0x82, 0x3d, 0x43, 0xdd, 0x30, 0x04, 0x20, 0xea,
+   0x58, 0xa5, 0xe7, 0xcc, 0xa4, 0x9c, 0x0b, 0xa6, 0x19, 0x10, 0x12, 0x2f, 0x8a, 0x5a, 0x37, 0xe2,
+   0x8c, 0x2a, 0x8b, 0xde, 0x34, 0xd3, 0xdb, 0xc2, 0xf7, 0xcc, 0xe4, 0x36, 0xb8, 0x09, 0xdc,
+};
+
+/* https://makler.allianz.de/wps/myportal/epa/login?TARGETURL=/wps/myportal/tw/makler.allianz.de/index.html?smartcard=false */
+static unsigned char allianz_desc[] = {
+   0x30, 0x82, 0x03, 0x86, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x01,
+   0xa1, 0x0e, 0x0c, 0x0c, 0x44, 0x2d, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x47, 0x6d, 0x62, 0x48,
+   0xa2, 0x18, 0x13, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64,
+   0x2d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x6e, 0x65, 0x74, 0xa3, 0x18, 0x0c, 0x16, 0x41, 0x6c,
+   0x6c, 0x69, 0x61, 0x6e, 0x7a, 0x20, 0x44, 0x65, 0x75, 0x74, 0x73, 0x63, 0x68, 0x6c, 0x61, 0x6e,
+   0x64, 0x20, 0x41, 0x47, 0xa4, 0x0c, 0x13, 0x0a, 0x61, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x7a, 0x2e,
+   0x64, 0x65, 0xa5, 0x82, 0x02, 0x96, 0x0c, 0x82, 0x02, 0x92, 0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20,
+   0x41, 0x6e, 0x73, 0x63, 0x68, 0x72, 0x69, 0x66, 0x74, 0x20, 0x75, 0x6e, 0x64, 0x20, 0x45, 0x2d,
+   0x4d, 0x61, 0x69, 0x6c, 0x2d, 0x41, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x20, 0x64, 0x65, 0x73,
+   0x20, 0x44, 0x69, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x6e, 0x62, 0x69, 0x65, 0x74, 0x65, 0x72,
+   0x73, 0x3a, 0x0d, 0x0a, 0x41, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x7a, 0x20, 0x44, 0x65, 0x75, 0x74,
+   0x73, 0x63, 0x68, 0x6c, 0x61, 0x6e, 0x64, 0x20, 0x41, 0x47, 0x0d, 0x0a, 0x4b, 0xc3, 0xb6, 0x6e,
+   0x69, 0x67, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x61, 0xc3, 0x9f, 0x65, 0x20, 0x32, 0x38, 0x0d, 0x0a,
+   0x38, 0x30, 0x38, 0x30, 0x32, 0x20, 0x4d, 0xc3, 0xbc, 0x6e, 0x63, 0x68, 0x65, 0x6e, 0x0d, 0x0a,
+   0x69, 0x6e, 0x66, 0x6f, 0x40, 0x61, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x7a, 0x2e, 0x64, 0x65, 0x0d,
+   0x0a, 0x0d, 0x0a, 0x47, 0x65, 0x73, 0x63, 0x68, 0xc3, 0xa4, 0x66, 0x74, 0x73, 0x7a, 0x77, 0x65,
+   0x63, 0x6b, 0x3a, 0x0d, 0x0a, 0x2d, 0x20, 0x44, 0x69, 0x65, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e,
+   0x20, 0x64, 0x65, 0x73, 0x20, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x61, 0x75, 0x73,
+   0x77, 0x65, 0x69, 0x73, 0x65, 0x73, 0x20, 0x77, 0x65, 0x72, 0x64, 0x65, 0x6e, 0x20, 0x76, 0x6f,
+   0x6e, 0x20, 0x64, 0x65, 0x72, 0x20, 0x41, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x7a, 0x20, 0x44, 0x65,
+   0x75, 0x74, 0x73, 0x63, 0x68, 0x6c, 0x61, 0x6e, 0x64, 0x20, 0x41, 0x47, 0x20, 0x7a, 0x75, 0x6d,
+   0x20, 0x5a, 0x77, 0x65, 0x63, 0x6b, 0x20, 0x64, 0x65, 0x72, 0x20, 0x49, 0x64, 0x65, 0x6e, 0x74,
+   0x69, 0x66, 0x69, 0x7a, 0x69, 0x65, 0x72, 0x75, 0x6e, 0x67, 0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20,
+   0x64, 0x69, 0x65, 0x20, 0x4e, 0x75, 0x74, 0x7a, 0x75, 0x6e, 0x67, 0x20, 0x76, 0x6f, 0x6e, 0x20,
+   0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
+   0x73, 0x20, 0x76, 0x65, 0x72, 0x77, 0x65, 0x6e, 0x64, 0x65, 0x74, 0x2e, 0x20, 0x2d, 0x0d, 0x0a,
+   0x0d, 0x0a, 0x48, 0x69, 0x6e, 0x77, 0x65, 0x69, 0x73, 0x20, 0x61, 0x75, 0x66, 0x20, 0x64, 0x69,
+   0x65, 0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20, 0x64, 0x65, 0x6e, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73,
+   0x74, 0x65, 0x61, 0x6e, 0x62, 0x69, 0x65, 0x74, 0x65, 0x72, 0x20, 0x7a, 0x75, 0x73, 0x74, 0xc3,
+   0xa4, 0x6e, 0x64, 0x69, 0x67, 0x65, 0x6e, 0x20, 0x53, 0x74, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x2c,
+   0x20, 0x64, 0x69, 0x65, 0x20, 0x64, 0x69, 0x65, 0x20, 0x45, 0x69, 0x6e, 0x68, 0x61, 0x6c, 0x74,
+   0x75, 0x6e, 0x67, 0x20, 0x64, 0x65, 0x72, 0x20, 0x56, 0x6f, 0x72, 0x73, 0x63, 0x68, 0x72, 0x69,
+   0x66, 0x74, 0x65, 0x6e, 0x20, 0x7a, 0x75, 0x6d, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63,
+   0x68, 0x75, 0x74, 0x7a, 0x20, 0x6b, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x69, 0x65, 0x72,
+   0x65, 0x6e, 0x3a, 0x0d, 0x0a, 0x44, 0x65, 0x72, 0x20, 0x42, 0x61, 0x79, 0x65, 0x72, 0x69, 0x73,
+   0x63, 0x68, 0x65, 0x20, 0x4c, 0x61, 0x6e, 0x64, 0x65, 0x73, 0x62, 0x65, 0x61, 0x75, 0x66, 0x74,
+   0x72, 0x61, 0x67, 0x74, 0x65, 0x20, 0x66, 0xc3, 0xbc, 0x72, 0x20, 0x64, 0x65, 0x6e, 0x20, 0x44,
+   0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x0d, 0x0a, 0x57, 0x61, 0x67, 0x6d,
+   0xc3, 0xbc, 0x6c, 0x6c, 0x65, 0x72, 0x73, 0x74, 0x72, 0x61, 0xc3, 0x9f, 0x65, 0x20, 0x31, 0x38,
+   0x0d, 0x0a, 0x38, 0x30, 0x35, 0x33, 0x38, 0x20, 0x4d, 0xc3, 0xbc, 0x6e, 0x63, 0x68, 0x65, 0x6e,
+   0x0d, 0x0a, 0x30, 0x38, 0x39, 0x20, 0x2f, 0x20, 0x32, 0x31, 0x20, 0x32, 0x36, 0x20, 0x37, 0x32,
+   0x20, 0x2d, 0x20, 0x30, 0x0d, 0x0a, 0x70, 0x6f, 0x73, 0x74, 0x73, 0x74, 0x65, 0x6c, 0x6c, 0x65,
+   0x40, 0x64, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x2d, 0x62, 0x61, 0x79,
+   0x65, 0x72, 0x6e, 0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77,
+   0x77, 0x77, 0x2e, 0x64, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x2d, 0x62,
+   0x61, 0x79, 0x65, 0x72, 0x6e, 0x2e, 0x64, 0x65, 0x2f, 0x0d, 0x0a, 0x41, 0x6e, 0x73, 0x70, 0x72,
+   0x65, 0x63, 0x68, 0x70, 0x61, 0x72, 0x74, 0x6e, 0x65, 0x72, 0x3a, 0x20, 0x44, 0x72, 0x2e, 0x20,
+   0x54, 0x68, 0x6f, 0x6d, 0x61, 0x73, 0x20, 0x50, 0x65, 0x74, 0x72, 0x69, 0xa7, 0x81, 0x8b, 0x31,
+   0x81, 0x88, 0x04, 0x20, 0x2e, 0x15, 0x78, 0x88, 0x58, 0xe5, 0x6a, 0x91, 0xa4, 0x59, 0xbb, 0x70,
+   0x86, 0x94, 0x3a, 0x5a, 0x3a, 0xb8, 0x79, 0xf8, 0x8f, 0x72, 0xee, 0xe7, 0x2d, 0x5b, 0x82, 0x02,
+   0xb0, 0x35, 0x94, 0x3d, 0x04, 0x20, 0x79, 0x2e, 0x9e, 0xca, 0xb7, 0xec, 0x8b, 0x07, 0x40, 0x77,
+   0xab, 0x95, 0x4e, 0x3a, 0xfa, 0x9c, 0xea, 0xfe, 0xe9, 0x61, 0x39, 0x2f, 0x91, 0xc1, 0x1e, 0x6f,
+   0x27, 0xec, 0x08, 0xa1, 0x6f, 0x6d, 0x04, 0x20, 0x80, 0x5a, 0xd7, 0x54, 0x56, 0x8e, 0x47, 0x2c,
+   0x47, 0x61, 0xd5, 0x2d, 0x41, 0x0f, 0xb9, 0x91, 0x28, 0xab, 0x4c, 0xe2, 0xd7, 0x50, 0xfd, 0xa3,
+   0xa8, 0xda, 0x8f, 0xba, 0x67, 0xbb, 0x14, 0xeb, 0x04, 0x20, 0xb9, 0x9a, 0x7b, 0x5d, 0x20, 0x3c,
+   0x80, 0x29, 0xa4, 0x6d, 0xe4, 0xd5, 0x96, 0xe6, 0x46, 0x41, 0x5a, 0x4c, 0xcf, 0xc9, 0x46, 0x13,
+   0xbc, 0xc7, 0x70, 0x88, 0x64, 0x8c, 0xdc, 0x9f, 0xe1, 0xa7,
+};
+static unsigned char allianz_dvcert[] = {
+   0x7f, 0x21, 0x81, 0xe7, 0x7f, 0x4e, 0x81, 0xa0, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45,
+   0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, 0x4f, 0x06,
+   0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x46, 0x5f,
+   0x4b, 0x87, 0x11, 0xde, 0x56, 0xa2, 0x4a, 0x03, 0x1a, 0xec, 0xc3, 0x74, 0x8c, 0x0a, 0x13, 0xa6,
+   0x3f, 0x56, 0x67, 0x5c, 0x8d, 0xfc, 0x76, 0x8e, 0x1f, 0xfe, 0x69, 0xf9, 0x92, 0x19, 0x2d, 0xab,
+   0x1a, 0x41, 0xec, 0x37, 0xc3, 0xae, 0x23, 0xe1, 0x53, 0x90, 0x65, 0x44, 0xab, 0x9b, 0x84, 0xb4,
+   0x50, 0xc0, 0xbf, 0x2e, 0xe4, 0x62, 0x57, 0x6a, 0x33, 0xf4, 0xa5, 0x0a, 0x17, 0x07, 0x5f, 0x20,
+   0x10, 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30,
+   0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53,
+   0x05, 0x40, 0x05, 0x01, 0xff, 0x87, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x5f,
+   0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x07, 0x5f, 0x37, 0x40, 0x1b, 0x93, 0x4a, 0x7e, 0xc4,
+   0xd2, 0x01, 0xe8, 0xae, 0xb0, 0xe3, 0xbe, 0xda, 0x06, 0x60, 0x6b, 0x7b, 0x47, 0x10, 0xaf, 0xd3,
+   0x9a, 0x13, 0x14, 0x7d, 0x63, 0x2c, 0xf6, 0x72, 0xd6, 0x4b, 0x2f, 0x94, 0xd9, 0x93, 0x55, 0xad,
+   0x4a, 0x3b, 0x16, 0x07, 0x04, 0x86, 0x14, 0x9e, 0xd3, 0x53, 0xe0, 0xdc, 0x9d, 0x8c, 0xa7, 0x6b,
+   0x28, 0xf7, 0x94, 0x33, 0x07, 0x3b, 0x43, 0x40, 0xb3, 0x8e, 0x97,
+};
+static unsigned char allianz_cert[] = {
+   0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10,
+   0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31,
+   0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+   0x41, 0x04, 0x2d, 0x82, 0x40, 0x33, 0x30, 0xea, 0xa8, 0xd4, 0x9a, 0x01, 0x27, 0xe9, 0xb3, 0x94,
+   0x21, 0x7c, 0x3e, 0xbf, 0x05, 0x95, 0x77, 0xa6, 0xb8, 0x4f, 0x6c, 0x37, 0x92, 0xd7, 0x2d, 0x78,
+   0xdf, 0x78, 0x3b, 0x40, 0xc8, 0x0f, 0xcc, 0xe1, 0xe4, 0xf7, 0xec, 0x99, 0xd6, 0xd0, 0xd8, 0xff,
+   0xf1, 0xbd, 0x3e, 0xab, 0x0f, 0xfc, 0x63, 0x1b, 0xf8, 0xa1, 0x58, 0xca, 0xba, 0xb3, 0xa7, 0x2c,
+   0xc9, 0x44, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x34, 0x32, 0x30, 0x30,
+   0x34, 0x46, 0x51, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02,
+   0x02, 0x53, 0x05, 0x00, 0x00, 0x00, 0x18, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x02, 0x00,
+   0x09, 0x5f, 0x24, 0x06, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09,
+   0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0xbb, 0x3c, 0xf6, 0x55, 0x78,
+   0x20, 0xd8, 0x98, 0x7b, 0xfb, 0x51, 0x30, 0xd0, 0x54, 0x2c, 0x4e, 0xd4, 0xf9, 0x92, 0xb6, 0x4c,
+   0xe7, 0x6d, 0x1d, 0x7c, 0xf6, 0x71, 0xbf, 0xe6, 0xb0, 0xa8, 0x4a, 0x73, 0x2d, 0x06, 0x09, 0x04,
+   0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x36, 0x00, 0x2a, 0xab, 0x88, 0x34,
+   0x58, 0x76, 0x89, 0xfd, 0x43, 0xc2, 0x04, 0x8a, 0xdd, 0x1a, 0x5b, 0xe1, 0xa9, 0x44, 0xe5, 0x06,
+   0x8f, 0x1b, 0xb3, 0x3e, 0x40, 0x73, 0x33, 0xdb, 0x72, 0xb8, 0x5f, 0x37, 0x40, 0x18, 0x4e, 0xbc,
+   0xf9, 0x87, 0x34, 0xf2, 0xe8, 0xc3, 0x2a, 0xbf, 0xc9, 0x04, 0xe2, 0xb4, 0x04, 0x73, 0xb7, 0x67,
+   0x57, 0xcd, 0x38, 0x93, 0x2a, 0x45, 0x3e, 0xdc, 0x31, 0x2c, 0x47, 0xeb, 0x03, 0x5a, 0x00, 0x46,
+   0xa6, 0xaf, 0x91, 0x73, 0x91, 0x81, 0x4c, 0x3d, 0x0b, 0x20, 0xfb, 0xda, 0x3f, 0x46, 0x5f, 0xc8,
+   0x90, 0xd0, 0x45, 0x95, 0xec, 0xed, 0x0c, 0x19, 0x4c, 0xbf, 0xab, 0x14, 0xcd,
+};
+
+/* https://www.mein-cockpit.de/api/eid/finish/ */
+static unsigned char mein_cockpit_desc[] = {
+   0x30, 0x82, 0x02, 0xb5, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x01,
+   0xa1, 0x0e, 0x0c, 0x0c, 0x44, 0x2d, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x47, 0x6d, 0x62, 0x48,
+   0xa2, 0x18, 0x13, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64,
+   0x2d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x2e, 0x6e, 0x65, 0x74, 0xa3, 0x0d, 0x0c, 0x0b, 0x61, 0x6c,
+   0x6c, 0x79, 0x76, 0x65, 0x20, 0x47, 0x6d, 0x62, 0x48, 0xa4, 0x1d, 0x13, 0x1b, 0x68, 0x74, 0x74,
+   0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6d, 0x65, 0x69, 0x6e, 0x2d, 0x63, 0x6f,
+   0x63, 0x6b, 0x70, 0x69, 0x74, 0x2e, 0x64, 0x65, 0xa5, 0x82, 0x01, 0xe3, 0x0c, 0x82, 0x01, 0xdf,
+   0x4e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x41, 0x6e, 0x73, 0x63, 0x68, 0x72, 0x69, 0x66, 0x74, 0x20,
+   0x75, 0x6e, 0x64, 0x20, 0x45, 0x2d, 0x4d, 0x61, 0x69, 0x6c, 0x2d, 0x41, 0x64, 0x72, 0x65, 0x73,
+   0x73, 0x65, 0x20, 0x64, 0x65, 0x73, 0x20, 0x44, 0x69, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x6e,
+   0x62, 0x69, 0x65, 0x74, 0x65, 0x72, 0x73, 0x3a, 0x0d, 0x0a, 0x61, 0x6c, 0x6c, 0x79, 0x76, 0x65,
+   0x20, 0x47, 0x6d, 0x62, 0x48, 0x0d, 0x0a, 0x41, 0x6c, 0x73, 0x74, 0x65, 0x72, 0x74, 0x6f, 0x72,
+   0x20, 0x39, 0x0d, 0x0a, 0x32, 0x30, 0x30, 0x39, 0x35, 0x20, 0x48, 0x61, 0x6d, 0x62, 0x75, 0x72,
+   0x67, 0x0d, 0x0a, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x40, 0x61, 0x6c, 0x6c, 0x79, 0x76,
+   0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x0d, 0x0a, 0x0d, 0x0a, 0x47, 0x65, 0x73, 0x63, 0x68, 0xc3, 0xa4,
+   0x66, 0x74, 0x73, 0x7a, 0x77, 0x65, 0x63, 0x6b, 0x3a, 0x0d, 0x0a, 0x2d, 0x20, 0x45, 0x69, 0x6e,
+   0x62, 0x69, 0x6e, 0x64, 0x75, 0x6e, 0x67, 0x20, 0x69, 0x6e, 0x20, 0x64, 0x65, 0x6e, 0x20, 0x52,
+   0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x69, 0x65, 0x72, 0x75, 0x6e, 0x67, 0x73, 0x2d, 0x20, 0x75,
+   0x6e, 0x64, 0x20, 0x41, 0x6e, 0x6d, 0x65, 0x6c, 0x64, 0x65, 0x70, 0x72, 0x6f, 0x7a, 0x65, 0x73,
+   0x73, 0x20, 0x61, 0x6d, 0x20, 0x57, 0x65, 0x62, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6c, 0x20, 0x77,
+   0x77, 0x77, 0x2e, 0x6d, 0x65, 0x69, 0x6e, 0x2d, 0x63, 0x6f, 0x63, 0x6b, 0x70, 0x69, 0x74, 0x2e,
+   0x64, 0x65, 0x20, 0x2d, 0x0d, 0x0a, 0x0d, 0x0a, 0x44, 0x69, 0x65, 0x20, 0x66, 0xc3, 0xbc, 0x72,
+   0x20, 0x53, 0x69, 0x65, 0x20, 0x7a, 0x75, 0x73, 0x74, 0xc3, 0xa4, 0x6e, 0x64, 0x69, 0x67, 0x65,
+   0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x62, 0x65, 0x68, 0xc3,
+   0xb6, 0x72, 0x64, 0x65, 0x20, 0x69, 0x73, 0x74, 0x3a, 0x0d, 0x0a, 0x48, 0x61, 0x6d, 0x62, 0x75,
+   0x72, 0x67, 0x69, 0x73, 0x63, 0x68, 0x65, 0x72, 0x20, 0x44, 0x61, 0x74, 0x65, 0x6e, 0x73, 0x63,
+   0x68, 0x75, 0x74, 0x7a, 0x62, 0x65, 0x61, 0x75, 0x66, 0x74, 0x72, 0x61, 0x67, 0x74, 0x65, 0x72,
+   0x0d, 0x0a, 0x4b, 0x6c, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x77, 0x61, 0x6c, 0x6c, 0x20, 0x36, 0x0d,
+   0x0a, 0x32, 0x30, 0x30, 0x39, 0x35, 0x20, 0x48, 0x61, 0x6d, 0x62, 0x75, 0x72, 0x67, 0x0d, 0x0a,
+   0x30, 0x34, 0x30, 0x2f, 0x34, 0x32, 0x38, 0x20, 0x35, 0x34, 0x2d, 0x34, 0x30, 0x20, 0x34, 0x30,
+   0x0d, 0x0a, 0x6d, 0x61, 0x69, 0x6c, 0x62, 0x6f, 0x78, 0x40, 0x64, 0x61, 0x74, 0x65, 0x6e, 0x73,
+   0x63, 0x68, 0x75, 0x74, 0x7a, 0x2e, 0x68, 0x61, 0x6d, 0x62, 0x75, 0x72, 0x67, 0x2e, 0x64, 0x65,
+   0x0d, 0x0a, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x61, 0x74,
+   0x65, 0x6e, 0x73, 0x63, 0x68, 0x75, 0x74, 0x7a, 0x2e, 0x68, 0x61, 0x6d, 0x62, 0x75, 0x72, 0x67,
+   0x2e, 0x64, 0x65, 0x0d, 0x0a, 0x41, 0x6e, 0x73, 0x70, 0x72, 0x65, 0x63, 0x68, 0x70, 0x61, 0x72,
+   0x74, 0x6e, 0x65, 0x72, 0x3a, 0x20, 0x50, 0x72, 0x6f, 0x66, 0x2e, 0x20, 0x44, 0x72, 0x2e, 0x20,
+   0x4a, 0x6f, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x73, 0x20, 0x43, 0x61, 0x73, 0x70, 0x61, 0x72, 0xa7,
+   0x68, 0x31, 0x66, 0x04, 0x20, 0x2e, 0x15, 0x78, 0x88, 0x58, 0xe5, 0x6a, 0x91, 0xa4, 0x59, 0xbb,
+   0x70, 0x86, 0x94, 0x3a, 0x5a, 0x3a, 0xb8, 0x79, 0xf8, 0x8f, 0x72, 0xee, 0xe7, 0x2d, 0x5b, 0x82,
+   0x02, 0xb0, 0x35, 0x94, 0x3d, 0x04, 0x20, 0x80, 0x5a, 0xd7, 0x54, 0x56, 0x8e, 0x47, 0x2c, 0x47,
+   0x61, 0xd5, 0x2d, 0x41, 0x0f, 0xb9, 0x91, 0x28, 0xab, 0x4c, 0xe2, 0xd7, 0x50, 0xfd, 0xa3, 0xa8,
+   0xda, 0x8f, 0xba, 0x67, 0xbb, 0x14, 0xeb, 0x04, 0x20, 0xe9, 0xb2, 0xb7, 0xe1, 0x43, 0x0e, 0xfd,
+   0xe9, 0xe9, 0x9a, 0x25, 0x60, 0x3a, 0xd3, 0x2e, 0x26, 0x71, 0xef, 0xb6, 0xb0, 0x0d, 0x92, 0x14,
+   0x39, 0x42, 0x8d, 0xf9, 0x82, 0xce, 0x16, 0x8d, 0x44,
+};
+static unsigned char mein_cockpit_dvcert[] = {
+   0x7f, 0x21, 0x81, 0xe7, 0x7f, 0x4e, 0x81, 0xa0, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45,
+   0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, 0x4f, 0x06,
+   0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x46, 0x5f,
+   0x4b, 0x87, 0x11, 0xde, 0x56, 0xa2, 0x4a, 0x03, 0x1a, 0xec, 0xc3, 0x74, 0x8c, 0x0a, 0x13, 0xa6,
+   0x3f, 0x56, 0x67, 0x5c, 0x8d, 0xfc, 0x76, 0x8e, 0x1f, 0xfe, 0x69, 0xf9, 0x92, 0x19, 0x2d, 0xab,
+   0x1a, 0x41, 0xec, 0x37, 0xc3, 0xae, 0x23, 0xe1, 0x53, 0x90, 0x65, 0x44, 0xab, 0x9b, 0x84, 0xb4,
+   0x50, 0xc0, 0xbf, 0x2e, 0xe4, 0x62, 0x57, 0x6a, 0x33, 0xf4, 0xa5, 0x0a, 0x17, 0x07, 0x5f, 0x20,
+   0x10, 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30,
+   0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53,
+   0x05, 0x40, 0x05, 0x01, 0xff, 0x87, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x5f,
+   0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x07, 0x5f, 0x37, 0x40, 0x1b, 0x93, 0x4a, 0x7e, 0xc4,
+   0xd2, 0x01, 0xe8, 0xae, 0xb0, 0xe3, 0xbe, 0xda, 0x06, 0x60, 0x6b, 0x7b, 0x47, 0x10, 0xaf, 0xd3,
+   0x9a, 0x13, 0x14, 0x7d, 0x63, 0x2c, 0xf6, 0x72, 0xd6, 0x4b, 0x2f, 0x94, 0xd9, 0x93, 0x55, 0xad,
+   0x4a, 0x3b, 0x16, 0x07, 0x04, 0x86, 0x14, 0x9e, 0xd3, 0x53, 0xe0, 0xdc, 0x9d, 0x8c, 0xa7, 0x6b,
+   0x28, 0xf7, 0x94, 0x33, 0x07, 0x3b, 0x43, 0x40, 0xb3, 0x8e, 0x97,
+};
+static unsigned char mein_cockpit_cert[] = {
+   0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10,
+   0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31,
+   0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86,
+   0x41, 0x04, 0x30, 0xc6, 0x55, 0x64, 0x02, 0x9f, 0xcb, 0xa9, 0x93, 0x4a, 0x46, 0x7c, 0x5d, 0x53,
+   0xb4, 0x0f, 0x87, 0xc3, 0x0f, 0x1f, 0x04, 0xb5, 0x0f, 0x2b, 0xa7, 0x6a, 0xf0, 0xc7, 0x4b, 0x8f,
+   0x2a, 0xc0, 0x57, 0xcb, 0x17, 0x6d, 0x2a, 0x1d, 0x15, 0x0b, 0x53, 0x1f, 0xe5, 0x9f, 0x4f, 0x31,
+   0x5d, 0x22, 0xd2, 0xcf, 0x45, 0x63, 0x60, 0x2f, 0x9c, 0xe0, 0x85, 0xda, 0x62, 0x24, 0x0f, 0xd2,
+   0x9d, 0x7a, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x34, 0x39, 0x30, 0x30,
+   0x34, 0x46, 0x4e, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02,
+   0x02, 0x53, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x02, 0x00,
+   0x09, 0x5f, 0x24, 0x06, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09,
+   0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x2b, 0xa8, 0x57, 0xae, 0xc0,
+   0x87, 0xcc, 0xcd, 0x2d, 0xd5, 0x26, 0xfd, 0xd8, 0x2e, 0xe3, 0x3e, 0xa2, 0x89, 0x40, 0x8b, 0x3c,
+   0x21, 0x61, 0xf3, 0x66, 0x80, 0xa9, 0xc3, 0x84, 0xc1, 0x43, 0xfb, 0x73, 0x2d, 0x06, 0x09, 0x04,
+   0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0xbe, 0x46, 0x23, 0xde, 0x47, 0xdc,
+   0x5f, 0x42, 0x24, 0x02, 0xf8, 0x51, 0xb2, 0x5c, 0x88, 0xd8, 0xf4, 0x66, 0xb1, 0xf4, 0x5c, 0xc9,
+   0x7e, 0x11, 0xe8, 0x09, 0xaf, 0xf4, 0xa3, 0xe4, 0x5f, 0xe3, 0x5f, 0x37, 0x40, 0x49, 0xff, 0x9b,
+   0xf0, 0xf3, 0x0a, 0x9e, 0x61, 0x16, 0x76, 0xa6, 0xc7, 0x95, 0xea, 0x55, 0x23, 0x4b, 0x2a, 0xe4,
+   0x3f, 0x69, 0x0f, 0x8a, 0x77, 0xa7, 0x6a, 0x23, 0x8a, 0x9c, 0xa3, 0x98, 0x28, 0x31, 0x3c, 0x0a,
+   0x30, 0x18, 0x39, 0xeb, 0x39, 0x1e, 0xb3, 0x1a, 0xd5, 0x78, 0x1a, 0xcd, 0xf1, 0xdf, 0x83, 0xc1,
+   0x69, 0xb1, 0x3a, 0xf9, 0xa6, 0x1f, 0x58, 0x72, 0xf5, 0xff, 0x70, 0xa7, 0x8c
+};
+
+/* https://www.service-bw.de/idm-web-portal/page/protected/index/index.faces?action=init&eid=true */
+static unsigned char service_bw_dvcert[] = {
+    0x7f, 0x21, 0x81, 0xe7, 0x7f, 0x4e, 0x81, 0xa0, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x0e, 0x44, 0x45, /* .!...N.._)..B.DE */
+    0x43, 0x56, 0x43, 0x41, 0x65, 0x49, 0x44, 0x30, 0x30, 0x31, 0x30, 0x32, 0x7f, 0x49, 0x4f, 0x06, /* CVCAeID00102.IO. */
+    0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, 0x41, 0x04, 0x46, 0x5f, /* ............A.F_ */
+    0x4b, 0x87, 0x11, 0xde, 0x56, 0xa2, 0x4a, 0x03, 0x1a, 0xec, 0xc3, 0x74, 0x8c, 0x0a, 0x13, 0xa6, /* K...V.J....t.... */
+    0x3f, 0x56, 0x67, 0x5c, 0x8d, 0xfc, 0x76, 0x8e, 0x1f, 0xfe, 0x69, 0xf9, 0x92, 0x19, 0x2d, 0xab, /* ?Vg\..v...i...-. */
+    0x1a, 0x41, 0xec, 0x37, 0xc3, 0xae, 0x23, 0xe1, 0x53, 0x90, 0x65, 0x44, 0xab, 0x9b, 0x84, 0xb4, /* .A.7..#.S.eD.... */
+    0x50, 0xc0, 0xbf, 0x2e, 0xe4, 0x62, 0x57, 0x6a, 0x33, 0xf4, 0xa5, 0x0a, 0x17, 0x07, 0x5f, 0x20, /* P....bWj3....._  */
+    0x10, 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, /* .DEDVeIDDTR10140 */
+    0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, 0x02, 0x53, /* 1.L............S */
+    0x05, 0x40, 0x05, 0x01, 0xff, 0x87, 0x5f, 0x25, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x5f, /* .@...._%......._ */
+    0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x07, 0x5f, 0x37, 0x40, 0x1b, 0x93, 0x4a, 0x7e, 0xc4, /* $......._7@..J~. */
+    0xd2, 0x01, 0xe8, 0xae, 0xb0, 0xe3, 0xbe, 0xda, 0x06, 0x60, 0x6b, 0x7b, 0x47, 0x10, 0xaf, 0xd3, /* .........`k{G... */
+    0x9a, 0x13, 0x14, 0x7d, 0x63, 0x2c, 0xf6, 0x72, 0xd6, 0x4b, 0x2f, 0x94, 0xd9, 0x93, 0x55, 0xad, /* ...}c,.r.K/...U. */
+    0x4a, 0x3b, 0x16, 0x07, 0x04, 0x86, 0x14, 0x9e, 0xd3, 0x53, 0xe0, 0xdc, 0x9d, 0x8c, 0xa7, 0x6b, /* J;.......S.....k */
+    0x28, 0xf7, 0x94, 0x33, 0x07, 0x3b, 0x43, 0x40, 0xb3, 0x8e, 0x97                                /* (..3.;C@... */
+};
+static unsigned char service_bw_cert[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x4f, 0xba, 0x55, 0x36, 0xf0, 0x0f, 0xbd, 0xce, 0x28, 0xcb, 0xee, 0xd6, 0x0b, 0x88, /* A.O.U6....(..... */
+    0xc9, 0x24, 0xbb, 0xcd, 0x58, 0x04, 0xb6, 0x08, 0x29, 0x73, 0x58, 0xea, 0x95, 0x73, 0x7c, 0x0b, /* .$..X...)sX..s|. */
+    0xb8, 0xb3, 0x9c, 0x45, 0x81, 0x42, 0xaf, 0x86, 0xb5, 0xea, 0x02, 0xb8, 0x33, 0x20, 0xc5, 0x0f, /* ...E.B......3 .. */
+    0xed, 0x94, 0x72, 0x79, 0xdc, 0x3d, 0x1e, 0xe1, 0x8e, 0x10, 0x89, 0x07, 0x2c, 0x5c, 0xcc, 0x5a, /* ..ry.=......,\.Z */
+    0xbc, 0x16, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35, 0x35, 0x30, 0x30, /* .._ .DE000005500 */
+    0x30, 0x56, 0x31, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 0V1.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x00, 0xdb, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x01, 0x02, /* .S......_%...... */
+    0x03, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x01, 0x02, 0x04, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x40, 0x56, 0xea, 0x70, 0x4b, /* .......... @V.pK */
+    0xa2, 0x91, 0xe2, 0x6b, 0x21, 0xfc, 0x1e, 0x4e, 0x37, 0xd9, 0x37, 0x5c, 0xb9, 0x3b, 0xbc, 0x91, /* ...k!..N7.7\.;.. */
+    0xea, 0x41, 0x91, 0x2f, 0x72, 0x6c, 0xcc, 0x3a, 0xff, 0x6f, 0x64, 0x73, 0x2d, 0x06, 0x09, 0x04, /* .A./rl.:.ods-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x4c, 0xb0, 0x13, 0x22, 0x73, 0x7a, /* ......... L.."sz */
+    0xc5, 0x6c, 0x6c, 0xac, 0x4d, 0xef, 0xce, 0x69, 0x07, 0x19, 0x0e, 0xae, 0x58, 0xb4, 0xeb, 0x1b, /* .ll.M..i....X... */
+    0x7e, 0xd3, 0x47, 0x53, 0x81, 0x27, 0x75, 0xb5, 0x7a, 0xbb, 0x5f, 0x37, 0x40, 0x25, 0x61, 0x7f, /* ~.GS.'u.z._7@%a. */
+    0xd6, 0xa2, 0x92, 0xbc, 0x1e, 0x04, 0x7b, 0x6c, 0x46, 0x42, 0x0c, 0x8b, 0xfd, 0x21, 0x28, 0xbc, /* ......{lFB...!(. */
+    0x5c, 0xb0, 0x78, 0x00, 0x20, 0xe3, 0x0e, 0x24, 0x16, 0xc8, 0xf3, 0xd4, 0x81, 0x0b, 0x77, 0x29, /* \.x. ..$......w) */
+    0x5e, 0x90, 0xfa, 0x59, 0x30, 0xa5, 0x31, 0x69, 0x8f, 0xef, 0x21, 0x9c, 0x01, 0xb8, 0xa5, 0xc6, /* ^..Y0.1i..!..... */
+    0xe6, 0xe5, 0x40, 0x1d, 0x05, 0x33, 0x55, 0xd5, 0x5a, 0x74, 0xac, 0x47, 0xf5                    /* ..@..3U.Zt.G. */
+};
+static unsigned char service_bw_cert_2[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x21, 0xdf, 0x03, 0x60, 0x1f, 0x93, 0xa2, 0x8d, 0x57, 0xbd, 0xcb, 0x7f, 0xff, 0xd5, /* A.!..`....W..... */
+    0x74, 0x80, 0x21, 0x28, 0x23, 0x29, 0x33, 0xb5, 0xdf, 0x4e, 0xfe, 0x55, 0x83, 0x57, 0x72, 0xae, /* t.!(#)3..N.U.Wr. */
+    0xbb, 0xf9, 0x10, 0xe0, 0x73, 0x7c, 0xce, 0x19, 0x98, 0x5b, 0xd3, 0xf1, 0x93, 0x6c, 0x7a, 0x6c, /* ....s|...[...lzl */
+    0xf9, 0x92, 0xe5, 0xe6, 0x47, 0x4d, 0xd3, 0xcf, 0x07, 0xee, 0x7e, 0x95, 0x8b, 0x2a, 0xd4, 0xc8, /* ....GM....~..*.. */
+    0x1d, 0xf2, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35, 0x35, 0x30, 0x30, /* .._ .DE000005500 */
+    0x30, 0x58, 0x49, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 0XI.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x00, 0xdb, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+    0x03, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, 0x04, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x40, 0x56, 0xea, 0x70, 0x4b, /* .......... @V.pK */
+    0xa2, 0x91, 0xe2, 0x6b, 0x21, 0xfc, 0x1e, 0x4e, 0x37, 0xd9, 0x37, 0x5c, 0xb9, 0x3b, 0xbc, 0x91, /* ...k!..N7.7\.;.. */
+    0xea, 0x41, 0x91, 0x2f, 0x72, 0x6c, 0xcc, 0x3a, 0xff, 0x6f, 0x64, 0x73, 0x2d, 0x06, 0x09, 0x04, /* .A./rl.:.ods-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x4c, 0xb0, 0x13, 0x22, 0x73, 0x7a, /* ......... L.."sz */
+    0xc5, 0x6c, 0x6c, 0xac, 0x4d, 0xef, 0xce, 0x69, 0x07, 0x19, 0x0e, 0xae, 0x58, 0xb4, 0xeb, 0x1b, /* .ll.M..i....X... */
+    0x7e, 0xd3, 0x47, 0x53, 0x81, 0x27, 0x75, 0xb5, 0x7a, 0xbb, 0x5f, 0x37, 0x40, 0x2b, 0x54, 0xc6, /* ~.GS.'u.z._7@+T. */
+    0x2f, 0x58, 0x25, 0xf9, 0x5a, 0xb3, 0x89, 0x05, 0x67, 0xfc, 0xa0, 0x5b, 0x09, 0x2e, 0x19, 0x31, /* /X%.Z...g..[...1 */
+    0x8d, 0xb1, 0xcc, 0xe9, 0xbd, 0x2b, 0x2f, 0x4d, 0x27, 0x04, 0xaa, 0x69, 0x62, 0x4d, 0x15, 0x58, /* .....+/M'..ibM.X */
+    0xd1, 0xb5, 0x75, 0xe7, 0x84, 0x06, 0xad, 0x96, 0x81, 0x5d, 0x74, 0xa6, 0x1a, 0xef, 0x5e, 0x37, /* ..u......]t...^7 */
+    0xdf, 0x7a, 0xe0, 0x18, 0x47, 0x94, 0x78, 0x97, 0x23, 0xcc, 0x7d, 0xb2, 0x02                   /* .z..G.x.#.}.. */
+    };
+static unsigned char service_bw_cert_3[] = {
+    0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+    0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+    0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+    0x41, 0x04, 0x3f, 0x5f, 0xd5, 0x01, 0x17, 0x2e, 0xb5, 0xf3, 0xbc, 0x78, 0xb3, 0x49, 0xb4, 0xb4, /* A.?_.......x.I.. */
+    0xd0, 0xda, 0xe4, 0x2d, 0x3e, 0xc9, 0xa6, 0x77, 0x40, 0x3e, 0xb7, 0xcb, 0x88, 0xcd, 0x86, 0x4d, /* ...->..w@>.....M */
+    0x5e, 0x2a, 0x35, 0x79, 0x6c, 0x98, 0x30, 0x9f, 0x7d, 0x29, 0x99, 0xc6, 0xae, 0x9a, 0xb7, 0x94, /* ^*5yl.0.})...... */
+    0x72, 0x18, 0x56, 0x1c, 0x8b, 0x22, 0x91, 0x73, 0x98, 0x45, 0x94, 0x21, 0xfc, 0xd8, 0x34, 0x6c, /* r.V..".s.E.!..4l */
+    0xe4, 0x04, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35, 0x35, 0x30, 0x30, /* .._ .DE000005500 */
+    0x30, 0x59, 0x46, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 0YF.L........... */
+    0x02, 0x53, 0x05, 0x00, 0x01, 0x00, 0xdb, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+    0x07, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, 0x08, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+    0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x40, 0x56, 0xea, 0x70, 0x4b, /* .......... @V.pK */
+    0xa2, 0x91, 0xe2, 0x6b, 0x21, 0xfc, 0x1e, 0x4e, 0x37, 0xd9, 0x37, 0x5c, 0xb9, 0x3b, 0xbc, 0x91, /* ...k!..N7.7\.;.. */
+    0xea, 0x41, 0x91, 0x2f, 0x72, 0x6c, 0xcc, 0x3a, 0xff, 0x6f, 0x64, 0x73, 0x2d, 0x06, 0x09, 0x04, /* .A./rl.:.ods-... */
+    0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x4c, 0xb0, 0x13, 0x22, 0x73, 0x7a, /* ......... L.."sz */
+    0xc5, 0x6c, 0x6c, 0xac, 0x4d, 0xef, 0xce, 0x69, 0x07, 0x19, 0x0e, 0xae, 0x58, 0xb4, 0xeb, 0x1b, /* .ll.M..i....X... */
+    0x7e, 0xd3, 0x47, 0x53, 0x81, 0x27, 0x75, 0xb5, 0x7a, 0xbb, 0x5f, 0x37, 0x40, 0x51, 0x50, 0x1b, /* ~.GS.'u.z._7@QP. */
+    0x46, 0x1d, 0xd0, 0xe9, 0x80, 0x09, 0x25, 0xc8, 0xb7, 0x49, 0xd1, 0x35, 0x85, 0x47, 0x7d, 0x7b, /* F.....%..I.5.G}{ */
+    0xc8, 0xd3, 0x40, 0x40, 0xb2, 0x34, 0x64, 0x52, 0xf4, 0x57, 0xd5, 0x24, 0x23, 0x5a, 0xaf, 0xfe, /* ..@@.4dR.W.$#Z.. */
+    0x5e, 0x9d, 0x6e, 0xf4, 0x4b, 0x03, 0xd1, 0x8f, 0x73, 0x90, 0xaf, 0x14, 0xcf, 0x1b, 0x85, 0xb7, /* ^.n.K...s....... */
+    0x73, 0xb1, 0x65, 0x50, 0x30, 0xf8, 0xf7, 0x5a, 0x05, 0x9a, 0x0b, 0x53, 0x75,                   /* s.eP0..Z...Su */
+    };
+static unsigned char service_bw_cert_4[] = {
+ 0x7f, 0x21, 0x82, 0x01, 0x48, 0x7f, 0x4e, 0x82, 0x01, 0x00, 0x5f, 0x29, 0x01, 0x00, 0x42, 0x10, /* .!..H.N..._)..B. */
+ 0x44, 0x45, 0x44, 0x56, 0x65, 0x49, 0x44, 0x44, 0x54, 0x52, 0x31, 0x30, 0x31, 0x34, 0x30, 0x31, /* DEDVeIDDTR101401 */
+ 0x7f, 0x49, 0x4f, 0x06, 0x0a, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x02, 0x02, 0x02, 0x02, 0x03, 0x86, /* .IO............. */
+ 0x41, 0x04, 0x31, 0xeb, 0xeb, 0xd5, 0x20, 0x2a, 0x28, 0x74, 0x57, 0xa9, 0x55, 0x5a, 0xd5, 0x47, /* A.1... *(tW.UZ.G */
+ 0x10, 0xfb, 0xd7, 0x97, 0x59, 0xf6, 0xa7, 0x77, 0x97, 0x7c, 0x68, 0xd9, 0x74, 0xa6, 0x45, 0x3d, /* ....Y..w.|h.t.E= */
+ 0xad, 0xcc, 0x9e, 0xb1, 0x20, 0x93, 0x82, 0xc0, 0xe9, 0x38, 0x1d, 0xce, 0xf1, 0xb2, 0x0a, 0x6b, /* .... ....8.....k */
+ 0xd6, 0xdd, 0x5e, 0x56, 0x06, 0x83, 0x94, 0xa2, 0xf3, 0x45, 0x3a, 0x20, 0x64, 0x40, 0x04, 0xbd, /* ..^V.....E: d@.. */
+ 0x2f, 0x91, 0x5f, 0x20, 0x0e, 0x44, 0x45, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35, 0x35, 0x30, 0x30, /* /._ .DE000005500 */
+ 0x30, 0x59, 0x56, 0x7f, 0x4c, 0x12, 0x06, 0x09, 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x02, /* 0YV.L........... */
+ 0x02, 0x53, 0x05, 0x00, 0x01, 0x00, 0xdb, 0x04, 0x5f, 0x25, 0x06, 0x01, 0x02, 0x00, 0x02, 0x00, /* .S......_%...... */
+ 0x09, 0x5f, 0x24, 0x06, 0x01, 0x02, 0x00, 0x02, 0x01, 0x00, 0x65, 0x5e, 0x73, 0x2d, 0x06, 0x09, /* ._$.......e^s-.. */
+ 0x04, 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x02, 0x80, 0x20, 0x40, 0x56, 0xea, 0x70, 0x4b, /* .......... @V.pK */
+ 0xa2, 0x91, 0xe2, 0x6b, 0x21, 0xfc, 0x1e, 0x4e, 0x37, 0xd9, 0x37, 0x5c, 0xb9, 0x3b, 0xbc, 0x91, /* ...k!..N7.7\.;.. */
+ 0xea, 0x41, 0x91, 0x2f, 0x72, 0x6c, 0xcc, 0x3a, 0xff, 0x6f, 0x64, 0x73, 0x2d, 0x06, 0x09, 0x04, /* .A./rl.:.ods-... */
+ 0x00, 0x7f, 0x00, 0x07, 0x03, 0x01, 0x03, 0x01, 0x80, 0x20, 0x4c, 0xb0, 0x13, 0x22, 0x73, 0x7a, /* ......... L.."sz */
+ 0xc5, 0x6c, 0x6c, 0xac, 0x4d, 0xef, 0xce, 0x69, 0x07, 0x19, 0x0e, 0xae, 0x58, 0xb4, 0xeb, 0x1b, /* .ll.M..i....X... */
+ 0x7e, 0xd3, 0x47, 0x53, 0x81, 0x27, 0x75, 0xb5, 0x7a, 0xbb, 0x5f, 0x37, 0x40, 0x5d, 0xce, 0xda, /* ~.GS.'u.z._7@].. */
+ 0xe9, 0xbf, 0x00, 0xb2, 0x70, 0x6c, 0x3f, 0x81, 0xd1, 0x20, 0x28, 0x0f, 0x1f, 0xbf, 0xdf, 0xe8, /* ....pl?.. (..... */
+ 0x08, 0x6e, 0x7d, 0xd3, 0xe6, 0xb3, 0xac, 0x45, 0xd2, 0x5b, 0xd1, 0xad, 0xde, 0x54, 0x17, 0xb7, /* .n}....E.[...T.. */
+ 0xe9, 0x44, 0x06, 0xfa, 0x47, 0x21, 0x99, 0xf5, 0x41, 0x36, 0x8c, 0xeb, 0xcd, 0xce, 0xcf, 0x9d, /* .D..G!..A6...... */
+ 0xc2, 0x50, 0x58, 0x61, 0x8c, 0xdf, 0x72, 0xe0, 0xd3, 0x00, 0xf3, 0xba, 0x76,                   /* .PXa..r.....v */
+};
+
+
+struct cv_cert {
+    const unsigned char *cv_cert;
+    const size_t cv_cert_len;
+    const unsigned char *cv_cert_desc;
+    const size_t cv_cert_desc_len;
+};
+
+static const struct cv_cert cv_certs[] = {
+    {cvc1, sizeof cvc1, cvc1_desc, sizeof cvc1_desc },
+    {cvc2, sizeof cvc2, NULL, 0 },
+    {wrong_tc_ecdh_cvca, sizeof wrong_tc_ecdh_cvca, NULL, 0 },
+    {kba_dvca_cert, sizeof kba_dvca_cert, NULL, 0 },
+    {kba_cert, sizeof kba_cert, kba_cert_desc, sizeof kba_cert_desc },
+    {kba_dvca_cert_2, sizeof kba_dvca_cert_2, NULL, 0 },
+    {kba_cert_2, sizeof kba_cert_2, kba_cert_desc_2, sizeof kba_cert_desc_2 },
+    {kba_cert_3, sizeof kba_cert_3, kba_cert_desc_2, sizeof kba_cert_desc_2 },
+    {kba_cert_4, sizeof kba_cert_4, kba_cert_desc_2, sizeof kba_cert_desc_2 },
+    {schufa_dvcert, sizeof schufa_dvcert, NULL, 0 },
+    {schufa_cert, sizeof schufa_cert, schufa_desc, sizeof schufa_desc },
+    {schufa_dvcert, sizeof schufa_dvcert, NULL, 0 },
+    {schufa_cert, sizeof schufa_cert, schufa_desc, sizeof schufa_desc },
+    {mein_cockpit_dvcert, sizeof mein_cockpit_dvcert, NULL, 0 },
+    {mein_cockpit_cert, sizeof mein_cockpit_cert, mein_cockpit_desc, sizeof mein_cockpit_desc },
+    {allianz_dvcert, sizeof allianz_dvcert, NULL, 0 },
+    {allianz_cert, sizeof allianz_cert, allianz_desc, sizeof allianz_desc },
+    {service_bw_dvcert, sizeof service_bw_dvcert, NULL, 0 },
+    {service_bw_cert, sizeof service_bw_cert, NULL, 0 },
+    {service_bw_cert_2, sizeof service_bw_cert_2, NULL, 0 },
+    {service_bw_cert_3, sizeof service_bw_cert_3, NULL, 0 },
+    {service_bw_cert_4, sizeof service_bw_cert_4, NULL, 0 },
+};
+
+
+struct pace_params {
+    int protocol;
+    int std_dp;
+};
+struct ta_params {
+    int protocol;
+    int curve;
+};
+struct ca_params {
+    int protocol;
+    int curve;
+};
+struct ri_params {
+    int protocol;
+    int std_dp;
+};
+struct pace_secret {
+    enum s_type type;
+    char *secret;
+};
+
+static const struct pace_params dynamic_pace_params[] = {
+    { NID_id_PACE_DH_GM_3DES_CBC_CBC, 0 },
+    { NID_id_PACE_DH_GM_AES_CBC_CMAC_128, 1},
+    { NID_id_PACE_DH_GM_AES_CBC_CMAC_192, 2 },
+    { NID_id_PACE_DH_GM_AES_CBC_CMAC_256, 0 },
+    { NID_id_PACE_DH_IM_3DES_CBC_CBC, 1},
+    { NID_id_PACE_DH_IM_AES_CBC_CMAC_128, 2 },
+    { NID_id_PACE_DH_IM_AES_CBC_CMAC_192, 0 },
+    { NID_id_PACE_DH_IM_AES_CBC_CMAC_256, 1},
+    { NID_id_PACE_ECDH_GM_3DES_CBC_CBC, 11 },
+    { NID_id_PACE_ECDH_GM_3DES_CBC_CBC, 16 },
+    { NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128, 9 },
+    { NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128, 12 },
+    { NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192, 18 },
+    { NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192, 10 },
+    { NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256, 15 },
+    { NID_id_PACE_ECDH_IM_3DES_CBC_CBC, 13 },
+    { NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128, 14 },
+    { NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192, 8 },
+    { NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256, 17 },
+};
+static const struct ta_params dynamic_ta_params[] = {
+    { NID_id_TA_RSA_v1_5_SHA_1, 1024 },
+    { NID_id_TA_RSA_v1_5_SHA_256, 1280 },
+    { NID_id_TA_RSA_PSS_SHA_1, 1536 },
+    { NID_id_TA_RSA_PSS_SHA_256, 2048 },
+    { NID_id_TA_RSA_v1_5_SHA_512, 3072 },
+    { NID_id_TA_RSA_PSS_SHA_512, 1024 },
+    { NID_id_TA_ECDSA_SHA_1, 8 },
+    { NID_id_TA_ECDSA_SHA_224, 9 },
+    { NID_id_TA_ECDSA_SHA_256, 10 },
+    { NID_id_TA_ECDSA_SHA_384, 11 },
+    { NID_id_TA_ECDSA_SHA_512, 12 },
+};
+static const struct ca_params dynamic_ca_params[] = {
+    { NID_id_CA_DH_3DES_CBC_CBC, 0 },
+    { NID_id_CA_DH_AES_CBC_CMAC_128, 1 },
+    { NID_id_CA_DH_AES_CBC_CMAC_192, 2 },
+    { NID_id_CA_DH_AES_CBC_CMAC_256, 0 },
+    { NID_id_CA_ECDH_3DES_CBC_CBC, 8 },
+    { NID_id_CA_ECDH_AES_CBC_CMAC_128, 11 },
+    { NID_id_CA_ECDH_AES_CBC_CMAC_192, 13 },
+    { NID_id_CA_ECDH_AES_CBC_CMAC_256, 14 },
+};
+static const struct ri_params dynamic_ri_params[] = {
+    { NID_id_RI_DH_SHA_1, 0 },
+    { NID_id_RI_DH_SHA_224, 1 },
+    { NID_id_RI_DH_SHA_256, 2 },
+    { NID_id_RI_DH_SHA_384, 0 },
+    { NID_id_RI_DH_SHA_512, 1 },
+    { NID_id_RI_ECDH_SHA_1, 8 },
+    { NID_id_RI_ECDH_SHA_224, 9 },
+    { NID_id_RI_ECDH_SHA_256, 10 },
+    { NID_id_RI_ECDH_SHA_384, 11 },
+    { NID_id_RI_ECDH_SHA_512, 12 },
+    { NID_id_RI_ECDH_SHA_1, 13 },
+    { NID_id_RI_ECDH_SHA_224, 14 },
+    { NID_id_RI_ECDH_SHA_256, 15 },
+    { NID_id_RI_ECDH_SHA_384, 16 },
+    { NID_id_RI_ECDH_SHA_512, 17 },
+    { NID_id_RI_ECDH_SHA_1, 18 },
+};
+static char pace_raw[0xff];
+static const struct pace_secret dynamic_pace_secrets[] = {
+    { PACE_PUK, "1234567890" },
+    { PACE_CAN, "654321" },
+    { PACE_PIN, "123456" },
+    {
+        PACE_MRZ,
+        /* ePA MRZ: https:// www.bsi.bund.de/cae/servlet/contentblob/650964/normal/37609/ePA_beideSeiten.jpg */
+        /* ePA MRZ: http://www.cio.bund.de/cln_093/sid_AF344A548BB315C1B49C3F627F830E35/SharedDocs/Kurzmeldungen/DE/2009/091217_finales_muster_neuer_personalausweis.html */
+        "IDD<<T220001293<<<<<<<<<<<<<<<6408125<1010318D<<<<<<<<<<<<<<MUSTERMANN<<ERIKA<<<<<<<<<<<<<"
+    },
+    { PACE_RAW, pace_raw },
+};
+/******************************************************************************/
+
+/***************************** Helper functions *******************************/
+
+#if 0
+static void hexdump(const char *title, const BUF_MEM *s)
+{
+    size_t n=0;
+
+    fprintf(stdout,"%s",title);
+
+    if (!s) {
+        fprintf(stdout,"(null)\n");
+    } else {
+        for(; n < s->length; ++n)
+        {
+            if((n%16) == 0)
+                fprintf(stdout,"\n    ");
+            fprintf(stdout,"%02x:",(unsigned char) s->data[n]);
+        }
+        fprintf(stdout,"\n");
+    }
+}
+#endif
+
+extern int
+EVP_PKEY_set_std_dp(EVP_PKEY *key, int stnd_dp);
+extern EVP_PKEY *
+EVP_PKEY_dup(EVP_PKEY *key);
+extern BUF_MEM *
+get_pubkey(EVP_PKEY *key, BN_CTX *bn_ctx);
+static EVP_PKEY *
+generate_signature_key(int curve)
+{
+    RSA *rsa = NULL;
+    EC_KEY *ec = NULL;
+    DH *dh = NULL;
+    BIGNUM *bn = NULL;
+
+    EVP_PKEY *key = EVP_PKEY_new();
+    if (!key)
+        goto err;
+
+    switch(curve) {
+        case 0:
+        case 1:
+        case 2:
+            if (!EVP_PKEY_set_std_dp(key, curve))
+                goto err;
+            dh = EVP_PKEY_get1_DH(key);
+            if (!dh
+                    || !DH_generate_key(dh)
+                    || !EVP_PKEY_set1_DH(key, dh))
+                goto err;
+            break;
+
+        case 8:
+        case 9:
+        case 10:
+        case 11:
+        case 12:
+        case 13:
+        case 14:
+        case 15:
+        case 16:
+        case 17:
+        case 18:
+            if (!EVP_PKEY_set_std_dp(key, curve))
+                goto err;
+            ec = EVP_PKEY_get1_EC_KEY(key);
+            if (!ec
+                    || !EC_KEY_generate_key(ec)
+                    || !EVP_PKEY_set1_EC_KEY(key, ec))
+                goto err;
+            break;
+
+        default:
+            /* RSA where curve specifies the keylength */
+            if(((bn = BN_new()) == NULL)
+                    || !BN_set_word(bn, RSA_F4)
+                    || ((rsa = RSA_new()) == NULL)
+                    || !RSA_generate_key_ex(rsa, curve, bn, NULL)
+                    || !EVP_PKEY_set1_RSA(key, rsa))
+                goto err;
+            break;
+    }
+
+    if (bn)
+        BN_clear_free(bn);
+    if (rsa)
+        RSA_free(rsa);
+    if (dh)
+        DH_free(dh);
+    if (ec)
+        EC_KEY_free(ec);
+
+    return key;
+
+err:
+    if (rsa)
+        RSA_free(rsa);
+    if (dh)
+        DH_free(dh);
+    if (ec)
+        EC_KEY_free(ec);
+    if (key)
+        EVP_PKEY_free(key);
+
+    return NULL;
+}
+
+/* Initialize an EVP_PKEY container from buffers containing the private and public
+ * key */
+static int
+EVP_PKEY_set_keys(EVP_PKEY *evp_pkey,
+           const BUF_MEM *privkey, const BUF_MEM *pubkey, BN_CTX *bn_ctx)
+{
+    EC_KEY *ec_key = NULL;
+    DH *dh = NULL;
+    EC_POINT *ec_point = NULL;
+    BIGNUM *bn = NULL;
+    int ok = 0;
+    const EC_GROUP *group;
+
+    if (!evp_pkey || !privkey || !pubkey)
+        goto err;
+
+    switch (EVP_PKEY_type(evp_pkey->type)) {
+        case EVP_PKEY_EC:
+            ec_key = EVP_PKEY_get1_EC_KEY(evp_pkey);
+            group = EC_KEY_get0_group(ec_key);
+            ec_point = EC_POINT_new(group);
+            bn = BN_bin2bn((unsigned char *) privkey->data, privkey->length, bn);
+            if (!ec_key || !ec_point || !bn
+                    || !EC_POINT_oct2point(group, ec_point,
+                           (unsigned char *) pubkey->data, pubkey->length,
+                        bn_ctx)
+                    || !EC_KEY_set_public_key(ec_key, ec_point)
+                    || !EC_KEY_set_private_key(ec_key, bn)
+                    || !EVP_PKEY_set1_EC_KEY(evp_pkey, ec_key))
+                goto err;
+            break;
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(evp_pkey);
+            dh->priv_key = BN_bin2bn((unsigned char *) privkey->data, privkey->length, dh->priv_key);
+            dh->pub_key = BN_bin2bn((unsigned char *) pubkey->data, pubkey->length, dh->pub_key);
+            if (!dh->priv_key || !dh->pub_key
+                    || !EVP_PKEY_set1_DH(evp_pkey, dh))
+                goto err;
+            break;
+        default:
+            goto err;
+            break;
+    }
+
+    ok = 1;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (ec_key)
+        EC_KEY_free(ec_key);
+    if (dh)
+        DH_free(dh);
+    if (ec_point)
+        EC_POINT_clear_free(ec_point);
+
+    return ok;
+}
+
+/* Compare the generator given in a buffer to the generator contained in an
+ * EVP_PKEY container */
+static int
+check_generator(EVP_PKEY *evp_pkey, const BUF_MEM generator, BN_CTX *bn_ctx)
+{
+    EC_KEY *ec_key = NULL;
+    DH *dh = NULL;
+    EC_POINT *ec_point = NULL;
+    BIGNUM *bn = NULL;
+    int ok = 0;
+    const EC_GROUP *group;
+
+    switch (EVP_PKEY_type(evp_pkey->type)) {
+        case EVP_PKEY_EC:
+            ec_key = EVP_PKEY_get1_EC_KEY(evp_pkey);
+            group = EC_KEY_get0_group(ec_key);
+            ec_point = EC_POINT_new(group);
+            if (!ec_point
+                    || !EC_POINT_oct2point(group, ec_point,
+                        (unsigned char *) generator.data, generator.length, bn_ctx)
+                    || EC_POINT_cmp(group, ec_point,
+                        EC_GROUP_get0_generator(group), bn_ctx) != 0)
+                goto err;
+            break;
+        case EVP_PKEY_DH:
+            dh = EVP_PKEY_get1_DH(evp_pkey);
+            bn = BN_bin2bn((unsigned char *) generator.data, generator.length, bn);
+            if (!bn || BN_cmp(dh->g, bn) != 0)
+                goto err;
+            break;
+        default:
+            goto err;
+            break;
+    }
+
+    ok = 1;
+
+err:
+    if (ec_key)
+        EC_KEY_free(ec_key);
+    if (ec_point)
+        EC_POINT_clear_free(ec_point);
+    if (dh)
+        DH_free(dh);
+    if (bn)
+        BN_clear_free(bn);
+
+    return ok;
+}
+
+static int
+buf_eq_buf(const BUF_MEM *buf1, const BUF_MEM *buf2)
+{
+    if (buf1 && buf1->length) {
+        if (!buf2 || !buf2->length || buf1->length != buf2->length
+                   || memcmp(buf1->data, buf2->data, buf1->length) != 0)
+            return 0;
+    } else {
+        if (buf2 && buf2->length)
+            return 0;
+    }
+
+    return 1;
+}
+#if 0
+static int
+buf_eq_str(const BUF_MEM *buf, const unsigned char *str, size_t len)
+{
+    if (len) {
+        if (!buf || buf->length != len || memcmp(buf->data, str, len) != 0)
+            return 0;
+    } else {
+        if (buf && buf->length)
+            return 0;
+    }
+
+    return 1;
+}
+#endif
+
+static void
+print_desc(int protocol, int curve)
+{
+    const char *sn;
+    sn = OBJ_nid2sn(protocol);
+    if (curve > 31) {
+        if (verbose)
+            printf("  Testing RSA %d Parameters with %s\n", curve, sn);
+        else
+            printf("  Testing  RSA %4d  with %-*s ", curve, 32, sn);
+    } else {
+        if (verbose)
+            printf("  Testing Std. Domain Parameters %d with %s\n", curve, sn);
+        else
+            printf("  Testing Std. DP %2d with %-*s ", curve, 32, sn);
+    }
+}
+/******************************************************************************/
+
+/****************************** Unit tests ************************************/
+
+/* Do a test of the EAC protocols emulating both parties (PICC and PCD)
+ * Keys are generated on the fly, only the secret used for PACE and the exact
+ * protocol OIDs have to specified in advance. Right now only the PACE protocol
+ * is tested. */
+static int
+dynamic_eac_test(const struct pace_secret pace_secret,
+                 const struct pace_params pace_params,
+                 const struct ta_params ta_params,
+                 const struct ca_params ca_params,
+                 const struct ri_params ri_params)
+{
+    int failed = 1;
+    PACE_SEC *s = NULL;
+    EAC_CTX *pcd_ctx = NULL, *picc_ctx = NULL;
+    BUF_MEM *enc_nonce = NULL,
+            *static_pub_picc = NULL, *static_pub_pcd = NULL,
+            *ephemeral_pub_picc = NULL, *ephemeral_pub_pcd = NULL,
+            *token_pcd = NULL, *token_picc = NULL,
+            *id_picc = NULL, *ta_nonce = NULL,
+            *ta_comp_ephemeral_key_for_ca = NULL, *ta_signature = NULL,
+            *ca_picc_pubkey = NULL, *ca_pcd_pubkey = NULL, *ca_nonce = NULL,
+            *ca_token = NULL, *ca_picc_comp_pubkey = NULL, *ri = NULL,
+            *sector_pub = NULL;
+    BIO *bio = NULL;
+
+    print_desc(pace_params.protocol, pace_params.std_dp);
+
+
+    /* Initialization */
+    picc_ctx = EAC_CTX_new();
+    pcd_ctx = EAC_CTX_new();
+    s = PACE_SEC_new(pace_secret.secret, strlen(pace_secret.secret), pace_secret.type);
+    CHECK(0, picc_ctx && pcd_ctx && s, "Creating Data")
+    switch (pace_params.protocol) {
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            picc_ctx->tr_version = EAC_TR_VERSION_2_01;
+            pcd_ctx->tr_version = EAC_TR_VERSION_2_01;
+            break;
+        default:
+            break;
+    }
+    CHECK(0, EAC_CTX_init_pace(picc_ctx, pace_params.protocol, pace_params.std_dp)
+            && EAC_CTX_init_pace(pcd_ctx, pace_params.protocol, pace_params.std_dp),
+            "Initializing PACE");
+
+
+    /* PACE */
+    CHECK(1, PACE_STEP1_enc_nonce(picc_ctx, s, &enc_nonce),
+            "PACE step 1: MRTD generated and encrypted nonce.");
+
+    CHECK(1, PACE_STEP2_dec_nonce(pcd_ctx, s, enc_nonce),
+            "PACE step 2: Terminal decrypted the correct nonce");
+
+    static_pub_picc = PACE_STEP3A_generate_mapping_data(picc_ctx);
+    static_pub_pcd = PACE_STEP3A_generate_mapping_data(pcd_ctx);
+    CHECK(1, static_pub_pcd && static_pub_picc,
+            "PACE step 3a: Generated key pairs for mapping");
+
+    switch (picc_ctx->pace_ctx->protocol) {
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            /* Integrated Mapping is special, only the terminal generates the key */
+            CHECK(0, PACE_STEP3A_map_generator(pcd_ctx, static_pub_pcd),
+                    "Computing mapped domain parameters");
+            break;
+        default:
+            CHECK(0, PACE_STEP3A_map_generator(pcd_ctx, static_pub_picc),
+                    "Computing mapped domain parameters");
+            break;
+    }
+    CHECK(1, PACE_STEP3A_map_generator(picc_ctx, static_pub_pcd),
+            "PACE step 3a: Mapped domain parameters on MRTD and Terminal");
+
+    ephemeral_pub_picc = PACE_STEP3B_generate_ephemeral_key(picc_ctx);
+    ephemeral_pub_pcd = PACE_STEP3B_generate_ephemeral_key(pcd_ctx);
+    CHECK(1, PACE_STEP3B_compute_shared_secret(picc_ctx, ephemeral_pub_pcd)
+            && PACE_STEP3B_compute_shared_secret(pcd_ctx, ephemeral_pub_picc)
+            && buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->shared_secret,
+                    pcd_ctx->pace_ctx->ka_ctx->shared_secret),
+            "PACE step 3b: computed shared secret");
+
+    CHECK(1, PACE_STEP3C_derive_keys(picc_ctx)
+            &&  PACE_STEP3C_derive_keys(pcd_ctx)
+            &&  buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->k_enc, pcd_ctx->pace_ctx->ka_ctx->k_enc)
+            &&  buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->k_mac, pcd_ctx->pace_ctx->ka_ctx->k_mac),
+            "PACE step 3c: Derived authentication and encryption key");
+
+    token_pcd = PACE_STEP3D_compute_authentication_token(pcd_ctx, ephemeral_pub_picc);
+    token_picc = PACE_STEP3D_compute_authentication_token(picc_ctx, ephemeral_pub_pcd);
+    CHECK(1, PACE_STEP3D_verify_authentication_token(pcd_ctx, token_picc) == 1
+            && PACE_STEP3D_verify_authentication_token(picc_ctx, token_pcd) == 1,
+            "PACE step 3d: Verified authentication tokens");
+
+    /* Initialize secure channel */
+    CHECK(0, EAC_CTX_set_encryption_ctx(pcd_ctx, EAC_ID_PACE)
+            && EAC_CTX_set_encryption_ctx(picc_ctx, EAC_ID_PACE),
+            "Set encryption/authentication context");
+    id_picc = EAC_Comp(picc_ctx, EAC_ID_PACE, ephemeral_pub_picc);
+    CHECK(0, id_picc,
+            "Computed ID of MRTD and Terminal");
+
+    OK;
+    print_desc(ta_params.protocol, ta_params.curve);
+
+
+    /* TODO write a clean wrapper to use for this kind of initialization */
+    pcd_ctx->ta_ctx->protocol = ta_params.protocol;
+    pcd_ctx->ta_ctx->priv_key = generate_signature_key(ta_params.curve);
+    CHECK(0, pcd_ctx->ta_ctx->priv_key,
+            "Failed to generate Terminal's TA private key");
+    picc_ctx->ta_ctx->protocol = ta_params.protocol;
+    picc_ctx->ta_ctx->pub_key = EVP_PKEY_dup(pcd_ctx->ta_ctx->priv_key);
+    CHECK(0, picc_ctx->ta_ctx->pub_key,
+            "Failed to import Terminal's TA public key to MRTD");
+
+    /* Initialize the CA context for both parties */
+    CHECK(0, EAC_CTX_init_ca(picc_ctx, ca_params.protocol, ca_params.curve,
+            NULL, 0, NULL, 0)
+            && EAC_CTX_init_ca(pcd_ctx, ca_params.protocol, ca_params.curve,
+                NULL, 0, NULL, 0),
+            "Initializing CA");
+    /* Domain parameters for CA are now set for PCD and PICC, usually we would
+     * like to simply generate a key on the PICC side. Since there is no
+     * generic EVP_PKEY wrapper for this, we simply overwrite it with an
+     * initialized one. */
+    EVP_PKEY_free(picc_ctx->ca_ctx->ka_ctx->key);
+    picc_ctx->ca_ctx->ka_ctx->key = generate_signature_key(ca_params.curve);
+    CHECK(0, picc_ctx->ca_ctx->ka_ctx->key,
+            "Failed to generate CA key");
+
+    ta_comp_ephemeral_key_for_ca = TA_STEP3_generate_ephemeral_key(pcd_ctx);
+    CHECK(1, ta_comp_ephemeral_key_for_ca,
+            "TA step 3: Generated ephemeral key for subsequent CA");
+
+    ta_nonce = TA_STEP4_get_nonce(picc_ctx);
+    CHECK(1, ta_nonce && TA_STEP4_set_nonce(pcd_ctx, ta_nonce),
+            "TA step 4: Generated nonce");
+
+    ta_signature = TA_STEP5_sign(pcd_ctx, ta_comp_ephemeral_key_for_ca,
+           id_picc, NULL);
+    CHECK(1, ta_signature,
+            "TA step 5: Created signature");
+
+    CHECK(1, TA_STEP6_verify(picc_ctx, ta_comp_ephemeral_key_for_ca,
+                id_picc, NULL, ta_signature) == 1,
+            "TA step 6: Verified signature");
+
+    OK;
+    print_desc(ca_params.protocol, ca_params.curve);
+
+
+    ca_picc_comp_pubkey = CA_STEP1_get_pubkey(picc_ctx);
+    ca_picc_pubkey = get_pubkey(picc_ctx->ca_ctx->ka_ctx->key,
+            picc_ctx->bn_ctx);
+    CHECK(1, ca_picc_comp_pubkey && ca_picc_pubkey,
+            "CA step 1: Exported MRTD's public key");
+
+    ca_pcd_pubkey = CA_STEP2_get_eph_pubkey(pcd_ctx);
+    CHECK(1, ca_pcd_pubkey,
+            "CA step 2: Exported terminal's public key");
+
+    CHECK(1, CA_STEP3_check_pcd_pubkey(picc_ctx,
+                ta_comp_ephemeral_key_for_ca, ca_pcd_pubkey) == 1,
+            "CA step 3: Checked terminal's public key");
+
+    CHECK(1, CA_STEP4_compute_shared_secret(picc_ctx, ca_pcd_pubkey)
+            && CA_STEP4_compute_shared_secret(pcd_ctx, ca_picc_pubkey),
+            "CA step 4: Computed the shared secret");
+
+    CHECK(1, CA_STEP5_derive_keys(picc_ctx, ca_pcd_pubkey, &ca_nonce, &ca_token),
+            "CA step 5: Derived MRTD's keys");
+
+    CHECK(1, CA_STEP6_derive_keys(pcd_ctx, ca_nonce, ca_token),
+            "CA step 6: Derived terminal's keys");
+
+
+    OK;
+    print_desc(ri_params.protocol, ri_params.std_dp);
+
+    CHECK(0, EAC_CTX_init_ri(picc_ctx, ri_params.protocol, ri_params.std_dp)
+            && EAC_CTX_init_ri(pcd_ctx, ri_params.protocol, ri_params.std_dp),
+            "Initializing RI")
+
+    sector_pub = get_pubkey(pcd_ctx->ri_ctx->static_key, pcd_ctx->bn_ctx);
+    CHECK(1, sector_pub, "RI step 1: Retrieving terminal's public key")
+
+    ri = RI_STEP2_compute_identifier(picc_ctx, sector_pub);
+    CHECK(1, ri, "RI step 2: Computing sector identifier")
+
+    failed = 0;
+
+err:
+    if (debug) {
+        bio = BIO_new_fp(stdout, BIO_NOCLOSE|BIO_FP_TEXT);
+        if (bio) {
+            BIO_printf(bio, "    PICC's EAC Context:\n");
+            EAC_CTX_print_private(bio, picc_ctx, 6);
+            BIO_printf(bio, "    PCD's EAC Context:\n");
+            EAC_CTX_print_private(bio, pcd_ctx, 6);
+            BIO_printf(bio, "    PACE step 1: Encrypted Nonce:\n");
+            BUF_MEM_print(bio, enc_nonce, 6);
+            BIO_printf(bio, "    PACE step 3a: PCD's mapping data:\n");
+            BUF_MEM_print(bio, static_pub_pcd, 6);
+            BIO_printf(bio, "    PACE step 3a: PICC's mapping data:\n");
+            BUF_MEM_print(bio, static_pub_picc, 6);
+            BIO_printf(bio, "    PACE step 3d: PCD's Authentication Token:\n");
+            BUF_MEM_print(bio, token_pcd, 6);
+            BIO_printf(bio, "    PACE step 3d: PICC's Authentication Token:\n");
+            BUF_MEM_print(bio, token_picc, 6);
+            BIO_printf(bio, "    PICC's compressed PACE public key (ID ICC):\n");
+            BUF_MEM_print(bio, id_picc, 6);
+            BIO_printf(bio, "    TA step 3: PCD's compressed CA public key:\n");
+            BUF_MEM_print(bio, ta_comp_ephemeral_key_for_ca, 6);
+            BIO_printf(bio, "    TA step 5: PCD's signature:\n");
+            BUF_MEM_print(bio, ta_signature, 6);
+            BIO_printf(bio, "    Sector-specific identifier:\n");
+            BUF_MEM_print(bio, ri, 6);
+            BIO_free_all(bio);
+        }
+    }
+    if (token_picc)
+        BUF_MEM_free(token_picc);
+    if (token_pcd)
+        BUF_MEM_free(token_pcd);
+    if (ephemeral_pub_picc)
+        BUF_MEM_free(ephemeral_pub_picc);
+    if (ephemeral_pub_pcd)
+        BUF_MEM_free(ephemeral_pub_pcd);
+    if (static_pub_picc)
+        BUF_MEM_free(static_pub_picc);
+    if (static_pub_pcd)
+        BUF_MEM_free(static_pub_pcd);
+    if (enc_nonce)
+        BUF_MEM_free(enc_nonce);
+    if (id_picc)
+        BUF_MEM_free(id_picc);
+    if (ta_nonce)
+        BUF_MEM_free(ta_nonce);
+    if (ta_comp_ephemeral_key_for_ca)
+        BUF_MEM_free(ta_comp_ephemeral_key_for_ca);
+    if (ta_signature)
+        BUF_MEM_free(ta_signature);
+    if (ca_picc_comp_pubkey)
+        BUF_MEM_free(ca_picc_comp_pubkey);
+    if (ca_picc_pubkey)
+        BUF_MEM_free(ca_picc_pubkey);
+    if (ca_pcd_pubkey)
+        BUF_MEM_free(ca_pcd_pubkey);
+    if (ca_nonce)
+        BUF_MEM_free(ca_nonce);
+    if (ca_token)
+        BUF_MEM_free(ca_token);
+    if (ri)
+        BUF_MEM_free(ri);
+    if (sector_pub)
+        BUF_MEM_free(sector_pub);
+    EAC_CTX_clear_free(picc_ctx);
+    EAC_CTX_clear_free(pcd_ctx);
+    PACE_SEC_clear_free(s);
+
+    END;
+}
+
+/* Perform dynamic tests of the EAC protocol using different combinations of the
+ * parameters (pace_secret, protocols and standardized domain parameters)*/
+static int
+do_dynamic_eac_tests(void)
+{
+    int i, j, k, l, m, failed = 0;
+
+    printf("Dynamic EAC tests:\n");
+
+    for (i = 0, j = 0, k = 0, l = 0, m = 0;
+            i < (sizeof dynamic_pace_params) / sizeof(*dynamic_pace_params);
+            i++, j++, k++, l++, m++) {
+        if (j >= (sizeof dynamic_pace_secrets) / sizeof(*dynamic_pace_secrets)) {
+            j = 0;
+        }
+        if (k >= (sizeof dynamic_ta_params) / sizeof(*dynamic_ta_params)) {
+            k = 0;
+        }
+        if (l >= (sizeof dynamic_ca_params) / sizeof(*dynamic_ca_params)) {
+            l = 0;
+        }
+        if (m >= (sizeof dynamic_ri_params) / sizeof(*dynamic_ri_params)) {
+            m = 0;
+        }
+        failed += dynamic_eac_test(dynamic_pace_secrets[j], dynamic_pace_params[i],
+                dynamic_ta_params[k], dynamic_ca_params[l], dynamic_ri_params[m]);
+    }
+
+    return failed;
+}
+
+/* Encrypt and decrypt some data with the symmetric keys derived during PACE */
+static int
+test_enc(EAC_CTX *ctx, unsigned int send_sequence_counter,
+        const BUF_MEM *data, const BUF_MEM *enc)
+{
+    int ok = 0;
+    BUF_MEM *pad = NULL, *enc_buf = NULL, *dec_buf = NULL;
+    BIGNUM *ssc = NULL;
+
+    ssc = BN_new();
+    CHECK(0, ssc && BN_set_word(ssc, send_sequence_counter),
+            "Initializing Send Sequence Counter");
+
+    pad = EAC_add_iso_pad(data, EVP_CIPHER_block_size(ctx->key_ctx->cipher));
+    enc_buf = EAC_encrypt(ctx, ssc, pad);
+    CHECK(0, buf_eq_buf(enc_buf, enc),
+            "Encrypting");
+
+    dec_buf = EAC_decrypt(ctx, ssc, enc_buf);
+    CHECK(0, buf_eq_buf(dec_buf, pad),
+            "Decrypting");
+
+    CHECK(1, 1, "Encrypting/Decrypting");
+
+    ok = 1;
+
+err:
+    if (ssc)
+        BN_clear_free(ssc);
+    if (pad)
+        BUF_MEM_free(pad);
+    if (enc_buf)
+        BUF_MEM_free(enc_buf);
+    if (dec_buf)
+        BUF_MEM_free(dec_buf);
+
+    return ok;
+}
+
+/* Authenticate some data with the symmetric keys derived during PACE */
+static int
+test_auth(EAC_CTX *ctx, unsigned int send_sequence_counter,
+        const BUF_MEM *data, const BUF_MEM *mac)
+{
+    int ok = 0;
+    BUF_MEM *pad = NULL, *auth = NULL;
+    BIGNUM *ssc = NULL;
+
+    ssc = BN_new();
+    CHECK(0, ssc && BN_set_word(ssc, send_sequence_counter),
+            "Initializing Send Sequence Counter");
+
+    pad = EAC_add_iso_pad(data, EVP_CIPHER_block_size(ctx->key_ctx->cipher));
+    auth = EAC_authenticate(ctx, ssc, pad);
+    CHECK(1, buf_eq_buf(auth, mac), "Authenticating");
+
+    ok = 1;
+
+err:
+    if (ssc)
+        BN_clear_free(ssc);
+    if (pad)
+        BUF_MEM_free(pad);
+    if (auth)
+        BUF_MEM_free(auth);
+
+    return ok;
+}
+
+/* Perform one EAC protocol run using static test data */
+static int
+static_eac_test(struct eac_worked_example tc)
+{
+    int failed = 1, i;
+    PACE_SEC *pace_sec = NULL;
+    BUF_MEM *enc_nonce = NULL,
+            *token_picc = NULL, *token_pcd = NULL,
+            *ta_comp_ephemeral_key_for_ca = NULL,
+            *signature = NULL, *ephemeral_pub_picc = NULL, *id_picc = NULL,
+            *ta_pcd_eph_pub_key_for_ca = NULL, *ta_pcd_comp_eph_pub_key_for_ca = NULL;
+    EAC_CTX *picc_ctx = NULL, *pcd_ctx = NULL;
+    BIO *bio = NULL;
+    CVC_CERT *ta_cert = NULL;
+
+
+    print_desc(tc.pace_info_oid, tc.pace_curve);
+
+    /* PACE */
+
+    /* Initialization */
+    pace_sec = PACE_SEC_new(tc.password, strlen(tc.password),
+            tc.password_type);
+    picc_ctx = EAC_CTX_new();
+    pcd_ctx = EAC_CTX_new();
+    CHECK(1, EAC_CTX_init_ef_cardaccess((unsigned char *) tc.ef_cardaccess.data, tc.ef_cardaccess.length,
+                picc_ctx)
+            && EAC_CTX_init_ef_cardaccess((unsigned char *) tc.ef_cardaccess.data,
+                tc.ef_cardaccess.length, pcd_ctx)
+            && picc_ctx->pace_ctx->version == tc.pace_version
+            && picc_ctx->pace_ctx->protocol == tc.pace_info_oid
+            && pcd_ctx->pace_ctx->version == tc.pace_version
+            && pcd_ctx->pace_ctx->protocol == tc.pace_info_oid,
+            "Parsing EF.CardAccess");
+
+
+    /* Generate, En-/Decrypt Nonce */
+    picc_ctx->pace_ctx->nonce = BUF_MEM_create_init((unsigned char *) tc.pace_nonce.data, tc.pace_nonce.length);
+    enc_nonce = BUF_MEM_create_init((unsigned char *) tc.pace_enc_nonce.data, tc.pace_enc_nonce.length);
+    CHECK(1, PACE_STEP2_dec_nonce(pcd_ctx, pace_sec, enc_nonce)
+            && buf_eq_buf(pcd_ctx->pace_ctx->nonce, &tc.pace_nonce),
+            "PACE step 2: Terminal decrypted the correct nonce");
+
+
+    /* Set static key pair and perform mapping to the ephemeral generator */
+    /* Since the static keys are pre-defined we can omit the call to
+     * PACE_STEP3A_generate_mapping_data */
+    CHECK(1, EVP_PKEY_set_keys(pcd_ctx->pace_ctx->static_key,
+                   &tc.pace_static_pcd_priv_key, &tc.pace_static_pcd_pub_key,
+                   pcd_ctx->bn_ctx)
+            && PACE_STEP3A_map_generator(pcd_ctx, &tc.pace_static_picc_pub_key)
+            && EVP_PKEY_set_keys(picc_ctx->pace_ctx->static_key,
+                &tc.pace_static_picc_priv_key, &tc.pace_static_picc_pub_key,
+                picc_ctx->bn_ctx)
+            && PACE_STEP3A_map_generator(picc_ctx, &tc.pace_static_pcd_pub_key)
+            && check_generator(picc_ctx->pace_ctx->ka_ctx->key,
+                tc.pace_eph_generator, picc_ctx->bn_ctx)
+            && check_generator(pcd_ctx->pace_ctx->ka_ctx->key,
+                tc.pace_eph_generator, pcd_ctx->bn_ctx),
+            "PACE step 3a: Mapped to ephemeral domain parameters");
+
+
+    /* Set the ephemeral key pair and perform the key agreement */
+    /* Since the static keys are pre-defined we can omit the call to
+     * PACE_STEP3B_generate_ephemeral_key */
+    pcd_ctx->pace_ctx->my_eph_pubkey =
+        BUF_MEM_create_init(tc.pace_eph_pcd_pub_key.data,
+                tc.pace_eph_pcd_pub_key.length);
+    picc_ctx->pace_ctx->my_eph_pubkey =
+        BUF_MEM_create_init(tc.pace_eph_picc_pub_key.data,
+                tc.pace_eph_picc_pub_key.length);
+    CHECK(1, EVP_PKEY_set_keys(pcd_ctx->pace_ctx->ka_ctx->key,
+                   &tc.pace_eph_pcd_priv_key, &tc.pace_eph_pcd_pub_key,
+                   pcd_ctx->bn_ctx)
+            && EVP_PKEY_set_keys(picc_ctx->pace_ctx->ka_ctx->key,
+                &tc.pace_eph_picc_priv_key, &tc.pace_eph_picc_pub_key,
+                picc_ctx->bn_ctx)
+            && PACE_STEP3B_compute_shared_secret(pcd_ctx, &tc.pace_eph_picc_pub_key)
+            && buf_eq_buf(pcd_ctx->pace_ctx->ka_ctx->shared_secret, &tc.pace_shared_secret_k)
+            && PACE_STEP3B_compute_shared_secret(picc_ctx, &tc.pace_eph_pcd_pub_key)
+            && buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->shared_secret, &tc.pace_shared_secret_k),
+            "PACE step 3b: computed shared secret");
+
+
+    /* Derive session keys */
+    CHECK(1, PACE_STEP3C_derive_keys(pcd_ctx)
+            && buf_eq_buf(pcd_ctx->pace_ctx->ka_ctx->k_enc, &tc.pace_k_enc)
+            && buf_eq_buf(pcd_ctx->pace_ctx->ka_ctx->k_mac, &tc.pace_k_mac)
+            && PACE_STEP3C_derive_keys(picc_ctx)
+            && buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->k_enc, &tc.pace_k_enc)
+            && buf_eq_buf(picc_ctx->pace_ctx->ka_ctx->k_mac, &tc.pace_k_mac),
+            "PACE step 3c: Derived Keys");
+
+
+    /* Derive and verify authentication tokens */
+    token_pcd = PACE_STEP3D_compute_authentication_token(pcd_ctx,
+            &tc.pace_eph_picc_pub_key);
+    token_picc = PACE_STEP3D_compute_authentication_token(picc_ctx,
+            &tc.pace_eph_pcd_pub_key);
+    CHECK(1, buf_eq_buf(token_pcd, &tc.pace_authentication_token_pcd)
+            && buf_eq_buf(token_picc, &tc.pace_authentication_token_picc)
+            && PACE_STEP3D_verify_authentication_token(picc_ctx, token_pcd) == 1
+            && PACE_STEP3D_verify_authentication_token(pcd_ctx, token_picc) == 1,
+            "PACE step 3d: Computed and verified authentication tokens");
+
+
+    /* Initialize secure channel */
+    CHECK(0, EAC_CTX_set_encryption_ctx(pcd_ctx, EAC_ID_PACE)
+            && EAC_CTX_set_encryption_ctx(picc_ctx, EAC_ID_PACE),
+            "Initializing encryption");
+    /* picc_ctx and pcd_ctx look the same with respect to SM, it doesn't matter
+     * which one we are using for encryption/decryption or authentication */
+
+    /* En-/Decrypt some test data */
+    for (i = 0; (size_t) i < tc.pace_encrypt_decrypt_len; i++) {
+        if (!test_enc(pcd_ctx, tc.pace_encrypt_decrypt[i].ssc,
+                    &tc.pace_encrypt_decrypt[i].data,
+                    &tc.pace_encrypt_decrypt[i].cipher))
+            goto err;;
+    }
+
+    /* Authenticate some test data */
+    for (i = 0; (size_t) i < tc.pace_authenticate_len; i++) {
+        if (!test_auth(picc_ctx, tc.pace_authenticate[i].ssc,
+                    &tc.pace_authenticate[i].data,
+                    &tc.pace_authenticate[i].mac))
+            goto err;;
+    }
+
+    /* Terminal Authentication*/
+
+    /* We need to chose one of the supported CA keys specified in the EF.CardAccess
+     * BEFORE Terminal Authentication. Therefore, we need to initialize the CA
+     * context before TA. */
+    CHECK(1, EAC_CTX_init_ca(pcd_ctx, tc.ca_info_oid, tc.ca_curve,
+                (unsigned char *) tc.ca_pcd_priv_key.data, tc.ca_pcd_priv_key.length,
+                (unsigned char *) tc.ca_pcd_pub_key.data, tc.ca_pcd_pub_key.length)
+            && EAC_CTX_init_ca(picc_ctx, tc.ca_info_oid, tc.ca_curve,
+                (unsigned char *) tc.ca_picc_priv_key.data, tc.ca_picc_priv_key.length,
+                (unsigned char *) tc.ca_picc_pub_key.data, tc.ca_picc_pub_key.length),
+            "Initializing Chip Authentication");
+
+    picc_ctx->ta_ctx->flags |= TA_FLAG_SKIP_TIMECHECK;
+    pcd_ctx->ta_ctx->flags |= TA_FLAG_SKIP_TIMECHECK;
+    /* Initialize the TA contexts. The PICC gets initialized with the trust anchor
+     * (CVCA) and the PCD gets initialized with the terminal certificate */
+    CHECK(1, EAC_CTX_init_ta(pcd_ctx, (unsigned char *) tc.ta_pcd_key.data,
+                tc.ta_pcd_key.length, (unsigned char *) tc.ta_cert.data,
+                tc.ta_cert.length, NULL, 0)
+            && EAC_CTX_init_ta(picc_ctx, NULL, 0, (unsigned char *)
+                tc.ta_cvca.data, tc.ta_cvca.length, NULL, 0),
+            "Initializing Terminal Authentication");
+    OK;
+    print_desc(pcd_ctx->ta_ctx->protocol, tc.ta_curve);
+
+    /* Import the certificate chain. Currently we only support chains of length
+     * three (CVCA certificate, DV certificate and terminal certificate). The
+     * trust anchor is already imported during the EAC_CTX_init_ta call above */
+    CHECK(1, TA_STEP2_import_certificate(picc_ctx, (unsigned char *) tc.ta_dv_cert.data,
+                tc.ta_dv_cert.length)
+            && TA_STEP2_import_certificate(picc_ctx, (unsigned char *) tc.ta_cert.data,
+                tc.ta_cert.length),
+            "TA step 2: Imported and verified terminal's certificate");
+
+    /* Import the specified nonce. This makes TA_STEP4_get_nonce superfluous. */
+    CHECK(1, TA_STEP4_set_nonce(picc_ctx, &tc.ta_nonce)
+            && TA_STEP4_set_nonce(pcd_ctx, &tc.ta_nonce),
+            "TA STEP 4: Imported nonce");
+
+    /* Create the signature. Since the challenge is pre-specified we do not
+     * generate it on our own (and therefore don't call TA_STEP4_get_nonce */
+    ephemeral_pub_picc = BUF_MEM_create_init(tc.pace_eph_picc_pub_key.data, tc.pace_eph_picc_pub_key.length);
+    id_picc = EAC_Comp(picc_ctx, EAC_ID_PACE, ephemeral_pub_picc);
+    ta_pcd_eph_pub_key_for_ca = BUF_MEM_create_init(tc.ca_pcd_pub_key.data, tc.ca_pcd_pub_key.length);
+    ta_pcd_comp_eph_pub_key_for_ca = EAC_Comp(picc_ctx, EAC_ID_CA, ta_pcd_eph_pub_key_for_ca);
+    signature = TA_STEP5_sign(pcd_ctx, ta_pcd_comp_eph_pub_key_for_ca, id_picc, &tc.ta_auxdata);
+    CHECK(1, signature,
+            "TA step 5: Signed nonce, public key, auxiliary data");
+
+    /* Verify the response */
+    switch(picc_ctx->ta_ctx->protocol) {
+        case NID_id_TA_RSA_v1_5_SHA_1:
+        case NID_id_TA_RSA_v1_5_SHA_256:
+        case NID_id_TA_RSA_v1_5_SHA_512:
+            /* In case of a probabilistic signature our signature will not be
+             * equal to the signature specified in the worked example. Therefore,
+             * we only compare the signatures in the deterministic case */
+            CHECK(0, buf_eq_buf(signature, &tc.ta_pcd_signature),
+                    "Signature does match test data");
+        case NID_id_TA_RSA_PSS_SHA_1:
+        case NID_id_TA_RSA_PSS_SHA_256:
+        case NID_id_TA_RSA_PSS_SHA_512:
+        case NID_id_TA_ECDSA_SHA_1:
+        case NID_id_TA_ECDSA_SHA_224:
+        case NID_id_TA_ECDSA_SHA_256:
+        case NID_id_TA_ECDSA_SHA_384:
+        case NID_id_TA_ECDSA_SHA_512:
+            /* Verify both our as well as the pre-defined signature (equal in the
+             * deterministic case). */
+            CHECK(1, TA_STEP6_verify(picc_ctx, ta_pcd_comp_eph_pub_key_for_ca, id_picc,
+                        &tc.ta_auxdata, signature) == 1
+                    && TA_STEP6_verify(picc_ctx, ta_pcd_comp_eph_pub_key_for_ca, id_picc,
+                        &tc.ta_auxdata, &tc.ta_pcd_signature) == 1,
+                    "TA step 6: Verified signature");
+            break;
+        default:
+            CHECK(1, 0, "Unknown TA protocol OID");
+    }
+
+    OK;
+    print_desc(tc.ca_info_oid, tc.ca_curve);
+
+
+    /* Chip Authentication */
+    /* Generate the ephemeral CA key */
+    ta_comp_ephemeral_key_for_ca = CA_STEP2_get_eph_pubkey(pcd_ctx);
+    CHECK(1, buf_eq_buf(ta_comp_ephemeral_key_for_ca, &tc.ca_pcd_pub_key),
+            "CA step 2: Encoded PCD's ephemeral key");
+
+    /* We do not have the compressed public key and thus can't perform
+     * CA_STEP3_check_pcd_pubkey */
+
+    /* Perform the key agreement and check the results. */
+    CHECK(1, CA_STEP4_compute_shared_secret(picc_ctx, ta_comp_ephemeral_key_for_ca)
+            && buf_eq_buf(picc_ctx->ca_ctx->ka_ctx->shared_secret,
+                &tc.ca_shared_secret_k)
+            && CA_STEP4_compute_shared_secret(pcd_ctx, &tc.ca_picc_pub_key)
+            && buf_eq_buf(pcd_ctx->ca_ctx->ka_ctx->shared_secret,
+                &tc.ca_shared_secret_k),
+            "CA step 4: Compute shared secret");
+
+    /* Derive session keys */
+    CHECK(1, CA_STEP6_derive_keys(pcd_ctx, &tc.ca_nonce, &tc.ca_picc_token)
+            && buf_eq_buf(pcd_ctx->ca_ctx->ka_ctx->shared_secret,
+                &tc.ca_shared_secret_k)
+            && buf_eq_buf(pcd_ctx->ca_ctx->ka_ctx->k_enc,
+                &tc.ca_k_enc)
+            && buf_eq_buf(pcd_ctx->ca_ctx->ka_ctx->k_mac,
+                &tc.ca_k_mac),
+            "CA step 6: Derived keys for terminal");
+
+    /* Initialize secure channel (here keys were derived for PCD only) */
+    CHECK(1, EAC_CTX_set_encryption_ctx(pcd_ctx, EAC_ID_CA),
+            "Initializing encryption");
+
+    failed = 0;
+
+err:
+    if (debug) {
+        bio = BIO_new_fp(stdout, BIO_NOCLOSE|BIO_FP_TEXT);
+        if (bio) {
+            /*CVC_CERT *cert = NULL;
+            cert = CVC_d2i_CVC_CERT(&cert, (const unsigned char **) &tc.ta_cvca.data, tc.ta_cvca.length);
+            cert = CVC_d2i_CVC_CERT(&cert, (const unsigned char **) &tc.ta_dv_cert.data, tc.ta_dv_cert.length);
+            CVC_CERT_print_ctx(bio, cert, 0, NULL);
+            CVC_CERT_print_ctx(bio, picc_ctx->ta_ctx->current_cert, 0, NULL);*/
+            BIO_printf(bio, "    PICC's EAC Context:\n");
+            EAC_CTX_print_private(bio, picc_ctx, 6);
+            BIO_printf(bio, "    PCD's EAC Context:\n");
+            EAC_CTX_print_private(bio, pcd_ctx, 6);
+            BIO_printf(bio, "    PACE step 1: Encrypted Nonce:\n");
+            BUF_MEM_print(bio, enc_nonce, 6);
+            BIO_printf(bio, "    PACE step 3a: PCD's mapping data:\n");
+            BUF_MEM_print(bio, &tc.pace_eph_pcd_pub_key, 6);
+            BIO_printf(bio, "    PACE step 3a: PICC's mapping data:\n");
+            BUF_MEM_print(bio, &tc.pace_eph_picc_pub_key, 6);
+            BIO_printf(bio, "    PACE step 3d: PCD's Authentication Token:\n");
+            BUF_MEM_print(bio, token_pcd, 6);
+            BIO_printf(bio, "    PACE step 3d: PICC's Authentication Token:\n");
+            BUF_MEM_print(bio, token_picc, 6);
+            BIO_printf(bio, "    PICC's compressed PACE public key (ID ICC):\n");
+            BUF_MEM_print(bio, id_picc, 6);
+            BIO_printf(bio, "    TA step 3: PCD's compressed CA public key:\n");
+            BUF_MEM_print(bio, ta_comp_ephemeral_key_for_ca, 6);
+            BIO_printf(bio, "    TA step 5: PCD's signature:\n");
+            BUF_MEM_print(bio, &tc.ta_pcd_signature, 6);
+            BIO_free_all(bio);
+        }
+    }
+
+    if (ephemeral_pub_picc)
+        BUF_MEM_free(ephemeral_pub_picc);
+    if (id_picc)
+        BUF_MEM_free(id_picc);
+    if (ta_pcd_eph_pub_key_for_ca)
+        BUF_MEM_free(ta_pcd_eph_pub_key_for_ca);
+    if (ta_pcd_comp_eph_pub_key_for_ca)
+        BUF_MEM_free(ta_pcd_comp_eph_pub_key_for_ca);
+    if (ta_cert)
+        CVC_CERT_free(ta_cert);
+    if (signature)
+        BUF_MEM_free(signature);
+    if (ta_comp_ephemeral_key_for_ca)
+        BUF_MEM_free(ta_comp_ephemeral_key_for_ca);
+    if (enc_nonce)
+        BUF_MEM_free(enc_nonce);
+    if (token_picc)
+        BUF_MEM_free(token_picc);
+    if (token_pcd)
+        BUF_MEM_free(token_pcd);
+    EAC_CTX_clear_free(picc_ctx);
+    EAC_CTX_clear_free(pcd_ctx);
+    PACE_SEC_clear_free(pace_sec);
+
+    END;
+}
+
+/* Perform all the tests specified in the EAC worked example */
+static int
+test_worked_examples(void)
+{
+    int i, failed = 0;
+
+    printf("EAC worked examples:\n");
+
+    for (i = 0; i<(sizeof eac_examples)/sizeof(*eac_examples); i++) {
+        failed += static_eac_test(eac_examples[i]);
+    }
+
+    return failed;
+}
+
+/* Try to parse an EF.CardAccess structure and extract the content */
+static int
+test_ef_cardaccess_parsing(const struct ef_cardaccess tc)
+{
+    int failed = 1;
+    EAC_CTX *ctx = NULL;
+
+    ctx = EAC_CTX_new();
+    CHECK(1, ctx && EAC_CTX_init_ef_cardaccess(tc.ef_cardaccess,
+                tc.ef_cardaccess_len, ctx)
+            && ctx->pace_ctx && ctx->pace_ctx->static_key &&
+            ctx->pace_ctx->ka_ctx && ctx->pace_ctx->ka_ctx->md
+            && ctx->pace_ctx->ka_ctx->cipher &&
+            ctx->pace_ctx->map_compute_key && ctx->pace_ctx->map_generate_key,
+            "Parsed EF.CardAccess");
+
+    failed = 0;
+
+err:
+    EAC_CTX_clear_free(ctx);
+
+    return failed;
+}
+
+/* Try to parse a CV certificate and optionally the corresponding certificate
+ * description*/
+static int
+test_cv_cert_parsing(const struct cv_cert tc)
+{
+    BIO *bio = NULL;
+    CVC_CERT *cvc_cert = NULL;
+    CVC_CERTIFICATE_DESCRIPTION *desc = NULL;
+    const unsigned char *p;
+    int failed = 1;
+
+    if (tc.cv_cert && tc.cv_cert_len) {
+        p = tc.cv_cert;
+        cvc_cert = CVC_d2i_CVC_CERT(NULL, &p, tc.cv_cert_len);
+        CHECK(1, cvc_cert,
+                "Parsed CV Certificate");
+    }
+
+    if (tc.cv_cert_desc && tc.cv_cert_desc_len) {
+        p = tc.cv_cert_desc;
+        desc = d2i_CVC_CERTIFICATE_DESCRIPTION(NULL, &p, tc.cv_cert_desc_len);
+        CHECK(1, desc,
+                "Parsed Certificate Description");
+    }
+
+    if (tc.cv_cert && tc.cv_cert_len && tc.cv_cert_desc && tc.cv_cert_desc_len) {
+        CHECK(1, 1 == CVC_check_description(cvc_cert, tc.cv_cert_desc, tc.cv_cert_desc_len),
+                "Certificate Description matches Certificate");
+    }
+
+    failed = 0;
+
+err:
+    if (debug) {
+        bio = BIO_new_fp(stdout, BIO_NOCLOSE|BIO_FP_TEXT);
+        if (bio) {
+            BIO_printf(bio, "    Card Verifiable Certificate:\n");
+            cvc_print(bio, cvc_cert, 6);
+            CVC_CERTIFICATE_DESCRIPTION_print_ctx(bio, desc, 4, NULL);
+        }
+    }
+
+    if (desc)
+        CVC_CERTIFICATE_DESCRIPTION_free(desc);
+    if (cvc_cert)
+        CVC_CERT_free(cvc_cert);
+    if (bio)
+        BIO_free_all(bio);
+
+    return failed;
+}
+
+/* Perform the parsing of EF.CardAccess and CV certificates for various test
+ * vectors */
+static int
+test_parsing(void)
+{
+    int i, failed = 0;
+
+    printf("Parsing capabilities:\n");
+
+    printf("  EF.CardAccess              %s", verbose ? "\n" : " ");
+    for (i = 0; i<(sizeof ef_cardaccess_files)/sizeof(*ef_cardaccess_files); i++) {
+        failed += test_ef_cardaccess_parsing(ef_cardaccess_files[i]);
+    }
+    TESTEND;
+
+    printf("  Card Verifiable Certificate%s", verbose ? "\n" : " ");
+    for (i = 0; i<(sizeof cv_certs)/sizeof(*cv_certs); i++) {
+        failed += test_cv_cert_parsing(cv_certs[i]);
+    }
+
+    END;
+}
+
+
+
+/******************************************************************************/
+
+int
+main(int argc, char *argv[])
+{
+    int i;
+    int failed = 0;
+    unsigned char c;
+
+    for (i=1; i<argc; i++)
+    {
+        if ((strcmp(argv[i], "--verbose") == 0)
+                || (strcmp(argv[i], "-v") == 0)) {
+            verbose++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--debug") == 0)
+                || (strcmp(argv[i], "-d") == 0)) {
+            verbose++;
+            debug++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--help") == 0)
+                || (strcmp(argv[i], "-h") == 0)) {
+            fprintf(stderr,
+                    "%s tests the OpenSSL implementation of EAC\n"
+                    "\n"
+                    "  Extended Access Control (EAC) includes Password Authentication\n"
+                    "  Connection Establishment (PACE), Terminal Authentication (TA)\n"
+                    "  and Chip Authentication (CA).\n"
+                    "\n"
+                    "Usage: %s [Options]\n"
+                    "\n"
+                    "Options:\n"
+                    "  -h,--help         show this help message and exit\n"
+                    "  -v,--verbose      more verbosity\n"
+                    "  -d,--debug        even more verbosity\n"
+                    "     --version      print version information and exit\n"
+                    , argv[0], argv[0]
+            );
+            return 0;
+        }
+        if (strcmp(argv[i], "--version") == 0) {
+            fprintf(stderr,
+                    "%s 0.6\n"
+                    "\n"
+                    "Written by Frank Morgner and Dominik Oepen.\n"
+                    , argv[0]
+            );
+            return 0;
+        }
+
+        fprintf(stderr, "unrecognized option \"%s\"\n", argv[i]);
+        return 1;
+    }
+
+    /* all possible characters as character string */
+    for (c = 0x20, i = 0; i < sizeof pace_raw; c++, i++) {
+        while (c <= 0x1f || (c >= 0x7f && c <= 0x9f)) {
+            c++;
+        }
+        pace_raw[i] = c;
+    }
+
+    /*printf("%s:%d\n", __FILE__, __LINE__);*/
+    failed += test_parsing();
+    failed += test_worked_examples();
+    failed += do_dynamic_eac_tests();
+
+    if (failed)
+        printf("%d errors collected.\n", failed);
+    else
+        printf("Everything works as expected.\n");
+
+    return failed;
+}
+
+#endif /* OPENSSL_NO_PACE */
Index: openssl/crypto/eac/pace.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,194 @@
+/**
+ * @file
+ * @brief OpenPACE implementation
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_kdf.h"
+#include "eac_util.h"
+#include "eac_lib.h"
+#include "pace_mappings.h"
+#include <openssl/crypto.h>
+#include <openssl/eac.h>
+#include <openssl/ecdh.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include <string.h>
+
+int
+PACE_STEP1_enc_nonce(const EAC_CTX * ctx, const PACE_SEC * pi,
+                   BUF_MEM ** enc_nonce)
+{
+    BUF_MEM * key = NULL;
+    int r = 0;
+
+    if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->ka_ctx || !ctx->pace_ctx->ka_ctx->cipher|| !enc_nonce) {
+        EACerr(EAC_F_PACE_STEP1_ENC_NONCE, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    key = kdf_pi(pi, NULL, ctx->pace_ctx->ka_ctx, ctx->md_ctx);
+    if (!key)
+        goto err;
+
+    BUF_MEM_clear_free(ctx->pace_ctx->nonce);
+    ctx->pace_ctx->nonce = randb(EVP_CIPHER_block_size(ctx->pace_ctx->ka_ctx->cipher));
+    if (!ctx->pace_ctx->nonce)
+        goto err;
+
+    *enc_nonce = cipher_no_pad(ctx->pace_ctx->ka_ctx, ctx->cipher_ctx, key, ctx->pace_ctx->nonce, 1);
+    if (!*enc_nonce)
+        goto err;
+
+    r = 1;
+
+err:
+    BUF_MEM_clear_free(key);
+
+    return r;
+}
+
+int
+PACE_STEP2_dec_nonce(const EAC_CTX * ctx, const PACE_SEC * pi,
+        const BUF_MEM * enc_nonce)
+{
+    BUF_MEM *key = NULL;
+    int r = 0;
+
+    if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->ka_ctx || !ctx->pace_ctx->ka_ctx->cipher) {
+        EACerr(EAC_F_PACE_STEP2_DEC_NONCE, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    key = kdf_pi(pi, NULL, ctx->pace_ctx->ka_ctx, ctx->md_ctx);
+    if (!key)
+        goto err;
+
+    BUF_MEM_clear_free(ctx->pace_ctx->nonce);
+    ctx->pace_ctx->nonce = cipher_no_pad(ctx->pace_ctx->ka_ctx, ctx->cipher_ctx, key, enc_nonce, 0);
+    if (!ctx->pace_ctx->nonce)
+        goto err;
+
+    r = 1;
+
+err:
+    BUF_MEM_clear_free(key);
+
+    return r;
+}
+
+BUF_MEM *
+PACE_STEP3A_generate_mapping_data(const EAC_CTX * ctx)
+{
+    if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->map_generate_key) {
+        EACerr(EAC_F_PACE_STEP3A_GENERATE_MAPPING_DATA, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return ctx->pace_ctx->map_generate_key(ctx->pace_ctx, ctx->bn_ctx);
+}
+
+int
+PACE_STEP3A_map_generator(const EAC_CTX * ctx, const BUF_MEM * in)
+{
+    if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->map_compute_key) {
+        EACerr(EAC_F_PACE_STEP3A_MAP_GENERATOR, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    return ctx->pace_ctx->map_compute_key(ctx->pace_ctx, ctx->pace_ctx->nonce, in, ctx->bn_ctx);
+}
+
+BUF_MEM *
+PACE_STEP3B_generate_ephemeral_key(EAC_CTX * ctx)
+{
+    if (!ctx || !ctx->pace_ctx) {
+        EACerr(EAC_F_PACE_STEP3B_GENERATE_EPHEMERAL_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    ctx->pace_ctx->my_eph_pubkey = KA_CTX_generate_key(ctx->pace_ctx->ka_ctx,
+            ctx->bn_ctx);
+
+    if (!ctx->pace_ctx->my_eph_pubkey)
+        return NULL;
+
+    return BUF_MEM_create_init(ctx->pace_ctx->my_eph_pubkey->data,
+            ctx->pace_ctx->my_eph_pubkey->length);
+}
+
+int
+PACE_STEP3B_compute_shared_secret(const EAC_CTX * ctx, const BUF_MEM * in)
+{
+    BUF_MEM *my_pub = NULL;
+    int r = 0;
+
+    if (!ctx || !ctx->pace_ctx || !ctx->pace_ctx->ka_ctx
+            || !ctx->pace_ctx->ka_ctx->compute_key || !in) {
+        EACerr(EAC_F_PACE_STEP3B_COMPUTE_SHARED_SECRET, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Check if the new public key is different from the other party's public
+     * key.  Note that this check is only required since TR-03110 v2.02, but it
+     * makes sense to always check this... */
+    if (!ctx->pace_ctx->my_eph_pubkey
+               || (in->length == ctx->pace_ctx->my_eph_pubkey->length
+                && memcmp(in->data, ctx->pace_ctx->my_eph_pubkey, in->length) == 0)) {
+        EACerr(EAC_F_PACE_STEP3B_COMPUTE_SHARED_SECRET, EAC_R_BAD_DH_OR_ECKEY_OBJECT);
+        goto err;
+    }
+
+
+    if (!KA_CTX_compute_key(ctx->pace_ctx->ka_ctx, in, ctx->bn_ctx))
+        goto err;
+
+    r = 1;
+
+err:
+    if (my_pub)
+        BUF_MEM_free(my_pub);
+
+    return r;
+}
+
+int
+PACE_STEP3C_derive_keys(const EAC_CTX *ctx)
+{
+    if (!ctx || !ctx->pace_ctx) {
+        EACerr(EAC_F_PACE_STEP3C_DERIVE_KEYS, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    return KA_CTX_derive_keys(ctx->pace_ctx->ka_ctx, NULL, ctx->md_ctx);
+}
+
+BUF_MEM *
+PACE_STEP3D_compute_authentication_token(const EAC_CTX *ctx, const BUF_MEM *pub)
+{
+    if (!ctx || !ctx->pace_ctx) {
+        EACerr(EAC_F_PACE_STEP3D_COMPUTE_AUTHENTICATION_TOKEN, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return get_authentication_token(ctx->pace_ctx->protocol,
+            ctx->pace_ctx->ka_ctx, ctx->bn_ctx,
+            ctx->tr_version, pub);
+}
+
+int
+PACE_STEP3D_verify_authentication_token(const EAC_CTX *ctx, const BUF_MEM *token)
+{
+    if (!ctx || !token|| !ctx->pace_ctx) {
+        EACerr(EAC_F_PACE_STEP3D_VERIFY_AUTHENTICATION_TOKEN, EAC_R_INVALID_ARGUMENTS);
+        return -1;
+    }
+
+    return verify_authentication_token(ctx->pace_ctx->protocol,
+            ctx->pace_ctx->ka_ctx, ctx->bn_ctx, ctx->tr_version,
+            token);
+}
Index: openssl/crypto/eac/pace.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace.h	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,208 @@
+/**
+ * @file pace.h
+ * @brief Interface for Password Authenticated Connection Establishment
+ *
+ * PACE is a protocol used to establish strong session keys based
+ * on a weak shared secret (password). The result of a PACE run
+ * are two symmetric keys, one for MAC computation and one for
+ * encryption. It was specified for Extended Access Control (EAC)
+ * in Machine Readable Travel Documents (MRTD), but can also be
+ * used for securing any other communication channel.
+ * PACE can be used with different suites of algorithms and is not
+ * subject to any patents.
+ *
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_H_
+#define PACE_H_
+
+#include <openssl/buffer.h>
+#include <openssl/eac.h>
+#include <openssl/bn.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Enum for the type of the secret used. */
+enum s_type {
+    /** MRZ is the Machine Readable Zone, printed on the card, encoding
+     * the personal information of the user */
+    PACE_MRZ = 1,
+    /** CAN is the Card access number printed on the card */
+    PACE_CAN,
+    /** PIN is the Personal Identification Number, a secret known only
+     * to the user and not printed on the card */
+    PACE_PIN,
+    /** PUK is the Personal Unblocking key. This type of secret is used
+     * when the card is suspended due to too many incorrect PACE runs */
+    PACE_PUK,
+    /** This type of secret is not defined in BSI TR-03110. We use it as
+     * a generic type, so we can use PACE independent from a ID card */
+    PACE_RAW,
+    /** Undefined type, if nothing else matches */
+    PACE_SEC_UNDEF
+};
+
+/** @brief Shared secret for PACE */
+typedef struct pace_sec {
+    /** @brief Type of the secret */
+    enum s_type type;
+    /** @brief Raw secret */
+    BUF_MEM *mem;
+    /** @brief Encoded secret */
+    BUF_MEM *encoded;
+} PACE_SEC;
+
+/**
+ * @addtogroup management
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Free a PACE secret.
+ *
+ * Sensitive memory is cleared with OPENSSL_cleanse().
+ *
+ * @param[in] s (optional) Object to free
+ */
+void PACE_SEC_clear_free(PACE_SEC * s);
+/**
+ * @brief Create and initialize a new PACE secret.
+ *
+ * @param[in] sec Raw secret
+ * @param[in] sec_len Length of \a sec
+ * @param[in] type Type of secret
+ *
+ * @return New PACE secret or NULL in case of an error
+ */
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type);
+/** @} ***********************************************************************/
+
+/**
+ * @addtogroup paceproto
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Generates and encrypts a nonce.
+ *
+ * @param[in,out] ctx       EAC context. The nonce is saved in \a ctx.
+ * @param[in] pi        Shared secret for PACE
+ * @param[out] enc_nonce Where to save the new object containing the encrypted nonce
+ *
+ * @return          1 on success or 0 in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+int PACE_STEP1_enc_nonce(const EAC_CTX * ctx, const PACE_SEC * pi,
+                   BUF_MEM ** enc_nonce);
+/**
+ * @brief Decrypt the nonce from the other party.
+ *
+ * @param[in,out] ctx EAC context The decrypted nonce is saved in \a ctx.
+ * @param[in] pi Shared secret for PACE
+ * @param[in] enc_nonce Encrypted nonce from the other party
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+int PACE_STEP2_dec_nonce(const EAC_CTX * ctx, const PACE_SEC * pi,
+        const BUF_MEM * enc_nonce);
+/**
+ * @brief Generate a mapping data to perform the mapping to ephemeral domain
+ * parameters
+ *
+ * @param[in,out] ctx EAC context
+ *
+ * @return Mapping data to be transmitted to the other party or NULL in case of
+ * an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ * @see @ref pacemapecdh and @ref pacemapdh describe the mappings
+ */
+BUF_MEM *
+PACE_STEP3A_generate_mapping_data(const EAC_CTX * ctx);
+/**
+ * @brief Map to the ephemeral domain parameters.
+ *
+ * @param[in,out] ctx EAC context
+ * @param[in] in Mapping data from the other party
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ * @see @ref pacemapecdh and @ref pacemapdh describe the mappings
+ */
+int
+PACE_STEP3A_map_generator(const EAC_CTX * ctx, const BUF_MEM * in);
+/**
+ * @brief Generate a keypair for key agreement
+ *
+ * @param[in,out] ctx EAC context
+ *
+ * @return Public key or NULL in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+BUF_MEM * PACE_STEP3B_generate_ephemeral_key(EAC_CTX * ctx);
+/**
+ * @brief Compute the shared secret for key agreement
+ *
+ * @param[in,out] ctx EAC context. The secret is saved in \a ctx.
+ * @param[in] in Public key from the other party
+ *
+ * @return 1 on success 0 in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+int
+PACE_STEP3B_compute_shared_secret(const EAC_CTX * ctx, const BUF_MEM * in);
+/**
+ * @brief Derives encryption and authentication keys
+ *
+ * @param[in,out] ctx EAC context. The keys are saved in \a ctx.
+ *
+ * @return          1 on success or 0 in case of an error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+int PACE_STEP3C_derive_keys(const EAC_CTX *ctx);
+/**
+ * @brief Compute the authentication token from domain parameters
+ *           and public key
+ *
+ * @param[in] ctx EAC context
+ * @param[in] pub Public key from the other party (generated in PACE step 3b)
+ *
+ * @return Authentication token or NULL in case of error
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+BUF_MEM * PACE_STEP3D_compute_authentication_token(const EAC_CTX *ctx,
+        const BUF_MEM *pub);
+/**
+ * @brief Verifies an authentication token.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] token Authentication token from the other party
+ *
+ * @return 1 if the token has been verified as correct, 0 if not or -1 in case of an error
+ * occurred.
+ *
+ * @see PACE's @ref paceps describes this protocol step
+ */
+int PACE_STEP3D_verify_authentication_token(const EAC_CTX * ctx,
+        const BUF_MEM * token);
+
+/** @} ***********************************************************************/
+
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/pace_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace_lib.c	2012-04-04 23:09:18.806547076 +0200
@@ -0,0 +1,284 @@
+/**
+ * @file
+ * @brief Data management functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_dh.h"
+#include "eac_ecdh.h"
+#include "eac_util.h"
+#include "eac_lib.h"
+#include "pace_mappings.h"
+#include <openssl/buffer.h>
+#include <openssl/crypto.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include <openssl/err.h>
+#include <string.h>
+
+/**
+ * @brief Encodes a shared secret according to TR-3110 Table F.2
+ *
+ * @param pi Password to encode
+ *
+ * @return BUF_MEM object containing the encoded password or NULL if an error occurred
+ *
+ * @note This function is automatically called during PACE, normally you should not need to use it.
+ */
+static BUF_MEM *
+encoded_secret(const PACE_SEC * pi);
+/* Data must include the check byte when used for PACE */
+#define MRZ_SERIALNUMBER_LEN    (9+1)
+#define MRZ_DATEOFBIRTH_LEN     (6+1)
+#define MRZ_DATEOFEXPIRY_LEN    (6+1)
+#define MRZ_SERIALNUMBER_OFF    5
+#define MRZ_DATEOFBIRTH_OFF     30
+#define MRZ_DATEOFEXPIRY_OFF    38
+/**
+ * @brief Encodes the Machine readable zone according to TR-03110 table A.3
+ *
+ * @param[in] mrz buffer containing the MRZ
+ * @param[in] len size of the buffer
+ *
+ * @return the encoded MRZ or NULL on error
+ */
+static BUF_MEM *
+encoded_mrz(const char *mrz, size_t len);
+
+void
+PACE_SEC_clear_free(PACE_SEC * s)
+{
+    if (s) {
+        if (s->mem) {
+            OPENSSL_cleanse(s->mem->data, s->mem->max);
+            BUF_MEM_free(s->mem);
+        }
+        if (s->encoded) {
+            OPENSSL_cleanse(s->encoded->data, s->encoded->max);
+            BUF_MEM_free(s->encoded);
+        }
+        OPENSSL_free(s);
+    }
+}
+
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type)
+{
+    PACE_SEC *out = OPENSSL_malloc(sizeof(PACE_SEC));
+    if (!out)
+        goto err;
+
+    switch (type) {
+        case PACE_PUK:
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_MRZ:
+        case PACE_RAW:
+            out->type = type;
+            break;
+
+        default:
+            EACerr(EAC_F_PACE_SEC_NEW, EAC_R_INVALID_ARGUMENTS);
+            goto err;
+    }
+
+    out->mem = BUF_MEM_create_init(sec, sec_len);
+    out->encoded = encoded_secret(out);
+    if (!out->mem || !out->encoded)
+        goto err;
+
+    return out;
+
+err:
+    PACE_SEC_clear_free(out);
+
+    return NULL;
+}
+
+static BUF_MEM *
+encoded_secret(const PACE_SEC * pi)
+{
+    /* Encoding of the secret according to TR-03110 2.02 Table A3 */
+    BUF_MEM * out;
+
+    if (!pi) {
+        EACerr(EAC_F_ENCODED_SECRET, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    switch (pi->type) {
+        case PACE_PUK:
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_RAW:
+            if (!is_char_str(pi->mem))
+                return NULL;
+
+            out = BUF_MEM_create_init(pi->mem->data, pi->mem->length);
+            break;
+        case PACE_MRZ:
+            out = encoded_mrz(pi->mem->data, pi->mem->length);
+            break;
+        default:
+            EACerr(EAC_F_ENCODED_SECRET, EAC_R_INVALID_ARGUMENTS);
+            return NULL;
+    }
+
+    return out;
+}
+
+static BUF_MEM *
+encoded_mrz(const char *in, size_t len)
+{
+    const char *serial, *dob, *doe;
+    BUF_MEM *cat = NULL, *out = NULL;
+
+    if (!in) {
+        EACerr(EAC_F_ENCODED_MRZ, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Parse MRZ */
+    if (len < MRZ_SERIALNUMBER_OFF + MRZ_SERIALNUMBER_LEN
+            || len < MRZ_DATEOFBIRTH_OFF + MRZ_DATEOFBIRTH_LEN
+            || len < MRZ_DATEOFEXPIRY_OFF + MRZ_DATEOFEXPIRY_LEN) {
+        EACerr(EAC_F_ENCODED_MRZ, EAC_R_INVALID_DATA);
+        goto err;
+    }
+    serial = in + MRZ_SERIALNUMBER_OFF;
+    dob = in + MRZ_DATEOFBIRTH_OFF;
+    doe = in + MRZ_DATEOFEXPIRY_OFF;
+
+    /* Concatenate Serial Number || Date of Birth || Date of Expiry */
+    cat = BUF_MEM_create(MRZ_SERIALNUMBER_LEN + MRZ_DATEOFBIRTH_LEN +
+            MRZ_DATEOFEXPIRY_LEN);
+    if (!cat)
+        goto err;
+    /* Flawfinder: ignore */
+    memcpy(cat->data, serial, MRZ_SERIALNUMBER_LEN);
+    /* Flawfinder: ignore */
+    memcpy(cat->data + MRZ_SERIALNUMBER_LEN, dob, MRZ_DATEOFBIRTH_LEN);
+    /* Flawfinder: ignore */
+    memcpy(cat->data + MRZ_SERIALNUMBER_LEN + MRZ_DATEOFBIRTH_LEN,
+            doe, MRZ_DATEOFEXPIRY_LEN);
+
+    /* Compute and output SHA1 hash of concatenation */
+    out = hash(EVP_sha1(), NULL, NULL, cat);
+
+err:
+    if(cat) {
+        OPENSSL_cleanse(cat->data, cat->length);
+        BUF_MEM_free(cat);
+    }
+
+    return out;
+}
+
+void
+PACE_CTX_clear_free(PACE_CTX * ctx)
+{
+    if (ctx) {
+        BUF_MEM_clear_free(ctx->nonce);
+        KA_CTX_clear_free(ctx->ka_ctx);
+        if (ctx->static_key)
+            EVP_PKEY_free(ctx->static_key);
+        if (ctx->my_eph_pubkey)
+            BUF_MEM_free(ctx->my_eph_pubkey);
+        OPENSSL_free(ctx);
+    }
+}
+
+PACE_CTX *
+PACE_CTX_new(void)
+{
+    PACE_CTX *out = OPENSSL_malloc(sizeof(PACE_CTX));
+    if (!out)
+        goto err;
+
+    out->ka_ctx = KA_CTX_new();
+    out->static_key = EVP_PKEY_new();
+    if (!out->ka_ctx || !out->static_key)
+        goto err;
+
+    out->map_compute_key = NULL;
+    out->map_generate_key = NULL;
+    out->nonce = NULL;
+    out->my_eph_pubkey = NULL;
+    out->protocol = NID_undef;
+    out->version = 0;
+
+    return out;
+
+err:
+    if (out) {
+        if (out->static_key)
+            EVP_PKEY_free(out->static_key);
+        KA_CTX_clear_free(out->ka_ctx);
+        OPENSSL_free(out);
+    }
+
+    return NULL;
+}
+
+int
+PACE_CTX_set_protocol(PACE_CTX * ctx, int protocol, enum eac_tr_version tr_version)
+{
+    if (!ctx) {
+        EACerr(EAC_F_PACE_CTX_SET_PROTOCOL, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+    if (!KA_CTX_set_protocol(ctx->ka_ctx, protocol))
+        return 0;
+
+    switch (protocol) {
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            ctx->map_generate_key = ecdh_gm_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            break;
+
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            ctx->map_generate_key = dh_gm_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            break;
+
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            if (tr_version > EAC_TR_VERSION_2_01) {
+                EACerr(EAC_F_PACE_CTX_SET_PROTOCOL, EAC_R_IM_ONLY_SUPPORTED_FOR_TR_201_AND_EARLIER);
+                return 0;
+            }
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            break;
+
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            if (tr_version > EAC_TR_VERSION_2_01) {
+                EACerr(EAC_F_PACE_CTX_SET_PROTOCOL, EAC_R_IM_ONLY_SUPPORTED_FOR_TR_201_AND_EARLIER);
+                return 0;
+            }
+            ctx->map_generate_key = ecdh_im_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            break;
+
+        default:
+            EACerr(EAC_F_PACE_CTX_SET_PROTOCOL, EAC_R_UNKNOWN_PROTOCOL);
+            return 0;
+    }
+    ctx->protocol = protocol;
+
+    return 1;
+}
Index: openssl/crypto/eac/pace_lib.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace_lib.h	2012-04-04 22:45:10.857498149 +0200
@@ -0,0 +1,37 @@
+/**
+ * @file
+ * @brief Interface to PACE library functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_LIB_H_
+#define PACE_LIB_H_
+
+#include <openssl/eac.h>
+/**
+ * @brief Frees a \c PACE_CTX object and all its components
+ *
+ * @param[in] s Object to free (optional)
+ */
+void PACE_CTX_clear_free(PACE_CTX * s);
+/**
+ * @brief Creates a new \c PACE_CTX object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACE_CTX * PACE_CTX_new(void);
+/**
+ * @brief Initializes a \c PACE_CTX object using the protocol OID. This
+ * parameter can be found in the PACEInfo part of an EF.CardAccess.
+ *
+ * @param[in,out] ctx The \c PACE_CTX object to initialize
+ * @param[in] protocol The NID of the OID
+ * @param[in] tr_version
+ *
+ * @return 1 in case of success, 0 otherwise
+ */
+int PACE_CTX_set_protocol(PACE_CTX * ctx, int protocol, enum eac_tr_version tr_version);
+
+#endif
Index: openssl/crypto/eac/pace_mappings.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace_mappings.c	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,475 @@
+/**
+ * @file
+ * @brief Functions for domain parameter mappings
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include "eac_dh.h"
+#include "eac_ecdh.h"
+#include "eac_util.h"
+#include "pace_mappings.h"
+#include <openssl/bn.h>
+#include <openssl/crypto.h>
+#include <openssl/ec.h>
+#include <openssl/ecdh.h>
+#include <openssl/err.h>
+
+BUF_MEM *
+dh_gm_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx)
+{
+    if (!ctx) {
+        EACerr(EAC_F_DH_GM_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return dh_generate_key(ctx->static_key, bn_ctx);
+}
+
+int
+dh_gm_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx)
+{
+    int ret = 0;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL, *bn_h = NULL, *bn_g = NULL;
+    DH *static_key = NULL, *ephemeral_key = NULL;
+
+    if (!ctx || !ctx->static_key || !s || !ctx->ka_ctx) {
+        EACerr(EAC_F_DH_GM_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    static_key = EVP_PKEY_get1_DH(ctx->static_key);
+    if (!static_key)
+        goto err;
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    /* complete the DH and convert the result to a BIGNUM */
+    mem_h = dh_compute_key(ctx->static_key, in, bn_ctx);
+    if (!mem_h)
+        goto err;
+    bn_h = BN_bin2bn((unsigned char *) mem_h->data, mem_h->length, bn_h);
+    if (!bn_h)
+        goto err;
+
+    /* Initialize ephemeral parameters with parameters from the static key */
+    ephemeral_key = DHparams_dup_with_q(static_key);
+    if (!ephemeral_key)
+        goto err;
+
+    /* map to new generator */
+    bn_g = BN_new();
+    if (!bn_g ||
+        /* bn_g = g^s mod p */
+        !BN_mod_exp(bn_g, static_key->g, bn_s, static_key->p, bn_ctx) ||
+        /* ephemeral_key->g = bn_g * h mod p = g^s * h mod p */
+        !BN_mod_mul(ephemeral_key->g, bn_g, bn_h, static_key->p, bn_ctx))
+        goto err;
+
+    /* Copy ephemeral key to context structure */
+    if (!EVP_PKEY_set1_DH(ctx->ka_ctx->key, ephemeral_key))
+        goto err;
+
+    ret = 1;
+
+err:
+    if (mem_h) {
+        OPENSSL_cleanse(mem_h->data, mem_h->max);
+        BUF_MEM_free(mem_h);
+    }
+    if (bn_h)
+        BN_clear_free(bn_h);
+    if (bn_g)
+        BN_clear_free(bn_g);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    /* Decrement reference count, keys are still available via PACE_CTX */
+    if (static_key)
+        DH_free(static_key);
+    if (ephemeral_key)
+        DH_free(ephemeral_key);
+
+    return ret;
+}
+
+BUF_MEM *
+dh_im_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx)
+{
+    if (!ctx || !ctx->ka_ctx) {
+        EACerr(EAC_F_DH_IM_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return randb(EVP_CIPHER_key_length(ctx->ka_ctx->cipher));
+}
+
+int
+dh_im_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx)
+{
+    int ret = 0;
+    BUF_MEM * x_mem = NULL;
+    BIGNUM * x_bn = NULL, *a = NULL, *p_1 = NULL, *q = NULL;
+    DH *static_key = NULL, *ephemeral_key = NULL;
+
+    if (!ctx || !in || !ctx->ka_ctx) {
+        EACerr(EAC_F_DH_IM_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+    if (in->length < (size_t) EVP_CIPHER_key_length(ctx->ka_ctx->cipher)
+            || !ctx->static_key)
+        goto err;
+
+    static_key = EVP_PKEY_get1_DH(ctx->static_key);
+    if (!static_key)
+        goto err;
+
+    /* Initialize ephemeral parameters with parameters from the static key */
+    ephemeral_key = DHparams_dup_with_q(static_key);
+    if (!ephemeral_key)
+        goto err;
+
+    /* Perform the actual mapping */
+    x_mem = cipher_no_pad(ctx->ka_ctx, NULL, in, s, 1);
+    if (!x_mem)
+        goto err;
+    x_bn = BN_bin2bn((unsigned char *) x_mem->data, x_mem->length, x_bn);
+    a = BN_new();
+    q = DH_get_q(static_key, bn_ctx);
+    p_1 = BN_dup(static_key->p);
+    if (!x_bn || !a || !q || !p_1 ||
+            /* p_1 = p-1 */
+            !BN_sub_word(p_1, 1) ||
+            /* a = p-1 / q */
+            !BN_div(a, NULL, p_1, q, bn_ctx) ||
+            /* g~ = x^a mod p */
+            !BN_mod_exp(ephemeral_key->g, x_bn, a, static_key->p, bn_ctx))
+        goto err;
+
+    /* check if g~ != 1 */
+    if (BN_is_one(ephemeral_key->g))
+        EACerr(EAC_F_DH_IM_COMPUTE_KEY, EAC_R_BAD_DH_GENERATOR);
+
+    /* Copy ephemeral key to context structure */
+    if (!EVP_PKEY_set1_DH(ctx->ka_ctx->key, ephemeral_key))
+        goto err;
+
+    ret = 1;
+
+err:
+    if (q)
+        BN_clear_free(q);
+    if (p_1)
+        BN_clear_free(p_1);
+    if (a)
+        BN_clear_free(a);
+    if (x_bn)
+        BN_clear_free(x_bn);
+    if (x_mem)
+        BUF_MEM_free(x_mem);
+    /* Decrement reference count, keys are still available via PACE_CTX */
+    if (static_key)
+        DH_free(static_key);
+    if (ephemeral_key)
+        DH_free(ephemeral_key);
+
+    return ret;
+}
+
+BUF_MEM *
+ecdh_gm_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx)
+{
+    if (!ctx) {
+        EACerr(EAC_F_ECDH_GM_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return ecdh_generate_key(ctx->static_key, bn_ctx);
+}
+
+int
+ecdh_gm_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx)
+{
+    int ret = 0;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL, *order = NULL, *cofactor = NULL;
+    EC_POINT * ecp_h = NULL, *ecp_g = NULL;
+    const ECDH_METHOD *default_method;
+    EC_GROUP *group = NULL;
+    EC_KEY *static_key = NULL, *ephemeral_key = NULL;
+
+    if (!ctx || !ctx->static_key || !s || !ctx->ka_ctx) {
+        EACerr(EAC_F_ECDH_GM_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    static_key = EVP_PKEY_get1_EC_KEY(ctx->static_key);
+    if (!static_key)
+        goto err;
+
+    /* Extract group parameters */
+    group = EC_GROUP_dup(EC_KEY_get0_group(static_key));
+    order = BN_new();
+    cofactor = BN_new();
+    if (!group || !order || !cofactor)
+        goto err;
+    EC_GROUP_get_order(group, order, bn_ctx);
+    EC_GROUP_get_cofactor(group, cofactor, bn_ctx);
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    default_method = ECDH_get_default_method();
+    ECDH_set_default_method(ECDH_OpenSSL_Point());
+    /* complete the ECDH and get the resulting point h */
+    mem_h = ecdh_compute_key(ctx->static_key, in, bn_ctx);
+    ECDH_set_default_method(default_method);
+    ecp_h = EC_POINT_new(group);
+    if (!mem_h || !ecp_h || !EC_POINT_oct2point(group, ecp_h,
+            (unsigned char *) mem_h->data, mem_h->length, bn_ctx))
+        goto err;
+
+    /* map to new generator */
+    ecp_g = EC_POINT_new(group);
+    /* g' = g*s + h*1 */
+    if (!EC_POINT_mul(group, ecp_g, bn_s, ecp_h, BN_value_one(), bn_ctx))
+        goto err;
+
+    /* Initialize ephemeral parameters with parameters from the static key */
+    ephemeral_key = EC_KEY_dup(static_key);
+    if (!ephemeral_key)
+        goto err;
+    EVP_PKEY_set1_EC_KEY(ctx->ka_ctx->key, ephemeral_key);
+
+    /* configure the new EC_KEY */
+    if (!EC_GROUP_set_generator(group, ecp_g, order, cofactor)
+            || !EC_GROUP_check(group, bn_ctx)
+            || !EC_KEY_set_group(ephemeral_key, group))
+        goto err;
+
+    ret = 1;
+
+err:
+    if (ecp_g)
+        EC_POINT_clear_free(ecp_g);
+    if (ecp_h)
+        EC_POINT_clear_free(ecp_h);
+    if (mem_h)
+        BUF_MEM_free(mem_h);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    if (order)
+        BN_clear_free(order);
+    if (cofactor)
+        BN_clear_free(cofactor);
+    /* Decrement reference count, keys are still available via PACE_CTX */
+    if (static_key)
+        EC_KEY_free(static_key);
+    if (ephemeral_key)
+        EC_KEY_free(ephemeral_key);
+    if (group)
+        EC_GROUP_clear_free(group);
+
+    return ret;
+}
+
+BUF_MEM *
+ecdh_im_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx)
+{
+    if (!ctx || !ctx->ka_ctx) {
+        EACerr(EAC_F_ECDH_IM_GENERATE_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    return randb(EVP_CIPHER_key_length(ctx->ka_ctx->cipher));
+}
+
+int
+ecdh_im_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx)
+{
+    int ret = 0;
+    BUF_MEM * x_mem = NULL;
+    BIGNUM * a = NULL, *b = NULL, *p = NULL;
+    BIGNUM * x = NULL, *y = NULL, *v = NULL, *u = NULL;
+    BIGNUM * tmp = NULL, *tmp2 = NULL, *bn_const = NULL, *bn_inv = NULL;
+    BIGNUM * two = NULL, *three = NULL, *four = NULL, *six = NULL;
+    BIGNUM * twentyseven = NULL;
+    EC_KEY *static_key = NULL, *ephemeral_key = NULL;
+    EC_POINT *g = NULL;
+
+    if (!ctx || !ctx->static_key || !s || !ctx->ka_ctx) {
+        EACerr(EAC_F_ECDH_IM_COMPUTE_KEY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    static_key = EVP_PKEY_get1_EC_KEY(ctx->static_key);
+    if (!static_key)
+        goto err;
+
+    /* Setup all the variables*/
+    a = BN_new();
+    b = BN_new();
+    p = BN_new();
+    x = BN_new();
+    y = BN_new();
+    v = BN_new();
+    two = BN_new();
+    three = BN_new();
+    four = BN_new();
+    six = BN_new();
+    twentyseven = BN_new();
+    tmp = BN_new();
+    tmp2 = BN_new();
+    bn_const = BN_new();
+    bn_inv = BN_new();
+    if (!a || !b || !p || !x || !y || !v ||
+            !two || !three || !four || !six || !twentyseven ||
+            !tmp || !tmp2 || !bn_const ||
+            !bn_inv)
+        goto err;
+
+    /* Encrypt the Nonce using the symmetric key in */
+    x_mem = cipher_no_pad(ctx->ka_ctx, NULL, in, s, 1);
+    if (!x_mem)
+        goto err;
+
+    /* Fetch the curve parameters */
+    if (!EC_GROUP_get_curve_GFp(EC_KEY_get0_group(static_key), p, a, b, bn_ctx))
+        goto err;
+
+    /* Assign constants */
+    if (    !BN_set_word(two,2)||
+            !BN_set_word(three,3)||
+            !BN_set_word(four,4)||
+            !BN_set_word(six,6)||
+            !BN_set_word(twentyseven,27)
+            ) goto err;
+
+    /* Check prerequisites for curve parameters */
+    if (
+            /* p > 3;*/
+           (BN_cmp(p, three) != 1) ||
+           /* p mod 3 = 2; (p has the form p=q^n, q prime) */
+           !BN_nnmod(tmp, p, three, bn_ctx) ||
+           (BN_cmp(tmp, two) != 0)) {
+        EACerr(EAC_F_ECDH_IM_COMPUTE_KEY, EAC_R_UNSUITED_CURVE);
+        goto err;
+    }
+
+    /* Convert encrypted nonce to BIGNUM */
+    u = BN_bin2bn((unsigned char *) x_mem->data, x_mem->length, u);
+    if (!u)
+        goto err;
+
+    if ( /* v = (3a - u^4) / 6u mod p */
+            !BN_mod_mul(tmp, three, a, p, bn_ctx) ||
+            !BN_mod_exp(tmp2, u, four, p, bn_ctx) ||
+            !BN_mod_sub(v, tmp, tmp2, p, bn_ctx) ||
+            !BN_mod_mul(tmp, u, six, p, bn_ctx) ||
+            /* For division within a galois field we need to compute
+             * the multiplicative inverse of a number */
+            !BN_mod_inverse(bn_inv, tmp, p, bn_ctx) ||
+            !BN_mod_mul(v, v, bn_inv, p, bn_ctx) ||
+
+            /* x = (v^2 - b - ((u^6)/27)) */
+            !BN_mod_sqr(tmp, v, p, bn_ctx) ||
+            !BN_mod_sub(tmp2, tmp, b, p, bn_ctx) ||
+            !BN_mod_exp(tmp, u, six, p, bn_ctx) ||
+            !BN_mod_inverse(bn_inv, twentyseven, p, bn_ctx) ||
+            !BN_mod_mul(tmp, tmp, bn_inv, p, bn_ctx) ||
+            !BN_mod_sub(x, tmp2, tmp, p, bn_ctx) ||
+
+            /* x -> x^(1/3) = x^((2p^n -1)/3) */
+            !BN_mul(tmp, two, p, bn_ctx) ||
+            !BN_sub(tmp, tmp, BN_value_one()) ||
+
+            /* Division is defined, because p^n = 2 mod 3 */
+            !BN_div(tmp, y, tmp, three, bn_ctx) ||
+            !BN_mod_exp(tmp2, x, tmp, p, bn_ctx) ||
+            !BN_copy(x, tmp2) ||
+
+            /* x += (u^2)/3 */
+            !BN_mod_sqr(tmp, u, p, bn_ctx) ||
+            !BN_mod_inverse(bn_inv, three, p, bn_ctx) ||
+            !BN_mod_mul(tmp2, tmp, bn_inv, p, bn_ctx) ||
+            !BN_mod_add(tmp, x, tmp2, p, bn_ctx) ||
+            !BN_copy(x, tmp) ||
+
+            /* y = ux + v */
+            !BN_mod_mul(y, u, x, p, bn_ctx) ||
+            !BN_mod_add(tmp, y, v, p, bn_ctx) ||
+            !BN_copy(y, tmp)
+            )
+        goto err;
+
+    /* Initialize ephemeral parameters with parameters from the static key */
+    ephemeral_key = EC_KEY_dup(static_key);
+    if (!ephemeral_key)
+        goto err;
+    EVP_PKEY_set1_EC_KEY(ctx->ka_ctx->key, ephemeral_key);
+
+    /* configure the new EC_KEY */
+    g = EC_POINT_new(EC_KEY_get0_group(ephemeral_key));
+    if (!g)
+        goto err;
+    if (!EC_POINT_set_affine_coordinates_GFp(EC_KEY_get0_group(ephemeral_key), g,
+            x, y, bn_ctx))
+        goto err;
+
+    ret = 1;
+
+err:
+    if (x_mem)
+        BUF_MEM_free(x_mem);
+    if (a)
+        BN_clear_free(a);
+    if (b)
+        BN_clear_free(b);
+    if (p)
+        BN_clear_free(p);
+    if (x)
+        BN_clear_free(x);
+    if (y)
+        BN_clear_free(y);
+    if (v)
+        BN_clear_free(v);
+    if (u)
+        BN_clear_free(u);
+    if (two)
+        BN_clear_free(two);
+    if (three)
+        BN_clear_free(three);
+    if (four)
+        BN_clear_free(four);
+    if (six)
+        BN_clear_free(six);
+    if (twentyseven)
+        BN_clear_free(twentyseven);
+    if (tmp)
+        BN_clear_free(tmp);
+    if (tmp2)
+        BN_clear_free(tmp2);
+    if (bn_const)
+        BN_clear_free(bn_const);
+    if (bn_inv)
+        BN_clear_free(bn_inv);
+    if (g)
+        EC_POINT_clear_free(g);
+    /* Decrement reference count, keys are still available via PACE_CTX */
+    if (static_key)
+        EC_KEY_free(static_key);
+    if (ephemeral_key)
+        EC_KEY_free(ephemeral_key);
+
+    return ret;
+}
Index: openssl/crypto/eac/pace_mappings.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/pace_mappings.h	2012-04-04 22:45:10.853496128 +0200
@@ -0,0 +1,73 @@
+/**
+ * @file
+ * @brief Interface to functions for domain parameter mappings
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_MAPPINGS_H_
+#define PACE_MAPPINGS_H_
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/pace.h>
+
+/**
+ * @defgroup encoding               Mapping
+ * @{ ************************************************************************/
+
+BUF_MEM *
+dh_gm_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx);
+/**
+ * @brief Computes a key for DH Generic Mapping (see TR-3110 A.3.5.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+int
+dh_gm_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx);
+/**
+ * @brief Generates a key for DH Integrated Mapping (see TR-3110 A.3.5.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+BUF_MEM *
+dh_im_generate_key(const PACE_CTX *ctx, BN_CTX *bn_ctx);
+/**
+ * @brief Computes a key for DH Integrated Mapping (see TR-3110 A.3.5.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+int
+dh_im_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx);
+BUF_MEM *
+ecdh_gm_generate_key(const PACE_CTX * ctx, BN_CTX *bn_ctx);
+/**
+ * @brief Computes a key for ECDH Generic Mapping (see TR-3110 A.3.4.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+int
+ecdh_gm_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx);
+/**
+ * @brief Generates a key for ECDH Integrated Mapping (see TR-3110 A.3.4.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+BUF_MEM *
+ecdh_im_generate_key(const PACE_CTX *ctx, BN_CTX *bn_ctx);
+/**
+ * @brief Computes a key for ECDH Integrated Mapping (see TR-3110 A.3.4.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+int
+ecdh_im_compute_key(PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in,
+        BN_CTX *bn_ctx);
+
+/** @} ***********************************************************************/
+
+#endif /*PACE_MAPPINGS_H_*/
Index: openssl/crypto/eac/ri.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ri.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,48 @@
+/**
+ * @file
+ * @brief Restricted Identification implementation
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ * @author Paul Wilhelm  <wilhelm@math.hu-berlin.de>
+ */
+
+#include "eac_lib.h"
+#include "eac_util.h"
+#include <openssl/crypto.h>
+#include <openssl/eac.h>
+#include <openssl/ecdh.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <string.h>
+
+BUF_MEM *
+RI_STEP2_compute_identifier(EAC_CTX *ctx, BUF_MEM *sector_pubkey)
+{
+
+    BUF_MEM *sector_identifier = NULL, *shared_secret = NULL;
+
+    if (!ctx || !sector_pubkey || !ctx->bn_ctx || !ctx->ri_ctx
+             || !ctx->ri_ctx->compute_key
+             || !ctx->ri_ctx->static_key) {
+        EACerr(EAC_F_RI_STEP2_COMPUTE_IDENTIFIER, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Perform the key agreement */
+    shared_secret = ctx->ri_ctx->compute_key(ctx->ri_ctx->static_key,
+            sector_pubkey, ctx->bn_ctx);
+    if (!shared_secret)
+        goto err;
+
+    /* Compute the hash of the shared secret (which is the sector identifier) */
+    sector_identifier = hash(ctx->ri_ctx->md, ctx->md_ctx, NULL, shared_secret);
+
+err:
+    if (shared_secret)
+        BUF_MEM_clear_free(shared_secret);
+
+    return sector_identifier;
+}
+
Index: openssl/crypto/eac/ri.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ri.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,81 @@
+/**
+ * @file pace.h
+ * @brief Interface for Restricted Identification
+ *
+ * Restricted Identification is a protocol to generate
+ * pseudonym identifier based on key agreement protocol.
+ * The protocol use a secret key of an asymetric
+ * key pair and the public key of a second asymetric key pair.
+ * For every two diffrent secret keys with same public key the
+ * identifier is diffrent.
+ * For any two diffrent public keys it is computational infeasible
+ * to link two identifiers with the same secret key.
+ *
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Paul Wilhelm  <wilhelm@math.hu-berlin.de>
+ */
+
+#ifndef RI_H_
+#define RI_H_
+
+#include <openssl/buffer.h>
+#include <openssl/eac.h>
+#include <openssl/bn.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @addtogroup management
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Frees a \c RI_CTX object and all its components
+ *
+ * @param[in] s Object to free (optional)
+ */
+void RI_CTX_clear_free(RI_CTX * s);
+/**
+ * @brief Creates a new \c RI_CTX object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+RI_CTX * RI_CTX_new(void);
+/**
+ * @brief Initializes a \c RI_CTX object using the protocol OID. This
+ * parameter can be found in the RIInfo part of an EF.CardSecurity.
+ *
+ * @param[in,out] ctx The \c RI_CTX object to initialize
+ * @param[in] protocol The NID of the OID
+ *
+ * @return 1 in case of success, 0 otherwise
+ */
+int RI_CTX_set_protocol(RI_CTX * ctx, int protocol);
+/** @} ***********************************************************************/
+
+/**
+ * @addtogroup riproto
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Compute a sector specific identifier for a card within a given sector.
+ *
+ * @param[in] ctx The EAC context of the card
+ * @param[in] sector_pubkey the sector public key
+ *
+ * @return The sector identifier or NULL in case of an error
+ *
+ * @see RI's @ref rips describes this protocol step
+ */
+BUF_MEM * RI_STEP2_compute_identifier(EAC_CTX *ctx, BUF_MEM *sector_pubkey);
+
+/** @} ***********************************************************************/
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/ri_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ri_lib.c	2012-04-04 22:45:10.849494109 +0200
@@ -0,0 +1,140 @@
+/**
+ * @file
+ * @brief Data management functions
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ * @author Paul Wilhelm  <wilhelm@math.hu-berlin.de>
+ */
+
+#include "eac_dh.h"
+#include "eac_ecdh.h"
+#include "eac_lib.h"
+#include "eac_util.h"
+#include <openssl/buffer.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/ri.h>
+#include <string.h>
+
+
+void
+RI_CTX_clear_free(RI_CTX * ctx)
+{
+    if (ctx) {
+        if (ctx->static_key)
+            EVP_PKEY_free(ctx->static_key);
+        OPENSSL_free(ctx);
+    }
+}
+
+RI_CTX *
+RI_CTX_new(void)
+{
+    RI_CTX *out = NULL;
+
+    out = (RI_CTX *)OPENSSL_malloc(sizeof(RI_CTX));
+    if (!out)
+        goto err;
+
+    out->static_key = EVP_PKEY_new();
+    if (!out->static_key)
+        goto err;
+
+    out->compute_key = NULL;
+    out->generate_key = NULL;
+    out->protocol = NID_undef;
+    out->md = NULL;
+
+    return out;
+
+err:
+    if (out) {
+        if (out->static_key)
+            EVP_PKEY_free(out->static_key);
+        OPENSSL_free(out);
+    }
+
+    return NULL;
+}
+
+int
+RI_CTX_set_protocol(RI_CTX * ctx, int protocol)
+{
+    if (!ctx) {
+        EACerr(EAC_F_RI_CTX_SET_PROTOCOL, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    switch (protocol) {
+        case NID_id_RI_ECDH_SHA_1:
+            ctx->md = EVP_sha1();
+            ctx->compute_key = ecdh_compute_key;
+            ctx->generate_key = ecdh_generate_key;
+            break;
+
+        case NID_id_RI_ECDH_SHA_224:
+            ctx->md = EVP_sha224();
+            ctx->compute_key = ecdh_compute_key;
+            ctx->generate_key = ecdh_generate_key;
+            break;
+
+        case NID_id_RI_ECDH_SHA_256:
+            ctx->md = EVP_sha256();
+            ctx->compute_key = ecdh_compute_key;
+            ctx->generate_key = ecdh_generate_key;
+            break;
+
+        case NID_id_RI_ECDH_SHA_384:
+            ctx->md = EVP_sha384();
+            ctx->compute_key = ecdh_compute_key;
+            ctx->generate_key = ecdh_generate_key;
+            break;
+
+        case NID_id_RI_ECDH_SHA_512:
+            ctx->md = EVP_sha512();
+            ctx->compute_key = ecdh_compute_key;
+            ctx->generate_key = ecdh_generate_key;
+            break;
+
+        case NID_id_RI_DH_SHA_1:
+            ctx->md = EVP_sha1();
+            ctx->compute_key = dh_compute_key;
+            ctx->generate_key = dh_generate_key;
+            break;
+
+        case NID_id_RI_DH_SHA_224:
+            ctx->md = EVP_sha224();
+            ctx->compute_key = dh_compute_key;
+            ctx->generate_key = dh_generate_key;
+            break;
+
+
+        case NID_id_RI_DH_SHA_256:
+            ctx->md = EVP_sha256();
+            ctx->compute_key = dh_compute_key;
+            ctx->generate_key = dh_generate_key;
+            break;
+
+        case NID_id_RI_DH_SHA_384:
+            ctx->md = EVP_sha384();
+            ctx->compute_key = dh_compute_key;
+            ctx->generate_key = dh_generate_key;
+            break;
+
+        case NID_id_RI_DH_SHA_512:
+            ctx->md = EVP_sha512();
+            ctx->compute_key = dh_compute_key;
+            ctx->generate_key = dh_generate_key;
+            break;
+
+        default:
+            EACerr(EAC_F_RI_CTX_SET_PROTOCOL, EAC_R_UNKNOWN_PROTOCOL);
+            return 0;
+    }
+    ctx->protocol = protocol;
+
+    return 1;
+}
Index: openssl/crypto/eac/ta.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ta.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,210 @@
+/**
+ * @file ta.c
+ *
+ * @date 2011-04-03
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/cv_cert.h>
+#include <openssl/ecdsa.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/rsa.h>
+#include <openssl/ta.h>
+#include <string.h>
+#include "eac_util.h"
+#include "ta_lib.h"
+#include "eac_lib.h"
+
+#include <openssl/bio.h>
+
+int
+TA_STEP2_import_certificate(const EAC_CTX *ctx,
+           const unsigned char *cert, size_t cert_len)
+{
+    CVC_CERT *ta_cert = NULL;
+    int r = 0;
+
+    if (!ctx) {
+        EACerr(EAC_F_TA_STEP2_IMPORT_CERTIFICATE, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    ta_cert = CVC_d2i_CVC_CERT(&ta_cert, &cert, cert_len);
+    r = TA_CTX_import_certificate(ctx->ta_ctx, ta_cert, ctx->bn_ctx);
+
+err:
+    if (ta_cert)
+        CVC_CERT_free(ta_cert);
+
+    return r;
+}
+
+/**
+ * @brief gets the data, which is signed in the process of TA
+ *
+ * @param[in] pcd_ta_comp_eph_pubkey compressed ephemeral CA public key of PCD
+ * @param[in] id_picc compressed ephemeral PACE public key of PICC
+ * @param[in] nonce nonce from PICC
+ * @param[in] (optional) auxdata auxiliary data from PCD
+ *
+ * @return A buffer containing the data to be signed or NULL in case of an error
+ */
+static BUF_MEM *
+get_ta_sigdata(const BUF_MEM *pcd_ta_comp_eph_pubkey,
+        const BUF_MEM *id_picc, const BUF_MEM *nonce,
+        const BUF_MEM *auxdata)
+{
+    size_t len;
+    BUF_MEM *data = NULL;
+
+    if (!nonce || !pcd_ta_comp_eph_pubkey) {
+        EACerr(EAC_F_GET_TA_SIGDATA, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    /* Data to be signed: ID PICC || r PICC || Comp(~PK_PCD) || APCD */
+
+    /* Authenticated auxiliary data are optional (only necessary if special
+     * functions will be used later on) */
+    if (auxdata) {
+        len = id_picc->length + nonce->length +
+            pcd_ta_comp_eph_pubkey->length + auxdata->length;
+    } else {
+        len = id_picc->length + nonce->length +
+            pcd_ta_comp_eph_pubkey->length;
+    }
+    data = BUF_MEM_create(len);
+    if (!data)
+        return NULL;
+
+    /* Concatenate the data */
+    memcpy(data->data, id_picc->data, id_picc->length);
+    memcpy(data->data + id_picc->length, nonce->data, nonce->length);
+    memcpy(data->data + id_picc->length + nonce->length, pcd_ta_comp_eph_pubkey->data,
+            pcd_ta_comp_eph_pubkey->length);
+    if (auxdata)
+        memcpy(data->data + id_picc->length + nonce->length +
+                pcd_ta_comp_eph_pubkey->length, auxdata->data, auxdata->length);
+
+    return data;
+}
+
+BUF_MEM *
+TA_STEP3_generate_ephemeral_key(const EAC_CTX *ctx)
+{
+    BUF_MEM *comp_pub_key, *pub_key = NULL;
+
+    if (!ctx || !ctx->ca_ctx || !ctx->ca_ctx->ka_ctx) {
+        EACerr(EAC_F_TA_STEP3_GENERATE_EPHEMERAL_KEY, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    pub_key = KA_CTX_generate_key(ctx->ca_ctx->ka_ctx, ctx->bn_ctx);
+
+    comp_pub_key = Comp(ctx->ca_ctx->ka_ctx->key, pub_key, ctx->bn_ctx,
+            ctx->md_ctx);
+
+    if (pub_key)
+        BUF_MEM_free(pub_key);
+
+    return comp_pub_key;
+}
+
+/* Nonce for TA is always 8 bytes long */
+#define TA_NONCE_SIZE 8
+BUF_MEM *
+TA_STEP4_get_nonce(const EAC_CTX *ctx)
+{
+    if (!ctx || !ctx->ta_ctx) {
+        EACerr(EAC_F_TA_STEP4_GET_NONCE, EAC_R_INVALID_ARGUMENTS);
+        return NULL;
+    }
+
+    BUF_MEM_clear_free(ctx->ta_ctx->nonce);
+    ctx->ta_ctx->nonce = randb(TA_NONCE_SIZE);
+
+    if (!ctx->ta_ctx->nonce)
+        return NULL;
+
+    return BUF_MEM_dup(ctx->ta_ctx->nonce);
+}
+
+int
+TA_STEP4_set_nonce(const EAC_CTX *ctx, const BUF_MEM *nonce) {
+    int r = 0;
+
+    if (!ctx || !ctx->ta_ctx || !nonce) {
+        EACerr(EAC_F_TA_STEP4_SET_NONCE, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (ctx->ta_ctx->nonce)
+      BUF_MEM_free(ctx->ta_ctx->nonce);
+
+    ctx->ta_ctx->nonce = BUF_MEM_dup(nonce);
+    if (!ctx->ta_ctx->nonce) {
+        EACerr(EAC_F_TA_STEP4_SET_NONCE, EAC_R_FAILED_TO_COPY);
+        goto err;
+    }
+
+  r = 1;
+
+err:
+    return r;
+}
+
+BUF_MEM *
+TA_STEP5_sign(const EAC_CTX *ctx, const BUF_MEM *my_ta_comp_eph_pubkey,
+           const BUF_MEM *opp_pace_comp_eph_pubkey, const BUF_MEM *auxdata)
+{
+    BUF_MEM *data = NULL, *signature = NULL;
+
+    if (!ctx || !ctx->ta_ctx) {
+        EACerr(EAC_F_TA_STEP5_SIGN, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    /* Get the data to be signed */
+    data = get_ta_sigdata(my_ta_comp_eph_pubkey, opp_pace_comp_eph_pubkey,
+            ctx->ta_ctx->nonce, auxdata);
+    signature = EAC_sign(ctx->ta_ctx->protocol, ctx->ta_ctx->priv_key, data);
+
+err:
+    if (data)
+        BUF_MEM_free(data);
+
+    return signature;
+}
+
+int
+TA_STEP6_verify(const EAC_CTX *ctx, const BUF_MEM *opp_ta_comp_eph_pubkey,
+           const BUF_MEM *my_pace_comp_eph_pubkey, const BUF_MEM *auxdata,
+           const BUF_MEM *signature)
+{
+    BUF_MEM *data = NULL;
+    int r = -1;
+
+    if (!ctx || !ctx->ta_ctx) {
+        EACerr(EAC_F_TA_STEP6_VERIFY, EAC_R_INVALID_ARGUMENTS);
+        goto err;
+    }
+
+    if (!ctx->ta_ctx->nonce) {
+        EACerr(EAC_F_TA_STEP6_VERIFY, EAC_R_CONDITIONS_NOT_SATISFIED);
+        goto err;
+    }
+
+    /* Get the data to be verified */
+    data = get_ta_sigdata(opp_ta_comp_eph_pubkey, my_pace_comp_eph_pubkey,
+            ctx->ta_ctx->nonce, auxdata);
+    r = EAC_verify(ctx->ta_ctx->protocol, ctx->ta_ctx->pub_key, signature, data);
+
+err:
+    if (data)
+        BUF_MEM_free(data);
+
+    return r;
+}
Index: openssl/crypto/eac/ta.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ta.h	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,132 @@
+/**
+ * @file ta.h
+ * @brief Interface for Terminal Authentication
+ *
+ * Terminal authentication (TA) is a protocol used to check
+ * the authenticity of a Terminal communicating with an MRTD chip.
+ * It is also used to establish the effective access rights of
+ * the terminal for all further communication. TA is a challenge-
+ * response protocol in which the certificate issues a challenge
+ * which is signed by the terminal. In order to be able to prove
+ * the authenticity of the answer, the MRTD chip needs to be provided
+ * with a certificate chain, which goes back to its own trust
+ * anchor.
+ *
+ * @date 2011-04-03
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef TA_H_
+#define TA_H_
+
+#include <openssl/eac.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Skip checking effective and expiration date of cv certificate against current time */
+#define TA_FLAG_SKIP_TIMECHECK 1
+
+/**
+ * @addtogroup taproto
+ *
+ * @{ ************************************************************************/
+
+/**
+ * @brief Imports a CV Certificate to the EAC context
+ *
+ * This function should be used to subsequently verify all certificates of a
+ * certificate chain. The signature and date of the certificate are verified
+ * using the trust anchor or the most recently imported certificate. The TA
+ * context is adjusted to use domain parameters of the imported certificate. If
+ * the chain contains a new trust anchor (i.e. a CVCA certificate), the old
+ * trust anchor is replaced when EAC is completed.
+ *
+ * @param[in,out] ctx EAC context
+ * @param[in] cert raw Certificate to import
+ * @param[in] cert_len Length of \a cert
+ *
+ * @return 1 on success or 0 in case of an error
+ *
+ * @see TA's @ref taps describes this protocol step
+ */
+int
+TA_STEP2_import_certificate(const EAC_CTX *ctx,
+           const unsigned char *cert, size_t cert_len);
+/**
+ * @brief Generates ephemeral key for CA
+ *
+ * @param[in,out] ctx EAC context. The CA context of \a ctx is initialized for key agreement
+ *
+ * @return Ephemeral public key or NULL in case of an error
+ *
+ * @see TA's @ref taps describes this protocol step
+ */
+BUF_MEM *
+TA_STEP3_generate_ephemeral_key(const EAC_CTX *ctx);
+/**
+ * @brief Generates a nonce for the PCD
+ *
+ * @param[in,out] ctx EAC context. The nonce is saved in \a ctx
+ *
+ * @return Nonce or NULL in case of an error
+ *
+ * @see TA's @ref taps describes this protocol step
+ *
+ * @note EAC_CTX_init_ca must have been called before the nonce can be generated
+ */
+BUF_MEM *
+TA_STEP4_get_nonce(const EAC_CTX *ctx);
+/**
+ * @brief Import the nonce from the PICC
+ *
+ * @param[in,out] ctx EAC context. The nonce is saved in \a ctx
+ * @param nonce The nonce to be copied
+ *
+ * @return 1 on success or 0 in case of an error
+ */
+int
+TA_STEP4_set_nonce(const EAC_CTX *ctx, const BUF_MEM *nonce);
+/**
+ * @brief Signs data for terminal authentication.
+ *
+ * @param[in] ctx EAC context
+ * @param[in] my_ta_eph_pubkey PCD's ephemeral public key generated in Step 3
+ * @param[in] opp_pace_eph_pubkey PICC's ephemeral public key generated in PACE Step 3b
+ * @param[in] auxdata (optional) Auxiliary data from PCD
+ *
+ * @return Signature or NULL in case of an error
+ *
+ * @see TA's @ref taps describes this protocol step
+ */
+BUF_MEM *
+TA_STEP5_sign(const EAC_CTX *ctx, const BUF_MEM *my_ta_eph_pubkey,
+           const BUF_MEM *opp_pace_eph_pubkey, const BUF_MEM *auxdata);
+/**
+ * @brief Verifies PCD's signature from TA step 5
+ *
+ * @param[in] ctx EAC context
+ * @param[in] opp_ta_comp_eph_pubkey PCD's compressed ephemeral public key generated in Step 3
+ * @param[in] my_pace_comp_eph_pubkey PICC's compressed ephemeral public key generated in PACE Step 3b
+ * @param[in] nonce Nonce generated in TA step 4
+ * @param[in] auxdata (optional) Auxiliary data from PCD
+ * @param[in] signature Data to verify
+ *
+ * @return 1 if the signature has been verified, 0 if not or -1 in case of an error
+ *
+ * @see TA's @ref taps describes this protocol step
+ */
+int
+TA_STEP6_verify(const EAC_CTX *ctx, const BUF_MEM *opp_ta_comp_eph_pubkey,
+           const BUF_MEM *my_pace_comp_eph_pubkey, const BUF_MEM *auxdata,
+           const BUF_MEM *signature);
+
+/** @} ***********************************************************************/
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/eac/ta_lib.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ta_lib.c	2012-04-04 22:45:10.861500172 +0200
@@ -0,0 +1,209 @@
+/**
+ * @file ta_lib.c
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/crypto.h>
+#include <openssl/cv_cert.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/ta.h>
+#include <openssl/rsa.h>
+#include <openssl/err.h>
+#include <openssl/cv_cert.h>
+#include <string.h>
+#include "eac_util.h"
+
+TA_CTX *
+TA_CTX_new(void) {
+    TA_CTX *ctx = (TA_CTX *) OPENSSL_malloc(sizeof(TA_CTX));
+    if (!ctx)
+        return NULL;
+
+    ctx->priv_key = NULL;
+    ctx->pub_key = NULL;
+    ctx->key_engine = NULL;
+    ctx->protocol = NID_undef;
+    ctx->version = 0;
+    ctx->pk_pcd = NULL;
+    ctx->nonce = NULL;
+    ctx->trust_anchor = NULL;
+    ctx->new_trust_anchor = NULL;
+    ctx->current_cert = NULL;
+    ctx->flags = 0;
+
+    return ctx;
+}
+
+void
+TA_CTX_clear_free(TA_CTX *ctx) {
+    if (!ctx)
+        return;
+
+    if (ctx->pk_pcd)
+        BUF_MEM_free(ctx->pk_pcd);
+    if (ctx->priv_key)
+        EVP_PKEY_free(ctx->priv_key);
+    if (ctx->pub_key)
+        EVP_PKEY_free(ctx->pub_key);
+    if (ctx->trust_anchor)
+        CVC_CERT_free(ctx->trust_anchor);
+    if (ctx->current_cert)
+        CVC_CERT_free(ctx->current_cert);
+    if (ctx->new_trust_anchor)
+        CVC_CERT_free(ctx->new_trust_anchor);
+    BUF_MEM_clear_free(ctx->nonce);
+
+    OPENSSL_free(ctx);
+    return;
+}
+
+#include <time.h>
+static int
+cvc_check_time(const CVC_CERT *cert)
+{
+    time_t loc;
+    struct tm exp_tm, eff_tm, *utc_tm;
+
+    if (!cert || !cert->body
+            || !cert->body->certificate_effective_date
+            || cert->body->certificate_effective_date->length != 6
+            || !is_bcd(cert->body->certificate_effective_date->data,
+                cert->body->certificate_effective_date->length)
+            || cert->body->certificate_expiration_date->length != 6
+            || !is_bcd(cert->body->certificate_expiration_date->data,
+                cert->body->certificate_expiration_date->length))
+        return -1;
+
+    time(&loc);
+    utc_tm = gmtime(&loc);
+    if (!utc_tm)
+        return -1;
+
+    memcpy(&eff_tm, utc_tm, sizeof(struct tm));
+    eff_tm.tm_sec = 0;          /* seconds */
+    eff_tm.tm_min = 0;          /* minutes */
+    eff_tm.tm_hour = 0;         /* hours */
+    eff_tm.tm_wday = -1;        /* day of the week */
+    eff_tm.tm_yday = -1;        /* day in the year */
+    eff_tm.tm_year = 100        /* The number of years since 1900 */
+        + ((unsigned char) cert->body->certificate_effective_date->data[0])*10
+        + (unsigned char) cert->body->certificate_effective_date->data[1];
+    eff_tm.tm_mon = ((unsigned char) cert->body->certificate_effective_date->data[2])*10
+        + (unsigned char) cert->body->certificate_effective_date->data[3] - 1;
+    eff_tm.tm_mday = ((unsigned char) cert->body->certificate_effective_date->data[4])*10
+        + (unsigned char) cert->body->certificate_effective_date->data[5];
+
+    memcpy(&exp_tm, utc_tm, sizeof(struct tm));
+    exp_tm.tm_sec = 59;         /* seconds */
+    exp_tm.tm_min = 59;         /* minutes */
+    exp_tm.tm_hour = 23;        /* hours */
+    exp_tm.tm_wday = -1;        /* day of the week */
+    exp_tm.tm_yday = -1;        /* day in the year */
+    exp_tm.tm_year = 100        /* The number of years since 1900 */
+        + ((unsigned char) cert->body->certificate_expiration_date->data[0])*10
+        + (unsigned char) cert->body->certificate_expiration_date->data[1];
+    exp_tm.tm_mon = ((unsigned char) cert->body->certificate_expiration_date->data[2])*10
+        + (unsigned char) cert->body->certificate_expiration_date->data[3] - 1;
+    exp_tm.tm_mday = ((unsigned char) cert->body->certificate_expiration_date->data[4])*10
+        + (unsigned char) cert->body->certificate_expiration_date->data[5];
+
+    if (exp_tm.tm_mon < 0 || exp_tm.tm_mon > 12
+            || exp_tm.tm_mday > 31
+            || eff_tm.tm_mon < 0 || eff_tm.tm_mon > 12
+            || eff_tm.tm_mday > 31
+            || difftime(mktime(utc_tm), mktime(&eff_tm)) < 0
+            || difftime(mktime(&exp_tm), mktime(utc_tm)) < 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+int
+TA_CTX_import_certificate(TA_CTX *ctx, const CVC_CERT *next_cert,
+           BN_CTX *bn_ctx)
+{
+    int oid, ok = 0, i;
+    EVP_PKEY *pub = NULL;
+
+    if (!ctx || !next_cert || !next_cert->body || !next_cert->body->chat) {
+        EACerr(EAC_F_TA_CTX_IMPORT_CERTIFICATE, EAC_R_INVALID_ARGUMENTS);
+        return 0;
+    }
+
+    /* Check date to see if the certificate is still valid
+     * (not for link certificates). */
+    if (!(ctx->flags & TA_FLAG_SKIP_TIMECHECK)
+            && CVC_get_role(next_cert->body->chat) != CVC_CVCA
+            && cvc_check_time(next_cert) != 1)
+        goto err;
+
+    /* If current cert if not set, this is the beginning of the certificate chain
+     * and therefore next_cert MUST be a trust anchor. */
+    if (ctx->current_cert) {
+        /* Check chain integrity: The CAR of a certificate must be equal to the
+         * the CHR of the next certificate in the chain */
+        if (!next_cert->body->certificate_authority_reference
+                || !ctx->current_cert->body->certificate_holder_reference
+                || next_cert->body->certificate_authority_reference->length !=
+                    ctx->current_cert->body->certificate_holder_reference->length
+                || memcmp(ctx->current_cert->body->certificate_holder_reference->data,
+                    next_cert->body->certificate_authority_reference->data,
+                    ctx->current_cert->body->certificate_holder_reference->length)) {
+            EACerr(EAC_F_TA_CTX_IMPORT_CERTIFICATE, EAC_R_CURRENT_CHR_DOES_NOT_MATCH_NEXT_CAR);
+            goto err;
+        }
+
+        i = CVC_verify_signature(next_cert, ctx->pub_key);
+        if (i <= 0) {
+            if (i == 0)
+                EACerr(EAC_F_TA_CTX_IMPORT_CERTIFICATE, EAC_R_CURRENT_SIGNATURE_NOT_VERIFIED);
+            goto err;
+        }
+
+        CVC_CERT_free(ctx->current_cert);
+    }
+
+    ctx->current_cert = CVC_CERT_dup(next_cert);
+    if (!ctx->current_cert)
+        goto err;
+
+    /* Set a (new) trust anchor */
+    if (CVC_get_role(next_cert->body->chat) == CVC_CVCA) {
+        if (!ctx->trust_anchor)
+            ctx->trust_anchor = CVC_CERT_dup(next_cert);
+        else {
+            if (ctx->new_trust_anchor)
+                CVC_CERT_free(ctx->new_trust_anchor);
+            ctx->new_trust_anchor = CVC_CERT_dup(next_cert);
+            if (!ctx->new_trust_anchor)
+                goto err;
+        }
+    }
+
+    /* Extract the public key of the terminal and overwrite the current key. */
+    if (ctx->priv_key) {
+        pub = CVC_get_pubkey(ctx->priv_key, next_cert, bn_ctx);
+    } else { /* ctx->pub might be NULL (in case of a CVCA certificate). */
+        pub = CVC_get_pubkey(ctx->pub_key, next_cert, bn_ctx);
+    }
+    if (!pub)
+        goto err;
+
+    EVP_PKEY_free(ctx->pub_key);
+    ctx->pub_key = pub;
+
+    /* Extract OID from the terminal certificate */
+    oid = OBJ_obj2nid(next_cert->body->public_key->oid);
+
+    /* Use the oid as the protocol identifier in the TA context */
+    ctx->protocol = oid;
+
+    ok = 1;
+
+err:
+    return ok;
+}
Index: openssl/crypto/eac/ta_lib.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ openssl/crypto/eac/ta_lib.h	2012-04-04 22:45:10.849494109 +0200
@@ -0,0 +1,41 @@
+/**
+ * @file ta_lib.h
+ *
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef TA_LIB_H_
+#define TA_LIB_H_
+
+/**
+ * @brief Import the parameters and public key from a card verifiable certificate
+ * into a TA_CTX structure. This function is used to verify certificate chains by
+ * subsequently importing all the certificates, starting with the CVCA.
+ * @param ctx The TA_CTX structure to initialize
+ * @param cvc The card verifiable certificate to be imported
+ * @param bn_ctx (optional)
+ * @return 1 on success or 0 in case of an error
+ */
+int
+TA_CTX_import_certificate(TA_CTX *ctx, const CVC_CERT *next_cert,
+           BN_CTX *bn_ctx);
+
+/**
+ * @brief Create a new \TA_CTX structure
+ * @return The new structure or NULL in case of an error
+ */
+TA_CTX *
+TA_CTX_new(void);
+
+/**
+ * @brief Free a \c TA_CTX object and all its components.
+ *
+ * Sensitive memory is cleared with OPENSSL_cleanse().
+ *
+ * @param ctx The \c TA_CTX to free
+ */
+void
+TA_CTX_clear_free(TA_CTX *ctx);
+
+#endif
Index: openssl/crypto/ec/ec.h
===================================================================
--- openssl.orig/crypto/ec/ec.h	2012-04-04 22:45:10.081106305 +0200
+++ openssl/crypto/ec/ec.h	2012-04-04 23:15:24.587305668 +0200
@@ -87,6 +87,7 @@
 #ifndef OPENSSL_NO_DEPRECATED
 #include <openssl/bn.h>
 #endif
+#include <openssl/buffer.h>
 
 #ifdef  __cplusplus
 extern "C" {
@@ -941,6 +942,18 @@
 
 #endif
 
+/**
+ * @brief converts an EC_POINT object to a BUF_MEM object
+ *
+ * @param ecdh EC_KEY object
+ * @param bn_ctx object (optional)
+ * @param ecp elliptic curve point to convert
+ *
+ * @return converted elliptic curve point or NULL if an error occurred
+ */
+BUF_MEM *
+EC_POINT_point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp);
+
 #define ECParameters_dup(x) ASN1_dup_of(EC_KEY,i2d_ECParameters,d2i_ECParameters,x)
 
 #ifndef __cplusplus
Index: openssl/crypto/ec/ec_print.c
===================================================================
--- openssl.orig/crypto/ec/ec_print.c	2012-04-04 22:45:10.077104279 +0200
+++ openssl/crypto/ec/ec_print.c	2012-04-04 23:15:24.587305668 +0200
@@ -54,6 +54,7 @@
  */
 
 #include <openssl/crypto.h>
+#include <openssl/buffer.h>
 #include "ec_lcl.h"
 
 BIGNUM *EC_POINT_point2bn(const EC_GROUP *group, 
@@ -86,6 +87,28 @@
 	return ret;
 }
 
+BUF_MEM *
+EC_POINT_point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp)
+{
+    size_t len;
+    BUF_MEM * out;
+
+    len = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), NULL, 0, bn_ctx);
+    if (len == 0)
+        return NULL;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    out->length = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), (unsigned char *) out->data, out->max,
+            bn_ctx);
+
+    return out;
+}
+
 EC_POINT *EC_POINT_bn2point(const EC_GROUP *group,
                             const BIGNUM *bn,
                             EC_POINT *point, 
Index: openssl/crypto/ecdh/ecdh.h
===================================================================
--- openssl.orig/crypto/ecdh/ecdh.h	2012-04-04 22:45:10.073102256 +0200
+++ openssl/crypto/ecdh/ecdh.h	2012-04-04 23:15:24.587305668 +0200
@@ -86,6 +86,7 @@
 #endif
 
 const ECDH_METHOD *ECDH_OpenSSL(void);
+const ECDH_METHOD *ECDH_OpenSSL_Point(void);
 
 void	  ECDH_set_default_method(const ECDH_METHOD *);
 const ECDH_METHOD *ECDH_get_default_method(void);
@@ -111,6 +112,7 @@
 /* Function codes. */
 #define ECDH_F_ECDH_CHECK				 102
 #define ECDH_F_ECDH_COMPUTE_KEY				 100
+#define ECDH_F_ECDH_COMPUTE_KEY_POINT			 103
 #define ECDH_F_ECDH_DATA_NEW_METHOD			 101
 
 /* Reason codes. */
Index: openssl/crypto/ecdh/ech_ossl.c
===================================================================
--- openssl.orig/crypto/ecdh/ech_ossl.c	2012-04-04 22:45:10.073102256 +0200
+++ openssl/crypto/ecdh/ech_ossl.c	2012-04-04 23:15:24.587305668 +0200
@@ -99,6 +99,113 @@
 	return &openssl_ecdh_meth;
 	}
 
+static int ecdh_compute_key_point(void *out, size_t outlen, const EC_POINT *pub_key,
+   EC_KEY *ecdh,
+   void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen));
+
+static ECDH_METHOD openssl_ecdh_meth_point = {
+    "OpenSSL ECDH method with Point",
+    ecdh_compute_key_point,
+#if 0
+    NULL, /* init   */
+    NULL, /* finish */
+#endif
+    0,    /* flags  */
+    NULL  /* app_data */
+};
+
+int ecdh_compute_key_point(void *out, size_t outlen, const EC_POINT *pub_key,
+   EC_KEY *ecdh,
+   void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))
+   {
+   BN_CTX *ctx;
+   EC_POINT *tmp=NULL;
+   const BIGNUM *priv_key;
+   const EC_GROUP* group;
+   int ret= -1;
+   size_t buflen;
+   unsigned char *buf=NULL;
+
+   if (outlen > INT_MAX)
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ERR_R_MALLOC_FAILURE); /* sort of, anyway */
+       return -1;
+       }
+
+   if ((ctx = BN_CTX_new()) == NULL) goto err;
+   BN_CTX_start(ctx);
+
+   priv_key = EC_KEY_get0_private_key(ecdh);
+   if (priv_key == NULL)
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ECDH_R_NO_PRIVATE_VALUE);
+       goto err;
+       }
+
+   group = EC_KEY_get0_group(ecdh);
+   if ((tmp=EC_POINT_new(group)) == NULL)
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ERR_R_MALLOC_FAILURE);
+       goto err;
+       }
+
+   if (!EC_POINT_mul(group, tmp, NULL, pub_key, priv_key, ctx))
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ECDH_R_POINT_ARITHMETIC_FAILURE);
+       goto err;
+       }
+
+
+        buflen = EC_POINT_point2oct(group, tmp,
+                EC_KEY_get_conv_form(ecdh), NULL, 0, ctx);
+        if (buflen < 0)
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ERR_R_BN_LIB);
+       goto err;
+       }
+   if ((buf = OPENSSL_malloc(buflen)) == NULL)
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ERR_R_MALLOC_FAILURE);
+       goto err;
+       }
+
+        if (buflen != EC_POINT_point2oct(group, tmp,
+                    EC_KEY_get_conv_form(ecdh), buf, buflen, ctx))
+       {
+       ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ERR_R_BN_LIB);
+       goto err;
+       }
+
+   if (KDF != 0)
+       {
+       if (KDF(buf, buflen, out, &outlen) == NULL)
+           {
+           ECDHerr(ECDH_F_ECDH_COMPUTE_KEY_POINT,ECDH_R_KDF_FAILED);
+           goto err;
+           }
+       ret = outlen;
+       }
+   else
+       {
+       /* no KDF, just copy as much as we can */
+       if (outlen > buflen)
+           outlen = buflen;
+       memcpy(out, buf, outlen);
+       ret = outlen;
+       }
+
+err:
+    if (tmp) EC_POINT_free(tmp);
+    if (ctx) BN_CTX_end(ctx);
+    if (ctx) BN_CTX_free(ctx);
+    if (buf) OPENSSL_free(buf);
+    return(ret);
+}
+
+const ECDH_METHOD *ECDH_OpenSSL_Point(void)
+    {
+    return &openssl_ecdh_meth_point;
+    }
 
 /* This implementation is based on the following primitives in the IEEE 1363 standard:
  *  - ECKAS-DH1
Index: openssl/crypto/err/err.c
===================================================================
--- openssl.orig/crypto/err/err.c	2012-04-04 22:45:10.141136596 +0200
+++ openssl/crypto/err/err.c	2012-04-04 23:15:24.575305609 +0200
@@ -156,6 +156,7 @@
 {ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
 {ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
 {ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
+{ERR_PACK(ERR_LIB_EAC,0,0)		,"EAC routines"},
 {0,NULL},
 	};
 
Index: openssl/crypto/err/err.h
===================================================================
--- openssl.orig/crypto/err/err.h	2012-04-04 22:45:10.141136596 +0200
+++ openssl/crypto/err/err.h	2012-04-04 23:15:24.575305609 +0200
@@ -198,6 +198,7 @@
 #define ERR_LIB_TS		47
 #define ERR_LIB_HMAC		48
 #define ERR_LIB_JPAKE		49
+#define ERR_LIB_EAC	    50
 
 #define ERR_LIB_USER		128
 
@@ -234,6 +235,7 @@
 #define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)
 #define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)
 #define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)
+#define EACerr(f,r) ERR_PUT_error(ERR_LIB_EAC,(f),(r),__FILE__,__LINE__)
 
 /* Borland C seems too stupid to be able to shift and do longs in
  * the pre-processor :-( */
Index: openssl/crypto/err/err_all.c
===================================================================
--- openssl.orig/crypto/err/err_all.c	2012-04-04 22:45:10.141136596 +0200
+++ openssl/crypto/err/err_all.c	2012-04-04 23:15:24.575305609 +0200
@@ -102,6 +102,9 @@
 #ifndef OPENSSL_NO_JPAKE
 #include <openssl/jpake.h>
 #endif
+#ifndef OPENSSL_NO_EAC
+#include <openssl/eac.h>
+#endif
 #include <openssl/comp.h>
 
 #ifdef OPENSSL_FIPS
@@ -159,6 +162,9 @@
 #ifndef OPENSSL_NO_JPAKE
 	ERR_load_JPAKE_strings();
 #endif
+#ifndef OPENSSL_NO_EAC
+	ERR_load_EAC_strings();
+#endif
 	ERR_load_COMP_strings();
 #endif
 #ifdef OPENSSL_FIPS
Index: openssl/crypto/err/openssl.ec
===================================================================
--- openssl.orig/crypto/err/openssl.ec	2012-04-04 22:45:10.141136596 +0200
+++ openssl/crypto/err/openssl.ec	2012-04-04 23:15:24.575305609 +0200
@@ -35,6 +35,7 @@
 L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
 L CMS		crypto/cms/cms.h		crypto/cms/cms_err.c
 L JPAKE		crypto/jpake/jpake.h		crypto/jpake/jpake_err.c
+L EAC		crypto/eac/eac.h		crypto/eac/eac_err.c
 
 # additional header files to be scanned for function names
 L NONE		crypto/x509/x509_vfy.h		NONE
Index: openssl/crypto/install-crypto.com
===================================================================
--- openssl.orig/crypto/install-crypto.com	2012-04-04 22:45:10.177154780 +0200
+++ openssl/crypto/install-crypto.com	2012-04-04 23:15:24.583305644 +0200
@@ -81,7 +81,7 @@
    buffer, bio, stack, lhash, rand, err, -
    evp, asn1, pem, x509, x509v3, conf, txt_db, pkcs7, pkcs12, comp, ocsp, -
    ui, krb5, -
-   store, cms, pqueue, ts, jpake
+   store, cms, pqueue, ts, jpake, eac
 $!
 $ exheader_ := crypto.h, opensslv.h, ebcdic.h, symhacks.h, ossl_typ.h
 $ exheader_'archd' := opensslconf.h
@@ -139,6 +139,7 @@
 $ exheader_pqueue := pqueue.h
 $ exheader_ts := ts.h
 $ exheader_jpake := jpake.h
+$ exheader_jpake := pace.h,eac.h,ta.h,ca.h,ri.h,cv_cert.h
 $ libs := ssl_libcrypto
 $!
 $ exe_dir := [-.'archd'.exe.crypto]
Index: openssl/crypto/objects/obj_dat.h
===================================================================
--- openssl.orig/crypto/objects/obj_dat.h	2012-04-04 22:45:10.173152755 +0200
+++ openssl/crypto/objects/obj_dat.h	2012-04-04 23:15:56.527464026 +0200
@@ -62,12 +62,12 @@
  * [including the GNU Public Licence.]
  */
 
-#define NUM_NID 920
-#define NUM_SN 913
-#define NUM_LN 913
-#define NUM_OBJ 857
+#define NUM_NID 1017
+#define NUM_SN 1010
+#define NUM_LN 1010
+#define NUM_OBJ 954
 
-static const unsigned char lvalues[5980]={
+static const unsigned char lvalues[6895]={
 0x00,                                        /* [  0] OBJ_undef */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,               /* [  1] OBJ_rsadsi */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,          /* [  7] OBJ_pkcs */
@@ -925,6 +925,103 @@
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x08,/* [5952] OBJ_mgf1 */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x0A,/* [5961] OBJ_rsassaPss */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x07,/* [5970] OBJ_rsaesOaep */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x01,/* [5979] OBJ_brainpoolP160r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x02,/* [5988] OBJ_brainpoolP160t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x03,/* [5997] OBJ_brainpoolP192r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x04,/* [6006] OBJ_brainpoolP192t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x05,/* [6015] OBJ_brainpoolP224r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x06,/* [6024] OBJ_brainpoolP224t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x07,/* [6033] OBJ_brainpoolP256r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x08,/* [6042] OBJ_brainpoolP256t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x09,/* [6051] OBJ_brainpoolP320r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0A,/* [6060] OBJ_brainpoolP320t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0B,/* [6069] OBJ_brainpoolP384r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0C,/* [6078] OBJ_brainpoolP384t1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0D,/* [6087] OBJ_brainpoolP512r1 */
+0x2B,0x24,0x03,0x03,0x02,0x08,0x01,0x01,0x0E,/* [6096] OBJ_brainpoolP512t1 */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x02,          /* [6105] OBJ_standardizedDomainParameters */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x01,0x01,/* [6112] OBJ_id_PK_DH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x01,0x02,/* [6121] OBJ_id_PK_ECDH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,     /* [6130] OBJ_id_TA */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,/* [6138] OBJ_id_TA_RSA */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x01,/* [6147] OBJ_id_TA_RSA_v1_5_SHA_1 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x02,/* [6157] OBJ_id_TA_RSA_v1_5_SHA_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x03,/* [6167] OBJ_id_TA_RSA_PSS_SHA_1 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x04,/* [6177] OBJ_id_TA_RSA_PSS_SHA_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x05,/* [6187] OBJ_id_TA_RSA_v1_5_SHA_512 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x01,0x06,/* [6197] OBJ_id_TA_RSA_PSS_SHA_512 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,/* [6207] OBJ_id_TA_ECDSA */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,0x01,/* [6216] OBJ_id_TA_ECDSA_SHA_1 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,0x02,/* [6226] OBJ_id_TA_ECDSA_SHA_224 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,0x03,/* [6236] OBJ_id_TA_ECDSA_SHA_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,0x04,/* [6246] OBJ_id_TA_ECDSA_SHA_384 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x02,0x02,0x05,/* [6256] OBJ_id_TA_ECDSA_SHA_512 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x01,/* [6266] OBJ_id_CA_DH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x01,0x01,/* [6275] OBJ_id_CA_DH_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x01,0x02,/* [6285] OBJ_id_CA_DH_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x01,0x03,/* [6295] OBJ_id_CA_DH_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x01,0x04,/* [6305] OBJ_id_CA_DH_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x02,/* [6315] OBJ_id_CA_ECDH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x02,0x01,/* [6324] OBJ_id_CA_ECDH_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x02,0x02,/* [6334] OBJ_id_CA_ECDH_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x02,0x03,/* [6344] OBJ_id_CA_ECDH_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x03,0x02,0x04,/* [6354] OBJ_id_CA_ECDH_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x01,/* [6364] OBJ_id_PACE_DH_GM */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x01,0x01,/* [6373] OBJ_id_PACE_DH_GM_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x01,0x02,/* [6383] OBJ_id_PACE_DH_GM_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x01,0x03,/* [6393] OBJ_id_PACE_DH_GM_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x01,0x04,/* [6403] OBJ_id_PACE_DH_GM_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x02,/* [6413] OBJ_id_PACE_ECDH_GM */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x02,0x01,/* [6422] OBJ_id_PACE_ECDH_GM_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x02,0x02,/* [6432] OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x02,0x03,/* [6442] OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x02,0x04,/* [6452] OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x03,/* [6462] OBJ_id_PACE_DH_IM */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x03,0x01,/* [6471] OBJ_id_PACE_DH_IM_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x03,0x02,/* [6481] OBJ_id_PACE_DH_IM_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x03,0x03,/* [6491] OBJ_id_PACE_DH_IM_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x03,0x04,/* [6501] OBJ_id_PACE_DH_IM_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x04,/* [6511] OBJ_id_PACE_ECDH_IM */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x04,0x01,/* [6520] OBJ_id_PACE_ECDH_IM_3DES_CBC_CBC */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x04,0x02,/* [6530] OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_128 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x04,0x03,/* [6540] OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_192 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x04,0x04,0x04,/* [6550] OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,/* [6560] OBJ_id_RI_DH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,0x01,/* [6569] OBJ_id_RI_DH_SHA_1 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,0x02,/* [6579] OBJ_id_RI_DH_SHA_224 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,0x03,/* [6589] OBJ_id_RI_DH_SHA_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,0x04,/* [6599] OBJ_id_RI_DH_SHA_384 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x01,0x05,/* [6609] OBJ_id_RI_DH_SHA_512 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,/* [6619] OBJ_id_RI_ECDH */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,0x01,/* [6628] OBJ_id_RI_ECDH_SHA_1 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,0x02,/* [6638] OBJ_id_RI_ECDH_SHA_224 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,0x03,/* [6648] OBJ_id_RI_ECDH_SHA_256 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,0x04,/* [6658] OBJ_id_RI_ECDH_SHA_384 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x05,0x02,0x05,/* [6668] OBJ_id_RI_ECDH_SHA_512 */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x06,     /* [6678] OBJ_id_CI */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x07,     /* [6686] OBJ_id_eIDSecurity */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x08,     /* [6694] OBJ_id_PT */
+0x2A,0x86,0x48,0xCE,0x3E,                    /* [6702] OBJ_ansi_x942 */
+0x2A,0x86,0x48,0xCE,0x3E,0x02,0x01,          /* [6707] OBJ_dhpublicnumber */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x06,     /* [6714] OBJ_cardInfoLocator */
+0x04,0x00,0x7F,0x00,0x07,0x02,0x02,0x07,     /* [6722] OBJ_eID */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x01,0x05,0x02,0x02,/* [6730] OBJ_ecka_dh_SessionKDF */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x01,0x05,0x02,0x02,0x01,/* [6740] OBJ_ecka_dh_SessionKDF_DES3 */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x01,0x05,0x02,0x02,0x02,/* [6751] OBJ_ecka_dh_SessionKDF_AES128 */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x01,0x05,0x02,0x02,0x03,/* [6762] OBJ_ecka_dh_SessionKDF_AES192 */
+0x04,0x00,0x7F,0x00,0x07,0x01,0x01,0x05,0x02,0x02,0x04,/* [6773] OBJ_ecka_dh_SessionKDF_AES256 */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x02,0x01,/* [6784] OBJ_id_IS */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x02,0x02,/* [6793] OBJ_id_AT */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x02,0x03,/* [6802] OBJ_id_ST */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x03,0x01,/* [6811] OBJ_id_description */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x03,0x01,0x01,/* [6820] OBJ_id_plainFormat */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x03,0x01,0x02,/* [6830] OBJ_id_htmlFormat */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x03,0x01,0x03,/* [6840] OBJ_id_pdfFormat */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x03,0x02,/* [6850] OBJ_id_sector */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x02,0x01,     /* [6859] OBJ_id_SecurityObject */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x04,0x01,/* [6867] OBJ_id_DateOfBirth */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x04,0x02,/* [6876] OBJ_id_DateOfExpiry */
+0x04,0x00,0x7F,0x00,0x07,0x03,0x01,0x04,0x03,/* [6885] OBJ_id_CommunityID */
 };
 
 static const ASN1_OBJECT nid_objs[NUM_NID]={
@@ -2406,6 +2503,185 @@
 {"AES-256-CBC-HMAC-SHA1","aes-256-cbc-hmac-sha1",
 	NID_aes_256_cbc_hmac_sha1,0,NULL,0},
 {"RSAES-OAEP","rsaesOaep",NID_rsaesOaep,9,&(lvalues[5970]),0},
+{"brainpoolP160r1","brainpoolP160r1",NID_brainpoolP160r1,9,
+	&(lvalues[5979]),0},
+{"brainpoolP160t1","brainpoolP160t1",NID_brainpoolP160t1,9,
+	&(lvalues[5988]),0},
+{"brainpoolP192r1","brainpoolP192r1",NID_brainpoolP192r1,9,
+	&(lvalues[5997]),0},
+{"brainpoolP192t1","brainpoolP192t1",NID_brainpoolP192t1,9,
+	&(lvalues[6006]),0},
+{"brainpoolP224r1","brainpoolP224r1",NID_brainpoolP224r1,9,
+	&(lvalues[6015]),0},
+{"brainpoolP224t1","brainpoolP224t1",NID_brainpoolP224t1,9,
+	&(lvalues[6024]),0},
+{"brainpoolP256r1","brainpoolP256r1",NID_brainpoolP256r1,9,
+	&(lvalues[6033]),0},
+{"brainpoolP256t1","brainpoolP256t1",NID_brainpoolP256t1,9,
+	&(lvalues[6042]),0},
+{"brainpoolP320r1","brainpoolP320r1",NID_brainpoolP320r1,9,
+	&(lvalues[6051]),0},
+{"brainpoolP320t1","brainpoolP320t1",NID_brainpoolP320t1,9,
+	&(lvalues[6060]),0},
+{"brainpoolP384r1","brainpoolP384r1",NID_brainpoolP384r1,9,
+	&(lvalues[6069]),0},
+{"brainpoolP384t1","brainpoolP384t1",NID_brainpoolP384t1,9,
+	&(lvalues[6078]),0},
+{"brainpoolP512r1","brainpoolP512r1",NID_brainpoolP512r1,9,
+	&(lvalues[6087]),0},
+{"brainpoolP512t1","brainpoolP512t1",NID_brainpoolP512t1,9,
+	&(lvalues[6096]),0},
+{"standardizedDomainParameters","standardizedDomainParameters",
+	NID_standardizedDomainParameters,7,&(lvalues[6105]),0},
+{"id-PK-DH","id-PK-DH",NID_id_PK_DH,9,&(lvalues[6112]),0},
+{"id-PK-ECDH","id-PK-ECDH",NID_id_PK_ECDH,9,&(lvalues[6121]),0},
+{"id-TA","id-TA",NID_id_TA,8,&(lvalues[6130]),0},
+{"id-TA-RSA","id-TA-RSA",NID_id_TA_RSA,9,&(lvalues[6138]),0},
+{"id-TA-RSA-v1-5-SHA-1","id-TA-RSA-v1-5-SHA-1",
+	NID_id_TA_RSA_v1_5_SHA_1,10,&(lvalues[6147]),0},
+{"id-TA-RSA-v1-5-SHA-256","id-TA-RSA-v1-5-SHA-256",
+	NID_id_TA_RSA_v1_5_SHA_256,10,&(lvalues[6157]),0},
+{"id-TA-RSA-PSS-SHA-1","id-TA-RSA-PSS-SHA-1",NID_id_TA_RSA_PSS_SHA_1,
+	10,&(lvalues[6167]),0},
+{"id-TA-RSA-PSS-SHA-256","id-TA-RSA-PSS-SHA-256",
+	NID_id_TA_RSA_PSS_SHA_256,10,&(lvalues[6177]),0},
+{"id-TA-RSA-v1-5-SHA-512","id-TA-RSA-v1-5-SHA-512",
+	NID_id_TA_RSA_v1_5_SHA_512,10,&(lvalues[6187]),0},
+{"id-TA-RSA-PSS-SHA-512","id-TA-RSA-PSS-SHA-512",
+	NID_id_TA_RSA_PSS_SHA_512,10,&(lvalues[6197]),0},
+{"id-TA-ECDSA","id-TA-ECDSA",NID_id_TA_ECDSA,9,&(lvalues[6207]),0},
+{"id-TA-ECDSA-SHA-1","id-TA-ECDSA-SHA-1",NID_id_TA_ECDSA_SHA_1,10,
+	&(lvalues[6216]),0},
+{"id-TA-ECDSA-SHA-224","id-TA-ECDSA-SHA-224",NID_id_TA_ECDSA_SHA_224,
+	10,&(lvalues[6226]),0},
+{"id-TA-ECDSA-SHA-256","id-TA-ECDSA-SHA-256",NID_id_TA_ECDSA_SHA_256,
+	10,&(lvalues[6236]),0},
+{"id-TA-ECDSA-SHA-384","id-TA-ECDSA-SHA-384",NID_id_TA_ECDSA_SHA_384,
+	10,&(lvalues[6246]),0},
+{"id-TA-ECDSA-SHA-512","id-TA-ECDSA-SHA-512",NID_id_TA_ECDSA_SHA_512,
+	10,&(lvalues[6256]),0},
+{"id-CA-DH","id-CA-DH",NID_id_CA_DH,9,&(lvalues[6266]),0},
+{"id-CA-DH-3DES-CBC-CBC","id-CA-DH-3DES-CBC-CBC",
+	NID_id_CA_DH_3DES_CBC_CBC,10,&(lvalues[6275]),0},
+{"id-CA-DH-AES-CBC-CMAC-128","id-CA-DH-AES-CBC-CMAC-128",
+	NID_id_CA_DH_AES_CBC_CMAC_128,10,&(lvalues[6285]),0},
+{"id-CA-DH-AES-CBC-CMAC-192","id-CA-DH-AES-CBC-CMAC-192",
+	NID_id_CA_DH_AES_CBC_CMAC_192,10,&(lvalues[6295]),0},
+{"id-CA-DH-AES-CBC-CMAC-256","id-CA-DH-AES-CBC-CMAC-256",
+	NID_id_CA_DH_AES_CBC_CMAC_256,10,&(lvalues[6305]),0},
+{"id-CA-ECDH","id-CA-ECDH",NID_id_CA_ECDH,9,&(lvalues[6315]),0},
+{"id-CA-ECDH-3DES-CBC-CBC","id-CA-ECDH-3DES-CBC-CBC",
+	NID_id_CA_ECDH_3DES_CBC_CBC,10,&(lvalues[6324]),0},
+{"id-CA-ECDH-AES-CBC-CMAC-128","id-CA-ECDH-AES-CBC-CMAC-128",
+	NID_id_CA_ECDH_AES_CBC_CMAC_128,10,&(lvalues[6334]),0},
+{"id-CA-ECDH-AES-CBC-CMAC-192","id-CA-ECDH-AES-CBC-CMAC-192",
+	NID_id_CA_ECDH_AES_CBC_CMAC_192,10,&(lvalues[6344]),0},
+{"id-CA-ECDH-AES-CBC-CMAC-256","id-CA-ECDH-AES-CBC-CMAC-256",
+	NID_id_CA_ECDH_AES_CBC_CMAC_256,10,&(lvalues[6354]),0},
+{"id-PACE-DH-GM","id-PACE-DH-GM",NID_id_PACE_DH_GM,9,&(lvalues[6364]),0},
+{"id-PACE-DH-GM-3DES-CBC-CBC","id-PACE-DH-GM-3DES-CBC-CBC",
+	NID_id_PACE_DH_GM_3DES_CBC_CBC,10,&(lvalues[6373]),0},
+{"id-PACE-DH-GM-AES-CBC-CMAC-128","id-PACE-DH-GM-AES-CBC-CMAC-128",
+	NID_id_PACE_DH_GM_AES_CBC_CMAC_128,10,&(lvalues[6383]),0},
+{"id-PACE-DH-GM-AES-CBC-CMAC-192","id-PACE-DH-GM-AES-CBC-CMAC-192",
+	NID_id_PACE_DH_GM_AES_CBC_CMAC_192,10,&(lvalues[6393]),0},
+{"id-PACE-DH-GM-AES-CBC-CMAC-256","id-PACE-DH-GM-AES-CBC-CMAC-256",
+	NID_id_PACE_DH_GM_AES_CBC_CMAC_256,10,&(lvalues[6403]),0},
+{"id-PACE-ECDH-GM","id-PACE-ECDH-GM",NID_id_PACE_ECDH_GM,9,
+	&(lvalues[6413]),0},
+{"id-PACE-ECDH-GM-3DES-CBC-CBC","id-PACE-ECDH-GM-3DES-CBC-CBC",
+	NID_id_PACE_ECDH_GM_3DES_CBC_CBC,10,&(lvalues[6422]),0},
+{"id-PACE-ECDH-GM-AES-CBC-CMAC-128",
+	"id-PACE-ECDH-GM-AES-CBC-CMAC-128",
+	NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128,10,&(lvalues[6432]),0},
+{"id-PACE-ECDH-GM-AES-CBC-CMAC-192",
+	"id-PACE-ECDH-GM-AES-CBC-CMAC-192",
+	NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192,10,&(lvalues[6442]),0},
+{"id-PACE-ECDH-GM-AES-CBC-CMAC-256",
+	"id-PACE-ECDH-GM-AES-CBC-CMAC-256",
+	NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256,10,&(lvalues[6452]),0},
+{"id-PACE-DH-IM","id-PACE-DH-IM",NID_id_PACE_DH_IM,9,&(lvalues[6462]),0},
+{"id-PACE-DH-IM-3DES-CBC-CBC","id-PACE-DH-IM-3DES-CBC-CBC",
+	NID_id_PACE_DH_IM_3DES_CBC_CBC,10,&(lvalues[6471]),0},
+{"id-PACE-DH-IM-AES-CBC-CMAC-128","id-PACE-DH-IM-AES-CBC-CMAC-128",
+	NID_id_PACE_DH_IM_AES_CBC_CMAC_128,10,&(lvalues[6481]),0},
+{"id-PACE-DH-IM-AES-CBC-CMAC-192","id-PACE-DH-IM-AES-CBC-CMAC-192",
+	NID_id_PACE_DH_IM_AES_CBC_CMAC_192,10,&(lvalues[6491]),0},
+{"id-PACE-DH-IM-AES-CBC-CMAC-256","id-PACE-DH-IM-AES-CBC-CMAC-256",
+	NID_id_PACE_DH_IM_AES_CBC_CMAC_256,10,&(lvalues[6501]),0},
+{"id-PACE-ECDH-IM","id-PACE-ECDH-IM",NID_id_PACE_ECDH_IM,9,
+	&(lvalues[6511]),0},
+{"id-PACE-ECDH-IM-3DES-CBC-CBC","id-PACE-ECDH-IM-3DES-CBC-CBC",
+	NID_id_PACE_ECDH_IM_3DES_CBC_CBC,10,&(lvalues[6520]),0},
+{"id-PACE-ECDH-IM-AES-CBC-CMAC-128",
+	"id-PACE-ECDH-IM-AES-CBC-CMAC-128",
+	NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128,10,&(lvalues[6530]),0},
+{"id-PACE-ECDH-IM-AES-CBC-CMAC-192",
+	"id-PACE-ECDH-IM-AES-CBC-CMAC-192",
+	NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192,10,&(lvalues[6540]),0},
+{"id-PACE-ECDH-IM-AES-CBC-CMAC-256",
+	"id-PACE-ECDH-IM-AES-CBC-CMAC-256",
+	NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256,10,&(lvalues[6550]),0},
+{"id-RI-DH","id-RI-DH",NID_id_RI_DH,9,&(lvalues[6560]),0},
+{"id-RI-DH-SHA-1","id-RI-DH-SHA-1",NID_id_RI_DH_SHA_1,10,
+	&(lvalues[6569]),0},
+{"id-RI-DH-SHA-224","id-RI-DH-SHA-224",NID_id_RI_DH_SHA_224,10,
+	&(lvalues[6579]),0},
+{"id-RI-DH-SHA-256","id-RI-DH-SHA-256",NID_id_RI_DH_SHA_256,10,
+	&(lvalues[6589]),0},
+{"id-RI-DH-SHA-384","id-RI-DH-SHA-384",NID_id_RI_DH_SHA_384,10,
+	&(lvalues[6599]),0},
+{"id-RI-DH-SHA-512","id-RI-DH-SHA-512",NID_id_RI_DH_SHA_512,10,
+	&(lvalues[6609]),0},
+{"id-RI-ECDH","id-RI-ECDH",NID_id_RI_ECDH,9,&(lvalues[6619]),0},
+{"id-RI-ECDH-SHA-1","id-RI-ECDH-SHA-1",NID_id_RI_ECDH_SHA_1,10,
+	&(lvalues[6628]),0},
+{"id-RI-ECDH-SHA-224","id-RI-ECDH-SHA-224",NID_id_RI_ECDH_SHA_224,10,
+	&(lvalues[6638]),0},
+{"id-RI-ECDH-SHA-256","id-RI-ECDH-SHA-256",NID_id_RI_ECDH_SHA_256,10,
+	&(lvalues[6648]),0},
+{"id-RI-ECDH-SHA-384","id-RI-ECDH-SHA-384",NID_id_RI_ECDH_SHA_384,10,
+	&(lvalues[6658]),0},
+{"id-RI-ECDH-SHA-512","id-RI-ECDH-SHA-512",NID_id_RI_ECDH_SHA_512,10,
+	&(lvalues[6668]),0},
+{"id-CI","id-CI",NID_id_CI,8,&(lvalues[6678]),0},
+{"id-eIDSecurity","id-eIDSecurity",NID_id_eIDSecurity,8,
+	&(lvalues[6686]),0},
+{"id-PT","id-PT",NID_id_PT,8,&(lvalues[6694]),0},
+{"ansi-x942","ansi-x942",NID_ansi_x942,5,&(lvalues[6702]),0},
+{"dhpublicnumber","dhpublicnumber",NID_dhpublicnumber,7,
+	&(lvalues[6707]),0},
+{"cardInfoLocator","cardInfoLocator",NID_cardInfoLocator,8,
+	&(lvalues[6714]),0},
+{"eID","eID",NID_eID,8,&(lvalues[6722]),0},
+{"ecka-dh-SessionKDF","ecka-dh-SessionKDF",NID_ecka_dh_SessionKDF,10,
+	&(lvalues[6730]),0},
+{"ecka-dh-SessionKDF-DES3","ecka-dh-SessionKDF-DES3",
+	NID_ecka_dh_SessionKDF_DES3,11,&(lvalues[6740]),0},
+{"ecka-dh-SessionKDF-AES128","ecka-dh-SessionKDF-AES128",
+	NID_ecka_dh_SessionKDF_AES128,11,&(lvalues[6751]),0},
+{"ecka-dh-SessionKDF-AES192","ecka-dh-SessionKDF-AES192",
+	NID_ecka_dh_SessionKDF_AES192,11,&(lvalues[6762]),0},
+{"ecka-dh-SessionKDF-AES256","ecka-dh-SessionKDF-AES256",
+	NID_ecka_dh_SessionKDF_AES256,11,&(lvalues[6773]),0},
+{"id-IS","id-IS",NID_id_IS,9,&(lvalues[6784]),0},
+{"id-AT","id-AT",NID_id_AT,9,&(lvalues[6793]),0},
+{"id-ST","id-ST",NID_id_ST,9,&(lvalues[6802]),0},
+{"id-description","id-description",NID_id_description,9,
+	&(lvalues[6811]),0},
+{"id-plainFormat","id-plainFormat",NID_id_plainFormat,10,
+	&(lvalues[6820]),0},
+{"id-htmlFormat","id-htmlFormat",NID_id_htmlFormat,10,&(lvalues[6830]),0},
+{"id-pdfFormat","id-pdfFormat",NID_id_pdfFormat,10,&(lvalues[6840]),0},
+{"id-sector","id-sector",NID_id_sector,9,&(lvalues[6850]),0},
+{"id-SecurityObject","id-SecurityObject",NID_id_SecurityObject,8,
+	&(lvalues[6859]),0},
+{"id-DateOfBirth","id-DateOfBirth",NID_id_DateOfBirth,9,
+	&(lvalues[6867]),0},
+{"id-DateOfExpiry","id-DateOfExpiry",NID_id_DateOfExpiry,9,
+	&(lvalues[6876]),0},
+{"id-CommunityID","id-CommunityID",NID_id_CommunityID,9,
+	&(lvalues[6885]),0},
 };
 
 static const unsigned int sn_objs[NUM_SN]={
@@ -2608,6 +2884,7 @@
 363,	/* "ad_timestamping" */
 376,	/* "algorithm" */
 405,	/* "ansi-X9-62" */
+996,	/* "ansi-x942" */
 910,	/* "anyExtendedKeyUsage" */
 746,	/* "anyPolicy" */
 370,	/* "archiveCutoff" */
@@ -2620,6 +2897,20 @@
 87,	/* "basicConstraints" */
 365,	/* "basicOCSPResponse" */
 285,	/* "biometricInfo" */
+920,	/* "brainpoolP160r1" */
+921,	/* "brainpoolP160t1" */
+922,	/* "brainpoolP192r1" */
+923,	/* "brainpoolP192t1" */
+924,	/* "brainpoolP224r1" */
+925,	/* "brainpoolP224t1" */
+926,	/* "brainpoolP256r1" */
+927,	/* "brainpoolP256t1" */
+928,	/* "brainpoolP320r1" */
+929,	/* "brainpoolP320t1" */
+930,	/* "brainpoolP384r1" */
+931,	/* "brainpoolP384t1" */
+932,	/* "brainpoolP512r1" */
+933,	/* "brainpoolP512t1" */
 494,	/* "buildingName" */
 860,	/* "businessCategory" */
 691,	/* "c2onb191v4" */
@@ -2646,6 +2937,7 @@
 483,	/* "cNAMERecord" */
 179,	/* "caIssuers" */
 785,	/* "caRepository" */
+998,	/* "cardInfoLocator" */
 443,	/* "caseIgnoreIA5StringSyntax" */
 152,	/* "certBag" */
 677,	/* "certicom-arc" */
@@ -2675,6 +2967,7 @@
 107,	/* "description" */
 871,	/* "destinationIndicator" */
 28,	/* "dhKeyAgreement" */
+997,	/* "dhpublicnumber" */
 382,	/* "directory" */
 887,	/* "distinguishedName" */
 892,	/* "dmdName" */
@@ -2691,6 +2984,7 @@
 452,	/* "domainRelatedObject" */
 802,	/* "dsa_with_SHA224" */
 803,	/* "dsa_with_SHA256" */
+999,	/* "eID" */
 791,	/* "ecdsa-with-Recommended" */
 416,	/* "ecdsa-with-SHA1" */
 793,	/* "ecdsa-with-SHA224" */
@@ -2698,6 +2992,11 @@
 795,	/* "ecdsa-with-SHA384" */
 796,	/* "ecdsa-with-SHA512" */
 792,	/* "ecdsa-with-Specified" */
+1000,	/* "ecka-dh-SessionKDF" */
+1002,	/* "ecka-dh-SessionKDF-AES128" */
+1003,	/* "ecka-dh-SessionKDF-AES192" */
+1004,	/* "ecka-dh-SessionKDF-AES256" */
+1001,	/* "ecka-dh-SessionKDF-DES3" */
 48,	/* "emailAddress" */
 132,	/* "emailProtection" */
 885,	/* "enhancedSearchGuide" */
@@ -2736,7 +3035,22 @@
 466,	/* "host" */
 889,	/* "houseIdentifier" */
 442,	/* "iA5StringSyntax" */
+1006,	/* "id-AT" */
+951,	/* "id-CA-DH" */
+952,	/* "id-CA-DH-3DES-CBC-CBC" */
+953,	/* "id-CA-DH-AES-CBC-CMAC-128" */
+954,	/* "id-CA-DH-AES-CBC-CMAC-192" */
+955,	/* "id-CA-DH-AES-CBC-CMAC-256" */
+956,	/* "id-CA-ECDH" */
+957,	/* "id-CA-ECDH-3DES-CBC-CBC" */
+958,	/* "id-CA-ECDH-AES-CBC-CMAC-128" */
+959,	/* "id-CA-ECDH-AES-CBC-CMAC-192" */
+960,	/* "id-CA-ECDH-AES-CBC-CMAC-256" */
+993,	/* "id-CI" */
+1016,	/* "id-CommunityID" */
 783,	/* "id-DHBasedMac" */
+1014,	/* "id-DateOfBirth" */
+1015,	/* "id-DateOfExpiry" */
 824,	/* "id-Gost28147-89-CryptoPro-A-ParamSet" */
 825,	/* "id-Gost28147-89-CryptoPro-B-ParamSet" */
 826,	/* "id-Gost28147-89-CryptoPro-C-ParamSet" */
@@ -2776,7 +3090,59 @@
 808,	/* "id-GostR3411-94-with-GostR3410-94" */
 852,	/* "id-GostR3411-94-with-GostR3410-94-cc" */
 810,	/* "id-HMACGostR3411-94" */
+1005,	/* "id-IS" */
+961,	/* "id-PACE-DH-GM" */
+962,	/* "id-PACE-DH-GM-3DES-CBC-CBC" */
+963,	/* "id-PACE-DH-GM-AES-CBC-CMAC-128" */
+964,	/* "id-PACE-DH-GM-AES-CBC-CMAC-192" */
+965,	/* "id-PACE-DH-GM-AES-CBC-CMAC-256" */
+971,	/* "id-PACE-DH-IM" */
+972,	/* "id-PACE-DH-IM-3DES-CBC-CBC" */
+973,	/* "id-PACE-DH-IM-AES-CBC-CMAC-128" */
+974,	/* "id-PACE-DH-IM-AES-CBC-CMAC-192" */
+975,	/* "id-PACE-DH-IM-AES-CBC-CMAC-256" */
+966,	/* "id-PACE-ECDH-GM" */
+967,	/* "id-PACE-ECDH-GM-3DES-CBC-CBC" */
+968,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-128" */
+969,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-192" */
+970,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-256" */
+976,	/* "id-PACE-ECDH-IM" */
+977,	/* "id-PACE-ECDH-IM-3DES-CBC-CBC" */
+978,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-128" */
+979,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-192" */
+980,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-256" */
+935,	/* "id-PK-DH" */
+936,	/* "id-PK-ECDH" */
+995,	/* "id-PT" */
 782,	/* "id-PasswordBasedMAC" */
+981,	/* "id-RI-DH" */
+982,	/* "id-RI-DH-SHA-1" */
+983,	/* "id-RI-DH-SHA-224" */
+984,	/* "id-RI-DH-SHA-256" */
+985,	/* "id-RI-DH-SHA-384" */
+986,	/* "id-RI-DH-SHA-512" */
+987,	/* "id-RI-ECDH" */
+988,	/* "id-RI-ECDH-SHA-1" */
+989,	/* "id-RI-ECDH-SHA-224" */
+990,	/* "id-RI-ECDH-SHA-256" */
+991,	/* "id-RI-ECDH-SHA-384" */
+992,	/* "id-RI-ECDH-SHA-512" */
+1007,	/* "id-ST" */
+1013,	/* "id-SecurityObject" */
+937,	/* "id-TA" */
+945,	/* "id-TA-ECDSA" */
+946,	/* "id-TA-ECDSA-SHA-1" */
+947,	/* "id-TA-ECDSA-SHA-224" */
+948,	/* "id-TA-ECDSA-SHA-256" */
+949,	/* "id-TA-ECDSA-SHA-384" */
+950,	/* "id-TA-ECDSA-SHA-512" */
+938,	/* "id-TA-RSA" */
+941,	/* "id-TA-RSA-PSS-SHA-1" */
+942,	/* "id-TA-RSA-PSS-SHA-256" */
+944,	/* "id-TA-RSA-PSS-SHA-512" */
+939,	/* "id-TA-RSA-v1-5-SHA-1" */
+940,	/* "id-TA-RSA-v1-5-SHA-256" */
+943,	/* "id-TA-RSA-v1-5-SHA-512" */
 266,	/* "id-aca" */
 355,	/* "id-aca-accessIdentity" */
 354,	/* "id-aca-authenticationInfo" */
@@ -2834,9 +3200,12 @@
 327,	/* "id-cmc-statusInfo" */
 331,	/* "id-cmc-transactionId" */
 787,	/* "id-ct-asciiTextWithCRLF" */
+1008,	/* "id-description" */
+994,	/* "id-eIDSecurity" */
 408,	/* "id-ecPublicKey" */
 508,	/* "id-hex-multipart-message" */
 507,	/* "id-hex-partial-message" */
+1010,	/* "id-htmlFormat" */
 260,	/* "id-it" */
 302,	/* "id-it-caKeyUpdateInfo" */
 298,	/* "id-it-caProtEncCert" */
@@ -2876,6 +3245,7 @@
 348,	/* "id-pda-dateOfBirth" */
 351,	/* "id-pda-gender" */
 349,	/* "id-pda-placeOfBirth" */
+1011,	/* "id-pdfFormat" */
 175,	/* "id-pe" */
 261,	/* "id-pkip" */
 258,	/* "id-pkix-mod" */
@@ -2883,6 +3253,7 @@
 271,	/* "id-pkix1-explicit-93" */
 270,	/* "id-pkix1-implicit-88" */
 272,	/* "id-pkix1-implicit-93" */
+1009,	/* "id-plainFormat" */
 662,	/* "id-ppl" */
 664,	/* "id-ppl-anyLanguage" */
 667,	/* "id-ppl-independent" */
@@ -2902,6 +3273,7 @@
 314,	/* "id-regInfo" */
 322,	/* "id-regInfo-certReq" */
 321,	/* "id-regInfo-utf8Pairs" */
+1012,	/* "id-sector" */
 512,	/* "id-set" */
 191,	/* "id-smime-aa" */
 215,	/* "id-smime-aa-contentHint" */
@@ -3277,6 +3649,7 @@
 454,	/* "simpleSecurityObject" */
 496,	/* "singleLevelQuality" */
 387,	/* "snmpv2" */
+934,	/* "standardizedDomainParameters" */
 660,	/* "street" */
 85,	/* "subjectAltName" */
 769,	/* "subjectDirectoryAttributes" */
@@ -3501,6 +3874,7 @@
 428,	/* "aes-256-ofb" */
 914,	/* "aes-256-xts" */
 376,	/* "algorithm" */
+996,	/* "ansi-x942" */
 484,	/* "associatedDomain" */
 485,	/* "associatedName" */
 501,	/* "audio" */
@@ -3509,6 +3883,20 @@
 93,	/* "bf-cfb" */
 92,	/* "bf-ecb" */
 94,	/* "bf-ofb" */
+920,	/* "brainpoolP160r1" */
+921,	/* "brainpoolP160t1" */
+922,	/* "brainpoolP192r1" */
+923,	/* "brainpoolP192t1" */
+924,	/* "brainpoolP224r1" */
+925,	/* "brainpoolP224t1" */
+926,	/* "brainpoolP256r1" */
+927,	/* "brainpoolP256t1" */
+928,	/* "brainpoolP320r1" */
+929,	/* "brainpoolP320t1" */
+930,	/* "brainpoolP384r1" */
+931,	/* "brainpoolP384t1" */
+932,	/* "brainpoolP512r1" */
+933,	/* "brainpoolP512t1" */
 494,	/* "buildingName" */
 860,	/* "businessCategory" */
 691,	/* "c2onb191v4" */
@@ -3551,6 +3939,7 @@
 765,	/* "camellia-256-cfb8" */
 756,	/* "camellia-256-ecb" */
 768,	/* "camellia-256-ofb" */
+998,	/* "cardInfoLocator" */
 443,	/* "caseIgnoreIA5StringSyntax" */
 108,	/* "cast5-cbc" */
 110,	/* "cast5-cfb" */
@@ -3601,6 +3990,7 @@
 871,	/* "destinationIndicator" */
 80,	/* "desx-cbc" */
 28,	/* "dhKeyAgreement" */
+997,	/* "dhpublicnumber" */
 11,	/* "directory services (X.500)" */
 378,	/* "directory services - algorithms" */
 887,	/* "distinguishedName" */
@@ -3625,6 +4015,7 @@
 802,	/* "dsa_with_SHA224" */
 803,	/* "dsa_with_SHA256" */
 297,	/* "dvcs" */
+999,	/* "eID" */
 791,	/* "ecdsa-with-Recommended" */
 416,	/* "ecdsa-with-SHA1" */
 793,	/* "ecdsa-with-SHA224" */
@@ -3632,6 +4023,11 @@
 795,	/* "ecdsa-with-SHA384" */
 796,	/* "ecdsa-with-SHA512" */
 792,	/* "ecdsa-with-Specified" */
+1000,	/* "ecka-dh-SessionKDF" */
+1002,	/* "ecka-dh-SessionKDF-AES128" */
+1003,	/* "ecka-dh-SessionKDF-AES192" */
+1004,	/* "ecka-dh-SessionKDF-AES256" */
+1001,	/* "ecka-dh-SessionKDF-DES3" */
 48,	/* "emailAddress" */
 632,	/* "encrypted track 2" */
 885,	/* "enhancedSearchGuide" */
@@ -3661,6 +4057,21 @@
 889,	/* "houseIdentifier" */
 442,	/* "iA5StringSyntax" */
 381,	/* "iana" */
+1006,	/* "id-AT" */
+951,	/* "id-CA-DH" */
+952,	/* "id-CA-DH-3DES-CBC-CBC" */
+953,	/* "id-CA-DH-AES-CBC-CMAC-128" */
+954,	/* "id-CA-DH-AES-CBC-CMAC-192" */
+955,	/* "id-CA-DH-AES-CBC-CMAC-256" */
+956,	/* "id-CA-ECDH" */
+957,	/* "id-CA-ECDH-3DES-CBC-CBC" */
+958,	/* "id-CA-ECDH-AES-CBC-CMAC-128" */
+959,	/* "id-CA-ECDH-AES-CBC-CMAC-192" */
+960,	/* "id-CA-ECDH-AES-CBC-CMAC-256" */
+993,	/* "id-CI" */
+1016,	/* "id-CommunityID" */
+1014,	/* "id-DateOfBirth" */
+1015,	/* "id-DateOfExpiry" */
 824,	/* "id-Gost28147-89-CryptoPro-A-ParamSet" */
 825,	/* "id-Gost28147-89-CryptoPro-B-ParamSet" */
 826,	/* "id-Gost28147-89-CryptoPro-C-ParamSet" */
@@ -3691,6 +4102,58 @@
 848,	/* "id-GostR3410-94-bBis" */
 822,	/* "id-GostR3411-94-CryptoProParamSet" */
 821,	/* "id-GostR3411-94-TestParamSet" */
+1005,	/* "id-IS" */
+961,	/* "id-PACE-DH-GM" */
+962,	/* "id-PACE-DH-GM-3DES-CBC-CBC" */
+963,	/* "id-PACE-DH-GM-AES-CBC-CMAC-128" */
+964,	/* "id-PACE-DH-GM-AES-CBC-CMAC-192" */
+965,	/* "id-PACE-DH-GM-AES-CBC-CMAC-256" */
+971,	/* "id-PACE-DH-IM" */
+972,	/* "id-PACE-DH-IM-3DES-CBC-CBC" */
+973,	/* "id-PACE-DH-IM-AES-CBC-CMAC-128" */
+974,	/* "id-PACE-DH-IM-AES-CBC-CMAC-192" */
+975,	/* "id-PACE-DH-IM-AES-CBC-CMAC-256" */
+966,	/* "id-PACE-ECDH-GM" */
+967,	/* "id-PACE-ECDH-GM-3DES-CBC-CBC" */
+968,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-128" */
+969,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-192" */
+970,	/* "id-PACE-ECDH-GM-AES-CBC-CMAC-256" */
+976,	/* "id-PACE-ECDH-IM" */
+977,	/* "id-PACE-ECDH-IM-3DES-CBC-CBC" */
+978,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-128" */
+979,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-192" */
+980,	/* "id-PACE-ECDH-IM-AES-CBC-CMAC-256" */
+935,	/* "id-PK-DH" */
+936,	/* "id-PK-ECDH" */
+995,	/* "id-PT" */
+981,	/* "id-RI-DH" */
+982,	/* "id-RI-DH-SHA-1" */
+983,	/* "id-RI-DH-SHA-224" */
+984,	/* "id-RI-DH-SHA-256" */
+985,	/* "id-RI-DH-SHA-384" */
+986,	/* "id-RI-DH-SHA-512" */
+987,	/* "id-RI-ECDH" */
+988,	/* "id-RI-ECDH-SHA-1" */
+989,	/* "id-RI-ECDH-SHA-224" */
+990,	/* "id-RI-ECDH-SHA-256" */
+991,	/* "id-RI-ECDH-SHA-384" */
+992,	/* "id-RI-ECDH-SHA-512" */
+1007,	/* "id-ST" */
+1013,	/* "id-SecurityObject" */
+937,	/* "id-TA" */
+945,	/* "id-TA-ECDSA" */
+946,	/* "id-TA-ECDSA-SHA-1" */
+947,	/* "id-TA-ECDSA-SHA-224" */
+948,	/* "id-TA-ECDSA-SHA-256" */
+949,	/* "id-TA-ECDSA-SHA-384" */
+950,	/* "id-TA-ECDSA-SHA-512" */
+938,	/* "id-TA-RSA" */
+941,	/* "id-TA-RSA-PSS-SHA-1" */
+942,	/* "id-TA-RSA-PSS-SHA-256" */
+944,	/* "id-TA-RSA-PSS-SHA-512" */
+939,	/* "id-TA-RSA-v1-5-SHA-1" */
+940,	/* "id-TA-RSA-v1-5-SHA-256" */
+943,	/* "id-TA-RSA-v1-5-SHA-512" */
 266,	/* "id-aca" */
 355,	/* "id-aca-accessIdentity" */
 354,	/* "id-aca-authenticationInfo" */
@@ -3742,9 +4205,12 @@
 327,	/* "id-cmc-statusInfo" */
 331,	/* "id-cmc-transactionId" */
 787,	/* "id-ct-asciiTextWithCRLF" */
+1008,	/* "id-description" */
+994,	/* "id-eIDSecurity" */
 408,	/* "id-ecPublicKey" */
 508,	/* "id-hex-multipart-message" */
 507,	/* "id-hex-partial-message" */
+1010,	/* "id-htmlFormat" */
 260,	/* "id-it" */
 302,	/* "id-it-caKeyUpdateInfo" */
 298,	/* "id-it-caProtEncCert" */
@@ -3783,6 +4249,7 @@
 348,	/* "id-pda-dateOfBirth" */
 351,	/* "id-pda-gender" */
 349,	/* "id-pda-placeOfBirth" */
+1011,	/* "id-pdfFormat" */
 175,	/* "id-pe" */
 261,	/* "id-pkip" */
 258,	/* "id-pkix-mod" */
@@ -3790,6 +4257,7 @@
 271,	/* "id-pkix1-explicit-93" */
 270,	/* "id-pkix1-implicit-88" */
 272,	/* "id-pkix1-implicit-93" */
+1009,	/* "id-plainFormat" */
 662,	/* "id-ppl" */
 267,	/* "id-qcs" */
 359,	/* "id-qcs-pkixQCSyntax-v1" */
@@ -3804,6 +4272,7 @@
 314,	/* "id-regInfo" */
 322,	/* "id-regInfo-certReq" */
 321,	/* "id-regInfo-utf8Pairs" */
+1012,	/* "id-sector" */
 191,	/* "id-smime-aa" */
 215,	/* "id-smime-aa-contentHint" */
 218,	/* "id-smime-aa-contentIdentifier" */
@@ -4195,6 +4664,7 @@
 52,	/* "signingTime" */
 454,	/* "simpleSecurityObject" */
 496,	/* "singleLevelQuality" */
+934,	/* "standardizedDomainParameters" */
 16,	/* "stateOrProvinceName" */
 660,	/* "streetAddress" */
 498,	/* "subtreeMaximumQuality" */
@@ -4479,6 +4949,7 @@
 806,	/* OBJ_cryptocom                    1 2 643 2 9 */
 184,	/* OBJ_X9_57                        1 2 840 10040 */
 405,	/* OBJ_ansi_X9_62                   1 2 840 10045 */
+996,	/* OBJ_ansi_x942                    1 2 840 10046 */
 389,	/* OBJ_Enterprises                  1 3 6 1 4 1 */
 504,	/* OBJ_mime_mhs                     1 3 6 1 7 1 */
 104,	/* OBJ_md5WithRSA                   1 3 14 3 2 3 */
@@ -4572,6 +5043,7 @@
 633,	/* OBJ_setAttr_T2cleartxt           2 23 42 3 3 4 2 */
 634,	/* OBJ_setAttr_TokICCsig            2 23 42 3 3 5 1 */
 635,	/* OBJ_setAttr_SecDevSig            2 23 42 3 3 5 2 */
+934,	/* OBJ_standardizedDomainParameters 0 4 0 127 0 7 1 2 */
 436,	/* OBJ_ucl                          0 9 2342 19200300 */
 820,	/* OBJ_id_Gost28147_89_None_KeyMeshing 1 2 643 2 2 14 0 */
 819,	/* OBJ_id_Gost28147_89_CryptoPro_KeyMeshing 1 2 643 2 2 14 1 */
@@ -4615,6 +5087,7 @@
 416,	/* OBJ_ecdsa_with_SHA1              1 2 840 10045 4 1 */
 791,	/* OBJ_ecdsa_with_Recommended       1 2 840 10045 4 2 */
 792,	/* OBJ_ecdsa_with_Specified         1 2 840 10045 4 3 */
+997,	/* OBJ_dhpublicnumber               1 2 840 10046 2 1 */
 258,	/* OBJ_id_pkix_mod                  1 3 6 1 5 5 7 0 */
 175,	/* OBJ_id_pe                        1 3 6 1 5 5 7 1 */
 259,	/* OBJ_id_qt                        1 3 6 1 5 5 7 2 */
@@ -4642,6 +5115,13 @@
 756,	/* OBJ_camellia_256_ecb             0 3 4401 5 3 1 9 41 */
 768,	/* OBJ_camellia_256_ofb128          0 3 4401 5 3 1 9 43 */
 759,	/* OBJ_camellia_256_cfb128          0 3 4401 5 3 1 9 44 */
+937,	/* OBJ_id_TA                        0 4 0 127 0 7 2 2 2 */
+993,	/* OBJ_id_CI                        0 4 0 127 0 7 2 2 6 */
+998,	/* OBJ_cardInfoLocator              0 4 0 127 0 7 2 2 6 */
+994,	/* OBJ_id_eIDSecurity               0 4 0 127 0 7 2 2 7 */
+999,	/* OBJ_eID                          0 4 0 127 0 7 2 2 7 */
+995,	/* OBJ_id_PT                        0 4 0 127 0 7 2 2 8 */
+1013,	/* OBJ_id_SecurityObject            0 4 0 127 0 7 3 2 1 */
 437,	/* OBJ_pilot                        0 9 2342 19200300 100 */
 776,	/* OBJ_seed_ecb                     1 2 410 200004 1 3 */
 777,	/* OBJ_seed_cbc                     1 2 410 200004 1 4 */
@@ -4816,6 +5296,26 @@
 781,	/* OBJ_hmac_sha1                    1 3 6 1 5 5 8 1 2 */
 58,	/* OBJ_netscape_cert_extension      2 16 840 1 113730 1 */
 59,	/* OBJ_netscape_data_type           2 16 840 1 113730 2 */
+935,	/* OBJ_id_PK_DH                     0 4 0 127 0 7 2 2 1 1 */
+936,	/* OBJ_id_PK_ECDH                   0 4 0 127 0 7 2 2 1 2 */
+938,	/* OBJ_id_TA_RSA                    0 4 0 127 0 7 2 2 2 1 */
+945,	/* OBJ_id_TA_ECDSA                  0 4 0 127 0 7 2 2 2 2 */
+951,	/* OBJ_id_CA_DH                     0 4 0 127 0 7 2 2 3 1 */
+956,	/* OBJ_id_CA_ECDH                   0 4 0 127 0 7 2 2 3 2 */
+961,	/* OBJ_id_PACE_DH_GM                0 4 0 127 0 7 2 2 4 1 */
+966,	/* OBJ_id_PACE_ECDH_GM              0 4 0 127 0 7 2 2 4 2 */
+971,	/* OBJ_id_PACE_DH_IM                0 4 0 127 0 7 2 2 4 3 */
+976,	/* OBJ_id_PACE_ECDH_IM              0 4 0 127 0 7 2 2 4 4 */
+981,	/* OBJ_id_RI_DH                     0 4 0 127 0 7 2 2 5 1 */
+987,	/* OBJ_id_RI_ECDH                   0 4 0 127 0 7 2 2 5 2 */
+1005,	/* OBJ_id_IS                        0 4 0 127 0 7 3 1 2 1 */
+1006,	/* OBJ_id_AT                        0 4 0 127 0 7 3 1 2 2 */
+1007,	/* OBJ_id_ST                        0 4 0 127 0 7 3 1 2 3 */
+1008,	/* OBJ_id_description               0 4 0 127 0 7 3 1 3 1 */
+1012,	/* OBJ_id_sector                    0 4 0 127 0 7 3 1 3 2 */
+1014,	/* OBJ_id_DateOfBirth               0 4 0 127 0 7 3 1 4 1 */
+1015,	/* OBJ_id_DateOfExpiry              0 4 0 127 0 7 3 1 4 2 */
+1016,	/* OBJ_id_CommunityID               0 4 0 127 0 7 3 1 4 3 */
 438,	/* OBJ_pilotAttributeType           0 9 2342 19200300 100 1 */
 439,	/* OBJ_pilotAttributeSyntax         0 9 2342 19200300 100 3 */
 440,	/* OBJ_pilotObjectClass             0 9 2342 19200300 100 4 */
@@ -4893,6 +5393,20 @@
 373,	/* OBJ_id_pkix_OCSP_valid           1 3 6 1 5 5 7 48 1 9 */
 374,	/* OBJ_id_pkix_OCSP_path            1 3 6 1 5 5 7 48 1 10 */
 375,	/* OBJ_id_pkix_OCSP_trustRoot       1 3 6 1 5 5 7 48 1 11 */
+920,	/* OBJ_brainpoolP160r1              1 3 36 3 3 2 8 1 1 1 */
+921,	/* OBJ_brainpoolP160t1              1 3 36 3 3 2 8 1 1 2 */
+922,	/* OBJ_brainpoolP192r1              1 3 36 3 3 2 8 1 1 3 */
+923,	/* OBJ_brainpoolP192t1              1 3 36 3 3 2 8 1 1 4 */
+924,	/* OBJ_brainpoolP224r1              1 3 36 3 3 2 8 1 1 5 */
+925,	/* OBJ_brainpoolP224t1              1 3 36 3 3 2 8 1 1 6 */
+926,	/* OBJ_brainpoolP256r1              1 3 36 3 3 2 8 1 1 7 */
+927,	/* OBJ_brainpoolP256t1              1 3 36 3 3 2 8 1 1 8 */
+928,	/* OBJ_brainpoolP320r1              1 3 36 3 3 2 8 1 1 9 */
+929,	/* OBJ_brainpoolP320t1              1 3 36 3 3 2 8 1 1 10 */
+930,	/* OBJ_brainpoolP384r1              1 3 36 3 3 2 8 1 1 11 */
+931,	/* OBJ_brainpoolP384t1              1 3 36 3 3 2 8 1 1 12 */
+932,	/* OBJ_brainpoolP512r1              1 3 36 3 3 2 8 1 1 13 */
+933,	/* OBJ_brainpoolP512t1              1 3 36 3 3 2 8 1 1 14 */
 418,	/* OBJ_aes_128_ecb                  2 16 840 1 101 3 4 1 1 */
 419,	/* OBJ_aes_128_cbc                  2 16 840 1 101 3 4 1 2 */
 420,	/* OBJ_aes_128_ofb128               2 16 840 1 101 3 4 1 3 */
@@ -4933,6 +5447,55 @@
 78,	/* OBJ_netscape_comment             2 16 840 1 113730 1 13 */
 79,	/* OBJ_netscape_cert_sequence       2 16 840 1 113730 2 5 */
 139,	/* OBJ_ns_sgc                       2 16 840 1 113730 4 1 */
+1000,	/* OBJ_ecka_dh_SessionKDF           0 4 0 127 0 7 1 1 5 2 2 */
+939,	/* OBJ_id_TA_RSA_v1_5_SHA_1         0 4 0 127 0 7 2 2 2 1 1 */
+940,	/* OBJ_id_TA_RSA_v1_5_SHA_256       0 4 0 127 0 7 2 2 2 1 2 */
+941,	/* OBJ_id_TA_RSA_PSS_SHA_1          0 4 0 127 0 7 2 2 2 1 3 */
+942,	/* OBJ_id_TA_RSA_PSS_SHA_256        0 4 0 127 0 7 2 2 2 1 4 */
+943,	/* OBJ_id_TA_RSA_v1_5_SHA_512       0 4 0 127 0 7 2 2 2 1 5 */
+944,	/* OBJ_id_TA_RSA_PSS_SHA_512        0 4 0 127 0 7 2 2 2 1 6 */
+946,	/* OBJ_id_TA_ECDSA_SHA_1            0 4 0 127 0 7 2 2 2 2 1 */
+947,	/* OBJ_id_TA_ECDSA_SHA_224          0 4 0 127 0 7 2 2 2 2 2 */
+948,	/* OBJ_id_TA_ECDSA_SHA_256          0 4 0 127 0 7 2 2 2 2 3 */
+949,	/* OBJ_id_TA_ECDSA_SHA_384          0 4 0 127 0 7 2 2 2 2 4 */
+950,	/* OBJ_id_TA_ECDSA_SHA_512          0 4 0 127 0 7 2 2 2 2 5 */
+952,	/* OBJ_id_CA_DH_3DES_CBC_CBC        0 4 0 127 0 7 2 2 3 1 1 */
+953,	/* OBJ_id_CA_DH_AES_CBC_CMAC_128    0 4 0 127 0 7 2 2 3 1 2 */
+954,	/* OBJ_id_CA_DH_AES_CBC_CMAC_192    0 4 0 127 0 7 2 2 3 1 3 */
+955,	/* OBJ_id_CA_DH_AES_CBC_CMAC_256    0 4 0 127 0 7 2 2 3 1 4 */
+957,	/* OBJ_id_CA_ECDH_3DES_CBC_CBC      0 4 0 127 0 7 2 2 3 2 1 */
+958,	/* OBJ_id_CA_ECDH_AES_CBC_CMAC_128  0 4 0 127 0 7 2 2 3 2 2 */
+959,	/* OBJ_id_CA_ECDH_AES_CBC_CMAC_192  0 4 0 127 0 7 2 2 3 2 3 */
+960,	/* OBJ_id_CA_ECDH_AES_CBC_CMAC_256  0 4 0 127 0 7 2 2 3 2 4 */
+962,	/* OBJ_id_PACE_DH_GM_3DES_CBC_CBC   0 4 0 127 0 7 2 2 4 1 1 */
+963,	/* OBJ_id_PACE_DH_GM_AES_CBC_CMAC_128 0 4 0 127 0 7 2 2 4 1 2 */
+964,	/* OBJ_id_PACE_DH_GM_AES_CBC_CMAC_192 0 4 0 127 0 7 2 2 4 1 3 */
+965,	/* OBJ_id_PACE_DH_GM_AES_CBC_CMAC_256 0 4 0 127 0 7 2 2 4 1 4 */
+967,	/* OBJ_id_PACE_ECDH_GM_3DES_CBC_CBC 0 4 0 127 0 7 2 2 4 2 1 */
+968,	/* OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_128 0 4 0 127 0 7 2 2 4 2 2 */
+969,	/* OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_192 0 4 0 127 0 7 2 2 4 2 3 */
+970,	/* OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_256 0 4 0 127 0 7 2 2 4 2 4 */
+972,	/* OBJ_id_PACE_DH_IM_3DES_CBC_CBC   0 4 0 127 0 7 2 2 4 3 1 */
+973,	/* OBJ_id_PACE_DH_IM_AES_CBC_CMAC_128 0 4 0 127 0 7 2 2 4 3 2 */
+974,	/* OBJ_id_PACE_DH_IM_AES_CBC_CMAC_192 0 4 0 127 0 7 2 2 4 3 3 */
+975,	/* OBJ_id_PACE_DH_IM_AES_CBC_CMAC_256 0 4 0 127 0 7 2 2 4 3 4 */
+977,	/* OBJ_id_PACE_ECDH_IM_3DES_CBC_CBC 0 4 0 127 0 7 2 2 4 4 1 */
+978,	/* OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_128 0 4 0 127 0 7 2 2 4 4 2 */
+979,	/* OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_192 0 4 0 127 0 7 2 2 4 4 3 */
+980,	/* OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_256 0 4 0 127 0 7 2 2 4 4 4 */
+982,	/* OBJ_id_RI_DH_SHA_1               0 4 0 127 0 7 2 2 5 1 1 */
+983,	/* OBJ_id_RI_DH_SHA_224             0 4 0 127 0 7 2 2 5 1 2 */
+984,	/* OBJ_id_RI_DH_SHA_256             0 4 0 127 0 7 2 2 5 1 3 */
+985,	/* OBJ_id_RI_DH_SHA_384             0 4 0 127 0 7 2 2 5 1 4 */
+986,	/* OBJ_id_RI_DH_SHA_512             0 4 0 127 0 7 2 2 5 1 5 */
+988,	/* OBJ_id_RI_ECDH_SHA_1             0 4 0 127 0 7 2 2 5 2 1 */
+989,	/* OBJ_id_RI_ECDH_SHA_224           0 4 0 127 0 7 2 2 5 2 2 */
+990,	/* OBJ_id_RI_ECDH_SHA_256           0 4 0 127 0 7 2 2 5 2 3 */
+991,	/* OBJ_id_RI_ECDH_SHA_384           0 4 0 127 0 7 2 2 5 2 4 */
+992,	/* OBJ_id_RI_ECDH_SHA_512           0 4 0 127 0 7 2 2 5 2 5 */
+1009,	/* OBJ_id_plainFormat               0 4 0 127 0 7 3 1 3 1 1 */
+1010,	/* OBJ_id_htmlFormat                0 4 0 127 0 7 3 1 3 1 2 */
+1011,	/* OBJ_id_pdfFormat                 0 4 0 127 0 7 3 1 3 1 3 */
 458,	/* OBJ_userId                       0 9 2342 19200300 100 1 1 */
 459,	/* OBJ_textEncodedORAddress         0 9 2342 19200300 100 1 2 */
 460,	/* OBJ_rfc822Mailbox                0 9 2342 19200300 100 1 3 */
@@ -5020,6 +5583,10 @@
 138,	/* OBJ_ms_efs                       1 3 6 1 4 1 311 10 3 4 */
 648,	/* OBJ_ms_smartcard_login           1 3 6 1 4 1 311 20 2 2 */
 649,	/* OBJ_ms_upn                       1 3 6 1 4 1 311 20 2 3 */
+1001,	/* OBJ_ecka_dh_SessionKDF_DES3      0 4 0 127 0 7 1 1 5 2 2 1 */
+1002,	/* OBJ_ecka_dh_SessionKDF_AES128    0 4 0 127 0 7 1 1 5 2 2 2 */
+1003,	/* OBJ_ecka_dh_SessionKDF_AES192    0 4 0 127 0 7 1 1 5 2 2 3 */
+1004,	/* OBJ_ecka_dh_SessionKDF_AES256    0 4 0 127 0 7 1 1 5 2 2 4 */
 751,	/* OBJ_camellia_128_cbc             1 2 392 200011 61 1 1 1 2 */
 752,	/* OBJ_camellia_192_cbc             1 2 392 200011 61 1 1 1 3 */
 753,	/* OBJ_camellia_256_cbc             1 2 392 200011 61 1 1 1 4 */
Index: openssl/crypto/objects/obj_mac.h
===================================================================
--- openssl.orig/crypto/objects/obj_mac.h	2012-04-04 22:45:10.173152755 +0200
+++ openssl/crypto/objects/obj_mac.h	2012-04-04 23:15:24.583305644 +0200
@@ -4086,3 +4086,359 @@
 #define NID_brainpoolP512t1		933
 #define OBJ_brainpoolP512t1		1L,3L,36L,3L,3L,2L,8L,1L,1L,14L
 
+#define OBJ_bsi_de		0L,4L,0L,127L,0L,7L
+
+#define SN_standardizedDomainParameters		"standardizedDomainParameters"
+#define NID_standardizedDomainParameters		934
+#define OBJ_standardizedDomainParameters		OBJ_bsi_de,1L,2L
+
+#define OBJ_id_PK		OBJ_bsi_de,2L,2L,1L
+
+#define SN_id_PK_DH		"id-PK-DH"
+#define NID_id_PK_DH		935
+#define OBJ_id_PK_DH		OBJ_id_PK,1L
+
+#define SN_id_PK_ECDH		"id-PK-ECDH"
+#define NID_id_PK_ECDH		936
+#define OBJ_id_PK_ECDH		OBJ_id_PK,2L
+
+#define SN_id_TA		"id-TA"
+#define NID_id_TA		937
+#define OBJ_id_TA		OBJ_bsi_de,2L,2L,2L
+
+#define SN_id_TA_RSA		"id-TA-RSA"
+#define NID_id_TA_RSA		938
+#define OBJ_id_TA_RSA		OBJ_id_TA,1L
+
+#define SN_id_TA_RSA_v1_5_SHA_1		"id-TA-RSA-v1-5-SHA-1"
+#define NID_id_TA_RSA_v1_5_SHA_1		939
+#define OBJ_id_TA_RSA_v1_5_SHA_1		OBJ_id_TA_RSA,1L
+
+#define SN_id_TA_RSA_v1_5_SHA_256		"id-TA-RSA-v1-5-SHA-256"
+#define NID_id_TA_RSA_v1_5_SHA_256		940
+#define OBJ_id_TA_RSA_v1_5_SHA_256		OBJ_id_TA_RSA,2L
+
+#define SN_id_TA_RSA_PSS_SHA_1		"id-TA-RSA-PSS-SHA-1"
+#define NID_id_TA_RSA_PSS_SHA_1		941
+#define OBJ_id_TA_RSA_PSS_SHA_1		OBJ_id_TA_RSA,3L
+
+#define SN_id_TA_RSA_PSS_SHA_256		"id-TA-RSA-PSS-SHA-256"
+#define NID_id_TA_RSA_PSS_SHA_256		942
+#define OBJ_id_TA_RSA_PSS_SHA_256		OBJ_id_TA_RSA,4L
+
+#define SN_id_TA_RSA_v1_5_SHA_512		"id-TA-RSA-v1-5-SHA-512"
+#define NID_id_TA_RSA_v1_5_SHA_512		943
+#define OBJ_id_TA_RSA_v1_5_SHA_512		OBJ_id_TA_RSA,5L
+
+#define SN_id_TA_RSA_PSS_SHA_512		"id-TA-RSA-PSS-SHA-512"
+#define NID_id_TA_RSA_PSS_SHA_512		944
+#define OBJ_id_TA_RSA_PSS_SHA_512		OBJ_id_TA_RSA,6L
+
+#define SN_id_TA_ECDSA		"id-TA-ECDSA"
+#define NID_id_TA_ECDSA		945
+#define OBJ_id_TA_ECDSA		OBJ_id_TA,2L
+
+#define SN_id_TA_ECDSA_SHA_1		"id-TA-ECDSA-SHA-1"
+#define NID_id_TA_ECDSA_SHA_1		946
+#define OBJ_id_TA_ECDSA_SHA_1		OBJ_id_TA_ECDSA,1L
+
+#define SN_id_TA_ECDSA_SHA_224		"id-TA-ECDSA-SHA-224"
+#define NID_id_TA_ECDSA_SHA_224		947
+#define OBJ_id_TA_ECDSA_SHA_224		OBJ_id_TA_ECDSA,2L
+
+#define SN_id_TA_ECDSA_SHA_256		"id-TA-ECDSA-SHA-256"
+#define NID_id_TA_ECDSA_SHA_256		948
+#define OBJ_id_TA_ECDSA_SHA_256		OBJ_id_TA_ECDSA,3L
+
+#define SN_id_TA_ECDSA_SHA_384		"id-TA-ECDSA-SHA-384"
+#define NID_id_TA_ECDSA_SHA_384		949
+#define OBJ_id_TA_ECDSA_SHA_384		OBJ_id_TA_ECDSA,4L
+
+#define SN_id_TA_ECDSA_SHA_512		"id-TA-ECDSA-SHA-512"
+#define NID_id_TA_ECDSA_SHA_512		950
+#define OBJ_id_TA_ECDSA_SHA_512		OBJ_id_TA_ECDSA,5L
+
+#define OBJ_id_CA		OBJ_bsi_de,2L,2L,3L
+
+#define SN_id_CA_DH		"id-CA-DH"
+#define NID_id_CA_DH		951
+#define OBJ_id_CA_DH		OBJ_id_CA,1L
+
+#define SN_id_CA_DH_3DES_CBC_CBC		"id-CA-DH-3DES-CBC-CBC"
+#define NID_id_CA_DH_3DES_CBC_CBC		952
+#define OBJ_id_CA_DH_3DES_CBC_CBC		OBJ_id_CA_DH,1L
+
+#define SN_id_CA_DH_AES_CBC_CMAC_128		"id-CA-DH-AES-CBC-CMAC-128"
+#define NID_id_CA_DH_AES_CBC_CMAC_128		953
+#define OBJ_id_CA_DH_AES_CBC_CMAC_128		OBJ_id_CA_DH,2L
+
+#define SN_id_CA_DH_AES_CBC_CMAC_192		"id-CA-DH-AES-CBC-CMAC-192"
+#define NID_id_CA_DH_AES_CBC_CMAC_192		954
+#define OBJ_id_CA_DH_AES_CBC_CMAC_192		OBJ_id_CA_DH,3L
+
+#define SN_id_CA_DH_AES_CBC_CMAC_256		"id-CA-DH-AES-CBC-CMAC-256"
+#define NID_id_CA_DH_AES_CBC_CMAC_256		955
+#define OBJ_id_CA_DH_AES_CBC_CMAC_256		OBJ_id_CA_DH,4L
+
+#define SN_id_CA_ECDH		"id-CA-ECDH"
+#define NID_id_CA_ECDH		956
+#define OBJ_id_CA_ECDH		OBJ_id_CA,2L
+
+#define SN_id_CA_ECDH_3DES_CBC_CBC		"id-CA-ECDH-3DES-CBC-CBC"
+#define NID_id_CA_ECDH_3DES_CBC_CBC		957
+#define OBJ_id_CA_ECDH_3DES_CBC_CBC		OBJ_id_CA_ECDH,1L
+
+#define SN_id_CA_ECDH_AES_CBC_CMAC_128		"id-CA-ECDH-AES-CBC-CMAC-128"
+#define NID_id_CA_ECDH_AES_CBC_CMAC_128		958
+#define OBJ_id_CA_ECDH_AES_CBC_CMAC_128		OBJ_id_CA_ECDH,2L
+
+#define SN_id_CA_ECDH_AES_CBC_CMAC_192		"id-CA-ECDH-AES-CBC-CMAC-192"
+#define NID_id_CA_ECDH_AES_CBC_CMAC_192		959
+#define OBJ_id_CA_ECDH_AES_CBC_CMAC_192		OBJ_id_CA_ECDH,3L
+
+#define SN_id_CA_ECDH_AES_CBC_CMAC_256		"id-CA-ECDH-AES-CBC-CMAC-256"
+#define NID_id_CA_ECDH_AES_CBC_CMAC_256		960
+#define OBJ_id_CA_ECDH_AES_CBC_CMAC_256		OBJ_id_CA_ECDH,4L
+
+#define OBJ_id_PACE		OBJ_bsi_de,2L,2L,4L
+
+#define SN_id_PACE_DH_GM		"id-PACE-DH-GM"
+#define NID_id_PACE_DH_GM		961
+#define OBJ_id_PACE_DH_GM		OBJ_id_PACE,1L
+
+#define SN_id_PACE_DH_GM_3DES_CBC_CBC		"id-PACE-DH-GM-3DES-CBC-CBC"
+#define NID_id_PACE_DH_GM_3DES_CBC_CBC		962
+#define OBJ_id_PACE_DH_GM_3DES_CBC_CBC		OBJ_id_PACE_DH_GM,1L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_128		"id-PACE-DH-GM-AES-CBC-CMAC-128"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_128		963
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_128		OBJ_id_PACE_DH_GM,2L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_192		"id-PACE-DH-GM-AES-CBC-CMAC-192"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_192		964
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_192		OBJ_id_PACE_DH_GM,3L
+
+#define SN_id_PACE_DH_GM_AES_CBC_CMAC_256		"id-PACE-DH-GM-AES-CBC-CMAC-256"
+#define NID_id_PACE_DH_GM_AES_CBC_CMAC_256		965
+#define OBJ_id_PACE_DH_GM_AES_CBC_CMAC_256		OBJ_id_PACE_DH_GM,4L
+
+#define SN_id_PACE_ECDH_GM		"id-PACE-ECDH-GM"
+#define NID_id_PACE_ECDH_GM		966
+#define OBJ_id_PACE_ECDH_GM		OBJ_id_PACE,2L
+
+#define SN_id_PACE_ECDH_GM_3DES_CBC_CBC		"id-PACE-ECDH-GM-3DES-CBC-CBC"
+#define NID_id_PACE_ECDH_GM_3DES_CBC_CBC		967
+#define OBJ_id_PACE_ECDH_GM_3DES_CBC_CBC		OBJ_id_PACE_ECDH_GM,1L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_128		"id-PACE-ECDH-GM-AES-CBC-CMAC-128"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128		968
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_128		OBJ_id_PACE_ECDH_GM,2L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_192		"id-PACE-ECDH-GM-AES-CBC-CMAC-192"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192		969
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_192		OBJ_id_PACE_ECDH_GM,3L
+
+#define SN_id_PACE_ECDH_GM_AES_CBC_CMAC_256		"id-PACE-ECDH-GM-AES-CBC-CMAC-256"
+#define NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256		970
+#define OBJ_id_PACE_ECDH_GM_AES_CBC_CMAC_256		OBJ_id_PACE_ECDH_GM,4L
+
+#define SN_id_PACE_DH_IM		"id-PACE-DH-IM"
+#define NID_id_PACE_DH_IM		971
+#define OBJ_id_PACE_DH_IM		OBJ_id_PACE,3L
+
+#define SN_id_PACE_DH_IM_3DES_CBC_CBC		"id-PACE-DH-IM-3DES-CBC-CBC"
+#define NID_id_PACE_DH_IM_3DES_CBC_CBC		972
+#define OBJ_id_PACE_DH_IM_3DES_CBC_CBC		OBJ_id_PACE_DH_IM,1L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_128		"id-PACE-DH-IM-AES-CBC-CMAC-128"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_128		973
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_128		OBJ_id_PACE_DH_IM,2L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_192		"id-PACE-DH-IM-AES-CBC-CMAC-192"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_192		974
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_192		OBJ_id_PACE_DH_IM,3L
+
+#define SN_id_PACE_DH_IM_AES_CBC_CMAC_256		"id-PACE-DH-IM-AES-CBC-CMAC-256"
+#define NID_id_PACE_DH_IM_AES_CBC_CMAC_256		975
+#define OBJ_id_PACE_DH_IM_AES_CBC_CMAC_256		OBJ_id_PACE_DH_IM,4L
+
+#define SN_id_PACE_ECDH_IM		"id-PACE-ECDH-IM"
+#define NID_id_PACE_ECDH_IM		976
+#define OBJ_id_PACE_ECDH_IM		OBJ_id_PACE,4L
+
+#define SN_id_PACE_ECDH_IM_3DES_CBC_CBC		"id-PACE-ECDH-IM-3DES-CBC-CBC"
+#define NID_id_PACE_ECDH_IM_3DES_CBC_CBC		977
+#define OBJ_id_PACE_ECDH_IM_3DES_CBC_CBC		OBJ_id_PACE_ECDH_IM,1L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_128		"id-PACE-ECDH-IM-AES-CBC-CMAC-128"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128		978
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_128		OBJ_id_PACE_ECDH_IM,2L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_192		"id-PACE-ECDH-IM-AES-CBC-CMAC-192"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192		979
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_192		OBJ_id_PACE_ECDH_IM,3L
+
+#define SN_id_PACE_ECDH_IM_AES_CBC_CMAC_256		"id-PACE-ECDH-IM-AES-CBC-CMAC-256"
+#define NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256		980
+#define OBJ_id_PACE_ECDH_IM_AES_CBC_CMAC_256		OBJ_id_PACE_ECDH_IM,4L
+
+#define OBJ_id_RI		OBJ_bsi_de,2L,2L,5L
+
+#define SN_id_RI_DH		"id-RI-DH"
+#define NID_id_RI_DH		981
+#define OBJ_id_RI_DH		OBJ_id_RI,1L
+
+#define SN_id_RI_DH_SHA_1		"id-RI-DH-SHA-1"
+#define NID_id_RI_DH_SHA_1		982
+#define OBJ_id_RI_DH_SHA_1		OBJ_id_RI_DH,1L
+
+#define SN_id_RI_DH_SHA_224		"id-RI-DH-SHA-224"
+#define NID_id_RI_DH_SHA_224		983
+#define OBJ_id_RI_DH_SHA_224		OBJ_id_RI_DH,2L
+
+#define SN_id_RI_DH_SHA_256		"id-RI-DH-SHA-256"
+#define NID_id_RI_DH_SHA_256		984
+#define OBJ_id_RI_DH_SHA_256		OBJ_id_RI_DH,3L
+
+#define SN_id_RI_DH_SHA_384		"id-RI-DH-SHA-384"
+#define NID_id_RI_DH_SHA_384		985
+#define OBJ_id_RI_DH_SHA_384		OBJ_id_RI_DH,4L
+
+#define SN_id_RI_DH_SHA_512		"id-RI-DH-SHA-512"
+#define NID_id_RI_DH_SHA_512		986
+#define OBJ_id_RI_DH_SHA_512		OBJ_id_RI_DH,5L
+
+#define SN_id_RI_ECDH		"id-RI-ECDH"
+#define NID_id_RI_ECDH		987
+#define OBJ_id_RI_ECDH		OBJ_id_RI,2L
+
+#define SN_id_RI_ECDH_SHA_1		"id-RI-ECDH-SHA-1"
+#define NID_id_RI_ECDH_SHA_1		988
+#define OBJ_id_RI_ECDH_SHA_1		OBJ_id_RI_ECDH,1L
+
+#define SN_id_RI_ECDH_SHA_224		"id-RI-ECDH-SHA-224"
+#define NID_id_RI_ECDH_SHA_224		989
+#define OBJ_id_RI_ECDH_SHA_224		OBJ_id_RI_ECDH,2L
+
+#define SN_id_RI_ECDH_SHA_256		"id-RI-ECDH-SHA-256"
+#define NID_id_RI_ECDH_SHA_256		990
+#define OBJ_id_RI_ECDH_SHA_256		OBJ_id_RI_ECDH,3L
+
+#define SN_id_RI_ECDH_SHA_384		"id-RI-ECDH-SHA-384"
+#define NID_id_RI_ECDH_SHA_384		991
+#define OBJ_id_RI_ECDH_SHA_384		OBJ_id_RI_ECDH,4L
+
+#define SN_id_RI_ECDH_SHA_512		"id-RI-ECDH-SHA-512"
+#define NID_id_RI_ECDH_SHA_512		992
+#define OBJ_id_RI_ECDH_SHA_512		OBJ_id_RI_ECDH,5L
+
+#define SN_id_CI		"id-CI"
+#define NID_id_CI		993
+#define OBJ_id_CI		OBJ_bsi_de,2L,2L,6L
+
+#define SN_id_eIDSecurity		"id-eIDSecurity"
+#define NID_id_eIDSecurity		994
+#define OBJ_id_eIDSecurity		OBJ_bsi_de,2L,2L,7L
+
+#define SN_id_PT		"id-PT"
+#define NID_id_PT		995
+#define OBJ_id_PT		OBJ_bsi_de,2L,2L,8L
+
+#define SN_ansi_x942		"ansi-x942"
+#define NID_ansi_x942		996
+#define OBJ_ansi_x942		OBJ_ISO_US,10046L
+
+#define OBJ_x942_number_type		OBJ_ansi_x942,2L
+
+#define SN_dhpublicnumber		"dhpublicnumber"
+#define NID_dhpublicnumber		997
+#define OBJ_dhpublicnumber		OBJ_x942_number_type,1L
+
+#define SN_cardInfoLocator		"cardInfoLocator"
+#define NID_cardInfoLocator		998
+#define OBJ_cardInfoLocator		OBJ_bsi_de,2L,2L,6L
+
+#define SN_eID		"eID"
+#define NID_eID		999
+#define OBJ_eID		OBJ_bsi_de,2L,2L,7L
+
+#define OBJ_id_ecc		OBJ_bsi_de,1L,1L
+
+#define OBJ_ecka_dh		OBJ_id_ecc,5L,2L
+
+#define SN_ecka_dh_SessionKDF		"ecka-dh-SessionKDF"
+#define NID_ecka_dh_SessionKDF		1000
+#define OBJ_ecka_dh_SessionKDF		OBJ_ecka_dh,2L
+
+#define SN_ecka_dh_SessionKDF_DES3		"ecka-dh-SessionKDF-DES3"
+#define NID_ecka_dh_SessionKDF_DES3		1001
+#define OBJ_ecka_dh_SessionKDF_DES3		OBJ_ecka_dh,2L,1L
+
+#define SN_ecka_dh_SessionKDF_AES128		"ecka-dh-SessionKDF-AES128"
+#define NID_ecka_dh_SessionKDF_AES128		1002
+#define OBJ_ecka_dh_SessionKDF_AES128		OBJ_ecka_dh,2L,2L
+
+#define SN_ecka_dh_SessionKDF_AES192		"ecka-dh-SessionKDF-AES192"
+#define NID_ecka_dh_SessionKDF_AES192		1003
+#define OBJ_ecka_dh_SessionKDF_AES192		OBJ_ecka_dh,2L,3L
+
+#define SN_ecka_dh_SessionKDF_AES256		"ecka-dh-SessionKDF-AES256"
+#define NID_ecka_dh_SessionKDF_AES256		1004
+#define OBJ_ecka_dh_SessionKDF_AES256		OBJ_ecka_dh,2L,4L
+
+#define OBJ_id_roles		OBJ_bsi_de,3L,1L,2L
+
+#define SN_id_IS		"id-IS"
+#define NID_id_IS		1005
+#define OBJ_id_IS		OBJ_id_roles,1L
+
+#define SN_id_AT		"id-AT"
+#define NID_id_AT		1006
+#define OBJ_id_AT		OBJ_id_roles,2L
+
+#define SN_id_ST		"id-ST"
+#define NID_id_ST		1007
+#define OBJ_id_ST		OBJ_id_roles,3L
+
+#define OBJ_id_extensions		OBJ_bsi_de,3L,1L,3L
+
+#define SN_id_description		"id-description"
+#define NID_id_description		1008
+#define OBJ_id_description		OBJ_id_extensions,1L
+
+#define SN_id_plainFormat		"id-plainFormat"
+#define NID_id_plainFormat		1009
+#define OBJ_id_plainFormat		OBJ_id_description,1L
+
+#define SN_id_htmlFormat		"id-htmlFormat"
+#define NID_id_htmlFormat		1010
+#define OBJ_id_htmlFormat		OBJ_id_description,2L
+
+#define SN_id_pdfFormat		"id-pdfFormat"
+#define NID_id_pdfFormat		1011
+#define OBJ_id_pdfFormat		OBJ_id_description,3L
+
+#define SN_id_sector		"id-sector"
+#define NID_id_sector		1012
+#define OBJ_id_sector		OBJ_id_extensions,2L
+
+#define OBJ_id_eID		OBJ_bsi_de,3L,2L
+
+#define SN_id_SecurityObject		"id-SecurityObject"
+#define NID_id_SecurityObject		1013
+#define OBJ_id_SecurityObject		OBJ_id_eID,1L
+
+#define OBJ_id_AuxiliaryData		OBJ_bsi_de,3L,1L,4L
+
+#define SN_id_DateOfBirth		"id-DateOfBirth"
+#define NID_id_DateOfBirth		1014
+#define OBJ_id_DateOfBirth		OBJ_id_AuxiliaryData,1L
+
+#define SN_id_DateOfExpiry		"id-DateOfExpiry"
+#define NID_id_DateOfExpiry		1015
+#define OBJ_id_DateOfExpiry		OBJ_id_AuxiliaryData,2L
+
+#define SN_id_CommunityID		"id-CommunityID"
+#define NID_id_CommunityID		1016
+#define OBJ_id_CommunityID		OBJ_id_AuxiliaryData,3L
+
Index: openssl/crypto/objects/obj_mac.num
===================================================================
--- openssl.orig/crypto/objects/obj_mac.num	2012-04-04 22:45:10.173152755 +0200
+++ openssl/crypto/objects/obj_mac.num	2012-04-04 23:15:24.579305623 +0200
@@ -931,3 +931,86 @@
 brainpoolP384t1		931
 brainpoolP512r1		932
 brainpoolP512t1		933
+standardizedDomainParameters		934
+id_PK_DH		935
+id_PK_ECDH		936
+id_TA		937
+id_TA_RSA		938
+id_TA_RSA_v1_5_SHA_1		939
+id_TA_RSA_v1_5_SHA_256		940
+id_TA_RSA_PSS_SHA_1		941
+id_TA_RSA_PSS_SHA_256		942
+id_TA_RSA_v1_5_SHA_512		943
+id_TA_RSA_PSS_SHA_512		944
+id_TA_ECDSA		945
+id_TA_ECDSA_SHA_1		946
+id_TA_ECDSA_SHA_224		947
+id_TA_ECDSA_SHA_256		948
+id_TA_ECDSA_SHA_384		949
+id_TA_ECDSA_SHA_512		950
+id_CA_DH		951
+id_CA_DH_3DES_CBC_CBC		952
+id_CA_DH_AES_CBC_CMAC_128		953
+id_CA_DH_AES_CBC_CMAC_192		954
+id_CA_DH_AES_CBC_CMAC_256		955
+id_CA_ECDH		956
+id_CA_ECDH_3DES_CBC_CBC		957
+id_CA_ECDH_AES_CBC_CMAC_128		958
+id_CA_ECDH_AES_CBC_CMAC_192		959
+id_CA_ECDH_AES_CBC_CMAC_256		960
+id_PACE_DH_GM		961
+id_PACE_DH_GM_3DES_CBC_CBC		962
+id_PACE_DH_GM_AES_CBC_CMAC_128		963
+id_PACE_DH_GM_AES_CBC_CMAC_192		964
+id_PACE_DH_GM_AES_CBC_CMAC_256		965
+id_PACE_ECDH_GM		966
+id_PACE_ECDH_GM_3DES_CBC_CBC		967
+id_PACE_ECDH_GM_AES_CBC_CMAC_128		968
+id_PACE_ECDH_GM_AES_CBC_CMAC_192		969
+id_PACE_ECDH_GM_AES_CBC_CMAC_256		970
+id_PACE_DH_IM		971
+id_PACE_DH_IM_3DES_CBC_CBC		972
+id_PACE_DH_IM_AES_CBC_CMAC_128		973
+id_PACE_DH_IM_AES_CBC_CMAC_192		974
+id_PACE_DH_IM_AES_CBC_CMAC_256		975
+id_PACE_ECDH_IM		976
+id_PACE_ECDH_IM_3DES_CBC_CBC		977
+id_PACE_ECDH_IM_AES_CBC_CMAC_128		978
+id_PACE_ECDH_IM_AES_CBC_CMAC_192		979
+id_PACE_ECDH_IM_AES_CBC_CMAC_256		980
+id_RI_DH		981
+id_RI_DH_SHA_1		982
+id_RI_DH_SHA_224		983
+id_RI_DH_SHA_256		984
+id_RI_DH_SHA_384		985
+id_RI_DH_SHA_512		986
+id_RI_ECDH		987
+id_RI_ECDH_SHA_1		988
+id_RI_ECDH_SHA_224		989
+id_RI_ECDH_SHA_256		990
+id_RI_ECDH_SHA_384		991
+id_RI_ECDH_SHA_512		992
+id_CI		993
+id_eIDSecurity		994
+id_PT		995
+ansi_x942		996
+dhpublicnumber		997
+cardInfoLocator		998
+eID		999
+ecka_dh_SessionKDF		1000
+ecka_dh_SessionKDF_DES3		1001
+ecka_dh_SessionKDF_AES128		1002
+ecka_dh_SessionKDF_AES192		1003
+ecka_dh_SessionKDF_AES256		1004
+id_IS		1005
+id_AT		1006
+id_ST		1007
+id_description		1008
+id_plainFormat		1009
+id_htmlFormat		1010
+id_pdfFormat		1011
+id_sector		1012
+id_SecurityObject		1013
+id_DateOfBirth		1014
+id_DateOfExpiry		1015
+id_CommunityID		1016
Index: openssl/crypto/objects/objects.txt
===================================================================
--- openssl.orig/crypto/objects/objects.txt	2012-04-04 22:45:10.173152755 +0200
+++ openssl/crypto/objects/objects.txt	2012-04-04 23:15:24.579305623 +0200
@@ -1309,4 +1309,118 @@
 1 3 36 3 3 2 8 1 1 11 : brainpoolP384r1
 1 3 36 3 3 2 8 1 1 12 : brainpoolP384t1
 1 3 36 3 3 2 8 1 1 13 : brainpoolP512r1
-1 3 36 3 3 2 8 1 1 14 : brainpoolP512t1            
+1 3 36 3 3 2 8 1 1 14 : brainpoolP512t1
+
+# BSI Extensions TR 3110 Version 2.01
+!Alias bsi-de           0 4 0 127 0 7
+bsi-de 1 2 :            standardizedDomainParameters
+
+!Alias id-PK            bsi-de 2 2 1
+id-PK 1 :               id-PK-DH
+id-PK 2 :               id-PK-ECDH
+
+bsi-de 2 2 2 :          id-TA
+id-TA 1 :               id-TA-RSA
+id-TA-RSA 1 :           id-TA-RSA-v1-5-SHA-1
+id-TA-RSA 2 :           id-TA-RSA-v1-5-SHA-256
+id-TA-RSA 3 :           id-TA-RSA-PSS-SHA-1
+id-TA-RSA 4 :           id-TA-RSA-PSS-SHA-256
+id-TA-RSA 5 :           id-TA-RSA-v1-5-SHA-512
+id-TA-RSA 6 :           id-TA-RSA-PSS-SHA-512
+id-TA 2 :               id-TA-ECDSA
+id-TA-ECDSA 1 :         id-TA-ECDSA-SHA-1
+id-TA-ECDSA 2 :         id-TA-ECDSA-SHA-224
+id-TA-ECDSA 3 :         id-TA-ECDSA-SHA-256
+id-TA-ECDSA 4 :         id-TA-ECDSA-SHA-384
+id-TA-ECDSA 5 :         id-TA-ECDSA-SHA-512
+
+!Alias id-CA            bsi-de 2 2 3
+id-CA 1 :               id-CA-DH
+id-CA-DH 1 :            id-CA-DH-3DES-CBC-CBC
+id-CA-DH 2 :            id-CA-DH-AES-CBC-CMAC-128
+id-CA-DH 3 :            id-CA-DH-AES-CBC-CMAC-192
+id-CA-DH 4 :            id-CA-DH-AES-CBC-CMAC-256
+id-CA 2 :               id-CA-ECDH
+id-CA-ECDH 1 :          id-CA-ECDH-3DES-CBC-CBC
+id-CA-ECDH 2 :          id-CA-ECDH-AES-CBC-CMAC-128
+id-CA-ECDH 3 :          id-CA-ECDH-AES-CBC-CMAC-192
+id-CA-ECDH 4 :          id-CA-ECDH-AES-CBC-CMAC-256
+
+!Alias id-PACE          bsi-de 2 2 4
+id-PACE 1 :             id-PACE-DH-GM
+id-PACE-DH-GM 1 :       id-PACE-DH-GM-3DES-CBC-CBC
+id-PACE-DH-GM 2 :       id-PACE-DH-GM-AES-CBC-CMAC-128
+id-PACE-DH-GM 3 :       id-PACE-DH-GM-AES-CBC-CMAC-192
+id-PACE-DH-GM 4 :       id-PACE-DH-GM-AES-CBC-CMAC-256
+id-PACE 2 :             id-PACE-ECDH-GM
+id-PACE-ECDH-GM 1 :     id-PACE-ECDH-GM-3DES-CBC-CBC
+id-PACE-ECDH-GM 2 :     id-PACE-ECDH-GM-AES-CBC-CMAC-128
+id-PACE-ECDH-GM 3 :     id-PACE-ECDH-GM-AES-CBC-CMAC-192
+id-PACE-ECDH-GM 4 :     id-PACE-ECDH-GM-AES-CBC-CMAC-256
+id-PACE 3 :             id-PACE-DH-IM
+id-PACE-DH-IM 1 :       id-PACE-DH-IM-3DES-CBC-CBC
+id-PACE-DH-IM 2 :       id-PACE-DH-IM-AES-CBC-CMAC-128
+id-PACE-DH-IM 3 :       id-PACE-DH-IM-AES-CBC-CMAC-192
+id-PACE-DH-IM 4 :       id-PACE-DH-IM-AES-CBC-CMAC-256
+id-PACE 4 :             id-PACE-ECDH-IM
+id-PACE-ECDH-IM 1 :     id-PACE-ECDH-IM-3DES-CBC-CBC
+id-PACE-ECDH-IM 2 :     id-PACE-ECDH-IM-AES-CBC-CMAC-128
+id-PACE-ECDH-IM 3 :     id-PACE-ECDH-IM-AES-CBC-CMAC-192
+id-PACE-ECDH-IM 4 :     id-PACE-ECDH-IM-AES-CBC-CMAC-256
+
+!Alias id-RI            bsi-de 2 2 5
+id-RI 1 :               id-RI-DH
+id-RI-DH 1 :            id-RI-DH-SHA-1
+id-RI-DH 2 :            id-RI-DH-SHA-224
+id-RI-DH 3 :            id-RI-DH-SHA-256
+id-RI-DH 4 :            id-RI-DH-SHA-384
+id-RI-DH 5 :            id-RI-DH-SHA-512
+id-RI 2 :               id-RI-ECDH
+id-RI-ECDH 1 :          id-RI-ECDH-SHA-1
+id-RI-ECDH 2 :          id-RI-ECDH-SHA-224
+id-RI-ECDH 3 :          id-RI-ECDH-SHA-256
+id-RI-ECDH 4 :          id-RI-ECDH-SHA-384
+id-RI-ECDH 5 :          id-RI-ECDH-SHA-512
+
+bsi-de 2 2 6 :          id-CI
+bsi-de 2 2 7 :          id-eIDSecurity
+bsi-de 2 2 8 :          id-PT
+
+ISO-US 10046 :          ansi-x942
+!Alias x942_number-type ansi-x942 2
+x942_number-type 1:     dhpublicnumber
+
+bsi-de 2 2 6 :          cardInfoLocator
+bsi-de 2 2 7 :          eID
+
+# BSI extensions TR-03111
+!Alias id-ecc   bsi-de 1 1
+!Alias ecka-dh  id-ecc 5 2
+ecka-dh 2 :          ecka-dh-SessionKDF
+ecka-dh 2 1 :        ecka-dh-SessionKDF-DES3
+ecka-dh 2 2 :        ecka-dh-SessionKDF-AES128
+ecka-dh 2 3 :        ecka-dh-SessionKDF-AES192
+ecka-dh 2 4 :        ecka-dh-SessionKDF-AES256
+
+# Role OIDs for CV certificates according to 03110
+!Alias id-roles bsi-de 3 1 2
+id-roles 1 :    id-IS
+id-roles 2 :    id-AT
+id-roles 3 :    id-ST
+
+# Description and extension OIDs from TR-03110
+!Alias id-extensions bsi-de 3 1 3
+id-extensions 1 :   id-description
+id-description 1 :  id-plainFormat
+id-description 2 :  id-htmlFormat
+id-description 3 :  id-pdfFormat
+id-extensions 2 :   id-sector
+
+!Alias id-eID bsi-de 3 2
+id-eID 1 :  id-SecurityObject
+
+#Auxiliary Data OIDS
+!Alias id-AuxiliaryData bsi-de 3 1 4
+id-AuxiliaryData 1 :    id-DateOfBirth
+id-AuxiliaryData 2 :    id-DateOfExpiry
+id-AuxiliaryData 3 :    id-CommunityID
Index: openssl/makevms.com
===================================================================
--- openssl.orig/makevms.com	2012-04-04 22:45:10.417275965 +0200
+++ openssl/makevms.com	2012-04-04 23:15:24.587305668 +0200
@@ -284,6 +284,7 @@
 		     MD5,-
 		     MDC2,-
 		     OCSP,-
+		     PACE,-
 		     PSK,-
 		     RC2,-
 		     RC4,-
@@ -712,7 +713,7 @@
    BUFFER, BIO, STACK, LHASH, RAND, ERR, -
    EVP, ASN1, PEM, X509, X509V3, CONF, TXT_DB, PKCS7, PKCS12, -
    COMP, OCSP, UI, KRB5, -
-   CMS, PQUEUE, TS, JPAKE, SRP, STORE, CMAC
+   CMS, PQUEUE, TS, JPAKE, SRP, STORE, CMAC, PACE
 $!
 $ EXHEADER_ := crypto.h, opensslv.h, ebcdic.h, symhacks.h, ossl_typ.h
 $ EXHEADER_'ARCHD' := opensslconf.h
@@ -768,6 +769,7 @@
 $ EXHEADER_PQUEUE := pqueue.h
 $ EXHEADER_TS := ts.h
 $ EXHEADER_JPAKE := jpake.h
+$ EXHEADER_PACE := pace.h, eac.h, ta.h, ca.h, ri.h, cv_cert.h
 $ EXHEADER_SRP := srp.h
 $!!! EXHEADER_STORE := store.h, str_compat.h
 $ EXHEADER_STORE := store.h
Index: openssl/test/Makefile
===================================================================
--- openssl.orig/test/Makefile	2012-04-04 22:45:10.057094185 +0200
+++ openssl/test/Makefile	2012-04-04 23:15:54.775455366 +0200
@@ -63,6 +63,8 @@
 JPAKETEST=	jpaketest
 SRPTEST=	srptest
 ASN1TEST=	asn1test
+EACTEST=	eactest
+CVCERTTEST= cv_cert_test
 
 TESTS=		alltests
 
@@ -74,7 +76,7 @@
 	$(RANDTEST)$(EXE_EXT) $(DHTEST)$(EXE_EXT) $(ENGINETEST)$(EXE_EXT) \
 	$(BFTEST)$(EXE_EXT) $(CASTTEST)$(EXE_EXT) $(SSLTEST)$(EXE_EXT) $(EXPTEST)$(EXE_EXT) $(DSATEST)$(EXE_EXT) $(RSATEST)$(EXE_EXT) \
 	$(EVPTEST)$(EXE_EXT) $(IGETEST)$(EXE_EXT) $(JPAKETEST)$(EXE_EXT) $(SRPTEST)$(EXE_EXT) \
-	$(ASN1TEST)$(EXE_EXT)
+	$(ASN1TEST)$(EXE_EXT) $(EACTEST)$(EXE_EXT) $(CVCERTTEST)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -94,7 +96,8 @@
 	$(DESTEST).c $(SHATEST).c $(SHA1TEST).c $(MDC2TEST).c $(RMDTEST).c \
 	$(RANDTEST).c $(DHTEST).c $(ENGINETEST).c $(CASTTEST).c \
 	$(BFTEST).c  $(SSLTEST).c $(DSATEST).c   $(EXPTEST).c $(RSATEST).c \
-	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c $(SRPTEST).c $(ASN1TEST).c
+	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c $(SRPTEST).c $(ASN1TEST).c \
+	$(EACTEST).c $(CVCERTTEST).c
 
 EXHEADER= 
 HEADER=	$(EXHEADER)
@@ -137,7 +140,7 @@
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_ssl test_tsa test_ige \
-	test_jpake test_srp test_cms
+	test_jpake test_srp test_cms test_eac test_cv_cert
 
 test_evp:
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
@@ -318,6 +321,14 @@
 	@echo "Test SRP"
 	../util/shlib_wrap.sh ./srptest
 
+test_eac:
+	@echo "EAC regression test"
+	../util/shlib_wrap.sh ./eactest
+
+test_cv_cert:
+	@echo "CV certificate parser regression test"
+	../util/shlib_wrap.sh ./cv_cert_test
+
 lint:
 	lint -DLINT $(INCLUDES) $(SRC)>fluff
 
@@ -469,6 +480,12 @@
 $(SRPTEST)$(EXE_EXT): $(SRPTEST).o $(DLIBCRYPTO)
 	@target=$(SRPTEST); $(BUILD_CMD)
 
+$(EACTEST)$(EXE_EXT): $(EACTEST).o $(DLIBCRYPTO)
+	@target=$(EACTEST); $(BUILD_CMD)
+
+$(CVCERTTEST)$(EXE_EXT): $(CVCERTTEST).o $(DLIBCRYPTO)
+	@target=$(CVCERTTEST); $(BUILD_CMD)
+
 #$(AESTEST).o: $(AESTEST).c
 #	$(CC) -c $(CFLAGS) -DINTERMEDIATE_VALUE_KAT -DTRACE_KAT_MCT $(AESTEST).c
 
@@ -514,6 +531,14 @@
 bntest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bntest.c
 casttest.o: ../e_os.h ../include/openssl/cast.h ../include/openssl/e_os2.h
 casttest.o: ../include/openssl/opensslconf.h casttest.c
+cv_cert_test.o: ../include/openssl/asn1.h ../include/openssl/asn1t.h
+cv_cert_test.o: ../include/openssl/bio.h ../include/openssl/crypto.h
+cv_cert_test.o: ../include/openssl/cv_cert.h ../include/openssl/e_os2.h
+cv_cert_test.o: ../include/openssl/err.h ../include/openssl/lhash.h
+cv_cert_test.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+cv_cert_test.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
+cv_cert_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+cv_cert_test.o: cv_cert_test.c
 destest.o: ../include/openssl/des.h ../include/openssl/des_old.h
 destest.o: ../include/openssl/e_os2.h ../include/openssl/opensslconf.h
 destest.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
@@ -534,16 +559,33 @@
 dsatest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
 dsatest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
 dsatest.o: ../include/openssl/symhacks.h dsatest.c
+eactest.o: ../include/openssl/asn1.h ../include/openssl/asn1t.h
+eactest.o: ../include/openssl/bio.h ../include/openssl/bn.h
+eactest.o: ../include/openssl/buffer.h ../include/openssl/ca.h
+eactest.o: ../include/openssl/cmac.h ../include/openssl/conf.h
+eactest.o: ../include/openssl/crypto.h ../include/openssl/cv_cert.h
+eactest.o: ../include/openssl/dh.h ../include/openssl/e_os2.h
+eactest.o: ../include/openssl/eac.h ../include/openssl/ec.h
+eactest.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+eactest.o: ../include/openssl/err.h ../include/openssl/evp.h
+eactest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+eactest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+eactest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+eactest.o: ../include/openssl/pace.h ../include/openssl/pkcs7.h
+eactest.o: ../include/openssl/ri.h ../include/openssl/safestack.h
+eactest.o: ../include/openssl/sha.h ../include/openssl/stack.h
+eactest.o: ../include/openssl/symhacks.h ../include/openssl/ta.h
+eactest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h eactest.c
 ecdhtest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ecdhtest.o: ../include/openssl/bn.h ../include/openssl/crypto.h
-ecdhtest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ecdhtest.o: ../include/openssl/ecdh.h ../include/openssl/err.h
-ecdhtest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ecdhtest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ecdhtest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ecdhtest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
-ecdhtest.o: ../include/openssl/sha.h ../include/openssl/stack.h
-ecdhtest.o: ../include/openssl/symhacks.h ecdhtest.c
+ecdhtest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ecdhtest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+ecdhtest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ecdhtest.o: ../include/openssl/err.h ../include/openssl/lhash.h
+ecdhtest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ecdhtest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ecdhtest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
+ecdhtest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ecdhtest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h ecdhtest.c
 ecdsatest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
 ecdsatest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 ecdsatest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
Index: openssl/test/maketests.com
===================================================================
--- openssl.orig/test/maketests.com	2012-04-04 22:45:10.057094185 +0200
+++ openssl/test/maketests.com	2012-04-04 23:15:24.571305587 +0200
@@ -147,7 +147,7 @@
 	       "RANDTEST,DHTEST,ENGINETEST,"+ -
 	       "BFTEST,CASTTEST,SSLTEST,EXPTEST,DSATEST,RSA_TEST,"+ -
 	       "EVP_TEST,IGETEST,JPAKETEST,SRPTEST,"+ -
-	       "ASN1TEST"
+	       "ASN1TEST, EACTEST, CVCERTTEST"
 $! Should we add MTTEST,PQ_TEST,LH_TEST,DIVTEST,TABTEST as well?
 $!
 $! Additional directory information.
@@ -185,6 +185,8 @@
 $ T_D_JPAKETEST  := [-.crypto.jpake]
 $ T_D_SRPTEST    := [-.crypto.srp]
 $ T_D_ASN1TEST   := [-.test]
+$ T_D_EACTEST    := [-.crypto.eac]
+$ T_D_CVCERTTEST := [-.crypto.eac]
 $!
 $ TCPIP_PROGRAMS = ",,"
 $ IF COMPILER .EQS. "VAXC" THEN -
Index: openssl/test/tests.com
===================================================================
--- openssl.orig/test/tests.com	2012-04-04 22:45:10.057094185 +0200
+++ openssl/test/tests.com	2012-04-04 23:15:24.571305587 +0200
@@ -56,7 +56,7 @@
 	test_enc,test_x509,test_rsa,test_crl,test_sid,-
 	test_gen,test_req,test_pkcs7,test_verify,test_dh,test_dsa,-
 	test_ss,test_ca,test_engine,test_evp,test_ssl,test_tsa,test_ige,-
-	test_jpake,test_srp,test_cms
+	test_jpake,test_srp,test_cms,test_eac,test_cv_cert
 $	endif
 $	tests = f$edit(tests,"COLLAPSE")
 $
@@ -68,8 +68,8 @@
 $	IDEATEST :=	ideatest
 $	SHATEST :=	shatest
 $	SHA1TEST :=	sha1test
-$	SHA256TEST :=	sha256t
-$	SHA512TEST :=	sha512t
+$	SHA256TEST :=	sha1test
+$	SHA512TEST :=	sha1test
 $	MDC2TEST :=	mdc2test
 $	RMDTEST :=	rmdtest
 $	MD2TEST :=	md2test
@@ -95,6 +95,8 @@
 $	JPAKETEST :=	jpaketest
 $	SRPTEST :=	srptest
 $	ASN1TEST :=	asn1test
+$	EACTEST :=	eactest
+$	CVCERTTEST :=	cv_cert_test
 $!
 $	tests_i = 0
 $ loop_tests:
@@ -226,6 +228,14 @@
 $	if (status)
 $	then
 $	    create /fdl = sys$input bntest-vms.tmp
+$ test_eac:
+$	write sys$output "Test EAC"
+$   mcr 'texe_dir' 'eactest'
+$   return
+$ test_cv_cert:
+$	write sys$output "Test CV Certificate parsing"
+$   mcr 'texe_dir' 'cv_cert_test'
+$   return
 FILE
 	ORGANIZATION	sequential
 RECORD
Index: openssl/util/libeay.num
===================================================================
--- openssl.orig/util/libeay.num	2012-04-04 22:45:10.409271931 +0200
+++ openssl/util/libeay.num	2012-04-04 23:22:15.189341732 +0200
@@ -4310,3 +4310,92 @@
 BIO_s_datagram_sctp                     4680	EXIST::FUNCTION:DGRAM,SCTP
 BIO_dgram_is_sctp                       4681	EXIST::FUNCTION:SCTP
 BIO_dgram_sctp_notification_cb          4682	EXIST::FUNCTION:SCTP
+PACE_STEP3B_generate_ephemeral_key      4683	EXIST::FUNCTION:
+d2i_CVC_CERTIFICATE_DESCRIPTION         4684	EXIST::FUNCTION:
+CVC_CERTIFICATE_DESCRIPTION_print_ctx   4685	EXIST::FUNCTION:
+EAC_hash_certificate_description        4686	EXIST::FUNCTION:
+ECDH_OpenSSL_Point                      4687	EXIST::FUNCTION:ECDH
+BUF_MEM_print                           4688	EXIST::FUNCTION:
+CVC_get_role                            4689	EXIST::FUNCTION:
+EAC_decrypt                             4690	EXIST::FUNCTION:
+CVC_CHAT_free                           4691	EXIST::FUNCTION:
+cvc_get_chat                            4692	EXIST::FUNCTION:
+CA_STEP5_derive_keys                    4693	EXIST::FUNCTION:
+CVC_CERT_new                            4694	EXIST::FUNCTION:
+CVC_CERTIFICATE_DESCRIPTION_it          4695	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+CVC_CERTIFICATE_DESCRIPTION_it          4695	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+PACE_STEP3A_generate_mapping_data       4696	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATES_it     4697	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+CVC_DISCRETIONARY_DATA_TEMPLATES_it     4697	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+TA_STEP6_verify                         4698	EXIST::FUNCTION:
+CA_STEP1_get_pubkey                     4699	EXIST::FUNCTION:
+i2d_CVC_CERT                            4700	EXIST::FUNCTION:
+EAC_CTX_init_ef_cardaccess              4701	EXIST::FUNCTION:
+PACE_STEP3C_derive_keys                 4702	EXIST::FUNCTION:
+EAC_CTX_init_pace                       4703	EXIST::FUNCTION:
+CA_STEP6_derive_keys                    4704	EXIST::FUNCTION:
+EAC_authenticate                        4705	EXIST::FUNCTION:
+TA_STEP5_sign                           4706	EXIST::FUNCTION:
+CA_STEP2_get_eph_pubkey                 4707	EXIST::FUNCTION:
+PACE_STEP3D_verify_authentication_token 4708	EXIST::FUNCTION:
+CVC_check_description                   4709	EXIST::FUNCTION:
+RI_STEP2_compute_identifier             4710	EXIST::FUNCTION:
+cvc_chat_print_authorizations           4711	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATE_it      4712	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+CVC_DISCRETIONARY_DATA_TEMPLATE_it      4712	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+TA_STEP2_import_certificate             4713	EXIST::FUNCTION:
+CVC_CHAT_new                            4714	EXIST::FUNCTION:
+BUF_MEM_create                          4715	EXIST::FUNCTION:
+EC_POINT_point2buf                      4716	EXIST::FUNCTION:EC
+d2i_CVC_DISCRETIONARY_DATA_TEMPLATES    4717	EXIST::FUNCTION:
+BUF_MEM_dup                             4718	EXIST::FUNCTION:
+EAC_encrypt                             4719	EXIST::FUNCTION:
+PACE_STEP3B_compute_shared_secret       4720	EXIST::FUNCTION:
+CA_STEP4_compute_shared_secret          4721	EXIST::FUNCTION:
+RI_CTX_set_protocol                     4722	EXIST::FUNCTION:
+EAC_CTX_clear_free                      4723	EXIST::FUNCTION:
+TA_STEP4_set_nonce                      4724	EXIST::FUNCTION:
+TA_STEP4_get_nonce                      4725	EXIST::FUNCTION:
+EAC_CTX_init_ca                         4726	EXIST::FUNCTION:
+certificate_description_print           4727	EXIST::FUNCTION:
+cvc_print                               4728	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATES_free   4729	EXIST::FUNCTION:
+d2i_CVC_CHAT                            4730	EXIST::FUNCTION:
+PACE_STEP3A_map_generator               4731	EXIST::FUNCTION:
+CVC_get_pubkey                          4732	EXIST::FUNCTION:
+CVC_d2i_CVC_CERT                        4733	EXIST::FUNCTION:
+EAC_CTX_print_private                   4734	EXIST::FUNCTION:
+cvc_chat_print                          4735	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATES_new    4736	EXIST::FUNCTION:
+CVC_CERTIFICATE_DESCRIPTION_free        4737	EXIST::FUNCTION:
+EAC_Comp                                4738	EXIST::FUNCTION:
+ERR_load_EAC_strings                    4739	EXIST::FUNCTION:
+PACE_STEP1_enc_nonce                    4740	EXIST::FUNCTION:
+RI_CTX_new                              4741	EXIST::FUNCTION:
+RI_CTX_clear_free                       4742	EXIST::FUNCTION:
+i2d_CVC_CERTIFICATE_DESCRIPTION         4743	EXIST::FUNCTION:
+CVC_CHAT_it                             4744	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+CVC_CHAT_it                             4744	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
+PACE_STEP2_dec_nonce                    4745	EXIST::FUNCTION:
+EAC_CTX_init_ri                         4746	EXIST::FUNCTION:
+i2d_CVC_DISCRETIONARY_DATA_TEMPLATE     4747	EXIST::FUNCTION:
+CVC_CERTIFICATE_DESCRIPTION_new         4748	EXIST::FUNCTION:
+EAC_CTX_new                             4749	EXIST::FUNCTION:
+TA_STEP3_generate_ephemeral_key         4750	EXIST::FUNCTION:
+PACE_SEC_new                            4751	EXIST::FUNCTION:
+i2d_CVC_CHAT                            4752	EXIST::FUNCTION:
+EAC_add_iso_pad                         4753	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATE_new     4754	EXIST::FUNCTION:
+EAC_CTX_init_ta                         4755	EXIST::FUNCTION:
+i2d_CVC_DISCRETIONARY_DATA_TEMPLATES    4756	EXIST::FUNCTION:
+PACE_SEC_clear_free                     4757	EXIST::FUNCTION:
+d2i_CVC_DISCRETIONARY_DATA_TEMPLATE     4758	EXIST::FUNCTION:
+CA_get_pubkey                           4759	EXIST::FUNCTION:
+BUF_MEM_create_init                     4760	EXIST::FUNCTION:
+EAC_CTX_set_encryption_ctx              4761	EXIST::FUNCTION:
+CVC_verify_signature                    4762	EXIST::FUNCTION:
+CVC_DISCRETIONARY_DATA_TEMPLATE_free    4763	EXIST::FUNCTION:
+CVC_CERT_free                           4764	EXIST::FUNCTION:
+PACE_STEP3D_compute_authentication_token 4765	EXIST::FUNCTION:
+BN_bn2buf                               4766	EXIST::FUNCTION:
+CA_STEP3_check_pcd_pubkey               4767	EXIST::FUNCTION:
Index: openssl/util/mk1mf.pl
===================================================================
--- openssl.orig/util/mk1mf.pl	2012-04-04 22:45:10.413273946 +0200
+++ openssl/util/mk1mf.pl	2012-04-04 23:15:24.571305587 +0200
@@ -283,6 +283,7 @@
 $cflags.=" -DOPENSSL_NO_EC2M"    if $no_ec2m;
 $cflags.= " -DZLIB" if $zlib_opt;
 $cflags.= " -DZLIB_SHARED" if $zlib_opt == 2;
+$cflags.= " -DOPENSSL_NO_PACE" if $no_pace;
 
 if ($no_static_engine)
 	{
@@ -785,6 +786,7 @@
 	return("") if $no_gost   && $dir =~ /\/ccgost/;
 	return("") if $no_cms  && $dir =~ /\/cms/;
 	return("") if $no_jpake  && $dir =~ /\/jpake/;
+    return("") if $no_pace && $dir =~ /\/eac/;
 	if ($no_des && $dir =~ /\/des/)
 		{
 		if ($val =~ /read_pwd/)
@@ -1121,7 +1123,8 @@
 		"no-cms" => \$no_cms,
 		"no-ec2m" => \$no_ec2m,
 		"no-jpake" => \$no_jpake,
-		"no-ec_nistp_64_gcc_128" => 0,
+		"no-pace" => \$no_pace,
+        "no-ec_nistp_64_gcc_128" => 0,
 		"no-err" => \$no_err,
 		"no-sock" => \$no_sock,
 		"no-krb5" => \$no_krb5,
Index: openssl/util/mkdef.pl
===================================================================
--- openssl.orig/util/mkdef.pl	2012-04-04 22:45:10.409271931 +0200
+++ openssl/util/mkdef.pl	2012-04-04 23:15:24.571305587 +0200
@@ -116,7 +116,9 @@
 			 # Hide SSL internals
 			 "SSL_INTERN",
 			 # SCTP
-			 "SCTP");
+			 "SCTP",
+             # EAC
+             "PACE");
 
 my $options="";
 open(IN,"<Makefile") || die "unable to open Makefile!\n";
@@ -136,7 +138,7 @@
 my $no_fp_api; my $no_static_engine=1; my $no_gmp; my $no_deprecated;
 my $no_rfc3779; my $no_psk; my $no_tlsext; my $no_cms; my $no_capieng;
 my $no_jpake; my $no_srp; my $no_ssl2; my $no_ec2m; my $no_nistp_gcc; 
-my $no_nextprotoneg; my $no_sctp;
+my $no_nextprotoneg; my $no_sctp; my $no_pace;
 
 my $fips;
 
@@ -235,6 +237,7 @@
 	elsif (/^no-jpake$/)	{ $no_jpake=1; }
 	elsif (/^no-srp$/)	{ $no_srp=1; }
 	elsif (/^no-sctp$/)	{ $no_sctp=1; }
+    elsif (/^no-pace$/) { $no_pace=1; }
 	}
 
 
@@ -341,6 +344,13 @@
 $crypto.=" crypto/modes/modes.h";
 $crypto.=" crypto/srp/srp.h";
 
+$crypto.=" crypto/eac/pace.h";
+$crypto.=" crypto/eac/cv_cert.h";
+$crypto.=" crypto/eac/eac.h";
+$crypto.=" crypto/eac/ta.h";
+$crypto.=" crypto/eac/ca.h";
+$crypto.=" crypto/eac/ri.h";
+
 my $symhacks="crypto/symhacks.h";
 
 my @ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
Index: openssl/util/mkfiles.pl
===================================================================
--- openssl.orig/util/mkfiles.pl	2012-04-04 22:45:10.413273946 +0200
+++ openssl/util/mkfiles.pl	2012-04-04 23:15:24.567305567 +0200
@@ -64,6 +64,7 @@
 "crypto/whrlpool",
 "crypto/ts",
 "crypto/srp",
+"crypto/eac",
 "ssl",
 "apps",
 "engines",
Index: openssl/test/cvca-eid.cv
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and openssl/test/cvca-eid.cv	2012-04-04 22:45:09.460793219 +0200 differ
