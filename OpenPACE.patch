Index: openssl/Configure
===================================================================
--- openssl.orig/Configure
+++ openssl/Configure
@@ -668,6 +668,7 @@ my %disabled = ( # "what"         => "co
                  "jpake"          => "experimental",
                  "md2"            => "default",
                  "rc5"            => "default",
+                 "pace"		  => "experimental",
 		 "rfc3779"	  => "default",
                  "shared"         => "default",
 		 "store"	  => "experimental",
Index: openssl/Makefile.org
===================================================================
--- openssl.orig/Makefile.org
+++ openssl/Makefile.org
@@ -122,7 +122,7 @@ SDIRS=  \
 	cmac \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts jpake store
+	cms pqueue ts jpake store pace
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
Index: openssl/crypto/ecdh/ecdh.h
===================================================================
--- openssl.orig/crypto/ecdh/ecdh.h
+++ openssl/crypto/ecdh/ecdh.h
@@ -86,6 +86,7 @@ extern "C" {
 #endif
 
 const ECDH_METHOD *ECDH_OpenSSL(void);
+const ECDH_METHOD *ECDH_OpenSSL_Point(void);
 
 void	  ECDH_set_default_method(const ECDH_METHOD *);
 const ECDH_METHOD *ECDH_get_default_method(void);
Index: openssl/crypto/ecdh/ech_ossl.c
===================================================================
--- openssl.orig/crypto/ecdh/ech_ossl.c
+++ openssl/crypto/ecdh/ech_ossl.c
@@ -211,3 +211,113 @@ err:
 	if (buf) OPENSSL_free(buf);
 	return(ret);
 	}
+
+static int ecdh_compute_key_point(void *out, size_t len, const EC_POINT *pub_key,
+	EC_KEY *ecdh,
+	void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen));
+
+static ECDH_METHOD openssl_ecdh_meth_point = {
+	"OpenSSL ECDH method with Point",
+	ecdh_compute_key_point,
+#if 0
+	NULL, /* init     */
+	NULL, /* finish   */
+#endif
+	0,    /* flags    */
+	NULL  /* app_data */
+};
+
+const ECDH_METHOD *ECDH_OpenSSL_Point(void)
+	{
+	return &openssl_ecdh_meth_point;
+	}
+/* This implementation calculates the point as in ecdh_compute_key.
+ * Finally an optional KDF is applied to the point rather than to the x-coordinate as done in ecdh_compute_key.
+ */
+int ecdh_compute_key_point(void *out, size_t outlen, const EC_POINT *pub_key,
+	EC_KEY *ecdh,
+	void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))
+	{
+	BN_CTX *ctx;
+	EC_POINT *tmp=NULL;
+	const BIGNUM *priv_key;
+	const EC_GROUP* group;
+	int ret= -1;
+	size_t buflen;
+	unsigned char *buf=NULL;
+
+	if (outlen > INT_MAX)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE); /* sort of, anyway */
+		return -1;
+		}
+
+	if ((ctx = BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+
+	priv_key = EC_KEY_get0_private_key(ecdh);
+	if (priv_key == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_NO_PRIVATE_VALUE);
+		goto err;
+		}
+
+	group = EC_KEY_get0_group(ecdh);
+	if ((tmp=EC_POINT_new(group)) == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if (!EC_POINT_mul(group, tmp, NULL, pub_key, priv_key, ctx))
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_POINT_ARITHMETIC_FAILURE);
+		goto err;
+		}
+
+
+        buflen = EC_POINT_point2oct(group, tmp,
+                EC_KEY_get_conv_form(ecdh), NULL, 0, ctx);
+        if (buflen < 0)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_BN_LIB);
+		goto err;
+		}
+	if ((buf = OPENSSL_malloc(buflen)) == NULL)
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+        if (buflen != EC_POINT_point2oct(group, tmp,
+                    EC_KEY_get_conv_form(ecdh), buf, buflen, ctx))
+		{
+		ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_BN_LIB);
+		goto err;
+		}
+
+	if (KDF != 0)
+		{
+		if (KDF(buf, buflen, out, &outlen) == NULL)
+			{
+			ECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_KDF_FAILED);
+			goto err;
+			}
+		ret = outlen;
+		}
+	else
+		{
+		/* no KDF, just copy as much as we can */
+		if (outlen > buflen)
+			outlen = buflen;
+		memcpy(out, buf, outlen);
+		ret = outlen;
+		}
+
+err:
+	if (tmp) EC_POINT_free(tmp);
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+	if (buf) OPENSSL_free(buf);
+	return(ret);
+	}
Index: openssl/crypto/err/err.c
===================================================================
--- openssl.orig/crypto/err/err.c
+++ openssl/crypto/err/err.c
@@ -156,6 +156,7 @@ static ERR_STRING_DATA ERR_str_libraries
 {ERR_PACK(ERR_LIB_FIPS,0,0)		,"FIPS routines"},
 {ERR_PACK(ERR_LIB_CMS,0,0)		,"CMS routines"},
 {ERR_PACK(ERR_LIB_HMAC,0,0)		,"HMAC routines"},
+{ERR_PACK(ERR_LIB_PACE,0,0)             ,"PACE routines"},
 {0,NULL},
 	};
 
Index: openssl/crypto/err/err.h
===================================================================
--- openssl.orig/crypto/err/err.h
+++ openssl/crypto/err/err.h
@@ -198,6 +198,7 @@ typedef struct err_state_st
 #define ERR_LIB_TS		47
 #define ERR_LIB_HMAC		48
 #define ERR_LIB_JPAKE		49
+#define ERR_LIB_PACE		50
 
 #define ERR_LIB_USER		128
 
@@ -234,6 +235,7 @@ typedef struct err_state_st
 #define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)
 #define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)
 #define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)
+#define PACEerr(f,r) ERR_PUT_error(ERR_LIB_PACE,(f),(r),__FILE__,__LINE__)
 
 /* Borland C seems too stupid to be able to shift and do longs in
  * the pre-processor :-( */
Index: openssl/crypto/err/err_all.c
===================================================================
--- openssl.orig/crypto/err/err_all.c
+++ openssl/crypto/err/err_all.c
@@ -102,6 +102,9 @@
 #ifndef OPENSSL_NO_JPAKE
 #include <openssl/jpake.h>
 #endif
+#ifndef OPENSSL_NO_PACE
+#include <openssl/pace.h>
+#endif
 #include <openssl/comp.h>
 
 void ERR_load_crypto_strings(void)
@@ -155,6 +158,9 @@ void ERR_load_crypto_strings(void)
 #ifndef OPENSSL_NO_JPAKE
 	ERR_load_JPAKE_strings();
 #endif
+#ifndef OPENSSL_NO_PACE
+	ERR_load_PACE_strings();
+#endif
 	ERR_load_COMP_strings();
 #endif
 	}
Index: openssl/crypto/err/openssl.ec
===================================================================
--- openssl.orig/crypto/err/openssl.ec
+++ openssl/crypto/err/openssl.ec
@@ -35,6 +35,7 @@ L TS		crypto/ts/ts.h			crypto/ts/ts_err.
 L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
 L CMS		crypto/cms/cms.h		crypto/cms/cms_err.c
 L JPAKE		crypto/jpake/jpake.h		crypto/jpake/jpake_err.c
+L PACE		crypto/pace/pace.h		crypto/pace/pace_err.c
 
 # additional header files to be scanned for function names
 L NONE		crypto/x509/x509_vfy.h		NONE
Index: openssl/crypto/objects/objects.txt
===================================================================
--- openssl.orig/crypto/objects/objects.txt
+++ openssl/crypto/objects/objects.txt
@@ -1276,3 +1276,31 @@ kisa 1 6                : SEED-OFB
 1 3 36 3 3 2 8 1 1 12 : brainpoolP384t1
 1 3 36 3 3 2 8 1 1 13 : brainpoolP512r1
 1 3 36 3 3 2 8 1 1 14 : brainpoolP512t1
+
+# BSI Extensions TR 3110 Version 2.01
+!Alias bsi-de           0 4 0 127 0 7
+!Alias id-PACE          bsi-de  2 2 4
+id-PACE 1 :             id-PACE-DH-GM
+id-PACE-DH-GM 1 :       id-PACE-DH-GM-3DES-CBC-CBC
+id-PACE-DH-GM 2 :       id-PACE-DH-GM-AES-CBC-CMAC-128
+id-PACE-DH-GM 3 :       id-PACE-DH-GM-AES-CBC-CMAC-192
+id-PACE-DH-GM 4 :       id-PACE-DH-GM-AES-CBC-CMAC-256
+id-PACE 2 :             id-PACE-ECDH-GM
+id-PACE-ECDH-GM 1 :     id-PACE-ECDH-GM-3DES-CBC-CBC
+id-PACE-ECDH-GM 2 :     id-PACE-ECDH-GM-AES-CBC-CMAC-128
+id-PACE-ECDH-GM 3 :     id-PACE-ECDH-GM-AES-CBC-CMAC-192
+id-PACE-ECDH-GM 4 :     id-PACE-ECDH-GM-AES-CBC-CMAC-256
+id-PACE 3 :             id-PACE-DH-IM
+id-PACE-DH-IM 1 :       id-PACE-DH-IM-3DES-CBC-CBC
+id-PACE-DH-IM 2 :       id-PACE-DH-IM-AES-CBC-CMAC-128
+id-PACE-DH-IM 3 :       id-PACE-DH-IM-AES-CBC-CMAC-192
+id-PACE-DH-IM 4 :       id-PACE-DH-IM-AES-CBC-CMAC-256
+id-PACE 4 :             id-PACE-ECDH-IM
+id-PACE-ECDH-IM 1 :     id-PACE-ECDH-IM-3DES-CBC-CBC
+id-PACE-ECDH-IM 2 :     id-PACE-ECDH-IM-AES-CBC-CMAC-128
+id-PACE-ECDH-IM 3 :     id-PACE-ECDH-IM-AES-CBC-CMAC-192
+id-PACE-ECDH-IM 4 :     id-PACE-ECDH-IM-AES-CBC-CMAC-256
+
+ISO-US 10046 :          ansi-x942
+!Alias x942_number-type ansi-x942 2
+x942_number-type 1:     dhpublicnumber
Index: openssl/crypto/pace/Makefile
===================================================================
--- /dev/null
+++ openssl/crypto/pace/Makefile
@@ -0,0 +1,153 @@
+DIR=pace
+TOP=../..
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+LIB=$(TOP)/libcrypto.a
+LIBOBJ=pace_err.o pace_lib.o pace_util.o pace.o pace_buffer.o pace_dh.o pace_kdf.o pace_ecdh.o pace_mappings.o#pace_ka.o
+LIBSRC=pace_err.c pace_lib.c pace_util.c pace.c pace_buffer.c pace_dh.c pace_kdf.c pace_ecdh.c pace_mappings.c#pace_ka.c
+
+EXHEADER=pace.h
+TEST=pacetest.c
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj des lib tags core .pure .nfs* *.old *.bak fluff
+
+pacetest: top pace.h pacetest.c $(LIB)
+	$(CC) $(CFLAGS) -Wall -Werror -g -o pacetest pacetest.c $(LIB)
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+pace.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h pace.c
+pace.o: pace_buffer.h pace_dh.h pace_ecdh.h pace_kdf.h pace_mappings.h
+pace.o: pace_util.h
+pace_buffer.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_buffer.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+pace_buffer.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_buffer.o: ../../include/openssl/opensslconf.h
+pace_buffer.o: ../../include/openssl/opensslv.h
+pace_buffer.o: ../../include/openssl/ossl_typ.h
+pace_buffer.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+pace_buffer.o: ../../include/openssl/symhacks.h pace_buffer.c pace_buffer.h
+pace_dh.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_dh.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_dh.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_dh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_dh.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_dh.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+pace_dh.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+pace_dh.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+pace_dh.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+pace_dh.o: ../../include/openssl/symhacks.h pace_buffer.h pace_dh.c pace_dh.h
+pace_ecdh.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_ecdh.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_ecdh.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_ecdh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_ecdh.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_ecdh.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_ecdh.o: ../../include/openssl/opensslconf.h
+pace_ecdh.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_ecdh.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_ecdh.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_ecdh.o: pace_buffer.h pace_ecdh.c pace_ecdh.h
+pace_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_err.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_err.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_err.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_err.o: ../../include/openssl/ecdh.h ../../include/openssl/err.h
+pace_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+pace_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_err.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_err.o: pace_err.c
+pace_kdf.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_kdf.o: ../../include/openssl/buffer.h ../../include/openssl/cmac.h
+pace_kdf.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_kdf.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_kdf.o: ../../include/openssl/ecdh.h ../../include/openssl/evp.h
+pace_kdf.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_kdf.o: ../../include/openssl/opensslconf.h
+pace_kdf.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_kdf.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_kdf.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_kdf.o: pace_kdf.c pace_kdf.h pace_util.h
+pace_lib.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_lib.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_lib.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_lib.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_lib.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_lib.o: ../../include/openssl/evp.h ../../include/openssl/obj_mac.h
+pace_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+pace_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_lib.o: ../../include/openssl/pace.h ../../include/openssl/safestack.h
+pace_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_lib.o: pace_lib.c
+pace_mappings.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_mappings.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_mappings.o: ../../include/openssl/cmac.h ../../include/openssl/crypto.h
+pace_mappings.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+pace_mappings.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+pace_mappings.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+pace_mappings.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+pace_mappings.o: ../../include/openssl/objects.h
+pace_mappings.o: ../../include/openssl/opensslconf.h
+pace_mappings.o: ../../include/openssl/opensslv.h
+pace_mappings.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pace.h
+pace_mappings.o: ../../include/openssl/safestack.h
+pace_mappings.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+pace_mappings.o: pace_dh.h pace_ecdh.h pace_mappings.c pace_mappings.h
+pace_mappings.o: pace_util.h
+pace_util.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+pace_util.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+pace_util.o: ../../include/openssl/cmac.h ../../include/openssl/conf.h
+pace_util.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+pace_util.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+pace_util.o: ../../include/openssl/ecdh.h ../../include/openssl/err.h
+pace_util.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+pace_util.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+pace_util.o: ../../include/openssl/opensslconf.h
+pace_util.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+pace_util.o: ../../include/openssl/pace.h ../../include/openssl/rand.h
+pace_util.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+pace_util.o: ../../include/openssl/symhacks.h pace_buffer.h pace_dh.h
+pace_util.o: pace_util.c pace_util.h
Index: openssl/crypto/pace/pace.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace.c
@@ -0,0 +1,521 @@
+/**
+ * @file pace.c
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ * @author Wolf Mueller  <Wolf.Mueller@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include <openssl/bn.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include "pace_util.h"
+#include "pace_buffer.h"
+#include "pace_dh.h"
+#include "pace_ecdh.h"
+#include "pace_kdf.h"
+#include "pace_mappings.h"
+
+int
+PACE_init(PACE_CTX * ctx, PACEDomainParameterInfo * dp, PACEInfo info)
+{
+    EVP_MD_CTX *md_ctx = NULL;
+    EVP_CIPHER_CTX *cipher_ctx = NULL;
+    BN_CTX *bn_ctx = NULL;
+    CMAC_CTX *cmac_ctx = NULL;
+
+    if (!ctx || !dp)
+        return 0;
+
+    ctx->iv = NULL;
+    switch (info.protocol) {
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede();
+            break;
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+            if (!init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede();
+            break;
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede();
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_generate_key;
+            ctx->map_compute_key = dh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_dh(&dp->domainParameter->parameters.dh))
+                goto err;
+            ctx->map_generate_key = dh_im_generate_key;
+            ctx->map_compute_key = dh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_gm_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_256_cbc();
+            break;
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha256();
+            ctx->cipher = EVP_aes_192_cbc();
+            break;
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            cmac_ctx = CMAC_CTX_new();
+            if (!cmac_ctx || !init_ecdh(
+                    &dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_aes_128_cbc();
+            break;
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            if (!init_ecdh(&dp->domainParameter->parameters.ecdh))
+                goto err;
+            ctx->map_generate_key = ecdh_generate_key;
+            ctx->map_compute_key = ecdh_im_compute_key;
+            ctx->md = EVP_sha1();
+            ctx->cipher = EVP_des_ede();
+            break;
+        default:
+            goto err;
+    }
+
+    if (!ctx->md_ctx) {
+        md_ctx = EVP_MD_CTX_create();
+        if (!md_ctx)
+            goto err;
+    }
+    if (!ctx->cipher_ctx) {
+        cipher_ctx = EVP_CIPHER_CTX_new();
+        if (!cipher_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(cipher_ctx);
+        if (!EVP_CipherInit_ex(cipher_ctx, ctx->cipher,
+                    ctx->cipher_engine, ctx->iv, NULL, -1))
+            goto err;
+    }
+    if (!ctx->bn_ctx) {
+        bn_ctx = BN_CTX_new();
+        if (!bn_ctx)
+            goto err;
+    }
+
+    if (md_ctx)
+        ctx->md_ctx = md_ctx;
+    if (cipher_ctx)
+        ctx->cipher_ctx = cipher_ctx;
+    if (bn_ctx)
+        ctx->bn_ctx = bn_ctx;
+    if (cmac_ctx)
+        ctx->cmac_ctx = cmac_ctx;
+
+    return 1;
+
+err:
+    if (md_ctx)
+        EVP_MD_CTX_destroy(md_ctx);
+    if (cipher_ctx)
+        EVP_CIPHER_CTX_cleanup(cipher_ctx);
+    if (bn_ctx)
+        BN_CTX_free(bn_ctx);
+    if (cmac_ctx)
+        ctx->cmac_ctx = cmac_ctx;
+
+    return 0;
+}
+
+int
+PACE_STEP1_enc_nonce(const PACE_SEC * pi, const PACE_CTX * ctx,
+        BUF_MEM ** nonce, BUF_MEM ** enc_nonce)
+{
+    BUF_MEM * key = NULL;
+
+    if (!ctx || !nonce || !enc_nonce)
+        goto err;
+
+    key = kdf_pi(pi, NULL, ctx->md, NULL, NULL);
+    if (!key)
+        goto err;
+
+    *nonce = randb(EVP_CIPHER_block_size(ctx->cipher));
+    if (!*nonce)
+        goto err;
+
+    *enc_nonce = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *) key->data, ctx->iv, 1, *nonce, 1);
+    if (!*enc_nonce)
+        goto err;
+
+    return 1;
+
+err:
+    if (key)
+        OPENSSL_free(key);
+    if (*nonce)
+        BUF_MEM_free(*nonce);
+    if (*enc_nonce)
+        BUF_MEM_free(*enc_nonce);
+
+    return 0;
+}
+
+BUF_MEM *
+PACE_STEP2_dec_nonce(const PACE_SEC * pi, const BUF_MEM * enc_nonce,
+        const PACE_CTX * ctx)
+{
+    BUF_MEM * nonce = NULL, * key = NULL;
+
+    if (!ctx)
+        goto err;
+
+    key = kdf_pi(pi, NULL, ctx->md, NULL, NULL);
+    if (!key)
+        goto err;
+
+    nonce = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *) key->data, ctx->iv, 0, enc_nonce, 1);
+
+err:
+    if (key)
+        BUF_MEM_free(key);
+
+    return nonce;
+}
+
+BUF_MEM *
+PACE_STEP3A_map_generate_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx)
+{
+    if (!ctx)
+        return NULL;
+
+    return ctx->map_generate_key(dp, ctx);
+}
+
+PACEDomainParameterInfo *
+PACE_STEP3A_map_compute_key(const PACEDomainParameterInfo * dp_in,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out;
+
+    if (!ctx)
+        return NULL;
+
+    out = ctx->map_compute_key(dp_in, ctx, s, in);
+
+    return out;
+}
+
+BUF_MEM *
+PACE_STEP3B_dh_generate_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx)
+{
+    if (!dp || !dp->domainParameter || !ctx)
+        return NULL;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            return dh_generate_key(dp, ctx);
+        case NID_X9_62_id_ecPublicKey:
+            return ecdh_generate_key(dp, ctx);
+        default:
+            return NULL;
+    }
+}
+
+BUF_MEM *
+PACE_STEP3B_dh_compute_key(const PACEDomainParameterInfo * dp,
+        const PACE_CTX * ctx, const BUF_MEM * in)
+{
+    BUF_MEM *out = NULL;
+
+    if (!dp || !dp->domainParameter || !ctx || !in)
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            out = dh_compute_key(dp, ctx, in);
+            break;
+        case NID_X9_62_id_ecPublicKey:
+            out = ecdh_compute_key(dp, ctx, in);
+            break;
+        default:
+            goto err;
+    }
+    if (!out)
+        goto err;
+
+    /* Check if the new public key is different from the other party's public
+     * key */
+    if ((in->length == out->length)
+            && (memcmp(in->data, out->data, out->length) == 0)) {
+        PACEerr(PACE_F_PACE_STEP3B_PROCESS, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+        goto err;
+    }
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+int
+PACE_STEP3C_derive_keys(const BUF_MEM * key, PACE_CTX * ctx, BUF_MEM ** k_mac,
+        BUF_MEM ** k_enc)
+{
+    if (!ctx)
+        goto err;
+
+    *k_mac = kdf_mac(key, NULL, ctx->md, ctx->md_ctx, ctx->md_engine);
+    *k_enc = kdf_enc(key, NULL, ctx->md, ctx->md_ctx, ctx->md_engine);
+    if (!*k_mac || !*k_enc)
+        goto err;
+
+    return 1;
+
+err:
+    if (*k_mac)
+        BUF_MEM_free(*k_mac);
+    if (*k_enc)
+        BUF_MEM_free(*k_enc);
+
+    return 0;
+}
+
+BUF_MEM *
+PACE_STEP3D_compute_authentication_token(PACE_CTX * ctx,
+        PACEDomainParameterInfo * dp, PACEInfo info, BUF_MEM * pub,
+        BUF_MEM * key, const uint16_t ssc)
+{
+    BUF_MEM *asn1 = NULL, *ssc_asn1 = NULL, *out;
+
+    asn1 = asn1_pubkey(ctx->bn_ctx, dp);
+    ssc_asn1 = encoded_ssc(ssc, ctx);
+    if (!asn1 || !ssc_asn1 || !ctx ||
+            !BUF_MEM_grow(ssc_asn1, ssc_asn1->length + asn1->length))
+        goto err;
+    /* BUF_MEM_grow already sets ssc_asn1->length */
+    memcpy(ssc_asn1->data + ssc_asn1->length - asn1->length, asn1->data,
+            asn1->length);
+
+    switch (info.protocol) {
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            out = retail_mac_des(key, ssc_asn1);
+            break;
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            out = cmac(ctx->cmac_ctx, ctx->cipher, key, ssc_asn1,
+                    PACE_AES_MAC_LENGTH);
+            break;
+        default:
+            goto err;
+    }
+
+    BUF_MEM_free(ssc_asn1);
+    BUF_MEM_free(asn1);
+
+    return out;
+
+err:
+    if (ssc_asn1)
+        BUF_MEM_free(ssc_asn1);
+    if (asn1)
+        BUF_MEM_free(asn1);
+
+    return NULL;
+}
+
+int
+PACE_STEP3D_verify_authentication_token(PACE_CTX * ctx,
+        PACEDomainParameterInfo * dp, PACEInfo info, BUF_MEM * pub,
+        BUF_MEM * key, BUF_MEM * token, const uint16_t ssc)
+{
+    PACEDomainParameterInfo *dp_opp = NULL;
+    BUF_MEM *token_verify = NULL, *pub_opp = NULL;
+    EC_POINT *ecp = NULL;
+    int rv = -1;
+
+    if (!dp || !dp->domainParameter || !token)
+        goto err;
+
+    dp_opp = PACEDomainParameterInfo_dup(dp);
+    if (!dp_opp)
+        goto err;
+
+    switch (dp->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            if (!dp->domainParameter->parameters.dh)
+                goto err;
+
+            dp_opp->domainParameter->parameters.dh->pub_key = BN_bin2bn(
+                    (unsigned char *) pub->data, pub->length,
+                    dp_opp->domainParameter->parameters.dh->pub_key);
+
+            pub_opp = bn2buf(dp->domainParameter->parameters.dh->pub_key);
+            break;
+
+        case NID_X9_62_id_ecPublicKey:
+            if (!dp->domainParameter->parameters.ecdh)
+                goto err;
+
+            ecp = EC_POINT_new(EC_KEY_get0_group(
+                    dp_opp->domainParameter->parameters.ecdh));
+            if (!ecp || !EC_POINT_oct2point(EC_KEY_get0_group(
+                    dp_opp->domainParameter->parameters.ecdh), ecp,
+                    (unsigned char *) pub->data, pub->length, ctx->bn_ctx)
+                    || !EC_KEY_set_public_key(
+                            dp_opp->domainParameter->parameters.ecdh, ecp))
+                goto err;
+
+            pub_opp = point2buf(dp->domainParameter->parameters.ecdh,
+                    ctx->bn_ctx, EC_KEY_get0_public_key(
+                            dp->domainParameter->parameters.ecdh));
+            break;
+
+        default:
+            goto err;
+    }
+
+    token_verify = PACE_STEP3D_compute_authentication_token(ctx, dp_opp, info,
+            pub_opp, key, ssc);
+    if (!token_verify)
+        goto err;
+
+
+    if ((token_verify->length != token->length) ||
+            (memcmp(token_verify->data, token->data, token->length) == 0))
+        rv = 1;
+    else
+        rv = 0;
+
+err:
+    if (ecp)
+        EC_POINT_free(ecp);
+    if (token_verify)
+        BUF_MEM_free(token_verify);
+    if (pub_opp)
+        BUF_MEM_free(pub_opp);
+    if (dp_opp)
+        PACEDomainParameterInfo_clear_free(dp_opp);
+
+    return rv;
+}
Index: openssl/crypto/pace/pace.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace.h
@@ -0,0 +1,383 @@
+/**
+ * @mainpage OpenPACE
+ * Implements the Password Authenticated Connection Establishment
+ * (PACE) protocol, as specified in BSI TR-03110 version 2.0.
+ *
+ * PACE is a protocol used to establish strong session keys based
+ * on a weak shared secret (password). The result of a PACE run
+ * are two symmetric keys, one for MAC computation and one for
+ * encryption. It was specfied for Extended Access Control (EAC)
+ * in Machine Readable Travel Documents (MRTD), but can also be
+ * used for securing any other communication channel.
+ *
+ * PACE can be used with different suites of algorithms and is not
+ * subject to any patents.
+ *
+ * @date 2009-04-29
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_H_
+#define PACE_H_
+
+#include <arpa/inet.h>
+#include <openssl/dh.h>
+#include <openssl/ecdh.h>
+#include <openssl/cmac.h>
+#include <openssl/buffer.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup types                 Data Types
+ * @{ ************************************************************************/
+
+/** Enum for the type of the secret used. */
+enum s_type {
+    /** MRZ is the Machine Readable Zone, printed on the card, encoding
+     * the personal information of the user */
+    PACE_MRZ = 1,
+    /** CAN is the Card access number printed on the card */
+    PACE_CAN,
+    /** PIN is the Personal Identification Number, a secret known only
+     * to the user and not printed on the card */
+    PACE_PIN,
+    /** PUK is the Personal Unblocking key. This type of secret is used
+     * when the card is suspended due to too many incorrect PACE runs */
+    PACE_PUK,
+    /** This type of secret is not defined in BSI TR-03110. We use it as
+     * a generic type, so we can use PACE independent from a ID card */
+    PACE_RAW,
+    /** Undefined type, if nothing else matches */
+    PACE_SEC_UNDEF,
+};
+/** Shared secret */
+typedef struct pace_sec {
+    /** The type of the secret */
+    enum s_type type;
+    /** The secret itself */
+    BUF_MEM * mem;
+} PACE_SEC;
+
+typedef struct algorithmidentifier {
+    /** NID to identify the algorithms to be used */
+    int algorithm;
+    /** Depending on algorithm either a DH object or a EC_KEY object. */
+    union {
+        /** Classic Diffie-Hellman parameters */
+        DH * dh;
+        /** Elliptic curve Diffie-Hellman parameters */
+        EC_KEY * ecdh;
+    } parameters;
+} AlgorithmIdentifier;
+
+typedef struct paceinfo {
+	/** NID to identify the exact protocol to be used, including methods for
+	 *  key agreement, mapping of domain parameters, encryption and integrity
+	 *  protection */
+	int protocol;
+	/** Version of the protocol, MUST be 1 or 2 */
+	int version;
+	/** Used to indicate the local domain parameter identifier */
+	int parameterId;
+} PACEInfo;
+
+typedef struct pacedomainparameterinfo {
+	/** NID to identify the type of domain parameters */
+	int protocol;
+	/** Structure that contains the actual domain parameters */
+	AlgorithmIdentifier  * domainParameter;
+	/** Used to indicate the local domain parameter identifier */
+	int parameterId;
+} PACEDomainParameterInfo;
+
+/** AES message authentication: CMAC of 8 bytes length */
+#define PACE_AES_MAC_LENGTH 8
+
+/** Context structure used in all protocol steps. Encompasses information
+ * about cipher, message digest, key agreement scheme, mapping method. */
+typedef struct pace_ctx {
+    /** BN_CTX object for various operations */
+    BN_CTX * bn_ctx;
+    /** Which hash function to use for Key Derivation */
+    const EVP_MD * md;
+    /** BN_CTX object for md */
+    EVP_MD_CTX * md_ctx;
+    /** ENGINE object for md */
+    ENGINE * md_engine;
+    /** CMAC_CTX object for cmac */
+    CMAC_CTX * cmac_ctx;
+    /** EVP_CIPHER object to use for encryption/decryption */
+    const EVP_CIPHER * cipher;
+    /** EVP_CIPHER_CTX object for cipher */
+    EVP_CIPHER_CTX * cipher_ctx;
+    /** ENGINE object for cipher */
+    ENGINE * cipher_engine;
+    /** Initialisation vector for encryption/decryption */
+    unsigned char * iv;
+    /** Points to the implementation of a specific mapping
+     * @see PACE_STEP3A_map_generate_key() */
+    BUF_MEM * (*map_generate_key)(const PACEDomainParameterInfo * dp,
+            const struct pace_ctx * ctx);
+    /** Points to the implementation of a specific mapping
+     * @see PACE_STEP3A_map_compute_key() */
+    PACEDomainParameterInfo * (*map_compute_key)(const PACEDomainParameterInfo * dp_in,
+            const struct pace_ctx * ctx, const BUF_MEM * s,
+            const BUF_MEM * in);
+} PACE_CTX;
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup manage              Data Managment
+ * @{ ************************************************************************/
+
+/**
+ * @brief Frees a AlgorithmIdentifier object and all of its components
+ *
+ * @param dp Object to free (optional)
+ */
+void AlgorithmIdentifier_clear_free(AlgorithmIdentifier * dp);
+/**
+ * @brief Creates a new AlgorithmIdentifier object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+AlgorithmIdentifier * AlgorithmIdentifier_new(void);
+/**
+ * @brief Duplicates a AlgorithmIdentifier object without preserving private keys
+ *
+ * @param dp_in Object to duplicate
+ *
+ * @return Duplicate of dp_in without private and public keys or NULL if an
+ * error occurred
+ */
+AlgorithmIdentifier * AlgorithmIdentifier_dup(const AlgorithmIdentifier * dp_in);
+/**
+ * @brief Frees a PACE_SEC object and all its of components
+ *
+ * @param s Object to free (optional)
+ */
+void PACE_SEC_clear_free(PACE_SEC * s);
+/**
+ * @brief Creates a new PACE_SEC object and initializes it with a secret
+ * @param sec Secret
+ * @param sec_len Length of secret in bytes
+ * @param type Type of secret
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type);
+/**
+ * @brief Frees a PACE_CTX object
+ *
+ * @param s Object to free (optional)
+ */
+void PACE_CTX_free(PACE_CTX * s);
+/**
+ * @brief Frees a PACE_CTX object and all its components
+ *
+ * @param s Object to free (optional)
+ */
+void PACE_CTX_clear_free(PACE_CTX * s);
+/**
+ * @brief Creates a new PACE_CTX object
+ *
+ * @return The new object or NULL if an error occurred
+ */
+PACE_CTX * PACE_CTX_new(void);
+/**
+ * @brief Frees a PACEDomainParameterInfo object
+ *
+ * @param dp Object to free (optional)
+ */
+void
+PACEDomainParameterInfo_free(PACEDomainParameterInfo * dp);
+/**
+ * @brief Frees a PACEDomainParameterInfo object and all its components
+ *
+ * @param dp Object to free (optional)
+ */
+void PACEDomainParameterInfo_clear_free(PACEDomainParameterInfo * dp);
+ /**
+  * @brief Creates a new PACEDomainParameterInfo object
+  *
+  * @return Pointer to the new object or NULL on error
+  */
+PACEDomainParameterInfo * PACEDomainParameterInfo_new(void);
+/**
+ * @brief Duplicates a PACEDomainParameterInfo structure
+ *
+ * @param dp_in PACEDomainParameterInfo structure to duplicate (optional)
+ * @return Pointer to the duplicated structure or NULL on error
+ */
+PACEDomainParameterInfo * PACEDomainParameterInfo_dup(const
+		PACEDomainParameterInfo * dp_in);
+/**
+ * @brief Initializes PACE_CTX/AlgorithmIdentifier objects
+ *
+ * @param ctx Object to initialize
+ * @param dp_info PaceDomainParameterInfo, which specifies the key agreement
+ * scheme and the domain parameters to use. See TR-3110 A.1.1.1
+ * @param info PACEInfo onject, which specifies cipher, message digest, key
+ * agreement scheme, mapping method and MAC method. See TR-3110 A.1.1.1
+ *
+ * @return 1 on success and 0 if an error occurred
+ */
+int PACE_init(PACE_CTX * ctx, PACEDomainParameterInfo * dp_info, PACEInfo info);
+/** @} ***********************************************************************/
+
+/**
+ * @defgroup proto               Protocol Steps
+ * @{ ************************************************************************/
+
+/**
+ * @brief Generates and encrypts a nonce.
+ *
+ * @param pi        Shared secret for key derivation (see kdf_pi())
+ * @param ctx       PACE_CTX object
+ * @param nonce     Where to save the new object containing the nonce
+ * @param enc_nonce Where to save the new object containing the encrypted nonce
+ *
+ * @return          1 on success and 0 if an error occurred
+ */
+int PACE_STEP1_enc_nonce(const PACE_SEC * pi, const PACE_CTX * ctx,
+        BUF_MEM ** nonce, BUF_MEM ** enc_nonce);
+/**
+ * @brief Decrypt the Nonce from the other party.
+ *
+ * @param pi PACE secret used to derive the symmetric key
+ * @param enc_nonce Encrypted nonce
+ * @param ctx Context structure that contains information about encryption and
+ * hash algorithms to use
+ *
+ * @return Plaintext nonce or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP2_dec_nonce(const PACE_SEC * pi,
+        const BUF_MEM * enc_nonce, const PACE_CTX * ctx);
+/**
+ * @brief Generate a public keypair to perform the mapping to new domain
+ * parameters
+ *
+ * @param dp Domain parameters
+ * @param ctx PACE_CTX object
+ *
+ * @return Buffer to be transmitted to the other party or NULL if an error
+ * occurred
+ */
+BUF_MEM *
+PACE_STEP3A_map_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Get the ephemeral domain parameters.
+ *
+ * Compute the shared secret from our own private key and the other
+ * parties public key. Then map the static domain parameters to new,
+ * ephemeral ones.
+ *
+ * @param dp_in Static domain parameters
+ * @param ctx
+ * @param s Nonce used for computing the ephemeral domain parameters
+ * @param in Public key from the other party
+ *
+ * @return Ephemeral domain parameters or NULL if an error occurred
+ */
+PACEDomainParameterInfo * PACE_STEP3A_map_compute_key(const PACEDomainParameterInfo * dp_in,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Generate a keypair for key agreement
+ *
+ * @param dp Ephemeral domain parameters (generated in step 3A)
+ * @param ctx PACE_CTX object
+ *
+ * @return Public key or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP3B_dh_generate_key(const PACEDomainParameterInfo * dp,
+		const PACE_CTX * ctx);
+/**
+ * @brief Compute the shared secret
+ *
+ * @param dp Ephemeral domain parameters (generated in step 3A)
+ * @param ctx PACE_CTX object
+ * @param in Public key from the other party
+ *
+ * @return Shared secret or NULL if an error occurred
+ */
+BUF_MEM * PACE_STEP3B_dh_compute_key(const PACEDomainParameterInfo * dp,
+		const PACE_CTX * ctx, const BUF_MEM * in);
+/**
+ * @brief Derives encryption and authentication keys
+ *
+ * @param key Shared secret (computed in step 3B)
+ * @param ctx PACE_CTX object
+ * @param k_mac Where to store the authentication key
+ * @param k_enc Where to store the encryption key
+ *
+ * @return          1 on success and 0 if an error occurred
+ */
+int PACE_STEP3C_derive_keys(const BUF_MEM * key, PACE_CTX * ctx,
+        BUF_MEM ** k_mac, BUF_MEM ** k_enc);
+/**
+ * @brief Compute the authentication token from domain parameters
+ *           and public key
+ *
+ * @param ctx PACE_CTX object
+ * @param dp Ephemeral domain parameters (generated in step 3A)
+ * @param info PACEInfo containing information about the MAC to be used
+ * @param pub Public key from the other party (generated in step 3B)
+ * @param key Authentication key (computed in step 3C)
+ * @param ssc Send sequence counter (Formatted in big endian)
+ *
+ * @return Authentication token or NULL in case of error
+ */
+BUF_MEM * PACE_STEP3D_compute_authentication_token(PACE_CTX * ctx,
+		PACEDomainParameterInfo * dp, PACEInfo info, BUF_MEM * pub, BUF_MEM * key,
+		const uint16_t ssc);
+/**
+ * @brief Verifies an authentication token.
+ *
+ * @param ctx PACE_CTX object
+ * @param dp Ephemeral domain parameters (generated in step 3A)
+ * @param pub Public key from the other party (generated in step 3B)
+ * @param key Authentication key (computed in step 3C)
+ * @param token Authentication token from the other party
+ * @param ssc Send sequence counter (Formatted in big endian)
+ *
+ * @return 1 if the token has been verified as correct, 0 if not, -1 if an error
+ * occurred.
+ */
+int PACE_STEP3D_verify_authentication_token(PACE_CTX * ctx,
+		PACEDomainParameterInfo * dp, PACEInfo info, BUF_MEM * pub, BUF_MEM * key,
+		BUF_MEM * token, const uint16_t ssc);
+/** @} ***********************************************************************/
+
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_PACE_strings(void);
+
+/* Error codes for the PACE functions. */
+
+/* Function codes. */
+#define PACE_F_ASN1_PUBKEY				 100
+#define PACE_F_DH_GET_ORDER				 101
+#define PACE_F_DH_GET_SG_PRIME				 102
+#define PACE_F_DH_GM_COMPUTE_KEY			 103
+#define PACE_F_ECDH_INTEGRATED_MAPPING			 104
+#define PACE_F_INIT_DH					 105
+#define PACE_F_PACE_STEP3B_PROCESS			 106
+
+/* Reason codes. */
+#define PACE_R_BAD_DH_OR_ECKEY_OBJECT			 100
+#define PACE_R_BAD_FORMAT				 101
+#define PACE_R_UNABLE_TO_GET_ORDER			 102
+#define PACE_R_UNABLE_TO_GET_SG_PRIME			 103
+#define PACE_R_UNSUITED_CURVE				 104
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
Index: openssl/crypto/pace/pace_buffer.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_buffer.c
@@ -0,0 +1,103 @@
+/**
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include "pace_buffer.h"
+
+BUF_MEM *
+BUF_MEM_create(size_t len)
+{
+    BUF_MEM *out = BUF_MEM_new();
+    if (!out)
+        return NULL;
+
+    if (!BUF_MEM_grow(out, len)) {
+        BUF_MEM_free(out);
+        return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len)
+{
+    BUF_MEM *out;
+
+    if (!buf)
+        return NULL;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    memcpy(out->data, buf, len);
+
+    return out;
+}
+
+BUF_MEM *
+point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp)
+{
+    size_t len;
+    BUF_MEM * out;
+
+    len = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), NULL, 0, bn_ctx);
+    if (len == 0)
+        return NULL;
+
+    out = BUF_MEM_create(len);
+    if (!out)
+        return NULL;
+
+    out->length = EC_POINT_point2oct(EC_KEY_get0_group(ecdh), ecp,
+            EC_KEY_get_conv_form(ecdh), (unsigned char *) out->data, out->max,
+            bn_ctx);
+
+    return out;
+}
+
+BUF_MEM *
+bn2buf(const BIGNUM *bn)
+{
+    BUF_MEM * out;
+
+    if (!bn)
+        return NULL;
+
+    out = BUF_MEM_create(BN_num_bytes(bn));
+    if (!out)
+        return NULL;
+
+    out->length = BN_bn2bin(bn, (unsigned char *) out->data);
+
+    return out;
+}
+
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+
+    if (!in)
+        return NULL;
+
+    out = BUF_MEM_create(in->length);
+    if (!out)
+        goto err;
+
+    memcpy(out->data, in->data, in->length);
+    out->max = in->max;
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_buffer.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_buffer.h
@@ -0,0 +1,63 @@
+/**
+ * @date 2009-11-30
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_BUFFER_H_
+#define PACE_BUFFER_H_
+
+#include <openssl/buffer.h>
+#include <openssl/ec.h>
+
+/**
+ * @brief Creates a BUF_MEM object
+ *
+ * @param len required length of the buffer
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create(size_t len);
+/**
+ * @brief Creates and initializes a BUF_MEM object
+ *
+ * @param buf Initial data
+ * @param len Length of buf
+ *
+ * @return Initialized BUF_MEM object or NULL if an error occurred
+ */
+BUF_MEM *
+BUF_MEM_create_init(const void *buf, size_t len);
+/**
+ * @brief converts an EC_POINT object to a BUF_MEM object
+ *
+ * @param ecdh EC_KEY object
+ * @param bn_ctx object (optional)
+ * @param ecp elliptic curve point to convert
+ *
+ * @return converted elliptic curve point or NULL if an error occurred
+ */
+BUF_MEM *
+point2buf(const EC_KEY * ecdh, BN_CTX * bn_ctx, const EC_POINT * ecp);
+/**
+ * @brief converts an BIGNUM object to a BUF_MEM object
+ *
+ * @param bn bignumber to convert
+ *
+ * @return converted bignumber or NULL if an error occurred
+ */
+BUF_MEM *
+bn2buf(const BIGNUM *bn);
+/**
+ * @brief duplicates a BUF_MEM structure
+ *
+ * @param in BUF_MEM to duplicate
+ *
+ * @return pointer to the new BUF_MEM or NULL in case of error
+ */
+BUF_MEM *
+BUF_MEM_dup(const BUF_MEM * in);
+
+#endif /*PACE_BUFFER_H_*/
\ No newline at end of file
Index: openssl/crypto/pace/pace_dh.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_dh.c
@@ -0,0 +1,210 @@
+/**
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/err.h>
+#include <openssl/pace.h>
+#include "pace_dh.h"
+#include "pace_buffer.h"
+
+int
+init_dh(DH ** dh)
+{
+    int i;
+    DH * tmp = NULL;
+
+    if (!*dh) {
+        tmp = DH_new();
+        if(!tmp || !DH_generate_parameters_ex(tmp, 64, DH_GENERATOR_5, NULL))
+            goto err;
+    } else
+    	tmp = *dh;
+
+    if (!DH_check(tmp, &i) || i) {
+        if (i)
+            PACEerr(PACE_F_INIT_DH, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+        goto err;
+    }
+
+    if (!*dh)
+    	*dh = tmp;
+
+    return 1;
+
+err:
+    if (!*dh && tmp)
+        DH_free(tmp);
+
+    return 0;
+}
+
+int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret)
+{
+    BIGNUM *bn = NULL;
+    int ok = 0;
+
+    if (!dh)
+        goto err;
+
+    /* Verify that y lies within the interval [2,p-1]. */
+    if (!DH_check_pub_key(dh, dh->pub_key, ret))
+        goto err;
+
+    /* If the DH is conform to RFC 2631 it should have a non-NULL q.
+     * Others (like the DHs generated from OpenSSL) might have a problem with
+     * this check. */
+    if (dh->q) {
+        /* Compute y^q mod p. If the result == 1, the key is valid. */
+        bn = BN_new();
+        if (!bn || !BN_mod_exp(bn, dh->pub_key, dh->q, dh->p, ctx))
+            goto err;
+        if (!BN_is_one(bn))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
+    }
+    ok = 1;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+
+    return ok;
+}
+
+
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *q = NULL, *bn = NULL;
+    int i;
+
+    if (!dh->q) {
+        q = BN_new();
+        bn = BN_dup(dh->p);
+        /* DH primes should be strong, based on a Sophie Germain prime q
+         * p=(2*q)+1 or (p-1)/2=q */
+        if (!q || !bn ||
+                !BN_sub_word(bn, 1) ||
+                !BN_rshift1(q, bn)) {
+            goto err;
+        }
+    } else {
+        q = BN_dup(dh->q);
+    }
+
+    /* q should always be prime */
+    i = BN_is_prime(q, BN_prime_checks, NULL, ctx, NULL);
+    if (i <= 0) {
+        if (i == 0)
+            PACEerr(PACE_F_DH_GET_SG_PRIME, PACE_R_UNABLE_TO_GET_SG_PRIME);
+        goto err;
+    }
+
+    return q;
+
+err:
+    if (bn)
+        BN_clear_free(bn);
+    if (q)
+        BN_clear_free(q);
+
+    return NULL;
+}
+
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx)
+{
+    BIGNUM *order = NULL, *bn = NULL;
+
+    if (!dh)
+        goto err;
+
+    /* suppose the order of g is q-1 */
+    order = DH_get_q(dh, ctx);
+    bn = BN_new();
+    if (!bn || !order || !BN_sub_word(order, 1) ||
+            !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+        goto err;
+
+    if (BN_cmp(bn, BN_value_one()) != 0) {
+        /* if bn != 1, then q-1 is not the order of g, but p-1 should be */
+        if (!BN_sub(order, dh->p, BN_value_one()) ||
+                !BN_mod_exp(bn, dh->g, order, dh->p, ctx))
+            goto err;
+        if (BN_cmp(bn, BN_value_one()) != 0) {
+            PACEerr(PACE_F_DH_GET_ORDER, PACE_R_UNABLE_TO_GET_ORDER);
+            goto err;
+        }
+    }
+
+    BN_clear_free(bn);
+
+    return order;
+
+err:
+    if (order)
+        BN_clear_free(order);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
+
+BUF_MEM *
+dh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    int ret;
+
+    if (!dp || !dp->domainParameter || !ctx ||
+            !DH_generate_key(dp->domainParameter->parameters.dh) ||
+            !DH_check_pub_key_rfc(dp->domainParameter->parameters.dh,
+                    ctx->bn_ctx, &ret))
+        return NULL;
+
+    if (ret) {
+        PACEerr(PACE_F_DH_GM_COMPUTE_KEY, PACE_R_BAD_DH_OR_ECKEY_OBJECT);
+        return NULL;
+    }
+
+    return bn2buf(dp->domainParameter->parameters.dh->pub_key);
+}
+
+BUF_MEM *
+dh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    BIGNUM * bn = NULL;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.dh ||
+            !ctx || !in)
+        goto err;
+
+    /* decode public key */
+    bn = BN_bin2bn((unsigned char *) in->data, in->length, bn);
+    if (!bn)
+        goto err;
+
+    out = BUF_MEM_create(DH_size(dp->domainParameter->parameters.dh));
+    if (!out)
+        goto err;
+
+    out->length = DH_compute_key((unsigned char *) out->data, bn,
+            dp->domainParameter->parameters.dh);
+    if (out->length < 0)
+        goto err;
+
+    BN_clear_free(bn);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
+
Index: openssl/crypto/pace/pace_dh.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_dh.h
@@ -0,0 +1,91 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_DH_H_
+#define PACE_DH_H_
+
+#include <openssl/bn.h>
+#include <openssl/dh.h>
+#include <openssl/buffer.h>
+
+/**
+ * @brief initializes a DH key structure. If the structure is already initialised,
+ * nothing is done
+ *
+ * @param dh DH object to use
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_dh(DH ** dh);
+/**
+ * @brief Computes the prime on which the modulus is based.
+ *
+ * If DH->q does not exist, tries to guess a Sophie Germain prime matching the
+ * DH's modulus.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object
+ *
+ * @return q or NULL if an error occurred
+ */
+BIGNUM *
+DH_get_q(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Computes the order of the DH's generator.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object (optional)
+ *
+ * @return order of g or NULL if an error occurred
+ *
+ * @note This calculation is for DHs using a safe prime, which will generate
+ * either an order-q or an order-2q group (see crypto/dh/dh_gen.c:151).
+ */
+BIGNUM *
+DH_get_order(const DH *dh, BN_CTX *ctx);
+/**
+ * @brief Public key validation method described in RFC 2631.
+ *
+ * Verify that DH->pub_key lies within the interval [2,p-1]. If it does not,
+ * the key is invalid.
+ * If DH->q exists, compute y^q mod p. If the result == 1, the key is valid.
+ * Otherwise the key is invalid.
+ *
+ * @param dh DH object to use
+ * @param ctx BN_CTX object
+ * @param ret Can contain these flags as result:
+ * DH_CHECK_PUBKEY_TOO_SMALL (smaller than 2)
+ * DH_CHECK_PUBKEY_TOO_LARGE (bigger than p-1)
+ * DH_CHECK_PUBKEY_INVALID (y^q mod p != 1)
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+DH_check_pub_key_rfc(const DH *dh, BN_CTX *ctx, int *ret);
+#define DH_CHECK_PUBKEY_INVALID		0x04
+
+/**
+ * @brief Generates a DH keypair
+ *
+ * @param dp object containing the DH object
+ * @param ctx
+ *
+ * @return public key of the generated keypair or NULL if an error occurred
+ */
+BUF_MEM *
+dh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes a DH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+dh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+		const BUF_MEM * in);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/pace/pace_ecdh.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_ecdh.c
@@ -0,0 +1,160 @@
+/**
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/objects.h>
+#include "pace_ecdh.h"
+#include "pace_buffer.h"
+
+int
+init_ecdh(EC_KEY ** ecdh)
+{
+    EC_KEY * tmp = NULL;
+
+    if (!*ecdh) {
+        /* Use default curve */
+        tmp = EC_KEY_new_by_curve_name(NID_brainpoolP256r1);
+        if (!tmp)
+            goto err;
+    }
+
+    if (!*ecdh)
+        *ecdh = tmp;
+    return 1;
+
+err:
+    if (!*ecdh && tmp)
+        EC_KEY_free(tmp);
+    return 0;
+}
+
+BUF_MEM *
+ecdh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    if (!dp || !ctx || !dp->domainParameter
+            || !dp->domainParameter->parameters.ecdh)
+        return NULL;
+    if (!EC_KEY_generate_key(dp->domainParameter->parameters.ecdh))
+        return NULL;
+
+    /* The key agreement algorithm ECKA prevents small subgroup attacks by
+     * using compatible cofactor multiplication. */
+
+    return point2buf(dp->domainParameter->parameters.ecdh, ctx->bn_ctx,
+            EC_KEY_get0_public_key(dp->domainParameter->parameters.ecdh));
+}
+
+BUF_MEM *
+ecdh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EC_POINT * ecp = NULL;
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !in)
+        goto err;
+    /* decode public key */
+    ecp = EC_POINT_new(EC_KEY_get0_group(dp->domainParameter->parameters.ecdh));
+    if (!ecp || !EC_POINT_oct2point(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), ecp,
+            (unsigned char *) in->data, in->length, ctx->bn_ctx))
+        goto err;
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(EC_POINT_point2oct(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), ecp, EC_KEY_get_conv_form(
+            dp->domainParameter->parameters.ecdh), NULL, 0, ctx->bn_ctx));
+    if (!out)
+        goto err;
+    /* copy data and set length */
+    out->length = ECDH_compute_key(out->data, out->max, ecp,
+            dp->domainParameter->parameters.ecdh, NULL);
+
+    EC_POINT_free(ecp);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (ecp)
+        EC_POINT_free(ecp);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+dp_ecdh_new_generator(const PACEDomainParameterInfo *template,
+        const EC_POINT *g, BN_CTX *ctx)
+{
+    BIGNUM *order = NULL, *cofactor = NULL;
+    PACEDomainParameterInfo * out = NULL;
+    EC_GROUP *group = NULL;
+    if (!template || !template->domainParameter
+            || !template->domainParameter->parameters.ecdh)
+        goto err;
+
+    order = BN_new();
+    cofactor = BN_new();
+    if (!order || !cofactor || !EC_GROUP_get_order(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh), order, ctx)
+            || !EC_GROUP_get_cofactor(EC_KEY_get0_group(
+                    template->domainParameter->parameters.ecdh), cofactor, ctx))
+        goto err;
+
+    group = EC_GROUP_dup(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh));
+    out = PACEDomainParameterInfo_dup(template);
+    if (!group || !out || !EC_POINT_is_on_curve(group, g, ctx)
+            || !EC_GROUP_set_generator(group, g, order, cofactor)
+            || !EC_GROUP_check(group, ctx) || !EC_KEY_set_group(
+            out->domainParameter->parameters.ecdh, group))
+        goto err;
+
+    BN_clear_free(cofactor);
+    BN_clear_free(order);
+    EC_GROUP_clear_free(group);
+
+    return out;
+
+err:
+    if (group)
+        EC_GROUP_clear_free(group);
+    if (cofactor)
+        BN_clear_free(cofactor);
+    if (order)
+        BN_clear_free(order);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+dp_ecdh_new_generator_by_coordinates(const PACEDomainParameterInfo *template,
+        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
+{
+    EC_POINT *g;
+    PACEDomainParameterInfo *out;
+    if (!template || !template->domainParameter
+            || !template->domainParameter->parameters.ecdh)
+        return NULL;
+
+    g = EC_POINT_new(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh));
+    if (!g)
+        return NULL;
+    if (!EC_POINT_set_affine_coordinates_GFp(EC_KEY_get0_group(
+            template->domainParameter->parameters.ecdh), g, x, y, ctx)) {
+        EC_POINT_free(g);
+        return NULL;
+    }
+
+    out = dp_ecdh_new_generator(template, g, ctx);
+
+    EC_POINT_free(g);
+
+    return out;
+}
Index: openssl/crypto/pace/pace_ecdh.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_ecdh.h
@@ -0,0 +1,76 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_ECDH_H_
+#define PACE_ECDH_H_
+
+#include <openssl/ec.h>
+#include <openssl/pace.h>
+#include <openssl/buffer.h>
+#include <openssl/bn.h>
+/**
+ * @brief initializes a key for ECDH. If the object is already initialised,
+ * nothing is don
+ *
+ * @param ecdh elliptic curve object to use
+ *
+ * @return 1 on success or 0 if an error occurred
+ */
+int
+init_ecdh(EC_KEY ** ecdh);
+/**
+ * @brief Generates an ECDH keypair
+ *
+ * @param dp object containing the EC_KEY object
+ * @param ctx
+ *
+ * @return public key of the generated keypair or NULL if an error occurred
+ */
+BUF_MEM *
+ecdh_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes an ECDH key
+ *
+ * @see PACE_STEP3B_dh_compute_key()
+ */
+BUF_MEM *
+ecdh_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+		const BUF_MEM * in);
+
+/**
+ * @brief creates a duplicate of template and changes the generator of its
+ * EC_KEY object
+ *
+ * @param template
+ * @param g the generator to use
+ * @param ctx (optional)
+ *
+ * @return the new and modified PACEDomainParameterInfo object or NULL if an
+ * error occurred
+ */
+PACEDomainParameterInfo *
+dp_ecdh_new_generator(const PACEDomainParameterInfo *template, const EC_POINT *g,
+		BN_CTX *ctx);
+/**
+ * @brief creates a duplicate of template and changes the generator of its
+ * EC_KEY object
+ *
+ * @param template
+ * @param x affine coordinate of the generator
+ * @param y affine coordinate of the generator
+ * @param ctx (optional)
+ *
+ * @return the new and modified PACEDomainParameterInfo object or NULL if an
+ * error occurred
+ *
+ * @see dp_ecdh_new_generator()
+ */
+PACEDomainParameterInfo *
+dp_ecdh_new_generator_by_coordinates(const PACEDomainParameterInfo *template,
+		const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);
+
+#endif /*PACE_ECDH_H_*/
Index: openssl/crypto/pace/pace_err.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_err.c
@@ -0,0 +1,105 @@
+/* crypto/pace/pace_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2009 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/pace.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_PACE,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_PACE,0,reason)
+
+static ERR_STRING_DATA PACE_str_functs[]=
+	{
+{ERR_FUNC(PACE_F_ASN1_PUBKEY),	"ASN1_PUBKEY"},
+{ERR_FUNC(PACE_F_DH_GET_ORDER),	"DH_GET_ORDER"},
+{ERR_FUNC(PACE_F_DH_GET_SG_PRIME),	"DH_GET_SG_PRIME"},
+{ERR_FUNC(PACE_F_DH_GM_COMPUTE_KEY),	"DH_GM_COMPUTE_KEY"},
+{ERR_FUNC(PACE_F_ECDH_INTEGRATED_MAPPING),	"ECDH_INTEGRATED_MAPPING"},
+{ERR_FUNC(PACE_F_INIT_DH),	"INIT_DH"},
+{ERR_FUNC(PACE_F_PACE_STEP3B_PROCESS),	"PACE_STEP3B_PROCESS"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA PACE_str_reasons[]=
+	{
+{ERR_REASON(PACE_R_BAD_DH_OR_ECKEY_OBJECT),"bad dh or eckey object"},
+{ERR_REASON(PACE_R_BAD_FORMAT)           ,"bad format"},
+{ERR_REASON(PACE_R_UNABLE_TO_GET_ORDER)  ,"unable to get order"},
+{ERR_REASON(PACE_R_UNABLE_TO_GET_SG_PRIME),"unable to get sg prime"},
+{ERR_REASON(PACE_R_UNSUITED_CURVE)       ,"unsuited curve"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_PACE_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(PACE_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,PACE_str_functs);
+		ERR_load_strings(0,PACE_str_reasons);
+		}
+#endif
+	}
Index: openssl/crypto/pace/pace_kdf.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_kdf.c
@@ -0,0 +1,74 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include "pace_kdf.h"
+#include "pace_util.h"
+
+BUF_MEM *
+kdf(const BUF_MEM * key, const BUF_MEM * nonce, const uint32_t counter,
+        const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl)
+{
+    int inlen;
+    BUF_MEM * in = NULL, *out = NULL;
+
+    if (!key)
+        goto err;
+
+    in = BUF_MEM_new();
+    if (!in)
+        goto err;
+
+    /* Concatenate secret || nonce || counter
+     * nonce is optional */
+    if (nonce) {
+        inlen = key->length + nonce->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        memcpy(in->data, key->data, key->length);
+        memcpy(in->data + key->length, nonce->data, nonce->length);
+        memcpy(in->data + key->length + nonce->length, &counter, sizeof counter);
+    } else {
+        inlen = key->length + sizeof counter;
+        if (!BUF_MEM_grow(in, inlen))
+            goto err;
+        memcpy(in->data, key->data, key->length);
+        memcpy(in->data + key->length, &counter, sizeof counter);
+    }
+
+    out = hash(md, ctx, impl, in);
+    if (!out)
+        goto err;
+
+    BUF_MEM_free(in);
+
+    return out;
+
+err:
+    if (in)
+        BUF_MEM_free(in);
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+kdf_pi(const PACE_SEC * pi, const BUF_MEM * nonce, const EVP_MD * md,
+        EVP_MD_CTX * ctx, ENGINE * impl)
+{
+    BUF_MEM * out;
+    BUF_MEM * enc = encoded_secret(pi);
+    if (!enc)
+        return NULL;
+
+    out = kdf(enc, nonce, htonl(KDF_PI_COUNTER), md, ctx, impl);
+
+    BUF_MEM_free(enc);
+
+    return out;
+}
Index: openssl/crypto/pace/pace_kdf.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_kdf.h
@@ -0,0 +1,61 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_KDF_H_
+#define PACE_KDF_H_
+
+#include <arpa/inet.h>
+#include <openssl/buffer.h>
+#include <openssl/pace.h>
+#include <openssl/evp.h>
+
+/**
+ * @defgroup kdf            Key Derivation Functions
+ * @{ ************************************************************************/
+
+/**
+ * @brief General key derivation function according to TR-3110 F.3.1
+ *
+ * @param key Shared secret
+ * @param nonce (optional)
+ * @param counter Formatted in big endian
+ * @param md Message digest to use
+ * @param ctx EVP_MD_CTX object to use (optional)
+ * @param impl ENGINE object to use for message digest (optional)
+ *
+ * @return derivated key or NULL if an error occurred
+ */
+BUF_MEM * kdf(const BUF_MEM * key, const BUF_MEM * nonce,
+        const uint32_t counter, const EVP_MD * md, EVP_MD_CTX * ctx,
+        ENGINE * impl);
+#define KDF_ENC_COUNTER 1
+#define KDF_MAC_COUNTER 2
+#define KDF_PI_COUNTER  3
+/**
+ * @brief Key derivation function to derive encryption key
+ *
+ * @see kdf()
+ */
+#define kdf_enc(key, nonce, md, ctx, impl) \
+    kdf(key, nonce, htonl(KDF_ENC_COUNTER), md, ctx, impl)
+/**
+ * @brief Key derivation function to derive authentication key
+ *
+ * @see kdf()
+ */
+#define kdf_mac(key, nonce, md, ctx, impl) \
+    kdf(key, nonce, htonl(KDF_MAC_COUNTER), md, ctx, impl)
+/**
+ * @brief Key derivation function from a password pi
+ *
+ * @see kdf()
+ */
+BUF_MEM * kdf_pi(const PACE_SEC * pi, const BUF_MEM * nonce,
+        const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl);
+/** @} ***********************************************************************/
+
+#endif /*PACE_KDF_H_*/
Index: openssl/crypto/pace/pace_lib.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_lib.c
@@ -0,0 +1,234 @@
+/**
+ * @date 2009-11-30
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/bn.h>
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/pace.h>
+#include "pace_buffer.h"
+
+void
+AlgorithmIdentifier_clear_free(AlgorithmIdentifier * dp)
+{
+    if (dp) {
+        switch (dp->algorithm) {
+            case NID_dhpublicnumber:
+                if (dp->parameters.dh)
+                    DH_free(dp->parameters.dh);
+                break;
+            case NID_X9_62_id_ecPublicKey:
+                if (dp->parameters.ecdh)
+                    EC_KEY_free(dp->parameters.ecdh);
+                break;
+            default:
+                break;
+        }
+        OPENSSL_free(dp);
+    }
+}
+
+AlgorithmIdentifier *
+AlgorithmIdentifier_new(void)
+{
+    AlgorithmIdentifier * out =
+            (AlgorithmIdentifier *) OPENSSL_malloc(sizeof(AlgorithmIdentifier));
+    if (!out)
+        return NULL;
+
+    out->algorithm = NID_undef;
+    out->parameters.dh = NULL;
+    /*out->parameters.ecdh = NULL;*/
+
+    return out;
+}
+
+AlgorithmIdentifier *
+AlgorithmIdentifier_dup(const AlgorithmIdentifier * dp_in)
+{
+    AlgorithmIdentifier * out = NULL;
+
+    if (!dp_in)
+        goto err;
+
+    out = AlgorithmIdentifier_new();
+    if (!out)
+        goto err;
+
+    out->algorithm = dp_in->algorithm;
+    switch (dp_in->algorithm) {
+        case NID_dhpublicnumber:
+            if (dp_in->parameters.dh) {
+                out->parameters.dh = DHparams_dup(dp_in->parameters.dh);
+                if (!out->parameters.dh)
+                    goto err;
+                BN_clear_free(out->parameters.dh->priv_key);
+                BN_clear_free(out->parameters.dh->pub_key);
+            }
+            break;
+
+        case NID_X9_62_id_ecPublicKey:
+            if (dp_in->parameters.ecdh) {
+                out->parameters.ecdh = EC_KEY_dup(dp_in->parameters.ecdh);
+                if (!out->parameters.ecdh)
+                    goto err;
+                /* Note: functions will return error, but clear the keys anyway */
+                EC_KEY_set_private_key(out->parameters.ecdh, NULL);
+                EC_KEY_set_public_key(out->parameters.ecdh, NULL);
+            }
+            break;
+
+        default:
+            goto err;
+    }
+
+    return out;
+
+err:
+    if (out)
+        AlgorithmIdentifier_clear_free(out);
+
+    return NULL;
+}
+
+void
+PACE_SEC_clear_free(PACE_SEC * s)
+{
+    if (s) {
+        if (s->mem)
+            BUF_MEM_free(s->mem);
+        OPENSSL_free(s);
+    }
+}
+
+PACE_SEC *
+PACE_SEC_new(const char *sec, size_t sec_len, enum s_type type)
+{
+    PACE_SEC * out = (PACE_SEC *) OPENSSL_malloc(sizeof(PACE_SEC));
+    if (!out)
+        goto err;
+
+    switch (type) {
+        case PACE_PUK:
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_MRZ:
+        case PACE_RAW:
+            out->type = type;
+            break;
+
+        default:
+            goto err;
+    }
+
+    out->mem = BUF_MEM_create_init(sec, sec_len);
+    if (!out->mem)
+        goto err;
+
+    return out;
+
+err:
+    PACE_SEC_clear_free(out);
+
+    return NULL;
+}
+
+void
+PACE_CTX_clear_free(PACE_CTX * ctx)
+{
+    if (ctx) {
+        if (ctx->bn_ctx)
+            BN_CTX_free(ctx->bn_ctx);
+        if (ctx->md_ctx) {
+            EVP_MD_CTX_destroy(ctx->md_ctx);
+        }
+        OPENSSL_free(ctx);
+    }
+}
+
+PACE_CTX *
+PACE_CTX_new(void)
+{
+    PACE_CTX * out = (PACE_CTX *) OPENSSL_malloc(sizeof(PACE_CTX));
+    if (!out)
+        return NULL;
+
+    out->bn_ctx = NULL;
+    out->md = NULL;
+    out->md_ctx = NULL;
+    out->md_engine = NULL;
+    out->cmac_ctx = NULL;
+    out->cipher_ctx = NULL;
+    out->cipher_engine = NULL;
+    out->iv = NULL;
+
+    return out;
+}
+
+void
+PACEDomainParameterInfo_clear_free(PACEDomainParameterInfo * dp)
+{
+    if (dp && dp->domainParameter) {
+        AlgorithmIdentifier_clear_free(dp->domainParameter);
+    }
+
+    PACEDomainParameterInfo_free(dp);
+}
+
+void
+PACEDomainParameterInfo_free(PACEDomainParameterInfo * dp)
+{
+    if (dp) {
+        OPENSSL_free(dp);
+    }
+}
+
+PACEDomainParameterInfo *
+PACEDomainParameterInfo_new(void)
+{
+    PACEDomainParameterInfo * out = (PACEDomainParameterInfo *) OPENSSL_malloc(
+            sizeof(PACEDomainParameterInfo));
+    if (!out)
+        return NULL;
+
+    out->domainParameter = NULL;
+    out->parameterId = 0;
+    out->protocol = NID_undef;
+
+    return out;
+}
+
+PACEDomainParameterInfo *
+PACEDomainParameterInfo_dup(const PACEDomainParameterInfo * dp_in)
+{
+    PACEDomainParameterInfo * dp_out = NULL;
+
+    if (!dp_in) {
+        goto err;
+    }
+
+    dp_out = PACEDomainParameterInfo_new();
+    if (!dp_out)
+        goto err;
+
+    if (dp_in->domainParameter) {
+        dp_out->domainParameter = AlgorithmIdentifier_dup(
+                dp_in->domainParameter);
+        if (!dp_out->domainParameter)
+            goto err;
+    }
+
+    dp_out->protocol = dp_in->protocol;
+    dp_out->parameterId = dp_in->parameterId;
+
+    return dp_out;
+
+err:
+    PACEDomainParameterInfo_clear_free(dp_out);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_mappings.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_mappings.c
@@ -0,0 +1,336 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <openssl/bn.h>
+#include <openssl/ec.h>
+#include <openssl/err.h>
+#include "pace_mappings.h"
+#include "pace_util.h"
+#include "pace_dh.h"
+#include "pace_ecdh.h"
+
+PACEDomainParameterInfo *
+dh_gm_compute_key(const PACEDomainParameterInfo * dp_info,
+        const PACE_CTX * ctx, const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL, *bn_h = NULL, *bn_g = NULL;
+
+    if (!dp_info || !ctx || !s)
+        goto err;
+
+    out = PACEDomainParameterInfo_dup(dp_info);
+    if (!out)
+        goto err;
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    /* complete the DH and convert the result to a BIGNUM */
+    mem_h = dh_compute_key(dp_info, ctx, in);
+    if (!mem_h)
+        goto err;
+    bn_h = BN_bin2bn((unsigned char *) mem_h->data, mem_h->length, bn_h);
+    if (!bn_h)
+        goto err;
+
+    /* map to new generator */
+    bn_g = BN_new();
+    if (!bn_g ||
+    /* bn_g = g^s mod p */
+    !BN_mod_exp(bn_g, dp_info->domainParameter->parameters.dh->g, bn_s,
+            dp_info->domainParameter->parameters.dh->p, ctx->bn_ctx) ||
+    /* out->parameters.dh->g = bn_g * h mod p = g^s * h mod p */
+    !BN_mod_mul(out->domainParameter->parameters.dh->g, bn_g, bn_h,
+            dp_info->domainParameter->parameters.dh->p, ctx->bn_ctx))
+        goto err;
+
+    BUF_MEM_free(mem_h);
+    BN_clear_free(bn_h);
+    BN_clear_free(bn_g);
+    BN_clear_free(bn_s);
+
+    return out;
+
+err:
+    if (mem_h)
+        BUF_MEM_free(mem_h);
+    if (bn_h)
+        BN_clear_free(bn_h);
+    if (bn_g)
+        BN_clear_free(bn_g);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+dh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx)
+{
+    if (!ctx)
+        return NULL;
+
+    return randb(EVP_CIPHER_key_length(ctx->cipher));
+}
+
+PACEDomainParameterInfo *
+dh_im_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BUF_MEM * x_mem = NULL;
+    BIGNUM * x_bn = NULL, *a = NULL, *p_1 = NULL, *q = NULL;
+
+    if (!in || in->length < EVP_CIPHER_key_length(ctx->cipher)
+            || !dp->domainParameter || !dp->domainParameter->parameters.dh)
+        goto err;
+
+    out = PACEDomainParameterInfo_dup(dp);
+    x_mem = cipher(ctx->cipher_ctx, ctx->cipher, ctx->cipher_engine,
+            (unsigned char *) in->data, ctx->iv, 1, s, 1);
+    if (!x_mem)
+        goto err;
+    x_bn = BN_bin2bn((unsigned char *) x_mem->data, x_mem->length, x_bn);
+    a = BN_new();
+    q = DH_get_q(dp->domainParameter->parameters.dh, ctx->bn_ctx);
+    p_1 = BN_dup(dp->domainParameter->parameters.dh->p);
+    if (!out || !x_bn || !a || !q || !p_1 ||
+            /* p_1 = p-1 */
+            !BN_sub_word(p_1, 1) ||
+            /* a = p-1 / q */
+            !BN_div(a, NULL, p_1, q, ctx->bn_ctx) ||
+            /* g~ = x^a mod p */
+            !BN_mod_exp(out->domainParameter->parameters.dh->g, x_bn, a,
+                dp->domainParameter->parameters.dh->p, ctx->bn_ctx))
+        goto err;
+
+    BN_clear_free(q);
+    BN_clear_free(p_1);
+    BN_clear_free(a);
+    BN_clear_free(x_bn);
+    BUF_MEM_free(x_mem);
+
+    return out;
+
+err:
+    if (q)
+        BN_clear_free(q);
+    if (p_1)
+        BN_clear_free(p_1);
+    if (a)
+        BN_clear_free(a);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+    if (x_bn)
+        BN_clear_free(x_bn);
+    if (x_mem)
+        BUF_MEM_free(x_mem);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+ecdh_gm_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out;
+    BUF_MEM * mem_h = NULL;
+    BIGNUM * bn_s = NULL;
+    EC_POINT * ecp_h = NULL, *ecp_g = NULL;
+    const ECDH_METHOD * default_method = NULL;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !s)
+        goto err;
+
+    default_method = ECDH_get_default_method();
+    ECDH_set_default_method(ECDH_OpenSSL_Point());
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    /* complete the ECDH and get the resulting point h */
+    mem_h = ecdh_compute_key(dp, ctx, in);
+    ecp_h = EC_POINT_new(
+            EC_KEY_get0_group(dp->domainParameter->parameters.ecdh));
+    if (!mem_h || !ecp_h || !EC_POINT_oct2point(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), ecp_h,
+            (unsigned char *) mem_h->data, mem_h->length, ctx->bn_ctx))
+        goto err;
+
+    /* map to new generator */
+    ecp_g = EC_POINT_new(
+            EC_KEY_get0_group(dp->domainParameter->parameters.ecdh));
+    /* g' = g * s + h */
+    if (!EC_POINT_mul(EC_KEY_get0_group(dp->domainParameter->parameters.ecdh),
+            ecp_g, bn_s, ecp_h, NULL, ctx->bn_ctx))
+        goto err;
+
+    /* configure the new EC_KEY */
+    out = dp_ecdh_new_generator(dp, ecp_g, ctx->bn_ctx);
+
+    EC_POINT_clear_free(ecp_g);
+    EC_POINT_clear_free(ecp_h);
+    BUF_MEM_free(mem_h);
+    BN_clear_free(bn_s);
+    ECDH_set_default_method(default_method);
+
+    return out;
+
+err:
+    if (ecp_g)
+        EC_POINT_clear_free(ecp_g);
+    if (ecp_h)
+        EC_POINT_clear_free(ecp_h);
+    if (mem_h)
+        BUF_MEM_free(mem_h);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    if (default_method)
+        ECDH_set_default_method(default_method);
+
+    return NULL;
+}
+
+PACEDomainParameterInfo *
+ecdh_im_compute_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in)
+{
+    PACEDomainParameterInfo * out = NULL;
+    BIGNUM * a = NULL, *b = NULL, *p = NULL;
+    BIGNUM * x = NULL, *y = NULL, *v = NULL, *bn_s = NULL;
+    BIGNUM * tmp = NULL, *tmp2 = NULL, *bn_const = NULL, *bn_inv = NULL;
+
+    if (!dp || !dp->domainParameter || !dp->domainParameter->parameters.ecdh
+            || !ctx || !s)
+        goto err;
+
+    a = BN_new();
+    b = BN_new();
+    p = BN_new();
+    x = BN_new();
+    y = BN_new();
+    v = BN_new();
+    tmp = BN_new();
+    tmp2 = BN_new();
+    bn_const = BN_new();
+    bn_inv = BN_new();
+    if (!a || !b || !p || !x || !y || !v || !tmp || !tmp2 || !bn_const
+            || !bn_inv)
+        goto err;
+
+    if (!EC_GROUP_get_curve_GFp(EC_KEY_get0_group(
+            dp->domainParameter->parameters.ecdh), p, a, b, ctx->bn_ctx))
+        goto err;
+
+    /* Check prerequisites for curve parameters */
+    if (!BN_set_word(bn_const, 3) || (BN_cmp(p, bn_const) != 1) ||
+    /* p^n mod 3 = 2, tested with n = 1*/
+    !BN_set_word(tmp2, 2) || !BN_nnmod(tmp, p, bn_const, ctx->bn_ctx)
+            || (BN_cmp(tmp, tmp2) != 0)) {
+        PACEerr(PACE_F_ECDH_INTEGRATED_MAPPING, PACE_R_UNSUITED_CURVE);
+        goto err;
+    }
+
+    /* Convert nonce to BIGNUM */
+    bn_s = BN_bin2bn((unsigned char *) s->data, s->length, bn_s);
+    if (!bn_s)
+        goto err;
+
+    if ( /* v = (3a - u^4) / 6u */
+            /* bn_const is still 3 */
+            !BN_mod_mul(tmp, bn_const, a, p, ctx->bn_ctx) || !BN_set_word(bn_const, 4)
+            || !BN_mod_exp(tmp2, bn_s, bn_const, p, ctx->bn_ctx)
+            || !BN_mod_sub(v, tmp, tmp2, p, ctx->bn_ctx) || !BN_set_word(
+                bn_const, 6) || !BN_mod_mul(tmp, bn_s, bn_const, p, ctx->bn_ctx) ||
+            /* For division within a galois field we need to compute
+             * the multiplicative inverse of a number */
+            !BN_mod_inverse(bn_inv, tmp, p, ctx->bn_ctx) || !BN_mod_mul(v, v, bn_inv,
+                p, ctx->bn_ctx) ||
+
+            /* x = (v^2 - b - ((u^6)/27)) */
+            !BN_mod_sqr(tmp, v, p, ctx->bn_ctx) || !BN_mod_sub(tmp2, tmp, b, p,
+                ctx->bn_ctx) ||
+            /* bn_const is still 6 */
+            !BN_mod_exp(tmp, bn_s, bn_const, p, ctx->bn_ctx) || !BN_set_word(bn_const,
+                27) || !BN_mod_inverse(bn_inv, bn_const, p, ctx->bn_ctx)
+            || !BN_mod_mul(tmp, tmp, bn_inv, p, ctx->bn_ctx) || !BN_mod_sub(x,
+                tmp2, tmp, p, ctx->bn_ctx) ||
+
+            /* x -> x^(1/3) = x^((2p^n -1)/3) */
+            !BN_set_word(bn_const, 2) || !BN_mul(tmp, bn_const, p, ctx->bn_ctx)
+            || !BN_set_word(bn_const, 1) || !BN_sub(tmp, tmp, bn_const)
+            || !BN_set_word(bn_const, 3) ||
+            /* Division is defined, because p^n = 2 mod 3 */
+            !BN_div(tmp, y, tmp, bn_const, ctx->bn_ctx) || !BN_mod_exp(tmp2, x, tmp, p,
+                    ctx->bn_ctx) || !BN_copy(x, tmp2) ||
+
+            /* x += u^2/3 */
+            !BN_mod_sqr(tmp, bn_s, p, ctx->bn_ctx) ||
+            /*bn_const is still 3*/
+            !BN_mod_inverse(bn_inv, bn_const, p, ctx->bn_ctx) || !BN_mod_mul(tmp2, tmp,
+                    bn_inv, p, ctx->bn_ctx)
+            || !BN_mod_add(tmp, x, tmp2, p, ctx->bn_ctx) || !BN_copy(x, tmp) ||
+
+            /* y = ux + v */
+            !BN_mod_mul(y, bn_s, x, p, ctx->bn_ctx) || !BN_mod_add(tmp, y, v, p,
+                    ctx->bn_ctx) || !BN_copy(y, tmp))
+        goto err;
+
+    /* configure the new EC_KEY */
+    out = dp_ecdh_new_generator_by_coordinates(dp, x, y, ctx->bn_ctx);
+
+    BN_clear_free(a);
+    BN_clear_free(b);
+    BN_clear_free(p);
+    BN_clear_free(x);
+    BN_clear_free(y);
+    BN_clear_free(v);
+    BN_clear_free(bn_s);
+    BN_clear_free(tmp);
+    BN_clear_free(tmp2);
+    BN_clear_free(bn_const);
+    BN_clear_free(bn_inv);
+
+    return out;
+
+err:
+    if (a)
+        BN_clear_free(a);
+    if (b)
+        BN_clear_free(b);
+    if (p)
+        BN_clear_free(p);
+    if (x)
+        BN_clear_free(x);
+    if (y)
+        BN_clear_free(y);
+    if (v)
+        BN_clear_free(v);
+    if (bn_s)
+        BN_clear_free(bn_s);
+    if (tmp)
+        BN_clear_free(tmp);
+    if (tmp2)
+        BN_clear_free(tmp2);
+    if (bn_const)
+        BN_clear_free(bn_const);
+    if (bn_inv)
+        BN_clear_free(bn_inv);
+    if (out)
+        PACEDomainParameterInfo_clear_free(out);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_mappings.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_mappings.h
@@ -0,0 +1,60 @@
+/**
+ * @date 2009-12-01
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_MAPPINGS_H_
+#define PACE_MAPPINGS_H_
+
+#include <openssl/pace.h>
+#include <openssl/buffer.h>
+
+/**
+ * @defgroup encoding               Mapping
+ * @{ ************************************************************************/
+
+/**
+ * @brief Computes a key for DH Generic Mapping (see TR-3110 A.3.5.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+dh_gm_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Computes a key for DH Integrated Mapping (see TR-3110 A.3.4.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+BUF_MEM *
+dh_im_generate_key(const PACEDomainParameterInfo * dp, const PACE_CTX * ctx);
+/**
+ * @brief Computes a key for DH Integrated Mapping (see TR-3110 A.3.4.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+dh_im_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Computes a key for ECDH Generic Mapping (see TR-3110 A.3.4.1)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+ecdh_gm_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+/**
+ * @brief Computes a key for ECDH Integrated Mapping (see TR-3110 A.3.4.2)
+ *
+ * @see PACE_STEP3A_map_compute_key()
+ */
+PACEDomainParameterInfo *
+ecdh_im_compute_key(const PACEDomainParameterInfo * dp_in, const PACE_CTX * ctx,
+        const BUF_MEM * s, const BUF_MEM * in);
+
+/** @} ***********************************************************************/
+
+#endif /*PACE_MAPPINGS_H_*/
Index: openssl/crypto/pace/pace_util.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_util.c
@@ -0,0 +1,605 @@
+/**
+ * @date 2009-11-30
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#include <string.h>
+#include <openssl/bio.h>
+#include <openssl/rand.h>
+#include <openssl/asn1.h>
+#include <openssl/conf.h>
+#include <openssl/err.h>
+#include "pace_util.h"
+#include "pace_buffer.h"
+#include "pace_dh.h"
+
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in)
+{
+    BUF_MEM * out = NULL;
+    EVP_MD_CTX * tmp_ctx = NULL;
+    unsigned int tmp_len;
+
+    if (!md || !in)
+        goto err;
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_MD_CTX_create();
+        if (!tmp_ctx)
+            goto err;
+    }
+
+    tmp_len = EVP_MD_size(md);
+    out = BUF_MEM_create(tmp_len);
+    if (!out || !EVP_DigestInit_ex(tmp_ctx, md, impl) ||
+            !EVP_DigestUpdate(tmp_ctx, in->data, in->length) ||
+            !EVP_DigestFinal_ex(tmp_ctx, (unsigned char *) out->data,
+                &tmp_len))
+        goto err;
+
+    if (!ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+    if (tmp_ctx && !ctx)
+        EVP_MD_CTX_destroy(tmp_ctx);
+
+    return NULL;
+}
+
+BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        unsigned char *key, unsigned char *iv, int enc, const BUF_MEM * in,
+        int init)
+{
+    BUF_MEM * out = NULL;
+    EVP_CIPHER_CTX * tmp_ctx = NULL;
+    int i;
+
+    if (!in)
+        goto err;
+
+    if (ctx)
+        tmp_ctx = ctx;
+    else {
+        tmp_ctx = EVP_CIPHER_CTX_new();
+        if (!tmp_ctx)
+            goto err;
+        EVP_CIPHER_CTX_init(tmp_ctx);
+    }
+
+    i = in->length + EVP_CIPHER_block_size(type);
+    out = BUF_MEM_create(i);
+    if (!out)
+        goto err;
+
+    /* get cipher */
+    if (ctx && init)
+        if (!EVP_CipherInit_ex(tmp_ctx, type, impl, key, iv, enc))
+            goto err;
+    if (!EVP_CipherUpdate(ctx, (unsigned char *) out->data, &i,
+            (unsigned char *) in->data, in->length))
+        goto err;
+    out->length = i;
+    if (!EVP_CipherFinal_ex(ctx, (unsigned char *) (out->data + out->length),
+            &i))
+        goto err;
+    out->length += i;
+
+    if (!ctx) {
+        EVP_CIPHER_CTX_cleanup(tmp_ctx);
+        EVP_CIPHER_CTX_free(tmp_ctx);
+    }
+
+    return out;
+
+err: if (out)
+        BUF_MEM_free(out);
+    if (!ctx && tmp_ctx) {
+        EVP_CIPHER_CTX_cleanup(tmp_ctx);
+        EVP_CIPHER_CTX_free(tmp_ctx);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+base64(const BUF_MEM * in)
+{
+    BIO *bmem = NULL, *b64 = NULL;
+    BUF_MEM *out = NULL;
+
+    if (!in)
+        goto err;
+
+    b64 = BIO_new(BIO_f_base64());
+    if (!b64)
+        goto err;
+    /* usually base64 adds newline */
+    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
+
+    bmem = BIO_new(BIO_s_mem());
+    if (!bmem)
+        goto err;
+    /* So BIO_free() leaves BUF_MEM alone */
+    if (!BIO_set_close(bmem, BIO_NOCLOSE))
+        goto err;
+    BIO_push(b64, bmem);
+
+    if ((BIO_write(b64, in->data, in->length) < 0) || (BIO_flush(b64) <= 0))
+        goto err;
+    BIO_get_mem_ptr(b64, &out);
+
+    BIO_free_all(b64);
+
+    return out;
+
+err:
+    if (b64)
+        BIO_free(b64);
+    if (bmem)
+        BIO_free(bmem);
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, unsigned int maclen)
+{
+    CMAC_CTX * cmac_ctx = NULL;
+    BUF_MEM * out = NULL;
+
+    if (!key || !in || !type ||
+            (key->length < EVP_CIPHER_key_length(type)))
+        goto err;
+
+    if (ctx)
+        cmac_ctx = ctx;
+    else {
+        cmac_ctx = CMAC_CTX_new();
+    }
+
+    /* get buffer in required size */
+    out = BUF_MEM_create(maclen);
+    if (!out)
+        goto err;
+
+    if (!cmac_ctx ||
+            !CMAC_Init(cmac_ctx, type, (unsigned char*) key->data,
+                EVP_CIPHER_key_length(type) * 8) ||
+            !CMAC_Update(cmac_ctx, (unsigned char*) in->data, in->length) ||
+            !CMAC_Final(cmac_ctx, (unsigned char*) out->data, maclen))
+        goto err;
+
+    if (!ctx)
+        CMAC_CTX_free(cmac_ctx);
+
+    return out;
+
+err:
+    if (cmac_ctx && !ctx) {
+        CMAC_CTX_free(cmac_ctx);
+    }
+    if (out) {
+        BUF_MEM_free(out);
+    }
+
+    return NULL;
+}
+
+BUF_MEM *
+randb(int numbytes)
+{
+    BUF_MEM * r = BUF_MEM_new();
+    if (!r || !BUF_MEM_grow(r, numbytes) ||
+            !RAND_bytes((unsigned char *) r->data, numbytes))
+        goto err;
+
+    return r;
+
+err:
+    if (r)
+        BUF_MEM_free(r);
+
+    return NULL;
+}
+
+BUF_MEM *
+add_iso_pad(const BUF_MEM * m, int block_size)
+{
+    BUF_MEM * out = NULL;
+    int p_len;
+
+    if (!m)
+        goto err;
+
+    /* calculate length of padded message */
+    p_len = (m->length / block_size) * block_size + block_size;
+
+    out = BUF_MEM_create(p_len);
+    if (!out)
+        goto err;
+
+    memcpy(out->data, m->data, m->length);
+
+    /* now add iso padding */
+    memset(out->data + m->length, 0x80, 1);
+    memset(out->data + m->length + 1, 0, p_len - m->length - 1);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in)
+{
+    BUF_MEM * c_tmp = NULL, *mac = NULL, *block = NULL, *pad = NULL;
+    EVP_CIPHER_CTX * ctx = NULL;
+    size_t len;
+
+    if (!key)
+        goto err;
+
+    pad = add_iso_pad(in, EVP_CIPHER_block_size(EVP_des_cbc()));
+    if (!pad)
+        goto err;
+
+    ctx = EVP_CIPHER_CTX_new();
+    if (!ctx)
+        goto err;
+    EVP_CIPHER_CTX_init(ctx);
+    if (!EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data, NULL, 1) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+
+    /* get last block of des_cbc encrypted input */
+    c_tmp = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 1, pad, 0);
+    if (!c_tmp)
+        goto err;
+    len = EVP_CIPHER_block_size(EVP_des_cbc());
+    block = BUF_MEM_create_init(c_tmp->data + c_tmp->length - len, len);
+
+    /* decrypt last block with the rest of the key */
+    /* IV is always NULL */
+    if (!EVP_CipherInit_ex(ctx, EVP_des_cbc(), NULL,
+            (unsigned char *) key->data + len, NULL, 0) ||
+            !EVP_CIPHER_CTX_set_padding(ctx, 0))
+        goto err;
+    mac = cipher(ctx, EVP_des_cbc(), NULL, NULL, NULL, 0, block, 0);
+
+    BUF_MEM_free(block);
+    BUF_MEM_free(c_tmp);
+    BUF_MEM_free(pad);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
+
+    return mac;
+
+err:
+    if (block)
+        BUF_MEM_free(block);
+    if (c_tmp)
+        BUF_MEM_free(c_tmp);
+    if (pad)
+        BUF_MEM_free(pad);
+    if (ctx) {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        EVP_CIPHER_CTX_free(ctx);
+    }
+
+    return NULL;
+}
+
+int
+is_no_valid_integer_hexstr(const char * str)
+{
+    if (!str || (strlen(str) < 2))
+        return 0;
+
+    /* positive INTEGERs are forbidden (TR-3110 D.2.1.1.), but they shouldn't occur anyway */
+    return (str[0] == '0') && (str[1] == '0');
+}
+
+int
+is_char_str(const BUF_MEM * str)
+{
+    const unsigned char * s = (unsigned char *) str->data;
+    int i = str->length;
+
+    while (i) {
+        if (*s <= 0x1f || (0x7f < *s && *s < 0x9f))
+            return 0;
+        s++;
+        i--;
+    }
+
+    return 1;
+}
+
+BUF_MEM *
+encoded_secret(const PACE_SEC * pi)
+{
+    BUF_MEM * out;
+
+    if (!pi)
+        return NULL;
+
+    switch (pi->type) {
+        case PACE_PUK:
+            out = base64(pi->mem);
+            break;
+
+        case PACE_CAN:
+        case PACE_PIN:
+        case PACE_MRZ:
+        case PACE_RAW:
+            if (!is_char_str(pi->mem))
+                return NULL;
+
+            out = BUF_MEM_create_init(pi->mem->data, pi->mem->length);
+            break;
+
+        default:
+            return NULL;
+    }
+
+    return out;
+}
+
+BUF_MEM *
+encoded_ssc(const uint16_t ssc, const PACE_CTX *ctx)
+{
+    BUF_MEM * out = NULL;
+    size_t len;
+
+    if (!ctx)
+        goto err;
+
+    len = EVP_CIPHER_block_size(ctx->cipher);
+    out = BUF_MEM_create(len);
+    if (!out || len < sizeof ssc)
+        goto err;
+
+    /* Copy SSC to the end of buffer and fill the rest with 0 */
+    memset(out->data, 0, len);
+    memcpy(out->data + len - sizeof ssc, &ssc, sizeof ssc);
+
+    return out;
+
+err:
+    if (out)
+        BUF_MEM_free(out);
+
+    return NULL;
+}
+
+BUF_MEM *
+asn1_pubkey(BN_CTX *ctx, const PACEDomainParameterInfo *dp)
+{
+    BUF_MEM *out = NULL;
+    BIO *bio = NULL;
+    CONF *conf = NULL;
+    ASN1_TYPE *atyp = NULL;
+    BIGNUM *bn = NULL, *a_bn = NULL, *b_bn = NULL;
+    char *genstr, *p = NULL, *q = NULL, *g = NULL, *y = NULL, *a = NULL, *b =
+            NULL, *G = NULL, *r = NULL, *Y = NULL, *f = NULL;
+    const char *sn;
+
+    if (!dp)
+        goto err;
+
+    bn = BN_new();
+    bio = BIO_new(BIO_s_mem());
+    sn = OBJ_nid2sn(dp->domainParameter->algorithm);
+    if (!bn || !bio || !sn || (BIO_printf(bio,
+            "asn1=IMPLICIT:78A,SEQUENCE:domainParameter\n"
+                "[domainParameter]\n"
+                "algorithm=OID:%s\n", sn) < 0))
+
+        switch (dp->domainParameter->algorithm) {
+            case NID_dhpublicnumber:
+                if (!dp->domainParameter->parameters.dh)
+                    goto err;
+
+                /* Prime modulus */
+                p = BN_bn2hex(dp->domainParameter->parameters.dh->p);
+
+                /* Order of the subgroup */
+                bn = DH_get_order(dp->domainParameter->parameters.dh, ctx);
+                q = BN_bn2hex(bn);
+
+                /* Generator */
+                g = BN_bn2hex(dp->domainParameter->parameters.dh->g);
+
+                /* Public value */
+                y = BN_bn2hex(dp->domainParameter->parameters.dh->pub_key);
+
+                if (is_no_valid_integer_hexstr(y)
+                        || is_no_valid_integer_hexstr(g)
+                        || is_no_valid_integer_hexstr(q)
+                        || is_no_valid_integer_hexstr(p)) {
+                    PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                    goto err;
+                }
+                if (BIO_printf(bio, "p=IMPLICIT:1C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "q=IMPLICIT:2C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "g=IMPLICIT:3C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "y=IMPLICIT:4C,FORMAT:HEX,OCTETSTRING:%s", p, q, g, y) < 0)
+                    goto err;
+
+                OPENSSL_free(y);
+                OPENSSL_free(g);
+                OPENSSL_free(q);
+                OPENSSL_free(p);
+                break;
+
+            case NID_X9_62_id_ecPublicKey:
+                if (!dp->domainParameter->parameters.ecdh)
+                    goto err;
+
+                a_bn = BN_new();
+                b_bn = BN_new();
+                if (!a_bn || !b_bn
+                        || !EC_GROUP_get_curve_GFp(EC_KEY_get0_group(
+                                dp->domainParameter->parameters.ecdh), bn,
+                                a_bn, b_bn, ctx))
+                    goto err;
+                /* Prime modulus */
+                p = BN_bn2hex(bn);
+                /* First coefficient */
+                a = BN_bn2hex(a_bn);
+                /* Second coefficient */
+                b = BN_bn2hex(b_bn);
+
+                /* Base Point */
+                G = EC_POINT_point2hex(EC_KEY_get0_group(
+                        dp->domainParameter->parameters.ecdh),
+                        EC_GROUP_get0_generator(EC_KEY_get0_group(
+                                dp->domainParameter->parameters.ecdh)),
+                        EC_KEY_get_conv_form(
+                                dp->domainParameter->parameters.ecdh),
+                        ctx);
+
+                /* Order of the base point */
+                if (!EC_GROUP_get_order(EC_KEY_get0_group(
+                        dp->domainParameter->parameters.ecdh), bn, ctx))
+                    goto err;
+                r = BN_bn2hex(bn);
+
+                /* Public point */
+                Y = EC_POINT_point2hex(EC_KEY_get0_group(
+                        dp->domainParameter->parameters.ecdh),
+                        EC_KEY_get0_public_key(
+                                dp->domainParameter->parameters.ecdh),
+                        EC_KEY_get_conv_form(
+                                dp->domainParameter->parameters.ecdh),
+                        ctx);
+
+                /* Cofactor */
+                if (!EC_GROUP_get_cofactor(EC_KEY_get0_group(
+                        dp->domainParameter->parameters.ecdh), bn, ctx))
+                    goto err;
+                f = BN_bn2hex(bn);
+
+                if (is_no_valid_integer_hexstr(f)
+                        || is_no_valid_integer_hexstr(r)
+                        || is_no_valid_integer_hexstr(b)
+                        || is_no_valid_integer_hexstr(a)
+                        || is_no_valid_integer_hexstr(p)) {
+                    PACEerr(PACE_F_ASN1_PUBKEY, PACE_R_BAD_FORMAT);
+                    goto err;
+                }
+                if (BIO_printf(bio, "p=IMPLICIT:1C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "a=IMPLICIT:2C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "b=IMPLICIT:3C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "G=IMPLICIT:4C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "r=IMPLICIT:5C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "Y=IMPLICIT:6C,FORMAT:HEX,OCTETSTRING:%s\n"
+                    "f=IMPLICIT:7C,FORMAT:HEX,OCTETSTRING:%s", p, a, b, G, r,
+                        Y, f) < 0)
+                    goto err;
+
+                OPENSSL_free(f);
+                OPENSSL_free(Y);
+                OPENSSL_free(r);
+                OPENSSL_free(G);
+                BN_clear_free(a_bn);
+                BN_clear_free(b_bn);
+                OPENSSL_free(b);
+                OPENSSL_free(a);
+                OPENSSL_free(p);
+                break;
+
+            default:
+                goto err;
+        }
+
+    if (BIO_flush(bio) <= 0)
+        goto err;
+
+    conf = NCONF_new(NULL);
+    if (!conf || (NCONF_load_bio(conf, bio, NULL) <= 0))
+        goto err;
+
+    genstr = NCONF_get_string(conf, "default", "asn1");
+    if (!genstr)
+        goto err;
+    atyp = ASN1_generate_nconf(genstr, conf);
+    if (!atyp)
+        goto err;
+
+    int l = i2d_ASN1_TYPE(atyp, NULL);
+    if (l <= 0)
+        goto err;
+    out = BUF_MEM_new();
+    if (!out || !BUF_MEM_grow(out, l))
+        goto err;
+    unsigned char *d = (unsigned char *) out->data;
+    i2d_ASN1_TYPE(atyp, &d);
+
+    ASN1_TYPE_free(atyp);
+    NCONF_free(conf);
+    BIO_free(bio);
+    BN_clear_free(bn);
+
+    return out;
+
+err:
+    if (y)
+        OPENSSL_free(y);
+    if (g)
+        OPENSSL_free(g);
+    if (q)
+        OPENSSL_free(q);
+    if (p)
+        OPENSSL_free(p);
+
+    if (f)
+        OPENSSL_free(f);
+    if (Y)
+        OPENSSL_free(Y);
+    if (r)
+        OPENSSL_free(r);
+    if (G)
+        OPENSSL_free(G);
+    if (a_bn)
+        BN_clear_free(a_bn);
+    if (b_bn)
+        BN_clear_free(b_bn);
+    if (b)
+        OPENSSL_free(b);
+    if (a)
+        OPENSSL_free(a);
+    if (p)
+        OPENSSL_free(p);
+
+    if (out)
+        BUF_MEM_free(out);
+    if (atyp)
+        ASN1_TYPE_free(atyp);
+    if (conf)
+        NCONF_free(conf);
+    if (bio)
+        BIO_free(bio);
+    if (bn)
+        BN_clear_free(bn);
+
+    return NULL;
+}
Index: openssl/crypto/pace/pace_util.h
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pace_util.h
@@ -0,0 +1,172 @@
+/**
+ * @date 2009-11-30
+ * @version 0.1
+ * @author Frank Morgner <morgner@informatik.hu-berlin.de>
+ * @author Dominik Oepen <oepen@informatik.hu-berlin.de>
+ */
+
+#ifndef PACE_UTIL_H_
+#define PACE_UTIL_H_
+
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/cmac.h>
+#include <openssl/ec.h>
+#include <openssl/pace.h>
+/**
+ * @brief Wrapper for the OpenSSL hash functions.
+ *
+ * @param md
+ * @param ctx (optional)
+ * @param impl (optional)
+ * @param in
+ *
+ * @return message digest or NULL if an error occurred
+ */
+BUF_MEM *
+hash(const EVP_MD * md, EVP_MD_CTX * ctx, ENGINE * impl, const BUF_MEM * in);
+/**
+ * @brief Wrapper to the OpenSSL encryption functions.
+ *
+ * @param ctx (optional)
+ * @param type
+ * @param impl only evaluated if init is 1. (optional)
+ * @param key only evaluated if init is 1.
+ * @param iv only evaluated if init is 1. (optional)
+ * @param enc only evaluated if init is 1.
+ * @param in
+ * @param init whether to initialize (1) the given ctx or not (0).
+ *
+ * @return cipher of in or NULL if an error occurred
+ */
+BUF_MEM *
+cipher(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl,
+        unsigned char *key, unsigned char *iv, int enc, const BUF_MEM * in,
+        const int init);
+/**
+ * @brief Wrapper to the OpenSSL pseudo-random number generator.
+ *
+ * @param numbytes number of bytes to randomize
+ *
+ * @return a buffer of randomized bytes or NULL if an error occurred
+ */
+BUF_MEM *
+randb(int numbytes);
+/**
+ * @brief Computes message authentication code in retail-mode according to
+ * ISO/IEC 9797-1 MAC algorithm 3 / padding method 2 with block cipher DES and
+ * IV=0.
+ *
+ * @param key authentication key
+ * @param in buffer to authenticate
+ * @param ssc Send sequence counter
+ *
+ * @return message authentication code or NULL if an error occurred
+ */
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in);
+/**
+ * @brief Compute a CMAC of the input buffer using the encryption algorithm
+ *           specified in the PACE context structure
+ *
+ * @param ctx EVP_CIPHER_CTX object (optional)
+ * @param type contains the encryption algorithm to use
+ * @param key the symmetric key used for the computation. The key must have
+ *           the correct length for the encryption algorithm used
+ * @param in buffer that contains the data to for CMAC computation
+ * @param maclen length in number of bytes of the MAC
+ *
+ * @return buffer containing the CMAC or NULL in case of error
+ */
+BUF_MEM *
+cmac(CMAC_CTX *ctx, const EVP_CIPHER *type, const BUF_MEM * key,
+        const BUF_MEM * in, unsigned int maclen);
+/**
+ * @brief encodes a buffer in base64
+ *
+ * @param in buffer to encode
+ *
+ * @return base 64 encoded buffer or NULL if an error occurred
+ */
+BUF_MEM *
+base64(const BUF_MEM * in);
+/**
+ * @brief Padds a buffer using ISO/IEC 9797-1 padding method 2.
+ *
+ * @param m buffer to padd
+ * @param block_size pad to this block size
+ *
+ * @return new buffer with the padded input or NULL if an error occurred
+ */
+BUF_MEM *
+add_iso_pad(const BUF_MEM * m, int block_size);
+
+/**
+ * @brief Computes a MAC for a given input using a given key
+ *
+ * @param key Key used for MAC computation
+ * @param in Input
+ *
+ * @return Message authentication code
+ */
+BUF_MEM *
+retail_mac_des(const BUF_MEM * key, const BUF_MEM * in);
+
+/**
+ * @defgroup encoding               Encoding
+ * @{ ************************************************************************/
+
+/**
+ * @brief Checks if str is NOT a INTEGER string in hex format according to TR-3110
+ * D.2.1.1.
+ *
+ * @param str hex string (must be NULL terminated)
+ *
+ * @return 1 if str is NOT a valid integer hex string or 0 if it is
+ */
+int is_no_valid_integer_hexstr(const char * str);
+/**
+ * @brief Checks if str is a character string according to TR-3110 D.2.1.4
+ *
+ * @param str BUF_MEM object with the string to check
+ *
+ * @return 1 if str is a character string or 0 if it is not
+ */
+int is_char_str(const BUF_MEM * str);
+/**
+ * @brief Encodes a shared secret according to TR-3110 Table F.2
+ *
+ * @param pi Password to encode
+ *
+ * @return BUF_MEM object containing the encoded password or NULL if an error occurred
+ *
+ * @note This function is automatically called during PACE, normally you should not need to use it.
+ */
+BUF_MEM * encoded_secret(const PACE_SEC * pi);
+/**
+ * @brief Encodes a send sequence counter according to TR-3110 F.3
+ *
+ * @param ssc Send sequence counter to encode (Formatted in big endian)
+ * @param ctx PACE_CTX object
+ *
+ * @return BUF_MEM object containing the send sequence counter or NULL if an error occurred
+ *
+ * @note This function is automatically called during PACE, normally you should not need to use it.
+ */
+BUF_MEM * encoded_ssc(const uint16_t ssc, const PACE_CTX *ctx);
+/** @} ***********************************************************************/
+
+/**
+ * @brief Encodes public key data objects of the domain parameters in ASN.1
+ * (see TR-3110 D.3)
+ *
+ * @param PACEDomainParameterInfo object containing an AlgorithmIdentifier, which
+ * includes the DH or EC_KEY object
+ * @param ctx
+ *
+ * @return ASN.1 encoded public key data objects or NULL if an error occurred
+ */
+BUF_MEM *
+asn1_pubkey(BN_CTX  *ctx, const PACEDomainParameterInfo *dp);
+
+#endif /*PACE_DH_H_*/
Index: openssl/crypto/pace/pacetest.c
===================================================================
--- /dev/null
+++ openssl/crypto/pace/pacetest.c
@@ -0,0 +1,523 @@
+#include <stdlib.h>
+#include <openssl/opensslconf.h>	/* for OPENSSL_NO_PACE */
+#ifdef OPENSSL_NO_PACE
+int
+main(int argc, char *argv[])
+{
+    printf("No PACE support\n");
+    return (0);
+}
+#else
+#include <openssl/pace.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/objects.h>
+#include <string.h>
+#include <openssl/buffer.h>
+
+#define start() printf("%s\t", __FUNCTION__)
+#define err(s) { printf(s "\n"); ERR_print_errors_fp(stdout); goto err; }
+
+static int verbose=0;
+static int debug=0;
+
+static void hexdump(const char *title, const BUF_MEM *s)
+{
+    int n=0;
+
+    fprintf(stdout,"%s",title);
+    for(; n < s->length; ++n)
+    {
+        if((n%16) == 0)
+        fprintf(stdout,"\n    ");
+        fprintf(stdout,"%02x:",(unsigned char) s->data[n]);
+    }
+    fprintf(stdout,"\n");
+}
+
+int do_test(char *sec_str, int sec_type, int curve, int algorithm)
+{
+    int ok = 1;
+    PACE_SEC *s = NULL;
+    PACE_CTX * ctx = NULL;
+    PACEInfo info;
+    PACEDomainParameterInfo * dp_info_picc = NULL, * dp_info_pcd = NULL;
+    AlgorithmIdentifier * dp_picc_at_pcd = NULL;
+    BUF_MEM * nonce_picc = NULL, * enc_nonce = NULL;
+    BUF_MEM * nonce_pcd = NULL;
+    BUF_MEM * map_pub_picc = NULL;
+    BUF_MEM * map_pub_pcd = NULL;
+    PACEDomainParameterInfo * map_picc = NULL;
+    PACEDomainParameterInfo * map_pcd = NULL;
+    BUF_MEM * pub_picc = NULL;
+    BUF_MEM * pub_pcd = NULL;
+    BUF_MEM * key_picc = NULL;
+    BUF_MEM * key_pcd = NULL;
+    BUF_MEM * k_mac = NULL, * k_enc = NULL;
+    BUF_MEM * token_pcd = NULL, * token_picc = NULL;
+
+    ctx = PACE_CTX_new();
+    dp_info_picc = PACEDomainParameterInfo_new();
+    dp_info_pcd = PACEDomainParameterInfo_new();
+    if (!ctx || !dp_info_picc || !dp_info_pcd)
+        err("Error allocating memory");
+    dp_info_picc->domainParameter = AlgorithmIdentifier_new();
+    if (!dp_info_picc->domainParameter)
+        err("Error allocating memory");
+
+    s = PACE_SEC_new(sec_str, strlen(sec_str), sec_type);
+    if (!s)
+        err("Error initializing PACE secret");
+    if (debug)
+        hexdump("Initialized PACE secret", s->mem);
+    info.protocol = algorithm;
+
+    switch (algorithm) {
+        case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            dp_info_picc->protocol = NID_id_PACE_ECDH_GM;
+            dp_info_picc->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            dp_info_picc->domainParameter->parameters.ecdh = EC_KEY_new_by_curve_name(curve);
+            break;
+        case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+            dp_info_picc->protocol = NID_id_PACE_ECDH_IM;
+            dp_info_picc->domainParameter->algorithm = NID_X9_62_id_ecPublicKey;
+            dp_info_picc->domainParameter->parameters.ecdh = EC_KEY_new_by_curve_name(curve);
+            break;
+        case NID_id_PACE_DH_GM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_GM_AES_CBC_CMAC_256:
+            dp_info_picc->protocol = NID_id_PACE_DH_GM;
+            dp_info_picc->domainParameter->algorithm = NID_dhpublicnumber;
+            dp_info_picc->domainParameter->parameters.dh = NULL;
+            break;
+        case NID_id_PACE_DH_IM_3DES_CBC_CBC:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_128:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_192:
+        case NID_id_PACE_DH_IM_AES_CBC_CMAC_256:
+            dp_info_picc->protocol = NID_id_PACE_DH_IM;
+            dp_info_picc->domainParameter->algorithm = NID_dhpublicnumber;
+            dp_info_picc->domainParameter->parameters.dh = NULL;
+            break;
+        default:
+            err("Cannot happen\n");
+    }
+    if (!PACE_init(ctx, dp_info_picc, info))
+        err("Error initializing domain parameters and PACE_CTX object for PICC");
+    dp_picc_at_pcd = AlgorithmIdentifier_dup(dp_info_picc->domainParameter);
+    if (!dp_picc_at_pcd)
+        err("Error initializing domain parameters and PACE_CTX object for PCD");
+    dp_info_pcd->domainParameter = dp_picc_at_pcd;
+    dp_info_pcd->protocol = dp_info_picc->protocol;
+
+    printf("Using ");
+    switch (s->type) {
+        case PACE_PUK:
+            printf("PUK");
+            break;
+        case PACE_CAN:
+            printf("CAN");
+            break;
+        case PACE_PIN:
+            printf("PIN");
+            break;
+        case PACE_MRZ:
+            printf("MRZ");
+            break;
+        case PACE_RAW:
+            printf("RAW");
+            break;
+        default:
+            err("\ncannot happen");
+    }
+    const char *sn = OBJ_nid2sn(info.protocol);
+    if (!sn)
+        err("\nError generating short name from nid.");
+    if (verbose)
+        printf(" with %s\n", sn);
+    else
+        printf(" with %s\t", sn);
+    if (debug)
+        switch (dp_info_picc->domainParameter->algorithm) {
+            case NID_dhpublicnumber:
+                DHparams_print_fp(stdout, dp_info_picc->domainParameter->parameters.dh);
+                break;
+            case NID_X9_62_id_ecPublicKey:
+                printf("Using curve: %s\n", OBJ_nid2sn(curve));
+                ECParameters_print_fp(stdout, dp_info_picc->domainParameter->parameters.ecdh);
+                break;
+            default:
+                err("cannot happen");
+        }
+
+    if (verbose)
+        printf("STEP1\n");
+    else
+        printf(".");
+    if (!PACE_STEP1_enc_nonce(s, ctx, &nonce_picc, &enc_nonce))
+        err("Error generating or encrypting nonce");
+    if (verbose)
+        printf("MRTD generated and encrypted nonce.");
+    else
+        printf(".");
+    if (debug) {
+        hexdump("MRTD generated Nonce", nonce_picc);
+        hexdump("Encrypted nonce", enc_nonce);
+    }
+
+    if (verbose)
+        printf("STEP2\n");
+    else
+        printf(".");
+    nonce_pcd = PACE_STEP2_dec_nonce(s, enc_nonce, ctx);
+    if (!nonce_pcd)
+        err("Error decrypting nonce");
+    if (nonce_picc->length != nonce_pcd->length ||
+            memcmp(nonce_picc->data, nonce_pcd->data, nonce_pcd->length) != 0)
+        err("Error decrypting nonce (doesn't match nonce)");
+    if (verbose)
+        printf("Terminal decrypted the correct nonce\n");
+    else
+        printf(".");
+
+    if (verbose)
+        printf("STEP3A generate key\n");
+    else
+        printf(".");
+    map_pub_picc = PACE_STEP3A_map_generate_key(dp_info_picc, ctx);
+    map_pub_pcd = PACE_STEP3A_map_generate_key(dp_info_pcd, ctx);
+    if(!map_pub_picc || !map_pub_pcd)
+        err("Error generating keypair to map domain parameters");
+    if (verbose)
+        printf("Generated keypair on MRTD and Terminal for mapping\n");
+    else
+        printf(".");
+    if (debug) {
+        hexdump("Public key MRTD", map_pub_picc);
+        hexdump("Public key Terminal", map_pub_pcd);
+    }
+
+    if (verbose)
+        printf("STEP3A compute key\n");
+    else
+        printf(".");
+    switch (dp_info_picc->protocol) {
+        case NID_id_PACE_DH_IM:
+            /* dh im is special, only mrtd generates the key */
+            map_picc = PACE_STEP3A_map_compute_key(dp_info_picc, ctx,
+                    nonce_picc, map_pub_picc);
+            break;
+        default:
+            map_picc = PACE_STEP3A_map_compute_key(dp_info_picc, ctx,
+                    nonce_picc, map_pub_pcd);
+            break;
+    }
+    map_pcd = PACE_STEP3A_map_compute_key(dp_info_pcd,
+            ctx, nonce_pcd, map_pub_picc);
+    if(!map_pcd || !map_picc)
+        err("Error computing mapped domain parameters");
+    if (verbose)
+        printf("Computed mapped domain parameters on MRTD and Terminal\n");
+    else
+        printf(".");
+    switch (map_picc->domainParameter->algorithm) {
+        case NID_dhpublicnumber:
+            if (BN_cmp(map_picc->domainParameter->parameters.dh->g,
+                        map_pcd->domainParameter->parameters.dh->g) != 0)
+                err("Error computing mapped domain parameters (MRTD and TERMINAL differ)");
+            if (debug) {
+                printf("Mapped domain parameters:\n");
+                DHparams_print_fp(stdout, map_picc->domainParameter->parameters.dh);
+            }
+            break;
+        case NID_X9_62_id_ecPublicKey:
+            if(EC_GROUP_cmp(EC_KEY_get0_group(map_picc->domainParameter->parameters.ecdh),
+                        EC_KEY_get0_group(map_pcd->domainParameter->parameters.ecdh),
+                        ctx->bn_ctx) != 0)
+                err("Error computing mapped domain parameters (MRTD and TERMINAL differ)");
+            if (debug) {
+                printf("Mapped domain parameters on MRTD and Terminal:\n");
+                ECParameters_print_fp(stdout, map_picc->domainParameter->parameters.ecdh);
+            }
+            break;
+        default:
+            err("cannot happen");
+    }
+
+    if (verbose)
+        printf("STEP3B\n");
+    else
+        printf(".");
+    pub_picc = PACE_STEP3B_dh_generate_key(map_picc, ctx);
+    pub_pcd = PACE_STEP3B_dh_generate_key(map_pcd, ctx);
+    if(!pub_picc || !pub_pcd)
+        err("Error generating keypair for key derivation");
+    if (verbose)
+        printf("Generated keypair on MRTD and Terminal for key derivation\n");
+    else
+        printf(".");
+    key_picc = PACE_STEP3B_dh_compute_key(map_picc, ctx, pub_pcd);
+    key_pcd = PACE_STEP3B_dh_compute_key(map_pcd, ctx, pub_picc);
+    if(!key_picc || !key_pcd)
+        err("Error computing key for key derivation");
+    if (key_pcd->length != key_picc->length ||
+            memcmp(key_picc->data, key_pcd->data, key_pcd->length) != 0)
+        err("Error computing key for key derivation (MRTD and TERMINAL differ)");
+    if (verbose)
+        printf("Computed the same key on MRTD and TERMINAL for key derivation\n");
+    else
+        printf(".");
+
+    if (verbose)
+        printf("STEP3C\n");
+    else
+        printf(".");
+    /* Note: Since the key is the same for MRTD and TERMINAL, k_enc and
+     * k_mac are the same, too */
+    if (!PACE_STEP3C_derive_keys(key_picc, ctx, &k_mac, &k_enc))
+        err("Error during key derivation");
+    if (verbose)
+        printf("Derived authentication and encryption key\n");
+    else
+        printf(".");
+    if (debug) {
+        hexdump("Derived authentication key", k_mac);
+        hexdump("Derived encryption key", k_enc);
+    }
+
+    if (verbose)
+        printf("STEP3D\n");
+    else
+        printf(".");
+    token_pcd = PACE_STEP3D_compute_authentication_token(ctx, map_pcd, info,
+            pub_picc, k_mac, 1);
+    token_picc = PACE_STEP3D_compute_authentication_token(ctx, map_picc, info,
+            pub_pcd, k_mac, 1);
+    if ((!token_pcd) || (!token_picc)) {
+        err("Failed to compute authentication token");
+    }
+    if (verbose)
+        printf("Computed authentication token for MRTD and TERMINAL");
+    else
+        printf(".");
+    if (debug) {
+        hexdump("Authentication token from MRTD", token_picc);
+        hexdump("Authentication token from TERMINAL", token_pcd);
+    }
+    if (!PACE_STEP3D_verify_authentication_token(ctx, map_pcd, info, pub_picc,
+                k_mac, token_picc, 1) ||
+            !PACE_STEP3D_verify_authentication_token(ctx, map_picc, info, pub_pcd,
+                k_mac, token_pcd, 1)) {
+        err("Could not verify authentication token.");
+    }
+    if (verbose) {
+        printf("Authentication token verified.\n");
+    } else {
+        printf(".");
+    }
+
+    ok = 0;
+
+err:
+    if (token_picc)
+        BUF_MEM_free(token_picc);
+    if (token_pcd)
+        BUF_MEM_free(token_pcd);
+    if (k_mac)
+        BUF_MEM_free(k_mac);
+    if (k_enc)
+        BUF_MEM_free(k_enc);
+    if (key_picc)
+        BUF_MEM_free(key_picc);
+    if (key_pcd)
+        BUF_MEM_free(key_pcd);
+    if (pub_picc)
+        BUF_MEM_free(pub_picc);
+    if (pub_pcd)
+        BUF_MEM_free(pub_pcd);
+    if (map_pub_picc)
+        BUF_MEM_free(map_pub_picc);
+    if (map_pub_pcd)
+        BUF_MEM_free(map_pub_pcd);
+    if (nonce_pcd)
+        BUF_MEM_free(nonce_pcd);
+    if (nonce_picc)
+        BUF_MEM_free(nonce_picc);
+    if (enc_nonce)
+        BUF_MEM_free(enc_nonce);
+    PACEDomainParameterInfo_clear_free(map_pcd);
+    PACEDomainParameterInfo_clear_free(map_picc);
+    AlgorithmIdentifier_clear_free(dp_picc_at_pcd);
+    PACEDomainParameterInfo_free(dp_info_pcd);
+    PACEDomainParameterInfo_clear_free(dp_info_picc);
+    PACE_CTX_clear_free(ctx);
+    PACE_SEC_clear_free(s);
+
+    if (verbose) {
+        if (ok == 0)
+            printf("Everything works as expected.\n");
+        else
+            printf("Some error occurred.\n");
+    } else {
+        if (ok == 0)
+            printf(" ok\n");
+        else
+            printf(" error\n");
+    }
+
+    return ok;
+}
+
+int real_life_test()
+{
+    int r = 0;
+    if (verbose)
+    printf("Starting a real life test\n");
+
+    enum s_type pace_sec_type [] = {
+        PACE_PUK,
+        PACE_CAN,
+        PACE_PIN,
+        PACE_MRZ,
+        PACE_RAW,
+        PACE_SEC_UNDEF,
+    };
+    enum s_type * sec_type = pace_sec_type;
+    char * pace_sec_str [] = {
+        "PUK",
+        "CAN",
+        "PIN",
+        "P<UTOERIKSSON<<ANNA<MARIX<<<<<<<<<<<<<<<<<<<L898902C<3UTO6908061F9406236ZE184226B<<<<<14",
+        "RAW",
+        NULL,
+    };
+    char ** sec_str = pace_sec_str;
+    int algorithm_type [] = {
+        NID_id_PACE_DH_IM_3DES_CBC_CBC,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_128,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_192,
+        NID_id_PACE_DH_IM_AES_CBC_CMAC_256,
+        NID_id_PACE_ECDH_IM_3DES_CBC_CBC,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192,
+        NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256,
+        NID_id_PACE_DH_GM_3DES_CBC_CBC,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_128,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_192,
+        NID_id_PACE_DH_GM_AES_CBC_CMAC_256,
+        NID_id_PACE_ECDH_GM_3DES_CBC_CBC,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192,
+        NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256,
+        NID_undef,
+    };
+    int * algorithm = algorithm_type;
+    int curve_type [] = {
+        /* Note: Only some curves work with IM, but all should work with GM */
+        NID_brainpoolP256r1,
+        NID_brainpoolP256t1,
+        NID_brainpoolP320r1,
+        NID_brainpoolP320t1,
+        NID_brainpoolP512r1,
+        NID_brainpoolP512t1,
+        NID_brainpoolP160r1,
+        NID_brainpoolP160t1,
+        NID_brainpoolP192r1,
+        NID_brainpoolP192t1,
+        NID_brainpoolP224r1,
+        NID_brainpoolP224t1,
+        NID_brainpoolP384r1,
+        NID_brainpoolP384t1,
+        NID_undef,
+    };
+    int * curve = curve_type;
+
+
+    while (*algorithm != NID_undef) {
+        r += do_test(*sec_str, *sec_type, *curve, *algorithm);
+
+        sec_str++;
+        sec_type++;
+        if (*sec_str == NULL || *sec_type == PACE_SEC_UNDEF) {
+            sec_str = pace_sec_str;
+            sec_type = pace_sec_type;
+        }
+        switch (*algorithm) {
+            case NID_id_PACE_ECDH_GM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_GM_AES_CBC_CMAC_256:
+            case NID_id_PACE_ECDH_IM_3DES_CBC_CBC:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_128:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_192:
+            case NID_id_PACE_ECDH_IM_AES_CBC_CMAC_256:
+                if(*curve != NID_undef)
+                    curve++;
+                break;
+            default:
+                break;
+        }
+        algorithm++;
+    }
+
+    return r;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+    for (i=1; i<argc; i++)
+    {
+        if ((strcmp(argv[i], "--verbose") == 0) ||
+                (strcmp(argv[i], "-v") == 0)) {
+            verbose++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--debug") == 0) ||
+                (strcmp(argv[i], "-d") == 0)) {
+            verbose++;
+            debug++;
+            continue;
+        }
+        if ((strcmp(argv[i], "--help") == 0) ||
+                (strcmp(argv[i], "-h") == 0)) {
+            fprintf(stderr,
+                    "%s tests the OpenSSL implementation of Password Authentication Connection Establishment (PACE)\n"
+                    "\n"
+                    "Usage: %s [Options]\n"
+                    "\n"
+                    "Options:\n"
+                    "  -h, --help              show this help message and exit\n"
+                    "  -v, --verbose           more verbosity\n"
+                    "      --version           print version information and exit\n"
+                    , argv[0], argv[0]
+            );
+            return 0;
+        }
+        if (strcmp(argv[i], "--version") == 0) {
+            fprintf(stderr,
+                    "%s 0.1\n"
+                    "\n"
+                    "Written by Frank Morgner and Dominik Oepen.\n"
+                    , argv[0]
+            );
+            return 0;
+        }
+
+        fprintf(stderr, "unrecognized option \"%s\"\n", argv[i]);
+        return 1;
+    }
+    /*printf("%s:%d\n", __FILE__, __LINE__);*/
+    int out = 0;
+    out += real_life_test();
+    return -out;
+}
+
+#endif /* OPENSSL_NO_PACE */
Index: openssl/makevms.com
===================================================================
--- openssl.orig/makevms.com
+++ openssl/makevms.com
@@ -525,6 +525,7 @@ $ EXHEADER_CMS := cms.h
 $ EXHEADER_PQUEUE := pqueue.h
 $ EXHEADER_TS := ts.h
 $ EXHEADER_JPAKE := jpake.h
+$ EXHEADER_PACE := pace.h
 $
 $ I = 0
 $ LOOP_SDIRS: 
Index: openssl/test/Makefile
===================================================================
--- openssl.orig/test/Makefile
+++ openssl/test/Makefile
@@ -63,11 +63,11 @@ IGETEST=	igetest
 GCMTESTA=  aesgcmtest
 CMACTESTA= cmac_test
 JPAKETEST=	jpaketest
-
+PACETEST=	pacetest
 
 TESTS=		alltests
 
-EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
+EXE=	$(PACETEST)$(EXE_EXT)#$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
 	$(MD2TEST)$(EXE_EXT)  $(MD4TEST)$(EXE_EXT) $(MD5TEST)$(EXE_EXT) $(HMACTEST)$(EXE_EXT) $(WPTEST)$(EXE_EXT) \
 	$(RC2TEST)$(EXE_EXT) $(RC4TEST)$(EXE_EXT) $(RC5TEST)$(EXE_EXT) \
 	$(DESTEST)$(EXE_EXT) $(SHATEST)$(EXE_EXT) $(SHA1TEST)$(EXE_EXT) $(SHA256TEST)$(EXE_EXT) $(SHA512TEST)$(EXE_EXT) \
@@ -75,7 +75,7 @@ EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_
 	$(RANDTEST)$(EXE_EXT) $(DHTEST)$(EXE_EXT) $(ENGINETEST)$(EXE_EXT) \
 	$(BFTEST)$(EXE_EXT) $(CASTTEST)$(EXE_EXT) $(SSLTEST)$(EXE_EXT) $(EXPTEST)$(EXE_EXT) $(DSATEST)$(EXE_EXT) $(RSATEST)$(EXE_EXT) \
 	$(EVPTEST)$(EXE_EXT) $(IGETEST)$(EXE_EXT) $(JPAKETEST)$(EXE_EXT) \
-	$(GCMTESTA)$(EXE_EXT) $(CMACTESTA)$(EXE_EXT)
+        $(GCMTESTA)$(EXE_EXT) $(CMACTESTA)$(EXE_EXT) $(PACETEST)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -88,7 +88,7 @@ OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATES
 	$(RANDTEST).o $(DHTEST).o $(ENGINETEST).o $(CASTTEST).o \
 	$(BFTEST).o  $(SSLTEST).o  $(DSATEST).o  $(EXPTEST).o $(RSATEST).o \
 	$(EVPTEST).o $(IGETEST).o $(JPAKETEST).o \
-	$(GCMTESTA).o $(CMACTESTA).o
+        $(GCMTESTA).o $(CMACTESTA).o $(PACETEST).o
 SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
 	$(HMACTEST).c $(WPTEST).c \
@@ -97,7 +97,7 @@ SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATES
 	$(RANDTEST).c $(DHTEST).c $(ENGINETEST).c $(CASTTEST).c \
 	$(BFTEST).c  $(SSLTEST).c $(DSATEST).c   $(EXPTEST).c $(RSATEST).c \
 	$(EVPTEST).c $(IGETEST).c $(JPAKETEST).c \
-	$(GCMTESTA).c $(CMACTESTA).c
+        $(GCMTESTA).c $(CMACTESTA).c $(PACETEST).c
 
 EXHEADER= 
 HEADER=	$(EXHEADER)
@@ -140,7 +140,7 @@ alltests: \
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_ssl test_tsa test_ige \
-	test_jpake test_cms test_aes_gcm test_cmac
+	test_jpake test_cms test_aes_gcm test_cmac test_pace
 
 test_evp:
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
@@ -314,6 +314,16 @@ test_cms:
 	@echo "CMS consistency test"
 	$(PERL) cms-test.pl
 
+test_pace: $(PACETEST)$(EXE_EXT)
+	@echo "Test PACE"
+	../util/shlib_wrap.sh ./$(PACETEST)
+
+#	TDES modes are known broken, the generated DES key needs parity fixed
+#		../util/shlib_wrap.sh ./$(CMACTESTB) testdata/CMAC/fax/CMACGenTDES2.fax ;\
+#		../util/shlib_wrap.sh ./$(CMACTESTB) testdata/CMAC/fax/CMACVerTDES2.fax ;\
+#		../util/shlib_wrap.sh ./$(CMACTESTB) testdata/CMAC/fax/CMACVerTDES3.fax ;\
+#		../util/shlib_wrap.sh ./$(CMACTESTB) testdata/CMAC/fax/CMACGenTDES3.fax ;\
+
 test_aes_gcm:  $(GCMTESTA)$(EXE_EXT)
 	@echo "Test AES GCM modes"
 	../util/shlib_wrap.sh ./aesgcmtest$(EXE_EXT)
@@ -455,6 +465,9 @@ $(IGETEST)$(EXE_EXT): $(IGETEST).o $(DLI
 $(JPAKETEST)$(EXE_EXT): $(JPAKETEST).o $(DLIBCRYPTO)
 	@target=$(JPAKETEST); $(BUILD_CMD)
 
+$(PACETEST)$(EXE_EXT): $(PACETEST).o $(DLIBCRYPTO)
+	@target=$(PACETEST); $(BUILD_CMD)
+
 $(GCMTESTA)$(EXE_EXT): $(GCMTESTA).o  $(DLIBCRYPTO)
 	@target=$(GCMTESTA); $(BUILD_CMD)
 
@@ -479,6 +492,15 @@ dummytest$(EXE_EXT): dummytest.o $(DLIBC
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
 
+aesgcmtest.o: ../include/openssl/aes.h ../include/openssl/aes_gcm.h
+aesgcmtest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+aesgcmtest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+aesgcmtest.o: ../include/openssl/err.h ../include/openssl/evp.h
+aesgcmtest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+aesgcmtest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+aesgcmtest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+aesgcmtest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
+aesgcmtest.o: ../include/openssl/symhacks.h aesgcmtest.c
 bftest.o: ../e_os.h ../include/openssl/blowfish.h ../include/openssl/e_os2.h
 bftest.o: ../include/openssl/opensslconf.h bftest.c
 bntest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
@@ -497,6 +519,15 @@ bntest.o: ../include/openssl/stack.h ../
 bntest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bntest.c
 casttest.o: ../e_os.h ../include/openssl/cast.h ../include/openssl/e_os2.h
 casttest.o: ../include/openssl/opensslconf.h casttest.c
+cmac_test.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+cmac_test.o: ../include/openssl/cmac.h ../include/openssl/crypto.h
+cmac_test.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+cmac_test.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+cmac_test.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+cmac_test.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+cmac_test.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
+cmac_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+cmac_test.o: cmac_test.c
 destest.o: ../include/openssl/des.h ../include/openssl/des_old.h
 destest.o: ../include/openssl/e_os2.h ../include/openssl/opensslconf.h
 destest.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
@@ -633,6 +664,17 @@ mdc2test.o: ../include/openssl/opensslco
 mdc2test.o: ../include/openssl/ossl_typ.h ../include/openssl/safestack.h
 mdc2test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 mdc2test.o: ../include/openssl/ui.h ../include/openssl/ui_compat.h mdc2test.c
+pacetest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+pacetest.o: ../include/openssl/buffer.h ../include/openssl/cmac.h
+pacetest.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+pacetest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+pacetest.o: ../include/openssl/ecdh.h ../include/openssl/err.h
+pacetest.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+pacetest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+pacetest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+pacetest.o: ../include/openssl/ossl_typ.h ../include/openssl/pace.h
+pacetest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
+pacetest.o: ../include/openssl/symhacks.h pacetest.c
 randtest.o: ../e_os.h ../include/openssl/e_os2.h
 randtest.o: ../include/openssl/opensslconf.h ../include/openssl/ossl_typ.h
 randtest.o: ../include/openssl/rand.h randtest.c
Index: openssl/test/tests.com
===================================================================
--- openssl.orig/test/tests.com
+++ openssl/test/tests.com
@@ -32,7 +32,7 @@ $	    tests := -
 	test_enc,test_x509,test_rsa,test_crl,test_sid,-
 	test_gen,test_req,test_pkcs7,test_verify,test_dh,test_dsa,-
 	test_ss,test_ca,test_engine,test_evp,test_ssl,test_tsa,test_ige,-
-	test_jpake,test_cms
+	test_jpake,test_cms, test_pace
 $	endif
 $	tests = f$edit(tests,"COLLAPSE")
 $
@@ -67,6 +67,7 @@ $	ENGINETEST :=	enginetest
 $	EVPTEST :=	evp_test
 $	IGETEST :=	igetest
 $	JPAKETEST :=	jpaketest
+$	PACETEST :=	pacetest
 $
 $	tests_i = 0
 $ loop_tests:
